<!doctype html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="J_Knight" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="正在学hybrid开发的iOS开发者">
<meta property="og:type" content="website">
<meta property="og:title" content="J_Knight">
<meta property="og:url" content="https://github.com/knightsj/knightsj.github.io/index.html">
<meta property="og:site_name" content="J_Knight">
<meta property="og:description" content="正在学hybrid开发的iOS开发者">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="J_Knight">
<meta name="twitter:description" content="正在学hybrid开发的iOS开发者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/knightsj/knightsj.github.io/"/>





  <title> J_Knight </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?46e6f54887b680a685201da90f1b9384";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>









  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">J_Knight</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">每天进步一点点</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/04/10/《Objective-C 高级编程》干货三部曲（一）：引用计数篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/《Objective-C 高级编程》干货三部曲（一）：引用计数篇/" itemprop="url">
                  《Objective-C 高级编程》干货三部曲（一）：引用计数篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T08:40:50+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结了<a href="http://www.jianshu.com/nb/6074358" target="_blank" rel="external">Effective Objective-C</a>之后，还想读一本进阶的iOS书，毫不犹豫选中了《Objective-C 高级编程》：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>这本书有三个章节，我针对每一章节进行总结并加上适当的扩展分享给大家。可以从下面这张图来看一下这三篇的整体结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程》 干货三部曲"></p>
<p>注意，这个结构并不和书中的结构一致，而是以书中的结构为参考，稍作了调整。</p>
<p>本篇是第一篇：引用计数，简单说两句：<br>Objective-C通过 retainCount 的机制来决定对象是否需要释放。 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。</p>
<p>先看一下手动内存管理：</p>
<h1 id="手动内存管理"><a href="#手动内存管理" class="headerlink" title="手动内存管理"></a>手动内存管理</h1><p>我个人觉得，学习一项新的技术之前，需要先了解一下它的核心思想。理解了核心思想之后，对技术点的把握就会更快一些：</p>
<h2 id="内存管理的思想"><a href="#内存管理的思想" class="headerlink" title="内存管理的思想"></a>内存管理的思想</h2><ul>
<li>思想一：自己生成的对象，自己持有。</li>
<li>思想二：非自己生成的对象，自己也能持有。</li>
<li>思想三：不再需要自己持有的对象时释放对象。</li>
<li>思想四：非自己持有的对象无法释放。</li>
</ul>
<p>从上面的思想来看，我们对对象的操作可以分为三种：生成，持有，释放，再加上废弃，一共有四种。它们所对应的Objective-C的方法和引用计数的变化是：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>Objecctive-C方法</th>
<th>引用计数的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy等方法</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain方法</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release方法</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc方法</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>用书中的图来直观感受一下这四种操作：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-5ced77c57afcfab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>下面开始逐一解释上面的四条思想：</p>
<h3 id="思想一：自己生成的对象，自己持有"><a href="#思想一：自己生成的对象，自己持有" class="headerlink" title="思想一：自己生成的对象，自己持有"></a>思想一：自己生成的对象，自己持有</h3><p>在生成对象时，使用以下面名称开头的方法生成对象以后，就会持有该对象：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure>
<p>这行代码过后，指向生成并持有[[NSObject alloc] init]的指针被赋给了obj，也就是说obj这个指针强引用[[NSObject alloc] init]这个对象。</p>
<p>同样适用于new方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure></p>
<p>注意：<br>这种将持有对象的指针赋给指针变量的情况不只局限于上面这四种方法名称，还包括以他们开头的所有方法名称：</p>
<ul>
<li>allocThisObject</li>
<li>newThatObject</li>
<li>copyThisObject</li>
<li>mutableCopyThatObject</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1 = [obj0 allocObject];<span class="comment">//符合上述命名规则，生成并持有对象</span></div></pre></td></tr></table></figure>
<p>它的内部实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)allocObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反过来，如果不符合上述的命名规则，那么就不会持有生成的对象，<br>看一个不符合上述命名规则的返回对象的createObject方法的内部实现🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)createObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">    [obj autorelease];<span class="comment">//取得对象，但自己不持有</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>经由这个方法返回以后，无法持有这个返回的对象。因为这里使用了autorelease。autorelease提供了这样一个功能：在对象超出其指定的生存范围时能够自动并正确地释放（详细会在后面介绍）。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-97b23d0108e4cadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<blockquote>
<p>也就是说，生成一个调用方不持有的对象是可以通过autorelease来实现的（例如NSMutableArray的array类方法）。</p>
<p>我的个人理解是：通过autorelease方法，使对象的持有权转移给了自动释放池。所以实现了：调用方拿到了对象，但这个对象还不被调用方所持有。</p>
</blockquote>
<p>由这个不符合命名规则的例子来引出思想二：</p>
<h3 id="思想二：非自己生成的对象，自己也能持有"><a href="#思想二：非自己生成的对象，自己也能持有" class="headerlink" title="思想二：非自己生成的对象，自己也能持有"></a>思想二：非自己生成的对象，自己也能持有</h3><p>我们现在知道，仅仅通过上面那个不符合命名规则的返回对象实例的方法是无法持有对象的。但是我们可以通过某个操作来持有这个返回的对象：这个方法就是通过retain方法来让指针变量持有这个新生成的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj <span class="keyword">retain</span>];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里[NSMutableArray array]返回的非自己持有的对象正是通过上文介绍过的autorelease方法实现的。所以如果想持有这个对象，需要执行retain方法才可以。</p>
</blockquote>
<h3 id="思想三：不再需要自己持有的对象时释放对象"><a href="#思想三：不再需要自己持有的对象时释放对象" class="headerlink" title="思想三：不再需要自己持有的对象时释放对象"></a>思想三：不再需要自己持有的对象时释放对象</h3><p>对象的持有者<strong>有义务</strong>在不再需要这个对象的时候<strong>主动</strong>将这个对象释放。注意，是<strong>有义务</strong>，而不是有权利，注意两个词的不同。</p>
<p>来看一下释放对象的例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj doSomething];<span class="comment">//使用该对象做一些事情</span></div><div class="line">[obj release];<span class="comment">//事情做完了，释放该对象</span></div></pre></td></tr></table></figure></p>
<p>同样适用于非自己生成并持有的对象（参考思想二）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj <span class="keyword">retain</span>];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj soSomething];<span class="comment">//使用该对象做一些事情</span></div><div class="line">[obj release];<span class="comment">//事情做完了，释放该对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>可能遇到的面试题</strong>：调用对象的release方法会销毁对象吗？<br>答案是不会：调用对象的release方法只是将对象的引用计数器-1，当对象的引用计数器为0的时候会调用了对象的dealloc 方法才能进行释放对象的内存。</p>
</blockquote>
<h3 id="思想四：无法释放非自己持有的对象"><a href="#思想四：无法释放非自己持有的对象" class="headerlink" title="思想四：无法释放非自己持有的对象"></a>思想四：无法释放非自己持有的对象</h3><p>在释放对象的时候，我们只能释放已经持有的对象，非自己持有的对象是不能被自己释放的。这很符合常识：就好比你自己才能从你自己的银行卡里取钱，取别人的卡里的钱是不对的（除非他的钱归你管。。。只是随便举个例子）。</p>
<h4 id="两种不允许的情况："><a href="#两种不允许的情况：" class="headerlink" title="两种不允许的情况："></a>两种不允许的情况：</h4><h4 id="1-释放一个已经废弃了的对象"><a href="#1-释放一个已经废弃了的对象" class="headerlink" title="1.  释放一个已经废弃了的对象"></a>1.  释放一个已经废弃了的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj doSomething];<span class="comment">//使用该对象</span></div><div class="line">[obj release];<span class="comment">//释放该对象，不再持有了</span></div><div class="line">[obj release];<span class="comment">//释放已经废弃了的对象，崩溃</span></div></pre></td></tr></table></figure>
<h4 id="2-释放自己不持有的对象"><a href="#2-释放自己不持有的对象" class="headerlink" title="2. 释放自己不持有的对象"></a>2. 释放自己不持有的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj release];<span class="comment">//释放了非自己持有的对象</span></div></pre></td></tr></table></figure>
<p>思考：哪些情况会使对象失去拥有者呢？</p>
<ol>
<li>将指向某对象的指针变量指向另一个对象。</li>
<li>将指向某对象的指针变量设置为nil。</li>
<li>当程序释放对象的某个拥有者时。</li>
<li>从collection类中删除对象时。</li>
</ol>
<p>现在知道了引用计数式内存管理的四个思想，我们再来看一下四个操作引用计数的方法：</p>
<h2 id="alloc-retain-release-dealloc的实现"><a href="#alloc-retain-release-dealloc的实现" class="headerlink" title="alloc/retain/release/dealloc的实现"></a>alloc/retain/release/dealloc的实现</h2><p>某种意义上，GNUstep 和 Foundation 框架的实现是相似的。所以这本书的作者通过GNUstep的源码来推测了苹果Cocoa框架的实现。</p>
<p>下面开始针对每一个方法，同时用GNUstep和苹果的实现方式（追踪程序的执行和作者的猜测）来对比一下各自的实现。</p>
<h3 id="GNUstep实现："><a href="#GNUstep实现：" class="headerlink" title="GNUstep实现："></a>GNUstep实现：</h3><h4 id="alloc方法"><a href="#alloc方法" class="headerlink" title="alloc方法"></a>alloc方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m alloc:</span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>) alloc</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">+ (<span class="keyword">id</span>) allocWithZone: (<span class="built_in">NSZone</span>*)z</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSAllocateObject</span>(<span class="keyword">self</span>, <span class="number">0</span>, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里NSAllocateObject方法分配了对象，看一下它的内部实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m NSAllocateObject:</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> obj_layout &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> retained;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">NSAllocateObject</span>(Class aClass, <span class="built_in">NSUInteger</span> extraBytes, <span class="built_in">NSZone</span> *zone)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> size = 计算容纳对象所需内存大小;</div><div class="line">    <span class="keyword">id</span> new = <span class="built_in">NSZoneMalloc</span>(zone, <span class="number">1</span>, size);<span class="comment">//返回新的实例</span></div><div class="line">    memset (new, <span class="number">0</span>, size);</div><div class="line">    new = (<span class="keyword">id</span>)&amp;((obj)new)[<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>NSAllocateObject函数通过NSZoneMalloc函数来分配存放对象所需要的内存空间。</li>
<li>obj_layout是用来保存引用计数，并将其写入对象内存头部。</li>
</ol>
</blockquote>
<p>对象的引用计数可以通过retainCount方法来取得：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GNUstep/modules/core/base/Source/<span class="built_in">NSObject</span>.m retainCount:</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span></div><div class="line"><span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> ((obj_layout)anObject)[<span class="number">-1</span>].retained;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，给NSExtraRefCount传入anObject以后，通过访问对象内存头部的.retained变量，来获取引用计数。</p>
<h4 id="retain方法"><a href="#retain方法" class="headerlink" title="retain方法"></a>retain方法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GNUstep/modules/core/base/Source/NSObject.m retain:</div><div class="line"></div><div class="line">- (id)retain</div><div class="line">&#123;</div><div class="line">    NSIncrementExtraRefCount(self);</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">inline void NSIncrementExtraRefCount(id anObject)</div><div class="line">&#123;</div><div class="line">    //retained变量超出最大值,抛出异常</div><div class="line">    if (((obj)anObject)[-1].retained == UINT_MAX - 1)&#123;</div><div class="line">        [NSException raise: NSInternalInconsistencyException</div><div class="line">        format: @"NSIncrementExtraRefCount() asked to increment too far”];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ((obj_layout)anObject)[-1].retained++;//retained变量+1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m release</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果当前的引用计数 = 0，调用dealloc函数</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> dealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果当前的retained值 = 0.则返回yes</span></div><div class="line">    <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果大于0，则-1，并返回NO</span></div><div class="line">    ((obj)anObject)[<span class="number">-1</span>].retained--;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="dealloc方法"><a href="#dealloc方法" class="headerlink" title="dealloc方法"></a>dealloc方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m dealloc</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    obj_layout o = &amp;((obj_layout)anObject)[<span class="number">-1</span>];</div><div class="line">    free(o);<span class="comment">//释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下上面的几个方法：</p>
<ul>
<li>Objective-C对象中保存着引用计数这一整数值。</li>
<li>调用alloc或者retain方法后，引用计数+1。</li>
<li>调用release后，引用计数-1。</li>
<li>引用计数为0时，调用dealloc方法废弃对象。</li>
</ul>
<p>下面看一下苹果的实现：</p>
<h3 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a>苹果的实现</h3><h4 id="alloc方法-1"><a href="#alloc方法-1" class="headerlink" title="alloc方法"></a>alloc方法</h4><p>通过在NSObject类的alloc类方法上设置断点，我们可以看到执行所调用的函数：</p>
<ul>
<li>+alloc</li>
<li>+allocWithZone:</li>
<li>class_createInstance//生成实例</li>
<li>calloc//分配内存块</li>
</ul>
<p>retainCount:</p>
<ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashGetCountOfKey</li>
</ul>
<h4 id="retain方法-1"><a href="#retain方法-1" class="headerlink" title="retain方法"></a>retain方法</h4><ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashAddValue</li>
</ul>
<h4 id="release方法-1"><a href="#release方法-1" class="headerlink" title="release方法"></a>release方法</h4><ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashRemoveValue</li>
</ul>
<p>我们可以看到他们都调用了一个共同的 __CFdoExternRefOperation 方法。</p>
<p>看一下它的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">CFBasicHashRef</span> table = 取得对象的散列表(obj);</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line"> </div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">    <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        count = <span class="built_in">CFBasicHashAddValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，__CFDoExternRefOperation通过switch语句 针对不同的操作来进行具体的方法调用，如果 op 是 OPERATION_retain，就去掉用具体实现 retain 的方法，以此类推。</p>
<p>可以猜想上层的retainCount,retain,release方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">NSUInteger</span>)____CFDoExternRefOperation(OPERATION_retainCount,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)____CFDoExternRefOperation(OPERATION_retain,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这里返回值应该是id，原书这里应该是错了</span></div><div class="line">- (<span class="keyword">id</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)____CFDoExternRefOperation(OPERATION_release,<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们观察一下switch里面每个语句里的执行函数名称，似乎和散列表（Hash）有关，这说明苹果对引用计数的管理应该是通过散列表来执行的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-46b607c905f2355d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>在这张表里，key为内存块地址，而对应的值为引用计数。也就是说，它保存了这样的信息：一些被引用的内存块各自对应的引用计数。</p>
<p>那么使用散列表来管理内存有什么好处呢？</p>
<p>因为计数表保存内存块地址，我们就可以通过这张表来：</p>
<ul>
<li>确认损坏内存块的位置。</li>
<li>在检测内存泄漏时，可以查看各对象的持有者是否存在。</li>
</ul>
<h2 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h2><h3 id="autorelease-介绍"><a href="#autorelease-介绍" class="headerlink" title="autorelease 介绍"></a>autorelease 介绍</h3><p>当对象超出其作用域时，对象实例的release方法就会被调用，autorelease的具体使用方法如下：</p>
<ol>
<li>生成并持有NSAutoreleasePool对象。</li>
<li>调用已分配对象的autorelease方法。</li>
<li>废弃NSAutoreleasePool对象。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-e4e905eeda890869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>所有调用过autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release方法（引用计数-1）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];<span class="comment">//相当于obj调用release方法</span></div></pre></td></tr></table></figure></p>
<p>NSRunLoop在每次循环过程中，NSAutoreleasePool对象都会被生成或废弃。<br>也就是说，如果有大量的autorelease变量，在NSAutoreleasePool对象废弃之前（一旦监听到RunLoop即将进入睡眠等待状态，就释放NSAutoreleasePool），都不会被销毁，容易导致内存激增的问题:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageArray.count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = imageArray[i];</div><div class="line">    [image doSomething];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0a9bf49d47a0e3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>因此，我们有必要在适当的时候再嵌套一个自动释放池来管理临时生成的autorelease变量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageArray.count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//临时pool</span></div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line">    <span class="built_in">UIImage</span> *image = imageArray[i];</div><div class="line">    [image doSomething];</div><div class="line">    [pool drain];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-157c469ad6fff139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<blockquote>
<p>可能会出的面试题：什么时候会创建自动释放池？<br>答：运行循环检测到事件并启动后，就会创建自动释放池，而且子线程的 runloop 默认是不工作的，无法主动创建，必须手动创建。<br>举个🌰：<br>自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则在出了作用域以后，自动释放对象会因为没有自动释放池去处理自己而造成内存泄露。</p>
</blockquote>
<h3 id="autorelease实现"><a href="#autorelease实现" class="headerlink" title="autorelease实现"></a>autorelease实现</h3><p>和上文一样，我们还是通过GNUstep和苹果的实现来分别看一下。</p>
<h4 id="GNUstep-实现"><a href="#GNUstep-实现" class="headerlink" title="GNUstep 实现"></a>GNUstep 实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m autorelease</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)autorelease</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果调用NSObject类的autorelease方法，则该对象就会被追加到正在使用的NSAutoreleasePool对象中的数组里（作者假想了一个简化的源代码）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSAutoreleasePool.m addObject</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = 取得正在使用的<span class="built_in">NSAutoreleasePool</span>对象</div><div class="line">    <span class="keyword">if</span> (pool != <span class="literal">nil</span>)&#123;</div><div class="line">        [pool addObject:anObj];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSAutoreleasePool对象不存在"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">    [pool.array addObject:anObj];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法，然后这个对象就被追加到正在使用的NSAutoreleasePool对象中的数组里。</p>
<p>再来看一下NSAutoreleasePool的drain方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drain</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> dealloc];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> emptyPool];</div><div class="line">    [array release];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)emptyPool</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">id</span> obj <span class="keyword">in</span> array)&#123;</div><div class="line">        [obj release];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在emptyPool方法里，确实是对数组里每一个对象进行了release操作。</p>
<h4 id="苹果的实现-1"><a href="#苹果的实现-1" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>我们可以通过objc4/NSObject.mm来确认苹果中autorelease的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">objc4/<span class="built_in">NSObject</span>.mm AutoreleasePoolPage</div><div class="line"> </div><div class="line"><span class="keyword">class</span> AutoreleasePoolPage</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//生成或者持有 NSAutoreleasePool 类对象</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//废弃 NSAutoreleasePool 类对象</span></div><div class="line">        releaseAll();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//相当于 NSAutoreleasePool 类的 addObject 类方法</span></div><div class="line">        AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例;</div><div class="line">       autoreleaesPoolPage-&gt;add(obj)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</div><div class="line">    &#123;   </div><div class="line">        <span class="comment">//将对象追加到内部数组中</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> releaseAll()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//调用内部数组中对象的 release 方法</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//压栈</span></div><div class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//出栈</span></div><div class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看一下外部的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">// 等同于 objc_autoreleasePoolPush</span></div><div class="line"> </div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line"><span class="comment">// 等同于 objc_autorelease(obj)</span></div><div class="line"> </div><div class="line">[<span class="built_in">NSAutoreleasePool</span> showPools];</div><div class="line"><span class="comment">// 查看 NSAutoreleasePool 状况</span></div><div class="line"> </div><div class="line">[pool drain];</div><div class="line"><span class="comment">// 等同于 objc_autoreleasePoolPop(pool)</span></div></pre></td></tr></table></figure>
<p>看函数名就可以知道，对autorelease分别执行push、pop操作。销毁对象时执行release操作。</p>
<blockquote>
<p><strong>可能出现的面试题：苹果是如何实现autoreleasepool的？</strong><br>autoreleasepool以一个队列数组的形式实现,主要通过下列三个函数完成.<br>•    objc_autoreleasepoolPush（压入）<br>•    objc_autoreleasepoolPop（弹出）<br>•    objc_autorelease（释放内部）</p>
</blockquote>
<h1 id="ARC内存管理"><a href="#ARC内存管理" class="headerlink" title="ARC内存管理"></a>ARC内存管理</h1><h2 id="内存管理的思想-1"><a href="#内存管理的思想-1" class="headerlink" title="内存管理的思想"></a>内存管理的思想</h2><p>上面学习了非ARC机制下的手动管理内存思想，针对引用计数的操作和自动释放池的相关内容。现在学习一下在ARC机制下的相关知识。</p>
<p>ARC和非ARC机制下的内存管理思想是一致的：</p>
<ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放对象。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<p>在ARC机制下，编译器就可以自动进行内存管理，减少了开发的工作量。但我们有时仍需要四种所有权修饰符来配合ARC来进行内存管理</p>
<h2 id="四种所有权修饰符"><a href="#四种所有权修饰符" class="headerlink" title="四种所有权修饰符"></a>四种所有权修饰符</h2><p>但是，在ARC机制下我们有的时候需要追加所有权声明(以下内容摘自官方文档)：</p>
<ul>
<li><strong>__strong</strong>：is the default. An object remains “alive” as long as there is a strong pointer to it.</li>
<li><strong>__weak</strong>：specifies a reference that does not keep the referenced object alive. A weak reference is set to nil when there are no strong references to the object.</li>
<li><strong>__unsafe_unretained</strong>：specifies a reference that does not keep the referenced object alive and is not set to nil when there are no strong references to the object. If the object it references is deallocated, the pointer is left dangling.</li>
<li><strong>__autoreleasing</strong>：is used to denote arguments that are passed by reference (id *) and are autoreleased on return.</li>
</ul>
<p>下面分别讲解一下这几个修饰符：</p>
<h3 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h3><p>__strong修饰符 是id类型和对象类型默认的所有权修饰符：</p>
<h4 id="strong使用方法："><a href="#strong使用方法：" class="headerlink" title="__strong使用方法："></a>__strong使用方法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>等同于：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure></p>
<p>看一下内存管理的过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj持有对象</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//obj超出其作用域，强引用失效</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>__strong修饰符表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃。</p>
</blockquote>
<p>在__strong修饰符修饰的变量之间相互赋值的情况：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj0 持有对象A</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj1 持有对象B</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj2 = <span class="literal">nil</span>;<span class="comment">//ojb2不持有任何对象</span></div><div class="line">obj0 = obj1;<span class="comment">//obj0强引用对象B；而对象A不再被ojb0引用，被废弃</span></div><div class="line">obj2 = obj0;<span class="comment">//obj2强引用对象B（现在obj0，ojb1，obj2都强引用对象B）</span></div><div class="line">obj1 = <span class="literal">nil</span>;<span class="comment">//obj1不再强引用对象B</span></div><div class="line">obj0 = <span class="literal">nil</span>;<span class="comment">//obj0不再强引用对象B</span></div><div class="line">obj2 = <span class="literal">nil</span>;<span class="comment">//obj2不再强引用对象B，不再有任何强引用引用对象B，对象B被废弃</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>而且，<strong>strong可以使一个变量初始化为nil：id </strong>strong obj0;<br>同样适用于：id <strong>weak obj1; id </strong>autoreleasing obj2;</p>
</blockquote>
<p>做个总结：被__strong修饰后，相当于强引用某个对象。对象一旦有一个强引用引用自己，引用计数就会+1，就不会被系统废弃。而这个对象如果不再被强引用的话，就会被系统废弃。</p>
<h4 id="strong内部实现："><a href="#strong内部实现：" class="headerlink" title="__strong内部实现："></a>__strong内部实现：</h4><p>生成并持有对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj持有对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = objc_mesgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(init));</div><div class="line">objc_release(obj);<span class="comment">//超出作用域，释放对象</span></div></pre></td></tr></table></figure></p>
<p>再看一下使用命名规则以外的构造方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(array));</div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>objc_retainAutoreleasedReturnValue的作用：持有对象，将对象注册到autoreleasepool并返回。</p>
</blockquote>
<p>同样也有objc_autoreleaseReturnValue，来看一下它的使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)array</div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)array</div><div class="line">&#123;</div><div class="line">   <span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">   objc_msgSend(obj,, <span class="keyword">@selector</span>(init));</div><div class="line">   <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>objc_autoreleaseReturnValue:返回注册到autoreleasepool的对象。</p>
</blockquote>
<h3 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h3><h4 id="weak使用方法："><a href="#weak使用方法：" class="headerlink" title="__weak使用方法："></a>__weak使用方法：</h4><p>__weak修饰符大多解决的是循环引用的问题：如果两个对象都互相强引用对方，同时都失去了外部对自己的引用，那么就会形成“孤岛”，这个孤岛将永远无法被释放，举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj</div><div class="line">&#123;</div><div class="line">    obj_ = obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> test0 = [[Test alloc] init];<span class="comment">//test0强引用对象A</span></div><div class="line">    <span class="keyword">id</span> test1 = [[Test alloc] init];<span class="comment">//test1强引用对象B</span></div><div class="line">    [test0 setObject:test1];<span class="comment">//test0强引用对象B</span></div><div class="line">    [test1 setObject:test0];<span class="comment">//test1强引用对象A</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为生成对象（第一，第二行）和set方法（第三，第四行）都是强引用，所以会造成两个对象互相强引用对方的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f2164aea2490deac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>所以，我们需要打破其中一种强引用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj_;<span class="comment">//由__strong变成了__weak</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这样一来，二者就只是弱引用对方了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-98777f8ef5bbfc13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<h4 id="weak内部实现"><a href="#weak内部实现" class="headerlink" title="__weak内部实现"></a>__weak内部实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1;</div><div class="line">objc_initWeak(&amp;obj1,obj);<span class="comment">//初始化附有__weak的变量</span></div><div class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(&amp;obj1);<span class="comment">//取出附有__weak修饰符变量所引用的对象并retain</span></div><div class="line">objc_autorelease(tmp);<span class="comment">//将对象注册到autoreleasepool中</span></div><div class="line">objc_destroyWeak(&amp;obj1);<span class="comment">//释放附有__weak的变量</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这确认了<strong>weak的一个功能：使用附有</strong>weak修饰符的变量，即是使用注册到autoreleasepool中的对象。</p>
</blockquote>
<p>这里需要着重讲解一下objc_initWeak方法和objc_destroyWeak方法：</p>
<ul>
<li>objc_initWeak:初始化附有__weak的变量，具体通过执行objc_strongWeak(&amp;obj1, obj)方法，将obj对象以&amp;obj1作为key放入一个weak表（Hash）中。</li>
<li>objc_destroyWeak：释放附有__weak的变量。具体通过执行objc_storeWeak(&amp;obj1,0)方法，在weak表中查询&amp;obj1这个键，将这个键从weak表中删除。</li>
</ul>
<blockquote>
<p>注意：因为同一个对象可以赋值给多个附有__weak的变量中，所以对于同一个键值，可以注册多个变量的地址。</p>
</blockquote>
<p>当一个对象不再被任何人持有，则需要释放它，过程为：</p>
<ul>
<li>objc_dealloc</li>
<li>dealloc</li>
<li>_objc_rootDealloc</li>
<li>objc_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating<ul>
<li>从weak表中获取废弃对象的地址</li>
<li>将包含在记录中的所有附有__weak修饰符变量的地址赋值为nil</li>
<li>从weak表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址</li>
</ul>
</li>
</ul>
<h3 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h3><h4 id="autoreleasing使用方法"><a href="#autoreleasing使用方法" class="headerlink" title="__autoreleasing使用方法"></a>__autoreleasing使用方法</h4><p>ARC下，可以用@autoreleasepool来替代NSAutoreleasePool类对象，用__autoreleasing修饰符修饰变量来替代ARC无效时调用对象的autorelease方法（对象被注册到autoreleasepool）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6dcb0d1fd878deeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>说到<strong>autoreleasing修饰符，就不得不提</strong>weak：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span>  __<span class="keyword">weak</span> obj1 = obj0;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>,[obj1 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure></p>
<p>等同于：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</div><div class="line"><span class="keyword">id</span> __autoreleasing tmp = obj1;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>,[tmp <span class="keyword">class</span>]);<span class="comment">//实际访问的是注册到自动个释放池的对象</span></div></pre></td></tr></table></figure>
<p>注意一下两段等效的代码里，NSLog语句里面访问的对象是不一样的，它说明：在访问__weak修饰符的变量（obj1）时必须访问注册到autoreleasepool的对象（tmp）。为什么呢？</p>
<p>因为__weak修饰符只持有对象的弱引用，也就是说在将来访问这个对象的时候，无法保证它是否还没有被废弃。因此，如果把这个对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。</p>
<h4 id="autoreleasing内部实现"><a href="#autoreleasing内部实现" class="headerlink" title="__autoreleasing内部实现"></a>__autoreleasing内部实现</h4><p>将对象赋值给附有__autoreleasing修饰符的变量等同于ARC无效时调用对象的autorelease方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">    <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();<span class="comment">//pool入栈</span></div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</div><div class="line">objc_autorelease(obj);</div><div class="line">objc_autoreleasePoolPop(pool);<span class="comment">//pool出栈</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们可以看到pool入栈，执行autorelease，出栈的三个方法。</p>
</blockquote>
<h2 id="ARC下的规则"><a href="#ARC下的规则" class="headerlink" title="ARC下的规则"></a>ARC下的规则</h2><p>我们知道了在ARC机制下编译器会帮助我们管理内存，但是在编译期，我们还是要遵守一些规则，作者为我们列出了以下的规则：</p>
<ol>
<li>不能使用retain/release/retainCount/autorelease</li>
<li>不能使用NSAllocateObject/NSDeallocateObject</li>
<li>必须遵守内存管理的方法名规则</li>
<li>不要显式调用dealloc</li>
<li>使用@autorelease块代替NSAutoreleasePool</li>
<li>不能使用区域（NSZone）</li>
<li>对象型变量不能作为C语言结构体的成员</li>
<li>显式转换id和void*</li>
</ol>
<h3 id="1-不能使用retain-release-retainCount-autorelease"><a href="#1-不能使用retain-release-retainCount-autorelease" class="headerlink" title="1. 不能使用retain/release/retainCount/autorelease"></a>1. 不能使用retain/release/retainCount/autorelease</h3><p>在ARC机制下使用retain/release/retainCount/autorelease方法，会导致编译器报错。</p>
<h3 id="2-不能使用NSAllocateObject-NSDeallocateObject"><a href="#2-不能使用NSAllocateObject-NSDeallocateObject" class="headerlink" title="2. 不能使用NSAllocateObject/NSDeallocateObject"></a>2. 不能使用NSAllocateObject/NSDeallocateObject</h3><p>在ARC机制下使用NSAllocateObject/NSDeallocateObject方法，会导致编译器报错。</p>
<h3 id="3-必须遵守内存管理的方法名规则"><a href="#3-必须遵守内存管理的方法名规则" class="headerlink" title="3. 必须遵守内存管理的方法名规则"></a>3. 必须遵守内存管理的方法名规则</h3><p>对象的生成／持有的方法必须遵循以下命名规则：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
<li>init</li>
</ul>
<p>前四种方法已经介绍完。而关于init方法的要求则更为严格：</p>
<ul>
<li>必须是实例方法</li>
<li>必须返回对象</li>
<li>返回对象的类型必须是id类型或方法声明类的对象类型</li>
</ul>
<h3 id="4-不要显式调用dealloc"><a href="#4-不要显式调用dealloc" class="headerlink" title="4. 不要显式调用dealloc"></a>4. 不要显式调用dealloc</h3><p>对象被废弃时，无论ARC是否有效，系统都会调用对象的dealloc方法。</p>
<p>我们只能在dealloc方法里写一些对象被废弃时需要进行的操作（例如移除已经注册的观察者对象）但是不能手动调用dealloc方法。</p>
<p>注意在ARC无效的时候，还需要调用[super dealloc]：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">//该对象的处理</span></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-使用-autorelease块代替NSAutoreleasePool"><a href="#5-使用-autorelease块代替NSAutoreleasePool" class="headerlink" title="5. 使用@autorelease块代替NSAutoreleasePool"></a>5. 使用@autorelease块代替NSAutoreleasePool</h3><p>ARC下须使用使用@autorelease块代替NSAutoreleasePool。</p>
<h3 id="6-不能使用区域（NSZone）"><a href="#6-不能使用区域（NSZone）" class="headerlink" title="6. 不能使用区域（NSZone）"></a>6. 不能使用区域（NSZone）</h3><p>NSZone已经在目前的运行时系统（<strong>OBC2</strong>被设定的环境）被忽略了。</p>
<h3 id="7-对象型变量不能作为C语言结构体的成员"><a href="#7-对象型变量不能作为C语言结构体的成员" class="headerlink" title="7. 对象型变量不能作为C语言结构体的成员"></a>7. 对象型变量不能作为C语言结构体的成员</h3><p>C语言的结构体如果存在Objective-C对象型变量，便会引起错误，因为C语言在规约上没有方法来管理结构体成员的生存周期 。</p>
<h3 id="8-显式转换id和void"><a href="#8-显式转换id和void" class="headerlink" title="8. 显式转换id和void*"></a>8. 显式转换id和void*</h3><p>非ARC下，这两个类型是可以直接赋值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj = [NSObject alloc] init];</div><div class="line">void *p = obj;</div><div class="line">id o = p;</div></pre></td></tr></table></figure>
<p>但是在ARC下就会引起编译错误。为了避免错误，我们需要通过__bridege来转换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span>*)obj;<span class="comment">//显式转换</span></div><div class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;<span class="comment">//显式转换</span></div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>来看一下属性的声明与所有权修饰符的关系</p>
<table>
<thead>
<tr>
<th>属性关键字</th>
<th>所有权 修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>__unsafe_unretained</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
</tr>
</tbody>
</table>
<p>说一下<strong>unsafe_unretained：
</strong>unsafe_unretained表示存取方法会直接为实例变量赋值。</p>
<p>这里的“unsafe”是相对于weak而言的。我们知道weak指向的对象被销毁时，指针会自动设置为nil。而__unsafe_unretained却不会，而是成为空指针。需要注意的是：当处理非对象属性的时候就不会出现空指针的问题。</p>
<p>这样第一章就介绍完了，第二篇会在下周一发布^^</p>
<hr>
<p>扩展文献：</p>
<ol>
<li><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Apple:Transitioning to ARC Release Notes</a> </li>
<li><a href="http://www.jianshu.com/p/6cf682f90fa2" target="_blank" rel="external">蚊香酱:可能是史上最全面的内存管理文章</a></li>
<li><a href="http://www.jianshu.com/p/0ad9957e3716" target="_blank" rel="external">微笑和飞飞:可能碰到的iOS笔试面试题（6）–内存管理</a></li>
<li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00RWORA1O/ref=sr_1_1?ie=UTF8&amp;qid=1491531635&amp;sr=8-1&amp;keywords=ios%E7%BC%96%E7%A8%8B" target="_blank" rel="external">《iOS编程(第4版)》</a> </li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/03/20/基于MVVM，用于快速搭建设置页，个人信息页的框架（附：仿微信iOS客户端发现页，个人页，设置页Demo）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/20/基于MVVM，用于快速搭建设置页，个人信息页的框架（附：仿微信iOS客户端发现页，个人页，设置页Demo）/" itemprop="url">
                  基于MVVM，用于快速搭建设置页，个人信息页的框架（附：仿微信iOS客户端发现页，个人页，设置页Demo）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-20T13:47:51+08:00">
                2017-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Production/" itemprop="url" rel="index">
                    <span itemprop="name">Production</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>写UITableView的时候，我们经常遇到的是完全依赖于网络请求，需要自定义的动态cell的需求（比如微博帖子列表）。但是同时，大多数app里面几乎也都有设置页，个人页等其他以静态表格为主的页面。</p>
<p>而且这些页面的共性比较多：</p>
<ol>
<li>大多数情况下在进入页面之前就已经拿到所有数据。</li>
<li>cell样式单一，自定义cell出现的几率比较小（几乎都是高度为44的cell）。</li>
<li>多数都分组。</li>
</ol>
<p>因为自己非常想写一个开源的东西出来（也可以暴露自己的不足），同时又受限于水平，所以就打算写这么一个比较简单，又具有通用性的框架：<strong>一个定制性比较高的适合在个人页和设置页使用的UITableView</strong>。</p>
<p>在真正写之前，看了几篇类似的文章，挑出三篇自己觉得比较好的：</p>
<ol>
<li><a href="https://www.objc.io/issues/1-view-controllers/table-views/">Clean Table View Code</a> </li>
<li><a href="http://www.jianshu.com/p/504c61a9dc82">如何写好一个UITableView</a></li>
<li><a href="http://www.jianshu.com/p/81d0c573f7a8">利用MVVM设计快速开发个人中心、设置等模块</a></li>
</ol>
<p>看完总结之后，利用上周3天的业余时间写好了这个框架，为了它实用性，我仿照了微信客户端的发现页，个人页和设置页写了一个Demo，来看一下效果图：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjstatictableview_1.png" alt="发现页 | 个人页 | 个人信息页 | 设置页"><br>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/20/基于MVVM，用于快速搭建设置页，个人信息页的框架（附：仿微信iOS客户端发现页，个人页，设置页Demo）/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/03/14/先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/14/先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结/" itemprop="url">
                  先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T08:37:08+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Career/" itemprop="url" rel="index">
                    <span itemprop="name">Career</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://upload-images.jianshu.io/upload_images/859001-10c56d4121bfe78d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Objective-C | Swift | C"></p>
<p>这篇面试总结很短，也没有面试题的答案，只是写给像我一样的非科班iOS开发者的一些话。</p>
<p>昨天进行了人生第一次视频面试，一共三个小时的技术面，还没见到人事，应该是挂了。</p>
<p>不过整个过程下来感触还是蛮多的，除了感受到面试官的牛X之外，也知道自己平时在学习中的不足。</p>
<h4 id="先介绍一下面试中觉得比较吃力的问题："><a href="#先介绍一下面试中觉得比较吃力的问题：" class="headerlink" title="先介绍一下面试中觉得比较吃力的问题："></a>先介绍一下面试中觉得比较吃力的问题：</h4><ol>
<li>如果让你实现属性的weak，如何实现的？</li>
<li>如果让你来实现属性的atomic，如何实现？</li>
<li>KVO为什么要创建一个子类来实现？</li>
<li>类结构体的组成，isa指针指向了什么？（这里应该将元类和根元类也说一下）</li>
<li>RunLoop有几种事件源？有几种模式？</li>
<li>方法列表的数据结构是什么？</li>
<li>分类是如何实现的？它为什么会覆盖掉原来的方法？</li>
</ol>
<p>另外值得一提的就是问了我自己写的博客里的东西（JSONModel的解析，EOC的笔记）等等。。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/03/14/先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/02/22/JSONModel源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/22/JSONModel源码解析/" itemprop="url">
                  JSONModel源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-22T09:16:56+08:00">
                2017-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这一系列的<a href="http://www.jianshu.com/nb/9137726">源码解析</a>分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。</p>
<p>想来想去，还是从<a href="https://github.com/jsonmodel/jsonmodel">JSONModel</a>开始吧～</p>
<p>首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。</p>
<p>该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/22/JSONModel源码解析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/02/14/VVeboTableView源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/14/VVeboTableView源码解析/" itemprop="url">
                  VVeboTableView源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-14T10:57:30+08:00">
                2017-02-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这次分享一个关于性能优化的源码。</p>
<p>我们知道<code>UITabelView</code>在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，<code>UITabelView</code>的性能将直接影响这个app的性能。</p>
<p>如果<code>UITabelView</code>里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。</p>
<p>但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。</p>
<p>最近在看一些iOS性能优化的文章，我找到了<a href="https://github.com/johnil/VVeboTableViewDemo">VVeboTableView</a>这个框架。严格来说这个不属于框架，而是作者用自己的方式优化<code>UITableView</code>的一个实现。</p>
<p>作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？</p>
<p>看了源码之后，我把作者的思路整理了出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png" alt="优化思路图"></p>
<p>下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/14/VVeboTableView源码解析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/02/09/PNChart源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/09/PNChart源码解析/" itemprop="url">
                  PNChart源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-09T11:33:20+08:00">
                2017-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一. 框架介绍"></a>一. 框架介绍</h2><p><a href="https://github.com/kevinzhow/PNChart">PNChart</a>是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。</p>
<p>该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类<code>PNGenericChart</code>,第二层就是所有类型的图表。提供一张图来直观感受一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png" alt="层级图"></p>
<blockquote>
<p>在这张图里，需要注意以下几点：</p>
<ol>
<li>带箭头的线和不带箭头的线的区别。</li>
<li><code>Data</code>类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有<code>Data</code>类，因为饼状图没有多组数据，而折线图<code>LineChart</code>是支持多组数据的，所以有<code>Data</code>类。</li>
<li><code>Item</code>类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。</li>
<li><code>BarChart</code>类里面的每一根柱子都是<code>PNBar</code>的实例（该类型的图表不在本篇讲解的范围之内）。</li>
</ol>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/09/PNChart源码解析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/02/04/MJRefresh 源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/04/MJRefresh 源码解析/" itemprop="url">
                  MJRefresh源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-04T09:30:17+08:00">
                2017-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a>是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。</p>
<p>该框架的结构设计得很清晰，使用一个基类<code>MJRefreshComponent</code>来做一些基本的设定，然后通过继承的方式，让<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png" alt="框架组织结构图"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/04/MJRefresh 源码解析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/02/04/SDWebImage源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/02/04/SDWebImage源码解析/" itemprop="url">
                  SDWebImage源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-02-04T09:24:37+08:00">
                2017-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>相信对于广大的iOS开发者，对<a href="https://github.com/rs/SDWebImage">SDWebImage</a>并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。</p>
<p>在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>] placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>] completed:^(<span class="built_in">UIImage</span> * _Nullable image, <span class="built_in">NSError</span> * _Nullable error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> * _Nullable imageURL) &#123;</div><div class="line">        </div><div class="line">        imageview.image = image;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图片加载完成"</span>);</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//图片下载完成后直接显示下载后的图片</span></div><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>]];</div></pre></td></tr></table></figure>
<p>在最开始先简单介绍这个框架：</p>
<p>这个框架的核心类是<code>SDWebImageManger</code>，在外部有<code>UIImageView+WebCache</code> 和 <code>UIButton+WebCache</code> 为下载图片的操作提供接口。内部有<code>SDWebImageManger</code>负责处理和协调 <code>SDWebImageDownloader</code> 和 <code>SDWebImageCache</code>：<code>SDWebImageDownloader</code>负责具体的下载任务，<code>SDWebImageCache</code>负责关于缓存的工作：添加，删除，查询缓存。</p>
<p>首先我们大致看一下这个框架的调用流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage"></p>
<p>从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。</p>
<p>OK～基本流程大概清楚了，我们看一下每个层具体实现吧～</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/02/04/SDWebImage源码解析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/17/MBProgressHUD源码解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/17/MBProgressHUD源码解析/" itemprop="url">
                  MBProgressHUD源码解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-17T17:02:54+08:00">
                2017-01-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的<strong>读好源码Project</strong>。</p>
<p>从哪个框架开始呢？我想到了<code>SDWebImage</code>，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～</p>
<p>找着找着就找到了<code>MBProgressHUD</code>，这个框架只有两个文件，一个头文件和一个实现文件，很适合我现在的水平（对于一个没怎么读过源码的选手），于是就撸起了袖子开始了。</p>
<p>连查知识点带记笔记一共花了大概3个小时（虽然文件很少，但是里面好多东西都不知道[捂脸]）。整体说来，收获还是比较大的，除了一些零碎的语法之外，框架作者对于代码结构的设计和各种情况的考虑还是很出色的，很值得学习，而且我在下文也有介绍。</p>
<p>这篇总结主要分三个部分来介绍这个框架：</p>
<ol>
<li>核心Public API</li>
<li>方法调用流程图</li>
<li>方法内部实现</li>
</ol>
<p>不多说了，开始吧～</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/17/MBProgressHUD源码解析/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/13/2016年终总结 | 善于总结，把握方向/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/13/2016年终总结 | 善于总结，把握方向/" itemprop="url">
                  2016年终总结 | 善于总结，把握方向
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-13T13:55:17+08:00">
                2017-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Career/" itemprop="url" rel="index">
                    <span itemprop="name">Career</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>记得去年这个时候看到很多同行写了年终总结，当时只工作了1个月的我觉得很是高大上。转眼一年过去了，从第一家公司来到现在的这家公司，无论技术上还是思想上都成熟了一些，巧的是简书在这个时候给我们这个平台来写年终总结。贵在参与，也为了自己，写一篇吧～</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-88a964d0151cb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GoodBye 2016，Welcome 2017"></p>
<p>2016年，是我事业起步的第一年，现在回头看去，这一年大致分为五个时期：</p>
<ol>
<li><strong>技术基础建设期（1月～5月）</strong>：从iOS小白的小白到独立上线app。</li>
<li><strong>技术快速成长期（6月～9月）</strong>：简书更新30篇文章，粉丝达到1000+。</li>
<li><strong>写简历找工作期（10月）</strong>：8家面试，3个offer。</li>
<li><strong>适应新的公司期（11月）</strong>：新项目1个月内上架。</li>
<li><strong>明年方向定位期（12月）</strong>：决定研究Hybrid app开发。</li>
</ol>
<p>下面开始按时间顺序分别总结一下每个时期里我的所做所思。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/13/2016年终总结 | 善于总结，把握方向/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/13/2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/13/2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer/" itemprop="url">
                  2016年10月求职记 | iOS工作经验不到1年，在1个月内拿到了3个offer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-13T13:54:44+08:00">
                2017-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Career/" itemprop="url" rel="index">
                    <span itemprop="name">Career</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>真的是非常非常感谢我的新东家，在我最需要新工作的时候给我抛来橄榄枝~</p>
<p>新东家的知名度很高，但并不是做互联网起家的，是一家有自己线下产业的大公司，创立时间也比较久，新项目（互联网）的技术团队组成非常优秀，所以虽然给我的待遇并没有很多，但还是毫不犹豫选择了这一家。为此还谢绝了后面的面试邀请（因为要准备一些入职材料和入职之前的相关学习）。</p>
<p>笔者在国庆节期间准备简历，在国庆节后开始投递简历。从最开始投递简历到拿到最后一个offer历时3周多。因为在这段求职时间里感触很多，所以想专门写一篇博客来讲述一下自己的求职心得，希望能给各位年底求职的小伙伴，特别是做iOS的同行一些值得借鉴的东西。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-23f60ab52ef7bafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/13/2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/13/高度封装FMDB框架：各用一句代码更新（添加&修改），查询，删除用户信息/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/13/高度封装FMDB框架：各用一句代码更新（添加&修改），查询，删除用户信息/" itemprop="url">
                  高度封装FMDB框架：各用一句代码更新（添加&修改），查询，删除用户信息
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-13T13:54:08+08:00">
                2017-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Production/" itemprop="url" rel="index">
                    <span itemprop="name">Production</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>在移动开发中，有时不得不在客户端本地保存一些数据。在iOS端，我们可以使用plist，属性列表等技术来存储数据，而相比而下更高端一点的，我们也可以使用<strong>数据库</strong>来存储数据。</p>
<p>有趣的是，很多iOS开发者没有去选择使用苹果自家的Core Data技术来操作数据库，而是选择了<a href="[https://github.com/ccgus/fmdb](https://github.com/ccgus/fmdb">FMDB</a>)这个第三方框架。</p>
<p>该框架很好地封装了操作繁琐的SQLite语句，让数据库的操作更加面向对象，而且上手快，门槛低，不用学习数据库的相关知识就可以使用自如。如此优秀流行的框架是值得学习的，于是笔者这两天研究了一下FMDB。研究后，略有所思，将它封装了一下，写了一个<code>Manager</code>类，最后结合了一个Demo演示如何使用这个类。</p>
<p>该博客分为两个部分:第一个部分讲解笔者封装的这个<code>Manager</code>类；第二部分结合Demo来体现该类的实用性。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/13/高度封装FMDB框架：各用一句代码更新（添加&修改），查询，删除用户信息/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（三）：技巧篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/13/《Effective Objective-C》超级干货三部曲（三）：技巧篇/" itemprop="url">
                  《Effective Objective-C》超级干货三部曲（三）：技巧篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-13T13:52:57+08:00">
                2017-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>《Effective Objective-C 》超级干货三部曲系列迎来了最后一篇：技巧篇，这一篇总结汇总了这本书中一些用来解决问题的偏向“设计模式”的知识点。</p>
<p>不知道笔者所谓的三部曲的童鞋们可以看一下这张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0599d987732d932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<p>前两篇传送门：<br><a href="http://www.jianshu.com/p/9c93c7ab734d">《Effective Objective-C 》超级干货三部曲（一）：概念篇</a><br><a href="http://www.jianshu.com/p/0b895e39eca1">《Effective Objective-C 》超级干货三部曲（二）：规范篇</a></p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/13/《Effective Objective-C》超级干货三部曲（三）：技巧篇/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（二）：规范篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/13/《Effective Objective-C》超级干货三部曲（二）：规范篇/" itemprop="url">
                  《Effective Objective-C》超级干货三部曲（二）：规范篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-13T13:52:04+08:00">
                2017-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>继上一篇<a href="http://www.jianshu.com/p/9c93c7ab734d">《Effective Objective-C 》超级干货三部曲（一）：概念篇</a>之后，本篇即是三部曲的第二篇：规范篇。<br>没看过三部曲第一篇的小伙伴可能不知道我在说神马，在这里还是先啰嗦一下三部曲是咋回事：笔者将《Effective Objective-C 》这本书的52个知识点分为三大类进行了归类整理：</p>
<ul>
<li>概念类：讲解了一些概念性知识。</li>
<li>规范类：讲解了一些为了避免一些问题或者为后续开发提供便利所需要遵循的规范性知识。</li>
<li>技巧类：讲解了一些为了解决某些特定问题而需要用到的技巧性知识。</li>
</ul>
<p>然后用思维导图整理了一下：<br><img src="http://upload-images.jianshu.io/upload_images/859001-0599d987732d932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<p>作为三部曲的第二篇，本篇总结抽取了《Effective Objective-C 》这本书中讲解规范性知识的部分：这些知识点都是为了避免在开发过程中出现问题或给开发提供便利的规范性知识点。掌握这些知识有助于形成科学地写OC代码的习惯，使得代码更加容易维护和扩展，学习这类知识是iOS初学者进阶的必经之路。</p>
<p>好吧，不费话了，开始了！</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/13/《Effective Objective-C》超级干货三部曲（二）：规范篇/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（一）：概念篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="J_Knight">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="J_Knight">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/13/《Effective Objective-C》超级干货三部曲（一）：概念篇/" itemprop="url">
                  《Effective Objective-C》超级干货三部曲（一）：概念篇
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-01-13T13:50:51+08:00">
                2017-01-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Objective-C/" itemprop="url" rel="index">
                    <span itemprop="name">Objective-C</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计</span>
                
                <span title="字数统计">
                  
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>很多文章和大牛都在推荐这本书，说它讲授了很多编写Objective-C语言时所应该遵循的规范。刚好笔者前段时间因为产品刚开发完，有了一点空档期，于是用了3个星期的时间仔细研读和总结了这本书。</p>
<p>在学习过程中也看过很多总结这本书的博客和文章，但是发现多数只是将每节的总结部分抄了过来，讲得并不是很详细，于是笔者就想按照自己的方式对这本书进行总结，并以博客的形式展现出来：既能分享，同时又能对知识进行一下梳理和二次复习。</p>
<p>虽然本书的作者按照知识模块来将这本书分成七个章节，共52节，但是笔者在拜读的过程中发现本书介绍的知识点可以大致分为三类：概念类，规范类，和技巧类。笔者打算按照这三类来对这本书进行总结，形成三部曲：</p>
<ul>
<li>概念类：讲解了一些概念性知识。</li>
<li>规范类：讲解了一些为了避免一些问题或者为后续开发提供便利所需要遵循的规范性知识。</li>
<li>技巧类：讲解了一些为了解决某些特定问题而需要用到的技巧性知识。</li>
</ul>
<p>而且，笔者也按照自己的归类将这本书的结构用思维导图工具画了出来：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-539498fef0819472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<blockquote>
<p>从图中可以看到，笔者并没有打乱原来作者的标题顺序。本篇总结即是三部曲之一：概念篇，后续会呈上规范篇和技巧篇。<br>备注：本总结所有的代码和图片都来自原书。其中，代码会适当加上笔者的注释，便于各位看官理解。</p>
</blockquote>
<p>好了，不啰嗦了， 开始吧！</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/01/13/《Effective Objective-C》超级干货三部曲（一）：概念篇/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg"
               alt="J_Knight" />
          <p class="site-author-name" itemprop="name">J_Knight</p>
           
              <p class="site-description motion-element" itemprop="description">正在学hybrid开发的iOS开发者</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">38</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">8</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">J_Knight</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  






  





  

  

  

  

</body>
</html>

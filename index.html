<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Knight_SJ" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="在学hybrid开发的iOS开发者">
<meta property="og:type" content="website">
<meta property="og:title" content="Knight_SJ">
<meta property="og:url" content="https://github.com/knightsj/knightsj.github.io/index.html">
<meta property="og:site_name" content="Knight_SJ">
<meta property="og:description" content="在学hybrid开发的iOS开发者">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Knight_SJ">
<meta name="twitter:description" content="在学hybrid开发的iOS开发者">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/knightsj/knightsj.github.io/"/>





  <title> Knight_SJ </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Knight_SJ</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">iOS开发|上海</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:30:42+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇是斯坦福大学iOS7系列课程（CS193P）的最后一节课的总结，终于把18节课的内容都总结完了，而且这个文集也画上了句号，有点不舍的赶脚。。</p>
<p>好了，不煽情了，开始！</p>
<h1 id="国际化-Internationalization"><a href="#国际化-Internationalization" class="headerlink" title="国际化 Internationalization"></a>国际化 Internationalization</h1><hr>
<p>如果我们想要将app推广到国际市场，那么就免不了将我们的app翻译成其他国家的语言以便于当地人去使用。</p>
<p>而翻译的内容主要集中于“非内容”部分：例如标题类文字，按钮上的文字，提示框的文字等等。</p>
<p>所谓“翻译”app的过程主要分为<strong>国际化</strong>和<strong>本地化</strong>两个步骤：</p>
<ol>
<li>国际化：是让app能够本地化的过程。</li>
<li>本地化：将程序翻译另外一种语言。<ul>
<li>故事版字符串的本地化：改变故事版中出现的字符串。</li>
<li>类文件字符串的本地化：改变文件中出现的字符串，包括字符串面量和非字符串面量。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>好的UI设计：给用户呈现出的内容大多数都需要显示的（内容），而不是自己添加的（提示）。这样一来，也会减少我们本地化的工作量。</li>
<li>所有的地方都要设置好自动布局，否则本地化将无从谈起，因为将文字翻译成其他语言后，长度很可能是不一样的。</li>
</ol>
</blockquote>
<p>下面来来具体看一下本地化的方法，分为<strong>故事版中字符串</strong>的本地化和<strong>类文件中字符串</strong>的本地化。</p>
<h2 id="1-故事版中的本地化"><a href="#1-故事版中的本地化" class="headerlink" title="1. 故事版中的本地化"></a>1. 故事版中的本地化</h2><p>在故事版中本地化的过程是：</p>
<ol>
<li>在项目里添加其他语言。</li>
<li>在被添加语言的故事版文件中找到相应的.string文件，加以更改。</li>
</ol>
<p>具体过程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-917657136741d815.gif?imageMogr2/auto-orient/strip" alt="故事版的本地化.gif"></p>
<h2 id="2-类文件中字符串的本地化"><a href="#2-类文件中字符串的本地化" class="headerlink" title="2. 类文件中字符串的本地化"></a>2. 类文件中字符串的本地化</h2><p>除了需要本地化故事版中的字符串，类文件中的字符串也需要本地化，因为故事版并不能显示所有需要翻译的字符串。</p>
<p>而且，类文件中的字符串分为两种形式：</p>
<ol>
<li>字符串面量。</li>
<li>非字符串面量。</li>
</ol>
<p>所谓字符串面量，就是用<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>NSString *myName = @“Jack”;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">类似这样的字符串是比较好找的，只需要搜索```@```即可很容易找到。</div><div class="line">但是，我们仍然会通过该方法搜索到不应该本地化的字符串：</div><div class="line">也就是不出现在UI中的字符串面量。</div><div class="line"></div><div class="line">例如：</div><div class="line"></div><div class="line">- 文件扩展名</div><div class="line">- segure的identifier</div><div class="line">- stiringWithFormat:</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 2.1字符串面量的本地化步骤：</div><div class="line"></div><div class="line"></div><div class="line">1. 找到需要本地化的字符串面量。</div><div class="line">2. 通过宏，将字符串面量添加到表中。</div><div class="line">3. 创建表的.string文件。</div><div class="line">4. 本地化.string文件</div><div class="line"></div><div class="line">﻿</div><div class="line">1.找到```@&quot;Sorry, this device cannot add a photo.&quot;```字符串面量。</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)viewDidAppear:(BOOL)animated<br>{<br>  [super viewDidAppear:animated];<br>  if (![[self class] canAddPhoto]) {</p>
<pre><code>[self fatalAlert:@&quot;Sorry, this device cannot add a photo.&quot;]; //
</code></pre><p>  } else {</p>
<pre><code>[self.locationManager startUpdatingLocation];
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">2.通过宏，将字符串面量添加到表中。</div></pre></td></tr></table></figure>
</li>
<li><p>(void)viewDidAppear:(BOOL)animated<br>{<br>  [super viewDidAppear:animated];</p>
<p>  if (![[self class] canAddPhoto]) {</p>
<pre><code>[self fatalAlert:ALERT_CANT_ADD_PHOTO]; // @&quot;Sorry, this device cannot add a photo.&quot;
</code></pre><p>  } else {</p>
<pre><code>[self.locationManager startUpdatingLocation];
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
</li>
</ul>
<p>#define ALERT_CANT_ADD_PHOTO NSLocalizedStringFromTable(@”ALERT_CANT_ADD_PHOTO”, @”AddPhotoViewController”, @”Alert message delivered when there is something that prevents the user from adding a new photo to the database that the user can do nothing about.”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">3.创建表的.string文件</div><div class="line"></div><div class="line">我们已经在AddPhotoViewController.m文件里将需要本地化的字符串添加到了叫做AddPhotoViewController的表里，下面就需要用命令行工具找到该.m文件：</div><div class="line"></div><div class="line">![找到.m文件所在目录](http://upload-images.jianshu.io/upload_images/859001-a043fa2da855615c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">![输入genstrigns ^*m命令](http://upload-images.jianshu.io/upload_images/859001-b3adf539663b1269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line">4.本地化.string文件</div><div class="line"></div><div class="line">在第三步中，我们需要手动创建```AddPhotoViewController```表的.string文件，然后在文件内部将对应的key进行翻译。因为过程略繁琐，所以以动图的形式呈献给大家：</div><div class="line"></div><div class="line">![本地化string.gif](http://upload-images.jianshu.io/upload_images/859001-100dfbddbe7399bb.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line"></div><div class="line">&gt;失误了，右侧的字符串应该是没有“@”的，大家注意。因为到最后才发现的，不好改了 额。。 理解万岁。。</div><div class="line"></div><div class="line">## 2.2 非字面量字符串的本地化：</div><div class="line"></div><div class="line">在类文件里，有些显示出来的字符串并不都是通过字符串面量赋值的，比如下面这个例子：</div></pre></td></tr></table></figure></p>
<p>self.title = newfrc.fetchRequest.entity.name;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在这里，title取的是模型里的字段，并没有用字面量语法来表示。</div><div class="line">对于这种情况，我们需要用NSBundle的```localizedStringForKey:value:table:```方法来进行本地化。</div></pre></td></tr></table></figure></p>
<p>self.title = [[NSBundle mainBundle] localizedStringForKey:newfrc.fetchRequest.entity.name<br>                         value:newfrc.fetchRequest.entity.name<br>                         table:@”Entities”];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样一来，我们就生成了对应名字叫**Entities**的表的映射。但是这张表对应的.string文件还没有生成，需要我们手动去生成，并设置对应的key和value。生成方法如下所示：</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">![手动生成.string文件](http://upload-images.jianshu.io/upload_images/859001-965d85e9b008d0c8.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># 设置页的UI</div><div class="line">---------</div><div class="line"></div><div class="line">在苹果系统的设置里，会有我们装入的app的信息和设置。有时，我们需要将一些设置选项放在这里面供用户使用。</div><div class="line"></div><div class="line">而这里的UI是通过通过Settings bundle来设定的。我们首先要新建一个Settings Bundle:</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">![创建Settings Bundle](http://upload-images.jianshu.io/upload_images/859001-d49a21d343306156.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line">创建成功后，分别有一个slider，switch，和textfield来对应设置页里的UI。</div><div class="line"></div><div class="line">在设置页里的样子是这样的：</div><div class="line"></div><div class="line"></div><div class="line">![新建的Settings Bundle 后的设置页效果](http://upload-images.jianshu.io/upload_images/859001-6dc1b24f8d070871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line">那么如何使用呢？我们设置一下上一节课的Bouncer Demo的弹性系数：让用户通过调节设置里的slider来调整app里的弹性系数。</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)resetElasticity<br>{<br>  //连接代码与Setting Bundle<br>  NSNumber *elasticity = [[NSUserDefaults standardUserDefaults] valueForKey:@”Setting_Elasticity”];//连接setting bundle<br>  if (elasticity) {</p>
<pre><code>//如果有，就取当前设定的
self.elastic.elasticity = [elasticity floatValue];
</code></pre><p>  } else {</p>
<pre><code>//如果没有，就设置为1
self.elastic.elasticity = 1.0;
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">在这里，通过```valueForKey```的键值对应了Setting Bundle plist 文件里的```identifier```，我们将plist文件里的```identifier```修改成了```Setting_Elasticity```而且更改了```Title```，而且将按钮和文本框删除掉，只保留了slider：</div><div class="line"></div><div class="line">![Setting Bundle plist](http://upload-images.jianshu.io/upload_images/859001-f195429739d8262b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line">所对应的设置页的UI：</div><div class="line"></div><div class="line">![新的设置页UI](http://upload-images.jianshu.io/upload_images/859001-1d15dcab18d5df94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">现在我们可以通过identifier连接了代码和plist文件，获取到了键对应的值。</div><div class="line"></div><div class="line">而且，我们还需考虑在程序运行过程中，用户跳转到了设置页面来设置弹性系数的情况。因此，我们需要监听用户是否更改了设置里的选项：</div><div class="line"></div><div class="line"></div><div class="line">监听用户在设置中的行为：</div></pre></td></tr></table></figure>
<p>  [[NSNotificationCenter defaultCenter] addObserverForName:NSUserDefaultsDidChangeNotification</p>
<pre><code>    object:nil
     queue:nil
usingBlock:^(NSNotification *note) {
    [self resetElasticity];
}];
</code></pre><p>```</p>
</li>
</ul>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>当~当~当~当~！<br>笔者终于利用了2个月的部分业余时间总结了所有斯坦福iOS7的课程和相关Demo。通过以博客的形式总结，更加加深了对知识的理解和认识，也对基础知识进行了一次查缺补漏，或许也在一定程度上给其他看到这些博客的同仁们一些帮助吧~</p>
<p>最后附上这一系列笔者总结的所有Demo在GitHub上的地址：<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">Stanford_iOS_Lecture_DemoBundle</a>。</p>
<p>笔者下一阶段应该是总结下面两本书的内容：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0eeac0652f909c84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Effective Objective- C 2.0"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c1046257878a01d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Swift 基础教程"></p>
<p>这两本书笔者都已经看了3分之一，因为要总结归纳，所以应该进度不是很快，不过还是会坚持写博客的！</p>
<p>加油~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十七）：CoreMotion，app的生命周期，方块碰撞游戏Demo/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（十七）：CoreMotion，app的生命周期，方块碰撞游戏Demo/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（十七）：CoreMotion，app的生命周期，方块碰撞游戏Demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:30:02+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本节课讲解了Core Motion框架的知识，简单介绍了app的生命周期，最后用一个方块碰撞游戏来对本节课的知识作总结。</p>
<h1 id="Core-Motion"><a href="#Core-Motion" class="headerlink" title="Core Motion"></a>Core Motion</h1><hr>
<p>CoreMotion是一个专门处理设备“动作”的框架，其中包含了加速度计，陀螺仪和磁力针。加速计由三个坐标轴决定，用户最常见的操作设备的动作移动，晃动手机(摇一摇)，倾斜手机都可以被设备检测到，加速计可以检测到线性的变化。陀螺仪可以更好的检测到偏转的动作，可以根据用户的动作做出相应的动作；磁力针可以判断设备的方向。</p>
<p>CoreMotion的工作是基于<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## CMMotionManager</div><div class="line"></div><div class="line">### 检测硬件设备：</div></pre></td></tr></table></figure></p>
<p>@property(readonly, nonatomic, getter=isAccelerometerAvailable) BOOL accelerometerAvailable <strong>TVOS_PROHIBITED;<br>@property(readonly, nonatomic, getter=isGyroAvailable) BOOL gyroAvailable </strong>TVOS_PROHIBITED;<br>@property(readonly, nonatomic, getter=isMagnetometerAvailable) BOOL magnetometerAvailable NS_AVAILABLE(NA,5_0) <strong>TVOS_PROHIBITED;<br>@property(readonly, nonatomic, getter=isDeviceMotionAvailable) BOOL deviceMotionAvailable </strong>TVOS_PROHIBITED;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 开启相应的模块：</div></pre></td></tr></table></figure></p>
<ul>
<li>(void)startAccelerometerUpdates __TVOS_PROHIBITED;</li>
<li>(void)startGyroUpdates __TVOS_PROHIBITED;</li>
<li>(void)startMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</li>
<li>(void)startDeviceMotionUpdates __TVOS_PROHIBITED;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 检测相应的模块是否正在收集数据：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@property(readonly, nonatomic, getter=isAccelerometerActive) BOOL accelerometerActive <strong>TVOS_PROHIBITED;<br>@property(readonly, nonatomic, getter=isGyroActive) BOOL gyroActive </strong>TVOS_PROHIBITED;<br>@property(readonly, nonatomic, getter=isMagnetometerActive) BOOL magnetometerActive NS_AVAILABLE(NA,5_0) <strong>TVOS_PROHIBITED;<br>@property(readonly, nonatomic, getter=isDeviceMotionActive) BOOL deviceMotionActive </strong>TVOS_PROHIBITED;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 关闭相应的模块：</div></pre></td></tr></table></figure>
<ul>
<li><p>(void)stopAccelerometerUpdates __TVOS_PROHIBITED;</p>
</li>
<li><p>(void)stopGyroUpdates __TVOS_PROHIBITED;</p>
</li>
<li><p>(void)stopMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</p>
</li>
<li><p>(void)stopDeviceMotionUpdates __TVOS_PROHIBITED; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 使用block监听</div></pre></td></tr></table></figure>
</li>
<li><p>(void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler __TVOS_PROHIBITED;</p>
</li>
<li><p>(void)startGyroUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMGyroHandler)handler __TVOS_PROHIBITED;</p>
</li>
<li><p>(void)startMagnetometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMMagnetometerHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</p>
</li>
<li><p>(void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame toQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">### CMMotionManager的工作步骤</div><div class="line">1. 首先初始化```CMMotionManager```类。</div><div class="line">2. 判断硬件设备的可使用性。</div><div class="line">3. 调用API</div><div class="line">详细的使用方法请看Demo部分的讲解部分。</div><div class="line"></div><div class="line"># app的生命周期</div><div class="line">---------</div><div class="line"></div><div class="line">程序在运行过程中，是由各种不同的状态的，在这些状态之间切换时可以执行一些代码用于满足一定的业务需求。</div><div class="line"></div><div class="line">## 应用程序的几种状态：</div><div class="line">- Not running:未运行  程序没启动</div><div class="line">- Inactive:未激活, 程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。</div><div class="line">- Active:激活,  程序在前台运行而且接收到了事件。这是程序在前台运行的正常状态。</div><div class="line">- Backgroud:后台, 程序在后台而且能执行代码。大多数程序进入这个状态后会在在这个状态上停留一会， 时间到之后会进入挂起状态(Suspended)。</div><div class="line">- Suspended:挂起 ,程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为当前处于前台程序提供更多的内存。</div><div class="line"></div><div class="line">## 应用程序的状态之间切换时调用的代理方法（AppDelegate）：</div></pre></td></tr></table></figure>
</li>
<li><p>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions   //启动基本完成，程序准备开始运行时调用。</p>
</li>
<li>(void)applicationWillResignActive:(UIApplication *)application          //当应用程序将要入非活动状态执行。在此期间，应用程序不接收消息或事件，比如来电话时。</li>
<li>(void)applicationDidBecomeActive:(UIApplication *)application           //当应用程序入活动状态执行。</li>
<li>(void)applicationDidEnterBackground:(UIApplication *)application        //当程序被推到后台的时候调用。</li>
<li>(void)applicationWillEnterForeground:(UIApplication *)application       //当程序从后台将要重新回到前台时候调用。</li>
<li><p>(void)applicationWillTerminate:(UIApplication *)application             // 当程序将要退出时调用，通常是用来保存数据和一些退出前的清理工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># Demo </div><div class="line">----</div><div class="line"></div><div class="line">## Demo需求:</div><div class="line">- 显示两个小方块，一黑一红，二者可以随着屏幕的转动而移动。</div><div class="line">- 由红色方块碰撞黑色方块来得分。</div><div class="line"></div><div class="line">## Demo效果图：</div><div class="line"></div><div class="line">![左：游戏进行中 | 右：游戏暂停](http://upload-images.jianshu.io/upload_images/859001-baa2c6607140ad2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">## 重要知识点和代码段：</div><div class="line"></div><div class="line">#### 1. 添加animator和重力行为和碰撞行为</div></pre></td></tr></table></figure>
</li>
<li><p>(UIDynamicAnimator *)animator<br>{<br>  if (!_animator) _animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];<br>  return _animator;<br>}</p>
</li>
<li><p>(UICollisionBehavior *)collider<br>{<br>  if (!_collider) {</p>
<pre><code>UICollisionBehavior *collider = [[UICollisionBehavior alloc] init];
collider.translatesReferenceBoundsIntoBoundary = YES;
[self.animator addBehavior:collider];
self.collider = collider;
</code></pre><p>  }<br>  return _collider;<br>}</p>
</li>
<li><p>(UIGravityBehavior *)gravity<br>{<br>  if (!_gravity) {</p>
<pre><code>UIGravityBehavior *gravity = [[UIGravityBehavior alloc] init];
[self.animator addBehavior:gravity];
self.gravity = gravity;
</code></pre><p>  }<br>  return _gravity;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;老规矩，还是要将animtor添加到view里面再向其添加各种动作行为。有关动画的讲解请参考笔者之前一篇总结：[斯坦福大学iOS开发公开课总结（八） ：协议，block，动画，俄罗斯方块Demo](http://www.jianshu.com/p/5f1f40f963ac)。</div><div class="line"></div><div class="line">#### 2. 根据偏移量来设置方块的位置</div></pre></td></tr></table></figure>
</li>
<li><p>(UIView *)addBlockOffsetFromCenterBy:(UIOffset)offset<br>{<br>  CGPoint blockCenter = CGPointMake(CGRectGetMidX(self.view.bounds)+offset.horizontal,</p>
<pre><code>CGRectGetMidY(self.view.bounds)+offset.vertical);
</code></pre><p>  CGRect blockFrame = CGRectMake(blockCenter.x-blockSize.width/2,</p>
<pre><code>blockCenter.y-blockSize.height/2,
blockSize.width,
blockSize.height);
</code></pre><p>  UIView *block = [[UIView alloc] initWithFrame:blockFrame];<br>  [self.view addSubview:block];<br>  return block;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;在这里，使用了```CGRectGetMidX```函数来获得view的横向中心点。</div><div class="line"></div><div class="line">#### 3. 初始化红色和黑色方块</div></pre></td></tr></table></figure>
<pre><code>self.redBlock = [self addBlockOffsetFromCenterBy:UIOffsetMake(-100, 0)];
self.redBlock.backgroundColor = [UIColor redColor];
[self.collider addItem:self.redBlock];
[self.gravity addItem:self.redBlock];

self.blackBlock = [self addBlockOffsetFromCenterBy:UIOffsetMake(+100, 0)];
self.blackBlock.backgroundColor = [UIColor blackColor];
[self.collider addItem:self.blackBlock];

//将开始的重力设为0：方块将不感受重力，只能通过人为手段施加
self.gravity.gravityDirection = CGVectorMake(0, 0);
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;在这里，红色方块具有碰撞和重力行为，但是黑色方块却只有碰撞行为。因为黑色是不受重力控制的，它的运动的触发只来自红色方块的碰撞。</div><div class="line"></div><div class="line">#### 4. 在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作：</div></pre></td></tr></table></figure>
<p>  [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationWillResignActiveNotification</p>
<pre><code>    object:nil
     queue:nil
usingBlock:^(NSNotification *note) {
    [self pauseGame];
}];
</code></pre><p>  [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidBecomeActiveNotification</p>
<pre><code>   object:nil
     queue:nil
usingBlock:^(NSNotification *note) {
    if (self.view.window) [self resumeGame];
}];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;我们也可以在appdelegate里面来实现这些方法，不过个人认为将方法写在一起看起来比较直观</div><div class="line"></div><div class="line">#### 5. CMMotionManager的初始化和使用</div></pre></td></tr></table></figure>
</li>
</ul>
<p>//初始化</p>
<ul>
<li>(CMMotionManager *)motionManager<br>{<br>  if (!_motionManager) {<pre><code>_motionManager = [[CMMotionManager alloc] init];
_motionManager.accelerometerUpdateInterval = 0.1;
</code></pre>  }<br>  return _motionManager;<br>}</li>
</ul>
<p>//将方法放在主线程的代码块中<br> if (!self.motionManager.isAccelerometerActive) {</p>
<pre><code>    [self.motionManager startAccelerometerUpdatesToQueue:[NSOperationQueue mainQueue]

                                             withHandler:^(CMAccelerometerData *accelerometerData, NSError *error) {
﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿//获取加速器的方向
                                                 CGFloat x = accelerometerData.acceleration.x;
                                                 CGFloat y = accelerometerData.acceleration.y;
﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿
﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿//根据设备的方向来给方块施加不同方向的重力
                                                 switch (self.interfaceOrientation) {
                                                     case UIInterfaceOrientationLandscapeRight:
                                                        self.gravity.gravityDirection = CGVectorMake(- y, - x); break;

                                                   case UIInterfaceOrientationLandscapeLeft:
                                                         self.gravity.gravityDirection = CGVectorMake(y, x); break;

                                                     case UIInterfaceOrientationPortrait:
                                                         self.gravity.gravityDirection = CGVectorMake(x, - y); break;

                                                     case UIInterfaceOrientationPortraitUpsideDown:
                                                        self.gravity.gravityDirection = CGVectorMake(- x, y); break;
                                                 }

                                                 [self updateScore];
                                             }];
}
</code></pre><p>﻿```</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>如果嫌麻烦的童鞋可以在留言留下邮箱，笔者会将Demo包发给你~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十六）：模态视图，UITextField,UImagePickerController，在Flickr添加摄影师照片Demo/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（十六）：模态视图，UITextField,UImagePickerController，在Flickr添加摄影师照片Demo/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（十六）：模态视图，UITextField，UImagePickerController，在Flickr添加摄影师照片Demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:28:46+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本节课讲解了模态视图，文本框，UImagePickerController的相关知识，并延续了上一节课的Demo，添加了照相并存储照片的功能。</p>
<h1 id="模态视图"><a href="#模态视图" class="headerlink" title="模态视图"></a>模态视图</h1><hr>
<p>模态视图不同于左右滑入的视图，它是从下往上，覆盖整个屏幕的视图。每次滑入都会重新新建一个控制器。通常用于修改信息等操作。</p>
<p>显示模态视图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">  [self presentViewController:(nonnull UIViewController *) animated:(BOOL) completion:^&#123;&#125;];</div></pre></td></tr></table></figure></p>
<p>让模态视图消失：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)dissmissViewControllerAnimated:(BOOL)animated completion:(void(^))block;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意:该消息是发送给present该模态视图的控制器，而不是该模态视图本身。因此，调用方法应该是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.presentingViewController dissmissViewControllerAnimated:YES ...];</div></pre></td></tr></table></figure>
<h1 id="UITextField"><a href="#UITextField" class="headerlink" title="UITextField"></a>UITextField</h1><hr>
<p>UITextField是文本框，可以用来输入文字，类似于UILabel。</p>
<h3 id="让键盘出现和消失："><a href="#让键盘出现和消失：" class="headerlink" title="让键盘出现和消失："></a>让键盘出现和消失：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[textField becomeFirstResponder];</div><div class="line">[textField resignFirstResponder];</div></pre></td></tr></table></figure>
<h2 id="代理方法："><a href="#代理方法：" class="headerlink" title="代理方法："></a>代理方法：</h2><h4 id="1-当点击了确定按键-让键盘消失"><a href="#1-当点击了确定按键-让键盘消失" class="headerlink" title="1. 当点击了确定按键,让键盘消失"></a>1. 当点击了确定按键,让键盘消失</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)textFieldShouldReturn:(UITextField *)textField</div><div class="line">&#123;</div><div class="line">    [textField resignFirstResponder];</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-当resignFirstResponder完成后执行："><a href="#2-当resignFirstResponder完成后执行：" class="headerlink" title="2. 当resignFirstResponder完成后执行："></a>2. 当resignFirstResponder完成后执行：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)textFieldDidEndEditing:(UITextField *)textField;</div></pre></td></tr></table></figure>
<h4 id="3-内容发生变化时收到通知："><a href="#3-内容发生变化时收到通知：" class="headerlink" title="3. 内容发生变化时收到通知："></a>3. 内容发生变化时收到通知：</h4><p>注册这个广播，就可以收到该通知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;</div></pre></td></tr></table></figure></p>
<h4 id="4-键盘"><a href="#4-键盘" class="headerlink" title="4. 键盘"></a>4. 键盘</h4><p>设置键盘的类型需要通过给实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>@protocol UITextInputTraits <nsobject></nsobject></p>
<p>@optional<br>@property(nonatomic) UITextAutocapitalizationType autocapitalizationType; // 自动大写<br>@property(nonatomic) UIKeyboardType keyboardType;                         // default is UIKeyboardTypeDefault<br>@property(nonatomic) UIReturnKeyType returnKeyType;                       // 回车键，返回键，搜索键盘<br>@property(nonatomic,getter=isSecureTextEntry) BOOL secureTextEntry;       // 密码<br>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 5. 监听键盘的高度：</div><div class="line">通过注册```UIKeyboard&#123;will,did&#125; &#123;show hide&#125;```广播来计算键盘弹出后的高度。</div><div class="line"></div><div class="line">     </div><div class="line"># Alert</div><div class="line">---</div><div class="line"></div><div class="line">Alert是用来提醒用户某些消息的控件，它会出现在屏幕的正中央。我们可以自定义它的显示消息和按钮。也可以设定点击某个按钮执行的操作。</div><div class="line"></div><div class="line">## 初始化：</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(instancetype)initWithTitle:(nullable NSString <em>)title delegate:(nullable id<uiactionsheetdelegate>)delegate cancelButtonTitle:(nullable NSString </uiactionsheetdelegate></em>)cancelButtonTitle destructiveButtonTitle:(nullable NSString <em>)destructiveButtonTitle otherButtonTitles:(nullable NSString </em>)otherButtonTitles, … NS_REQUIRES_NIL_TERMINATION NS_EXTENSION_UNAVAILABLE_IOS(“Use UIAlertController instead.”);</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 增加按钮</div></pre></td></tr></table></figure>
</li>
<li><p>(NSInteger)addButtonWithTitle:(nullable NSString *)title; </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 显示在屏幕上:</div></pre></td></tr></table></figure>
</li>
<li><p>(void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated NS_AVAILABLE_IOS(3_2);</p>
</li>
<li><p>(void)showInView:(UIView *)view;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 处理点击事件：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 8_3) __TVOS_PROHIBITED;  // after animation</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 手动让其消失</div></pre></td></tr></table></figure>
</li>
<li><p>(void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># UImagePickerController</div><div class="line">-------------</div><div class="line"></div><div class="line">UImagePickerController是用来选取图片，视频资源的控制器，也可以进行拍照。</div><div class="line"></div><div class="line">## 使用步骤：</div><div class="line">1. alloc/init, set delegate</div><div class="line">2. 配置摄像头，照片库，用户是否可以编辑相片</div><div class="line">3. 显示</div><div class="line">4. 实现代理方法，获取媒体</div><div class="line"></div><div class="line">## 检查硬件设备：</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>(BOOL)isSourceTypeAvailable:(UIImagePickerControllerSourceType)sourceType;  </li>
</ul>
<p>typedef NS_ENUM(NSInteger, UIImagePickerControllerSourceType) {<br>    UIImagePickerControllerSourceTypePhotoLibrary,<br>    UIImagePickerControllerSourceTypeCamera,<br>    UIImagePickerControllerSourceTypeSavedPhotosAlbum<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 检查是否可以摄像：</div></pre></td></tr></table></figure>
<ul>
<li>(nullable NSArray<nsstring *=""> *)availableMediaTypesForSourceType:(UIImagePickerControllerSourceType)sourceType;</nsstring></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">返回的数组是否有相应的字段：</div><div class="line">kUTTypeImage</div><div class="line">kUTTypeMovie</div><div class="line"></div><div class="line">## 允许用户编辑（裁剪）：</div></pre></td></tr></table></figure>
<p>@property BOOL allowEditing;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 获取了媒体（照片）后的代理方法</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)imagePickerController:(UIImagePickerController <em>)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString </em>,id&gt; *)info;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 点击了取消后的代理方法：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)imagePickerControllerDidCancel:(UIImagePickerController *)picker<br>{<br>  [self dismissViewControllerAnimated:YES completion:NULL];<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># Demo </div><div class="line">------------</div><div class="line"></div><div class="line">## Demo需求：</div><div class="line">- 在原摄影师列表的第一行添加“我的照片”。</div><div class="line">- 点击“我的照片”后，显示地图上“我”所照照片的地点。</div><div class="line">- 点击大头针，显示相应照片详情。</div><div class="line">- 在导航栏右上角显示照相机按钮。</div><div class="line">- 点击照相机按钮，从底部弹出添加照片的页面。</div><div class="line">- 点击“Take Photo”,启动相机，照相并可以裁剪。</div><div class="line">- 裁剪后，回到添加剂照片的页面。设置标题和副标题后，保存照片。</div><div class="line">- 回到地图页面，自动添加刚才所增加照片的大头针。</div><div class="line"></div><div class="line">## Demo效果图</div><div class="line"></div><div class="line">![左：添加照片 | 中：在地图上标注位置 | 右：点击查看大图](http://upload-images.jianshu.io/upload_images/859001-b1f9ecf0f562f5c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">## 重要知识点和代码段</div><div class="line"></div><div class="line">#### 1. 在添加照片页面显示后判断是否可以拍照</div></pre></td></tr></table></figure>
<ul>
<li><p>(void)viewDidAppear:(BOOL)animated<br>{<br>  [super viewDidAppear:animated];</p>
<p>  if (![[self class] canAddPhoto]) {</p>
<pre><code>[self fatalAlert:@&quot;Sorry, this device cannot add a photo.&quot;];
</code></pre><p>  } else {</p>
<pre><code>[self.locationManager startUpdatingLocation];//开始更新位置
</code></pre><p>  }<br>}</p>
</li>
<li><p>(void)viewWillDisappear:(BOOL)animated<br>{<br>  [super viewWillDisappear:animated];<br>  //页面消失前，停止更新位置，避免耗能<br>  [self.locationManager stopUpdatingLocation];<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>判断当前设备是否可以添加照片<br>*</li>
<li>@return 是否<br>*/</li>
</ul>
<ul>
<li><p>(BOOL)canAddPhoto<br>{<br>  //判断相机是否可用<br>  if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {</p>
<pre><code>//返回支持媒体类型的数组
NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];

//判断数组里有无照片类型
if ([availableMediaTypes containsObject:(NSString *)kUTTypeImage]) {

    //判断可以支持照片类型后，判断当前设备是否可以获取位置信息
    if ([CLLocationManager authorizationStatus] != kCLAuthorizationStatusRestricted) {

        return YES;
    }
}
</code></pre><p>  }<br>  return NO;<br>}</p>
</li>
</ul>
<ul>
<li>(void)fatalAlert:(NSString *)msg<br>{<br>  [[[UIAlertView alloc] initWithTitle:@”Add Photo”<pre><code>          message:msg
         delegate:self
cancelButtonTitle:nil
otherButtonTitles:@&quot;Cancel&quot;, nil] show];
</code></pre>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2. CLLocationManager的初始化和使用</div></pre></td></tr></table></figure>
<ul>
<li><p>(CLLocationManager *)locationManager<br>{<br>  if (!_locationManager) {</p>
<pre><code>//1. 初始化
CLLocationManager *locationManager = [[CLLocationManager alloc] init];

//2. 设置代理
locationManager.delegate = self;

//3. 设置精度
locationManager.desiredAccuracy = kCLLocationAccuracyBest;
_locationManager = locationManager;
//4. iOS8以上要调用，否则无法监听位置！
[_locationManager requestAlwaysAuthorization];
[_locationManager requestWhenInUseAuthorization];
</code></pre><p>  }<br>  return _locationManager;<br>}</p>
</li>
<li><p>(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray </em>)locations<br>{<br>  //获取最后得到的位置信息（最准确）<br>  self.location = [locations lastObject];<br>}</p>
</li>
<li><p>(void)locationManager:(CLLocationManager <em>)manager didFailWithError:(NSError </em>)error<br>{<br>  //获取错误码<br>  self.locationErrorCode = error.code;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3. UIImagePickerController的初始化和使用</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>点击了“Take Photo 添加照片”<br>*/</p>
<ul>
<li>(IBAction)takePhoto<br>{<br>//1. 初始化<br>UIImagePickerController *uiipc = [[UIImagePickerController alloc] init];</li>
</ul>
<p>//2. 设置代理<br>uiipc.delegate = self;</p>
<p>//3. 获取图片媒体<br>uiipc.mediaTypes = @[(NSString *)kUTTypeImage];<br>uiipc.sourceType = UIImagePickerControllerSourceTypeCamera | UIImagePickerControllerSourceTypePhotoLibrary;</p>
<p>//4. 允许裁剪<br>uiipc.allowsEditing = YES;</p>
<p>//5. 弹出UIImagePickerController<br>[self presentViewController:uiipc animated:YES completion:NULL];</p>
</li>
</ul>
<p>}</p>
<p>/**</p>
<ul>
<li>拍照成功<br>*</li>
<li>@param picker 当前的UIImagePickerController</li>
<li>@param info   获取的照片信息<br>*/</li>
</ul>
<ul>
<li><p>(void)imagePickerController:(UIImagePickerController <em>)picker didFinishPickingMediaWithInfo:(NSDictionary </em>)info<br>{<br>  //获取裁剪后的图片<br>  UIImage *image = info[UIImagePickerControllerEditedImage];</p>
<p>  //如果无法获取裁剪后的图片，获取原图<br>  if (!image) image = info[UIImagePickerControllerOriginalImage];</p>
<p>  //更新当前的image属性<br>  self.image = image;</p>
<p>  [self dismissViewControllerAnimated:YES completion:NULL];<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>点击了取消<br>*</li>
<li>@param picker 当前的UIImagePickerController<br>*/<ul>
<li>(void)imagePickerControllerDidCancel:(UIImagePickerController *)picker<br>{<br>[self dismissViewControllerAnimated:YES completion:NULL];<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 4. 判断是否执行某个Segue的Identifier</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>(BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(id)sender<br>{</p>
<p>  if ([identifier isEqualToString:@”Do Add Photo”]) {</p>
<pre><code>if (!self.image) {
    //无照片
    [self alert:@&quot;No photo taken!&quot;];
    return NO;

} else if (![self.titleTextField.text length]) {

    //无标题
    [self alert:@&quot;Title required!&quot;];
    return NO;

} else if (!self.location) {

    //没有获取到位置信息
    switch (self.locationErrorCode) {

        case kCLErrorLocationUnknown:
            [self alert:@&quot;Couldn&apos;t figure out where this photo was taken (yet).&quot;]; break;

        case kCLErrorDenied:
            [self alert:@&quot;Location Services disabled under Privacy in Settings application.&quot;]; break;

        case kCLErrorNetwork:
            [self alert:@&quot;Can&apos;t figure out where this photo is being taken.  Verify your connection to the network.&quot;]; break;

        default:
            [self alert:@&quot;Cant figure out where this photo is being taken, sorry.&quot;]; break;
    }

    return NO;

} else {
    return YES;
}
</code></pre><p>  } else {</p>
<pre><code>return [super shouldPerformSegueWithIdentifier:identifier sender:sender];
</code></pre><p>  }<br>}</p>
</li>
<li><p>(void)alert:(NSString *)msg<br>{</p>
<p>  [[[UIAlertView alloc] initWithTitle:@”Add Photo”</p>
<pre><code>          message:msg
         delegate:nil
cancelButtonTitle:nil
otherButtonTitles:@&quot;Cancel&quot;, nil] show];
</code></pre><p>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;在添加照片后，我们需要将该页面取消并储存相应的数据。但由于业务需求，如果想要储存数据的前提下取消页面的话，那么就需要在取消页面之前来判断当前的数据是否满足储存的条件：是否有照片；是否设置了标题；是否获取了位置信息等。</div><div class="line"></div><div class="line">#### 5. 确定页面可以被取消后，在页面被取消前储存数据：</div></pre></td></tr></table></figure>
<ul>
<li><p>(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender<br>{</p>
<p>  if ([segue.identifier isEqualToString:@”Do Add Photo”]) {</p>
<pre><code>NSManagedObjectContext *context = self.photographerTakingPhoto.managedObjectContext;

if (context) {

    Photo *photo = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Photo&quot;  inManagedObjectContext:context];

    photo.title = self.titleTextField.text;
    photo.subtittle = self.subtitleTextField.text;
    photo.whoTook = self.photographerTakingPhoto;
    photo.latitude = @(self.location.coordinate.latitude);
    photo.longitude = @(self.location.coordinate.longitude);
    photo.imageURL = [self.imageURL absoluteString];
    photo.thumbnailURL = [self.thumbnailURL absoluteString];            

    self.addedPhoto = photo;         
    self.imageURL = nil;
    self.thumbnailURL = nil;
}
</code></pre><p>  }<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 6. 获取新增图片的本地路径</div></pre></td></tr></table></figure>
<p>/**</p>
<ul>
<li>获取图片的本地URL<br>*</li>
<li>@return 图片的本地URL<br>*/</li>
</ul>
<ul>
<li>(NSURL *)imageURL<br>{<br>  if (!_imageURL &amp;&amp; self.image) {<pre><code>NSURL *url = [self uniqueDocumentURL];
if (url) {
    //UIImage -&gt; NSData
    NSData *imageData = UIImageJPEGRepresentation(self.image, 1.0);
    //将data写入url
    if ([imageData writeToURL:url atomically:YES]) {
        //如果写入成功，更新imageURL属性
        _imageURL = url;
    }
}
</code></pre>  }<br>  return _imageURL;<br>}</li>
</ul>
<p>/**</p>
<ul>
<li>获取图片缩略图的本地URL<br>*</li>
<li>@return 缩略图的本地URL<br>*/</li>
</ul>
<ul>
<li><p>(NSURL *)thumbnailURL<br>{</p>
<p>  NSURL *url = [self.imageURL URLByAppendingPathExtension:@”thumbnail”];<br>  if (![_thumbnailURL isEqual:url]) {</p>
<pre><code>_thumbnailURL = nil;
if (url) {
    //以某Size压缩图片（详情请看本Demo添加的image分类）
    UIImage *thumbnail = [self.image imageByScalingToSize:CGSizeMake(75, 75)];

    //0.5倍压缩
    NSData *imageData = UIImageJPEGRepresentation(thumbnail, 0.5);

    if ([imageData writeToURL:url atomically:YES]) {
        _thumbnailURL = url;
    }
}
</code></pre><p>  }<br>  return _thumbnailURL;<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>以时间来生成唯一本地路径<br>*</li>
<li>@return 本地路径<br>*/</li>
</ul>
<ul>
<li><p>(NSURL *)uniqueDocumentURL<br>{</p>
<p>  NSArray *documentDirectories = [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask];</p>
<p>  NSString *unique = [NSString stringWithFormat:@”%.0f”, floor([NSDate timeIntervalSinceReferenceDate])];<br>  return [[documentDirectories firstObject] URLByAppendingPathComponent:unique];</p>
</li>
</ul>
<p>}</p>
<p>```</p>
<blockquote>
<p>在这里，我们用当前的时间来拼接Document路径，获得了图片的唯一地址。</p>
</blockquote>
<p>笔者今天在公司附近拍了一张照片来验证效果：一张南京东路苹果旗舰店的照片，不过定位比较不准。可能是由于周围高楼比较多，而且定位时间不够长的关系。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>如果嫌麻烦的童鞋可以在留言留下邮箱，笔者会将Demo包发给你~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:27:10+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本总结将第十四和十五课放在了一起，原因有二：第一是略去了ipad开发Demo的部分（因为笔者木有ipad，无法进行调试）。第二是两节课都讲解了关于地图框架的相关知识，故将二者放在一起总结。</p>
<p>在本篇总结的最后，会给大家讲解在地图上显示Flickr上摄影师的照片作品。</p>
<h1 id="Network-Activity-Indicator"><a href="#Network-Activity-Indicator" class="headerlink" title="Network Activity Indicator"></a>Network Activity Indicator</h1><hr>
<p>顾名思义，该控件叫做网络活动指示器。当app有网络活动时，可以让状态栏左边的小圆圈滚动用来提示用户当前的网络状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible;</div></pre></td></tr></table></figure>
<p>如果设定为YES，状态栏上的小转轮就会转，反之亦然。</p>
<blockquote>
<p>注意：应用中的所有线程都可使用这个转轮，我们需要通过各种方法来向用户准确显示转轮的状态。</p>
</blockquote>
<h1 id="Core-Location"><a href="#Core-Location" class="headerlink" title="Core Location"></a>Core Location</h1><hr>
<p>通过该框架的基本类：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## Core Location几个重要的属性：</div><div class="line">#### 1. 坐标属性</div></pre></td></tr></table></figure></p>
<p>typedef struct {<br>CLLocationDegrees latitude;    //double value<br>CLLocationDegrees longitude;   //double value<br>} CLLocationCoordinate2D;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### 2. 高度</div></pre></td></tr></table></figure></p>
<p>@property(readonly, nonatomic) CLLocationDistance altitude; //单位是米<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3. 变化精度：</div></pre></td></tr></table></figure></p>
<p>@property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy;//水平精度<br>@property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy;//高度精度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如何获得CLLocation？</div><div class="line">通过实例化```CLLocationManager```类，让其告诉它的代理当前设备所处的位置。</div><div class="line">下面来介绍一下```CLLocationManager```:</div><div class="line"></div><div class="line"># CLLocationManager</div><div class="line"></div><div class="line">-----</div><div class="line">## CLLocationManager的工作步骤：</div><div class="line">1.查看硬件是否支持位置更新。</div><div class="line">2.实例化```CLLocationManager```让其告诉它的代理当前的位置。</div><div class="line">3.设置位置更新的类型(精度)。</div></pre></td></tr></table></figure></p>
<p>@property(assign, nonatomic) CLLocationAccuracy desiredAccuracy; //期望的经度<br>@property(assign, nonatomic) CLLocationDistance distanceFilter;  //更新到该距离之内不要告诉我更新了多少<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4.开始位置监控。</div></pre></td></tr></table></figure></p>
<ul>
<li>(void)startUpdatingLocation;//开始更新位置</li>
<li>(void)stopUpdatingLocation;//停止位置更新</li>
<li>(void)locationManager:(CLLocationManager <em>)manager didUpdateLocations:(NSArray&lt;CLLocation </em>&gt; *)locations;//位置更新的代理方法</li>
<li>(void)locationManager:(CLLocationManager <em>)manager didFailWithError:(NSError </em>)error;//更新失败<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 位置监控的类型：</div><div class="line"></div><div class="line">#### 1. 基于精度的监控</div></pre></td></tr></table></figure>
</li>
</ul>
<p>extern const CLLocationAccuracy kCLLocationAccuracyBestForNavigation; //最精确，但是非常耗能<br>extern const CLLocationAccuracy kCLLocationAccuracyBest;<br>extern const CLLocationAccuracy kCLLocationAccuracyNearestTenMeters;<br>extern const CLLocationAccuracy kCLLocationAccuracyHundredMeters;<br>extern const CLLocationAccuracy kCLLocationAccuracyKilometer;<br>extern const CLLocationAccuracy kCLLocationAccuracyThreeKilometers;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; 注意：精度越高，耗电量越大</div><div class="line"></div><div class="line">#### 2. 位置发生重大变化时更新。</div></pre></td></tr></table></figure></p>
<ul>
<li>(void)startMonitoringSignificantLocationChanges;</li>
<li><p>(void)stopMonitoringSignificantLocationChanges ;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">该方法在前台和后台都能监控位置的变化，甚至关掉app后，也可以启动应用告诉用户位置更新:</div></pre></td></tr></table></figure>
</li>
<li><p>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions {<br>  //如果<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</li>
</ul>
<h4 id="3-进入某个区域更新。"><a href="#3-进入某个区域更新。" class="headerlink" title="3. 进入某个区域更新。"></a>3. 进入某个区域更新。</h4><p>3.1设定一个圆形的区域，经过该区域的时候会更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)startMonitoringForRegion:(CLRegion *)region;</div><div class="line">- (void)requestStateForRegion:(CLRegion *)region;</div></pre></td></tr></table></figure>
<p>3.2 通过一个信标来监控</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic) CLLocationDistance maximumRegionMonitoringDistance;//设置最大监控距离</div><div class="line"></div><div class="line">- (void)startRangingBeaconsInRegion:(CLBeaconRegion *)region;//设置信标</div></pre></td></tr></table></figure>
<h4 id="4-监控前进的方向"><a href="#4-监控前进的方向" class="headerlink" title="4. 监控前进的方向"></a>4. 监控前进的方向</h4><h1 id="MapKit"><a href="#MapKit" class="headerlink" title="MapKit"></a>MapKit</h1><hr>
<p>MapKit是用于显示地图的框架，它通过<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">我们来看一下该框架中几个比较重要的元素：</div><div class="line"></div><div class="line">## 1. MKMapView</div><div class="line"></div><div class="line">MKMapView就是用来显示地图的View。</div><div class="line"></div><div class="line">MKMapView的属性：</div></pre></td></tr></table></figure></p>
<p>@property (nonatomic) MKMapType mapType;// MKMapTypeStandard : 标准；MKMapTypeSatellite:卫星；MKMapTypeHybrid：叠加<br>@property (nonatomic) BOOL showsUserLocation; //显示用户的地点<br>@property (nonatomic, readonly, getter=isUserLocationVisible) BOOL userLocationVisible;<br>//用户坐标是否可见<br>@property (nonatomic, getter=isZoomEnabled) BOOL zoomEnabled; //是否可放大缩小<br>@property (nonatomic, getter=isRotateEnabled) BOOL rotateEnabled; //是否可旋转<br>@property (nonatomic, getter=isPitchEnabled) BOOL pitchEnabled; //3D效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 2. MKAnnotationView</div><div class="line">在```MKMapView```视图里，可以显示用于标注具体位置的“大头针” ，它是MapKit框架里的```AnnotationView```。</div><div class="line"></div><div class="line">MKAnnotationView的属性：</div></pre></td></tr></table></figure>
<p>@property (nonatomic, strong, nullable) id <mkannotation> annotation;<br>@property (nonatomic, strong, nullable) UIImage <em>image;//大头针的图像<br>@property (strong, nonatomic, nullable) UIView </em>leftCalloutAccessoryView;//左附属对话框<br>@property (strong, nonatomic, nullable) UIView *rightCalloutAccessoryView;//右附属对话框<br>@property (nonatomic, getter=isDraggable) BOOL draggable //是否可拖动</mkannotation></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">大头针被点击时调用的方法：</div></pre></td></tr></table></figure>
<ul>
<li>(void)mapView:(MKMapView <em>)mapView didSelectAnnotationView:(MKAnnotationView </em>)view<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 3. id&lt;MKAnnotation&gt;</div><div class="line">AnnotationView的数据源就是：id&lt;MKAnnotation&gt;，任何遵从该协议的对象都可以成为AnnotationView的数据源，也就是说，任何遵守    ```MKAnootation```协议的对象你都可以将其放入地图中。</div><div class="line"></div><div class="line">我们先看一下在MKMapView里的关于MKAnnotation的属性：</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@property (nonatomic, readonly) NSArray<id<mkannotation>&gt; *annotations;//包含MapView所显示的所有Annotaion<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">注意：annotations是只读的数组，只能添加或者删除。</div></pre></td></tr></table></figure></id<mkannotation></p>
<ul>
<li>(void)addAnnotation:(id <mkannotation>)annotation;</mkannotation></li>
<li>(void)addAnnotations:(NSArray<id<mkannotation>&gt; *)annotations;</id<mkannotation></li>
<li>(void)removeAnnotation:(id <mkannotation>)annotation;</mkannotation></li>
<li>(void)removeAnnotations:(NSArray<id<mkannotation>&gt; *)annotations;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">MKAnnotation协议的方法：</div></pre></td></tr></table></figure>
</id<mkannotation></li>
</ul>
<p>@protocol MKAnnotation <nsobject><br>@property (nonatomic, readonly) CLLocationCoordinate2D coordinate; //坐标</nsobject></p>
<p>@optional<br>@property (nonatomic, readonly, copy, nullable) NSString <em>title;//标题<br>@property (nonatomic, readonly, copy, nullable) NSString </em>subtitle;//副标题</p>
<ul>
<li><p>(void)setCoordinate:(CLLocationCoordinate2D)newCoordinate ;//设置坐标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">那么二者是如何关联的呢？</div><div class="line">通过MKMapView的代理方法：</div></pre></td></tr></table></figure>
</li>
<li><p>(MKAnnotationView <em>)mapView:(MKMapView </em>)mapView viewForAnnotation:(id<mkannotation>)annotation<br>{<br>  //提供一个 annotation，返回一个 MKAnnotationView<br>}</mkannotation></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">## 4. Callout(对话框)</div><div class="line">点击大头针（MKAnnotationView），会出现一个白底的对话框，它被叫做```callout```,可以设置它的主标题和副标题。另外还有左右附属实图，它们可以显示图片或者箭头，也可被点击。</div><div class="line">﻿</div><div class="line"></div><div class="line"># Demo</div><div class="line">----</div><div class="line">## Demo需求：</div><div class="line">- 显示从flickr抓取的摄影师列表。</div><div class="line">- 点击列表中的一项，打开地图，在当前摄影师所照照片的地点显示大头针。</div><div class="line">- 点击其中的一个大头针，显示照片详情：缩略图和名称。</div><div class="line">- 点击箭头按钮，滑入显示照片的页面，显示原始照片。</div><div class="line"></div><div class="line">## Demo效果图：</div><div class="line"></div><div class="line">![在地图显示照片拍摄位置](http://upload-images.jianshu.io/upload_images/859001-269dd622430d4972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">## 重要代码段和知识点：</div><div class="line"></div><div class="line">#### 1. 更改Core Data模型</div><div class="line">在上一节课的基础上，我们需要在模型里的```Photo```实体添加经度和纬度的属性，还有大头针缩略图的URL属性。</div><div class="line">在更新属性后，一定要重新生成对应该实体的类文件，并且要将原app删除，因为数据库前后是不兼容的。</div><div class="line"></div><div class="line"></div><div class="line">![更新模型](http://upload-images.jianshu.io/upload_images/859001-0bf538fa1a08fe3d.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 2. 新建PhotosByPhotographerMapViewController.h，用来显示```MKMapView</div></pre></td></tr></table></figure>
</li>
</ul>
<p>因为要在地图上显示摄影师所照照片的位置，因此，该类的数据源来自摄影师模型：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>#import <uikit uikit.h=""></uikit></p>
<p>#import “Photographer.h”<br>@interface PhotosByPhotographerMapViewController : UIViewController<br>@property (nonatomic, strong) Photographer *photographer;//公共API：摄影师<br>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>#import “PhotosByPhotographerMapViewController.h”</p>
<p>#import <mapkit mapkit.h=""></mapkit></p>
<p>@interface PhotosByPhotographerMapViewController ()<mkmapviewdelegate><br>@property (strong, nonatomic) IBOutlet MKMapView <em>mapView;//地图view<br>@property (nonatomic,strong) NSArray </em>photosByPhotographer;//装入摄影师拥有的照片的数组<br>@end</mkmapviewdelegate></p>
<p>@implementation PhotosByPhotographerMapViewController<br>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3. 导入Mapkit的framework</div><div class="line"></div><div class="line">需要注意的是，除了要在类文件引用```&lt;MapKit/MapKit.h&gt;```框架以外，还要手动向项目中添加该框架：</div><div class="line"></div><div class="line">![手动添加MapKit框架.gif](http://upload-images.jianshu.io/upload_images/859001-8fb04dfbac7bbdd7.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line"></div><div class="line">#### 4. 更新photographer和mapView后更新annotation：</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)setMapView:(MKMapView *)mapView<br>{<br>  _mapView = mapView;</p>
<p>  //设置代理<br>  self.mapView.delegate = self;</p>
<p>  //更新<br>  [self updateMapViewAnnotations];<br>}</p>
</li>
<li><p>(void)setPhotographer:(Photographer *)photographer<br>{<br>  _photographer = photographer;<br>  //导航栏标题<br>  self.title = photographer.name;<br>  //准备更新数组，要事先设置其为nil，否则不会生成新的<br>  self.photosByPhotographer = nil;<br>  [self updateMapViewAnnotations];<br>}</p>
</li>
<li><p>(void)updateMapViewAnnotations<br>{<br>  [self.mapView removeAnnotations:self.mapView.annotations];<br>  [self.mapView addAnnotations:self.photosByPhotographer];<br>  [self.mapView showAnnotations:self.photosByPhotographer animated:YES];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### 5. 自定义点击大头针后显示的view</div></pre></td></tr></table></figure>
</li>
<li><p>(MKAnnotationView <em>)mapView:(MKMapView </em>)mapView viewForAnnotation:(id<mkannotation>)annotation<br>{</mkannotation></p>
<p>  //类似UITableviewCell的复用<br>  static NSString *reuseId = @”PhotosByPhotographerMapViewController”;    </p>
<p>  MKPinAnnotationView <em>view = (MKPinAnnotationView</em>)[mapView dequeueReusableAnnotationViewWithIdentifier:reuseId];    </p>
<p>  if (!view) {</p>
<pre><code> view = [[MKPinAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:reuseId];
//是否显示callout
 view.canShowCallout = YES;
 //设置左部分的callout：UIImageView
 UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 46, 46)];
 view.leftCalloutAccessoryView = imageView;
 //设置右部分的callout：UIButton
 UIButton *disclosurebutton = [[UIButton alloc] init];
 [disclosurebutton setBackgroundImage:[UIImage imageNamed:@&quot;disclosure&quot;] forState:UIControlStateNormal];
 [disclosurebutton sizeToFit];
 view.rightCalloutAccessoryView = disclosurebutton;
</code></pre><p>  }</p>
<p>  view.annotation = annotation;<br>  return view;</p>
</li>
</ul>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### 6. 点击大头针，更新callout左侧显示的缩略图</div></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>点击大头针view<br>*</li>
<li>@param mapView 大头针所属的mapView</li>
<li>@param view    大头针view<br>*/<ul>
<li>(void)mapView:(MKMapView <em>)mapView didSelectAnnotationView:(MKAnnotationView </em>)view<br>{<br>[self updateLeftCalloutAccessoryViewInAnnotationView:view];<br>}</li>
</ul>
</li>
</ul>
<p>/**</p>
<ul>
<li>更新callout里的图片（在左侧）<br>*</li>
<li>@param annotationView 当前被点击的大头针view<br>*/<ul>
<li>(void)updateLeftCalloutAccessoryViewInAnnotationView:(MKAnnotationView <em>)annotationView<br>{<br>UIImageView </em>imageView = nil;<br>if ([annotationView.leftCalloutAccessoryView isKindOfClass:[UIImageView class]]) {<br>  imageView = (UIImageView <em>)annotationView.leftCalloutAccessoryView;<br>}<br>if (imageView) {<br>  Photo </em>photo = nil;<br>  if ([annotationView.annotation isKindOfClass:[Photo class]]) {<pre><code>photo = (Photo *)annotationView.annotation;
</code></pre>  }<br>  if (photo) {<pre><code>NSString *urlString = photo.thumbnailURL;
imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]]];
</code></pre>  }<br>}<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;注意：显示图片的代码：``` imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]]];```方法会阻塞主线程，实际操作中应该放在子线程中执行。详情请参考笔者另一篇讲解关于多线程的博客：[最浅显易懂的iOS多线程技术 - GCD的教程](http://www.jianshu.com/p/6e74f5438f2c)。</div><div class="line"></div><div class="line"></div><div class="line">#### 7. 点击callout，在下一页面显示原图</div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>/**</p>
<ul>
<li>点击callout实行跳转<br>*</li>
<li>@param mapView 当前的mapView</li>
<li>@param view    当前callout所属的AnnotationView</li>
<li>@param control callout内部被点击的控件<br>*/<ul>
<li>(void)mapView:(MKMapView <em>)mapView annotationView:(MKAnnotationView </em>)view calloutAccessoryControlTapped:(UIControl *)control<br>{<br>[self performSegueWithIdentifier:@”Show Photo” sender:view];<br>}</li>
</ul>
</li>
</ul>
<p>/**</p>
<ul>
<li>调转执行前的代码<br>*</li>
<li>@param segue  连接前后两个控制器的segue</li>
<li><p>@param sender 被点击的AnnotaionView<br>*/</p>
<ul>
<li>(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender<br>{</li>
</ul>
<p>if ([sender isKindOfClass:[MKAnnotationView class]]) {</p>
<pre><code>[self prepareViewController:segue.destinationViewController
                   forSegue:segue.identifier
           toShowAnnotation:((MKAnnotationView *)sender).annotation];
</code></pre><p>}<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>为目标控制器准备数据（图片的URL）<br>*</li>
<li>@param vc              目标控制器</li>
<li>@param segueIdentifier segue.identifier</li>
<li>@param annotation      被点击的AnnotaionView<br>*/<ul>
<li>(void)prepareViewController:(id)vc<pre><code>        forSegue:(NSString *)segueIdentifier
toShowAnnotation:(id &lt;MKAnnotation&gt;)annotation
</code></pre>{<br>Photo <em>photo = nil;<br>if ([annotation isKindOfClass:[Photo class]]) {<br>  photo = (Photo </em>)annotation;<br>}<br>if (photo) {<br>  if (![segueIdentifier length] || [segueIdentifier isEqualToString:@”Show Photo”]) {<pre><code>if ([vc isKindOfClass:[ImageViewController class]]) {
    ImageViewController *ivc = (ImageViewController *)vc;
    ivc.imageURL = [NSURL URLWithString:photo.imageURL];
    ivc.title = photo.title;
}
</code></pre>  }<br>}<br>}<br>```<blockquote>
<p>注意：这里的<code>ivc.imageURL = [NSURL URLWithString:photo.imageURL];</code>代码同样会阻塞主线程，实际操作中应该放在子线程来做！</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>而且,本demo的图片地址应该都是在墙外的，所以最好先让电脑翻墙，然后在模拟器上运行比较好。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十二 十三）：CoreData，表格视图，Flickr摄影师资料列表/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（十二 十三）：CoreData，表格视图，Flickr摄影师资料列表/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（十二 十三）：CoreData,表格视图，Flickr摄影师资料列表Demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:21:28+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>第十二课和第十三课都介绍了CoreData的知识，并在十三课的中段通过一个Demo来具体实现了CoreData的操作。</p>
<p>笔者之前从未接触过Core Data的相关知识，因此学期这两节课比较吃力，这一篇总结还是有很多需要改进的地方，以后随着对Core Data认识的深入和对这两节课的反复咀嚼，会不断更新该总结。</p>
<p>开始吧！</p>
<h1 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h1><hr>
<p>Core Data是一种持久化技术，它能将模型对象的状态持久化到磁盘，但它最重要的特点是：Core Data不仅是一个加载、保存数据的框架，它还能和内存中的数据很好的共事。</p>
<p>排除错误认识：Core Data<strong>并不是数据库!</strong> 它只是连接类（Class）和数据库（SQL）的桥梁。通过Core Data的相关功能，我们可以对数据库进行增删改查的操作。</p>
<h2 id="CoreData是如何工作的呢？"><a href="#CoreData是如何工作的呢？" class="headerlink" title="CoreData是如何工作的呢？"></a>CoreData是如何工作的呢？</h2><h3 id="1-创建对象的可视化映射"><a href="#1-创建对象的可视化映射" class="headerlink" title="1. 创建对象的可视化映射"></a>1. 创建对象的可视化映射</h3><p>在看到可视化映射之前，需要了解<strong>实体</strong>的概念：</p>
<blockquote>
<p><strong>实体的概念</strong>：每个实体是一个表，每个表对应一个对象。<br>简单粗暴的理解：实体在数据库领域叫做表，在面向对象领域叫做对象。</p>
<p><strong>实体之间的关系</strong>=表之间创建关系，对象之间的关系。</p>
</blockquote>
<p><strong>注意</strong>：两个对象之间的关系在两个对象端具有不同的名称。而且关系的对应数量也是不同的：<figure class="highlight plain"><figcaption><span>one```,``` to many```。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;举个🌰 ：摄影者和照片的关系：</div><div class="line">摄影者对应多个照片，但是照片只对应一个摄影者。</div><div class="line"></div><div class="line">那么言归正传，如何创建对象的可视化映射呢？</div><div class="line">1. 创建模型文件，用来装入各种需要映射的实体。</div><div class="line">2.  在模型内部添加实体（Entity），创建实体之间的关系（必要时）。</div><div class="line"></div><div class="line">下面笔者录制了创建实体，增加实体属性，连接实体的操作：</div><div class="line"></div><div class="line"></div><div class="line">![创建实体，增加属性](http://upload-images.jianshu.io/upload_images/859001-ca646fa9e1e18f5a.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line"></div><div class="line">### 2. 为实体创建NSManagedObjectd子类</div><div class="line"></div><div class="line">我们需要将刚得到的可视化的实体“转变为”具体的类。在Core Data中，这些类都是NSManagedObjectd子类。</div><div class="line"></div><div class="line">下面演示一下其创建过程：</div><div class="line"></div><div class="line">![创建NSManagedObjectd子类](http://upload-images.jianshu.io/upload_images/859001-2eab784599ea6776.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">以实体```Photo```为例，系统为我们生成了```Photo.h```和```Photo.m```。</div><div class="line"></div><div class="line">我们先看一下```Photo.h```:</div></pre></td></tr></table></figure></p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>#import <coredata coredata.h=""></coredata></p>
<p>NS_ASSUME_NONNULL_BEGIN<br>@interface Photo : NSManagedObject<br>// Insert code here to declare functionality of your managed object subclass<br>@end<br>NS_ASSUME_NONNULL_END</p>
<p>#import “Photo+CoreDataProperties.h”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&gt;我们可以看到，```Photo```类继承了```NSManagedObject```。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">但是，有意思的是，系统还为我们自动生成了```Photo+CoreDataProperties.h```和```Photo+CoreDataProperties.m```，详情见动图左侧，创建实体类之后。</div><div class="line"></div><div class="line"></div><div class="line">**思考**：</div><div class="line">生成这两个文件的目的是什么呢？</div><div class="line">首先，我们首先要知道这两个文件是什么：</div><div class="line">他们构成了```Photo```类的分类(Category)。</div><div class="line"></div><div class="line">那么什么是分类呢？</div><div class="line">通过分类，我们可以向原有的类添加方法，而不需要通过继承的方式。分类的局限是：在分类里不能再添加属性。</div><div class="line"></div><div class="line">那么显然，通过````Photo+CoreDataProperties```，我们就可以不用继承```Photo```类来给其添加方法。因为原有的```Photo```类只具有属性，除了获取属性之外，并不能为我们做其他的事情。这时，如果可以在其他的地方给其无限地添加方法还是很具有诱惑力的。令人欣慰的是，系统可以自动为我们生成。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### 3. 通过创建NSManagedObjectContext访问，操作数据库</div><div class="line">数据库创建对象，设置对象属性，查询对象都需要```NSManagedObjectContext```。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">创建```NSManagedObjectContext```的两个不同的方法：</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">1.通过其自身的初始化：</div></pre></td></tr></table></figure></p>
<p>[NSManagedObjectContext alloc] init];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2.通过UIManagedDocument创建：</div><div class="line"></div><div class="line">UIManagedDocument 用于管理存储的机制，将Core Data数据库放入某存储空间。</div></pre></td></tr></table></figure></p>
<p>UIManagedDocument *document = [[UIManagedDocument alloc] initWithFileURL:url];<br>//url:这个core data 数据库存储的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 数据库的操作：</div><div class="line"></div><div class="line">#### 1. 向数据库添加对象（实体）：</div></pre></td></tr></table></figure></p>
<p>[NSEntityDescription insertNewObjectForEntityForName:@”Photo” inManagedObjectContext:context];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 2. 从数据库删除对象（实体）：</div></pre></td></tr></table></figure></p>
<p>[aDocument.managedObjectContext deleteObject:photo];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">删除对象后，系统会向所有对象发送这个消息</div></pre></td></tr></table></figure></p>
<ul>
<li>(void)prepareForDeletion{<br>//在这里保持数据同步，比如删掉这个对象的时候会影响到其他对象的数据<br>//应该在这个对象被删除前及时更新那个数据<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3. 在数据库查询对象（实体）：</div><div class="line"></div><div class="line"></div><div class="line">我们使用```NSFetchRequest```类查询数据库的对象，通过设置其不同属性来查找符合不同标准的数据：</div><div class="line"></div><div class="line">举个🌰 ：查找出100个photo的实体：</div></pre></td></tr></table></figure>
<p>NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@”Photo”];<br>request.fetchLimit = 100;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 关于Core data的线程安全</div></pre></td></tr></table></figure></p>
<p>//让context在安全队列中执行的方法<br>[context performBlock:^{<br>    [A doSomething];<br>}];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># NSFetchedResultsController</div><div class="line"></div><div class="line">------</div><div class="line"></div><div class="line"></div><div class="line">NSFetchedResultsController的作用是将NSFetchRequest 和 UITalbleView联系到一起。</div><div class="line">和TableView的数据源方法类似：</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(NSInteger)numberOfRowsInSection:(NSInteger)section{<br>return [[self.fetchedResultsController sections] count];<br>}</p>
</li>
<li><p>(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{<br> return [[self.fetchedResultsController sections] count] objectAtIndex:section] numberOfObjects];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">详细的使用方法会在Demo讲解部分中告诉大家。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># Demo</div><div class="line"></div><div class="line">-----</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## Demo需求</div><div class="line"></div><div class="line">- 每隔20分钟，从flickr拿回最新的摄影者数据。</div><div class="line">- 用一个TableView显示当前拿回的摄影者的名字和所照的照片数。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## Demo效果图</div><div class="line"></div><div class="line"></div><div class="line">![摄影师的信息列表](http://upload-images.jianshu.io/upload_images/859001-72dc6873f1c13917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 重要代码段</div><div class="line"></div><div class="line">#### 1. 在启动接口获取flickr的数组</div></pre></td></tr></table></figure>
</li>
<li><p>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions {<br>   self.photoDatabaseContext = [self createMainQueueManagedObjectContext];<br>   [self startFlickrFetch];<br>   return YES;<br>}</p>
</li>
<li><p>(void)startFlickrFetch<br>{<br>  [self.flickrDownloadSession getTasksWithCompletionHandler:^(NSArray <em>dataTasks, NSArray </em>uploadTasks, NSArray *downloadTasks) {</p>
<pre><code>if (![downloadTasks count]) {
    NSURLSessionDownloadTask *task = [self.flickrDownloadSession downloadTaskWithURL:[FlickrFetcher URLforRecentGeoreferencedPhotos]];
    task.taskDescription = FLICKR_FETCH;
    [task resume];
} else {
    for (NSURLSessionDownloadTask *task in downloadTasks) [task resume];
}
</code></pre><p>  }];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 2. 每隔20分钟获取新的内容</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setPhotoDatabaseContext:(NSManagedObjectContext *)photoDatabaseContext<br>{<br>  _photoDatabaseContext = photoDatabaseContext;</p>
<p>  //photoDatabaseContext设定成功后，每隔20分钟重新获取信息<br>  if (self.photoDatabaseContext)<br>  {</p>
<pre><code>self.flickrForegroundFetchTimer = [NSTimer scheduledTimerWithTimeInterval:FOREGROUND_FLICKR_FETCH_INTERVAL
                                                                   target:self
                                                                 selector:@selector(startFlickrFetch:)
                                                                 userInfo:nil
                                                                  repeats:YES];
</code></pre><p>  }</p>
<p>  //photoDatabaseContext设定成功后 向控制器发送消息<br>  NSDictionary *userInfo = self.photoDatabaseContext ? @{ PhotoDatabaseAvailabilityContext : self.photoDatabaseContext } : nil;<br>  [[NSNotificationCenter defaultCenter] postNotificationName:PhotoDatabaseAvailabilityNotification</p>
<pre><code>  object:self
userInfo:userInfo];
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3. 在表格视图查询所有摄影师的名字</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setManagedObjectContext:(NSManagedObjectContext *)managedObjectContext<br>{<br>  //哪个数据库<br>  _managedObjectContext = managedObjectContext;</p>
<p>  NSFetchRequest *requet = [NSFetchRequest fetchRequestWithEntityName:@”Photographer”];<br>  requet.predicate = nil;//所有的,无过滤<br>  requet.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@”name” ascending:YES selector:@selector(localizedStandardCompare:)]];</p>
<p>  self.fetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:requet managedObjectContext:managedObjectContext sectionNameKeyPath:nil cacheName:nil];</p>
</li>
</ul>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 4. 重写```tablelViwe:cellForRowAtIndex:```方法，显示摄影师数据</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath<br>{<br>  UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:@”Photographer cell”];</p>
<p>  //拿到摄影师的名字和摄影数量<br>  Photographer *photographer = [self.fetchedResultsController objectAtIndexPath:indexPath];<br>  cell.textLabel.text = photographer.name;<br>  cell.detailTextLabel.text = [NSString stringWithFormat:@”%lu photos”, [photographer.photos count]];<br>  return cell;</p>
</li>
</ul>
<p>}<br>```  </p>
<p>本Demo显然是一个未完成品，它只显示了摄影师的相关信息，并且只有一个页面。在接下来的课程中应该会对该Demo进行更多过的扩展。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:20:18+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="UITableview"><a href="#UITableview" class="headerlink" title="UITableview"></a>UITableview</h1><hr>
<p>UITableview是iOS软件中最常见的视图，用来以表格的形式显示数据。</p>
<h2 id="数据源方法"><a href="#数据源方法" class="headerlink" title="数据源方法"></a>数据源方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section;//表格的总section数，默认为返回1，可以不实现</div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; //返回当前section的行数，必须实现</div><div class="line">- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; //返回某section某row的cell，必须实现</div></pre></td></tr></table></figure>
<h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//cell被点击是调用的方法</div></pre></td></tr></table></figure>
<h2 id="根据cell获得对应的indexPath"><a href="#根据cell获得对应的indexPath" class="headerlink" title="根据cell获得对应的indexPath"></a>根据cell获得对应的indexPath</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> NSIndexPath *indexPath = [self.tableView  indexPathForCell :sender];</div></pre></td></tr></table></figure>
<h2 id="UITableView-Spinner"><a href="#UITableView-Spinner" class="headerlink" title="UITableView Spinner"></a>UITableView Spinner</h2><p>顶部加载时显示的小圆圈动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl;</div><div class="line"></div><div class="line">- (void)beginRefreshing;</div><div class="line">- (void)endRefreshing;</div></pre></td></tr></table></figure></p>
<h2 id="模型改变，刷新表格"><a href="#模型改变，刷新表格" class="headerlink" title="模型改变，刷新表格"></a>模型改变，刷新表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)reloadData; //刷新全部表格：一般在模型大部分变化的时候才调用，在某个数据变化时不推荐使用</div><div class="line"></div><div class="line">- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//只刷新某一个cell，在某行货少数行数据变化时推荐使用</div></pre></td></tr></table></figure>
<h1 id="Universal-Application"><a href="#Universal-Application" class="headerlink" title="Universal Application"></a>Universal Application</h1><hr>
<p>Universal Application通用应用是指既可以在iPhone上运行，也可以在iPad上运行的应用，它有两个故事版文件，一个是针对iphone的，另一个是针对ipad的。</p>
<p>iPad有两种独有的视图：</p>
<ol>
<li>Split View：拆分视图</li>
<li>Popover:弹窗</li>
</ol>
<p>识别是否是ipad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL iPad  = ([&#123;UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad)</div></pre></td></tr></table></figure></p>
<h1 id="UISplitViewController"><a href="#UISplitViewController" class="headerlink" title="UISplitViewController"></a>UISplitViewController</h1><hr>
<h2 id="UISplitViewController包括"><a href="#UISplitViewController包括" class="headerlink" title="UISplitViewController包括"></a>UISplitViewController包括</h2><ul>
<li>Master View Controller</li>
<li>Detail View Controller</li>
</ul>
<p>UISplitViewController是storyboard的最顶层，不能被加入到UIViewController里面</p>
<h2 id="获得SplitViewController："><a href="#获得SplitViewController：" class="headerlink" title="获得SplitViewController："></a>获得SplitViewController：</h2><p>返回当前UIViewcontroller所在的SplitViewController:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIViewController.h</div><div class="line"></div><div class="line">@property (strong) UISplitViewController  *splitViewController;</div></pre></td></tr></table></figure></p>
<h2 id="获得SplitViewController的master和detail："><a href="#获得SplitViewController的master和detail：" class="headerlink" title="获得SplitViewController的master和detail："></a>获得SplitViewController的master和detail：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (copy) NSArray *viewControllers;//0：master;1: detail</div></pre></td></tr></table></figure>
<h2 id="UISplitViewControllerDelegate"><a href="#UISplitViewControllerDelegate" class="headerlink" title="UISplitViewControllerDelegate"></a>UISplitViewControllerDelegate</h2><p>在awakeFromNib设置此代理,代理负责 控制master和detail何时出现</p>
<p>代理的几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)splitViewController:(UISplitViewController *)svc shouldHideViewController:(UIViewController *)vc inOrientation:(UIInterfaceOrientation)orientation&#123;</div><div class="line">           return NO; //永远不隐藏master，master和detail将一直在屏幕上显示，无论是横屏或竖屏 </div><div class="line">           return UIInterfaceOrientationIsPortrait(orientation);//竖屏不显示master 但是竖屏时左上角有按键可以显示master，但是</div><div class="line">不实现这个代理就不能出现按钮了。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在横屏或竖屏是否该隐藏master</p>
<h1 id="Popovers"><a href="#Popovers" class="headerlink" title="Popovers"></a>Popovers</h1><hr>
<p>Popover是弹窗控件，它的作用是控制另一个视图控制器弹出到屏幕上，也是ipad独有的控件。<br>因为ipad的面积比较大，所以有时可以只以弹窗的形式提供信息而不用跳转到下一页面。</p>
<p>注意：这个控件并没有继承UIViewController，是一个NSObject</p>
<h2 id="Popover的Segue是"><a href="#Popover的Segue是" class="headerlink" title="Popover的Segue是"></a>Popover的Segue是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在Popover出现之前：</div></pre></td></tr></table></figure></h2><ul>
<li><p>(void)prepareForSegue: (UIStoryboardSegue *)segue sender: (id)sender<br>{<br>  if([segue isKindOfClass:[UIStroyboardPopoverSegue class]]){</p>
<pre><code>UIPopoverController *popoverController = ((UIStroyboardPopoverSegue *)segue.)popoverController;
</code></pre><p>   }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 使Popover消失：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)dismissPopoverAnimated:(BOOL)animated;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">默认情况下，点击外部任何的地方都能使它消失，除非我们给它指定即使点击也不会消失的```UIVIew```。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@property (copy) NSArray *passthroughViews;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># Demo</div><div class="line">-----------------</div><div class="line"></div><div class="line">该Demo是同时适用iPad 和iPhone的，可惜笔者没有iPad，无法调试，于是只适配了iPhone，以后有机会会补上适配iPad的代码的。</div><div class="line"></div><div class="line">## Demo需求</div><div class="line">- 第一个页面用表格显示从Flickr抓取的图片数据，只显示图片名和图片详情。</div><div class="line">- 点击第一个页面的cell，跳转到图片详情页。</div><div class="line">- 图片详情页显示具体的大图，可以伸缩，可以移动。</div><div class="line"></div><div class="line">## 效果图</div><div class="line"></div><div class="line">![效果图](http://upload-images.jianshu.io/upload_images/859001-b0a8e98131ae59b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">## 重要代码段</div><div class="line"></div><div class="line">#### 1. 获取Flickr上的数据</div><div class="line"></div><div class="line">Flickr提供了公共的接口提供了自家的照片，接口文件在本Demo里的```Flickr Fetcher```文件里，唯一注意的是需要申请```APIKEY```,[申请网址]([http://www.flickr.com/services/api/misc.api_keys.html](http://www.flickr.com/services/api/misc.api_keys.html))。</div><div class="line"></div><div class="line">解析照片数据的过程是比较耗时的，所以需要分配到子线程来进行。获得数组后，在主线程将数组赋予当前类的属性里。</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)fetchPhotos<br>{<br>  self.photos = nil;<br>  NSURL *url = [FlickrFetcher URLforRecentGeoreferencedPhotos];</p>
<p>  //手动创建一个子线程<br>  dispatch_queue_t fetchQ = dispatch_queue_create(“flickr fetcher”, NULL);</p>
<p>  dispatch_async(fetchQ, ^{</p>
<pre><code>//获得json数据，比较耗时
NSData *jsonResults = [NSData dataWithContentsOfURL:url];

//获得字典
NSDictionary *propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:NULL];
NSArray *photos = [propertyListResults valueForKeyPath:FLICKR_RESULTS_PHOTOS];

dispatch_async(dispatch_get_main_queue(), ^{

   //回到主线程     
    self.photos = photos;

});    
</code></pre><p>  });<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;NULL是C指针，代表指向OC指针的指针没有指向任何对象</div><div class="line"></div><div class="line">什么是指向OC指针的指针？：&amp;error是指向error的指针</div><div class="line">如果我们这样写，就可以获得error：</div></pre></td></tr></table></figure>
<p> NSError <em>error = nil;<br> NSDictionary </em>propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:&amp;error];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果我们不关心error，就可以传NULL。</div><div class="line"></div><div class="line">好了，现在我们获得了数据，需要刷新表格：</div><div class="line"></div><div class="line">#### 2. 刷新表格</div></pre></td></tr></table></figure>
<ul>
<li>(void)setPhotos:(NSArray *)photos<br>{<br>  _photos = photos;<br>  [self.tableView reloadData];<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">只是刷新表格是不够的，还要实现```UITableView```的数据源方法来告诉```TableView```如何显示数据。（调用```reload```方法后会调用这些数据源方法）</div><div class="line"></div><div class="line">#### 3. 实现数据源方法</div></pre></td></tr></table></figure>
</li>
</ul>
<p>#pragma mark - Table view data source</p>
<ul>
<li><p>(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {<br>  //只有一组<br>   return 1;<br>}</p>
</li>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {<br> //行数为图片的个数<br>  return self.photos.count;<br>}</p>
</li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {</p>
<p>  //从重用池中拿到cell<br>  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@”Flickr Photo Cell” forIndexPath:indexPath];</p>
<p>  //通过indexPath来获得在数据里对应的图片数据<br>  NSDictionary *photoDict = self.photos[indexPath.row];<br>  //设置主标题和副标题</p>
<p>  cell.textLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_TITLE];</p>
<p>  cell.detailTextLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_DESCRIPTION];    </p>
<p>  return cell;</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### 4. 点击cell，实现跳转</div></pre></td></tr></table></figure>
<p>#pragma mark - Navigation</p>
<p>// In a storyboard-based application, you will often want to do a little preparation before navigation</p>
<ul>
<li><p>(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {</p>
<p>  if ([sender isKindOfClass:[UITableViewCell class]]) {</p>
<pre><code>NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];    

if (indexPath) {

    if ([segue.destinationViewController isKindOfClass:[ImageViewController class]]) {

        [self prepareImageViewController:segue.destinationViewController toDisplayPhoto:self.photos[indexPath.row]];                

    }
}
</code></pre><p>  }<br>}</p>
</li>
<li><p>(void)prepareImageViewController:(ImageViewController <em>)ivc toDisplayPhoto:(NSDictionary</em>)photo<br>{</p>
<p> //获得图像的URL传给ImageViewController<br>  ivc.imageURL = [FlickrFetcher URLforPhoto:photo format:FlickrPhotoFormatLarge];<br> //导航栏的标题为图片的名字<br>  ivc.title = [photo valueForKey:FLICKR_PHOTO_TITLE];</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;这里的```ImageViewController```复用了[斯坦福大学iOS开发公开课总结（十） ：多线程，UIScrollView，图片浏览器Demo](http://www.jianshu.com/p/ddb4f528b334)里第二个页面。</div><div class="line"></div><div class="line">#### 5. 优化</div><div class="line">每次跳转到图片详情页，将图片的原点设置在最左上端，并且大小恢复到该图片的原始大小</div></pre></td></tr></table></figure>
<ul>
<li><p>(void)setImage:(UIImage *)image<br>{</p>
<p>  //重置缩放大小为1<br>  self.scrollView.zoomScale = 1.0;<br>  self.imageView.image = image;<br>  [self.imageView sizeToFit];</p>
<p>  //将视图框的原点设在左上角<br>  self.imageView.frame = CGRectMake(0, 0, self.image.size.width, self.image.size.height);</p>
<p>  self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;</p>
<p>  [self.spinner stopAnimating];</p>
</li>
</ul>
<p>}<br>```</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十）：多线程，UIScrollView，图片浏览器Demo/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（十）：多线程，UIScrollView，图片浏览器Demo/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（十）：多线程，UIScrollView，图片浏览器Demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:19:16+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本节课讲授了多线程编程和UIScrollview控件，最后通过一个显示图片的Demo综合了本节课讲解的知识。通过本节课的学习，我们可以初步了解该如何处理耗时的任务来提高系统性能的方法以及通过UIScrollview控件来显示超出屏幕大小的图片并实现滚动和缩放的效果。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><hr>
<p>实现多线程编程（将不同的任务放在主线程和子线程工作），可以有效利用系统硬件优势提高系统性能。<br>首先，先介绍几个概念：</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列：在队列中放入用来执行任务的block。这些block按照队列的性质被取出到应该工作的线程(主线程，子线程)。</p>
<p>队列分为串行队列和并行队列。</p>
<ul>
<li>放入串行队列的任务将会在主线程执行，执行顺序是按照顺序执行。</li>
<li>放入并行队列的任务会在子线程执行，执行顺序是并行执行。</li>
</ul>
<p>那么什么样的任务会放在主线程或子线程执行呢？</p>
<h2 id="主线程-amp-子线程"><a href="#主线程-amp-子线程" class="headerlink" title="主线程&amp;子线程"></a>主线程&amp;子线程</h2><p>主线程：负责执行UI活动，绝大部分的UI活动都要在这里调用，不能让其阻塞，要将耗时的任务放到子线程来做。<br>子线程：负责执行耗时的运算，网络请求等不能放在主线程的任务。</p>
<p>系统为我们提供了共用的主队列(Main Dispatch Queue)和全局并行队列(Global Dispatch Queue)。我们只需将需要执行的任务放入到这两类队列里就可以实现多线程编程。</p>
<h2 id="得到主队列"><a href="#得到主队列" class="headerlink" title="得到主队列"></a>得到主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQ = dispatch_get_main_queue();</div><div class="line">NSOperationQueue *mainQ = [NSOperationQueue mainQueue];</div></pre></td></tr></table></figure>
<h2 id="得到主队列并布置任务"><a href="#得到主队列并布置任务" class="headerlink" title="得到主队列并布置任务"></a>得到主队列并布置任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//NSThread</div><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</div><div class="line"></div><div class="line">//GCD</div><div class="line"> dispatch_async(dispatch_get_main_queue(), ^&#123;                   </div><div class="line"></div><div class="line">                        [doSomething];</div><div class="line"></div><div class="line">                    &#125;);</div></pre></td></tr></table></figure>
<h2 id="得到全局并行队列"><a href="#得到全局并行队列" class="headerlink" title="得到全局并行队列"></a>得到全局并行队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch queue_t globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</div></pre></td></tr></table></figure>
<h2 id="得到全局并行队列并布置任务"><a href="#得到全局并行队列并布置任务" class="headerlink" title="得到全局并行队列并布置任务"></a>得到全局并行队列并布置任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"> </div><div class="line">         [doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="使用多线程的例子：线程之间通信"><a href="#使用多线程的例子：线程之间通信" class="headerlink" title="使用多线程的例子：线程之间通信"></a>使用多线程的例子：线程之间通信</h2><p>很多情况下，我们需要在子线程进行下载任务，下载完成后在主线程更新UI，这时候就需要线程之间的通信：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    </div><div class="line">            //下载图片</div><div class="line">            NSData *dataFromURL = [NSData dataWithContentsOfURL:imageURL];</div><div class="line">            UIImage *imageFromData = [UIImage imageWithData:dataFromURL];</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">            //加载完成更新view</div><div class="line">            UIImageView *imageView = [[UIImageView alloc] initWithImage:imageFromData];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在这里，我们在全局并行队列的回调block里调用了主线程，并在主线程里执行了UI操作。</p>
</blockquote>
<h2 id="使用多线程的例子：通过NSURLSession下载"><a href="#使用多线程的例子：通过NSURLSession下载" class="headerlink" title="使用多线程的例子：通过NSURLSession下载"></a>使用多线程的例子：通过NSURLSession下载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)mainQueueCallBack</div><div class="line">&#123;</div><div class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL];</div><div class="line">    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:nil delegateQueue:[NSOperationQueue mainQueue]];</div><div class="line">    NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line">         //这里是主队列，可以更新UI        </div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [task resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果没有```delegateQueue```呢？我们需要自己获取主线程</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><p>(void)noDelegateQueueRequest<br>{<br>  NSURLRequest <em>request = [NSURLRequest requestWithURL:self.imageURL];<br>  NSURLSessionConfiguration </em>configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];<br>  NSURLSession <em>session = [NSURLSession sessionWithConfiguration:configuration];<br>  NSURLSessionDownloadTask </em>task = [session downloadTaskWithRequest:request completionHandler:^(NSURL <em> _Nullable location, NSURLResponse </em> _Nullable response, NSError * _Nullable error) {</p>
<p>   //获取主线程-通过NSThread<br>   [self performSelectorOnMainThread:(doUIThings) withObject:nil waitUntilDone:NO];<br>   //获取主线程-通过GCD<br>  dispatch_async(dispatch_get_main_queue(), ^{                   </p>
<pre><code>    [doUIThings]
});         
</code></pre><p>  }];<br>  [task resume];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># UIScrollView</div><div class="line">-----</div><div class="line">UIScrollView是滚动视图，可以实现滚动和缩放的功能。</div><div class="line"></div><div class="line">## 几个比较重要的属性：</div><div class="line">视图要滚动的区域：```contentSize</div></pre></td></tr></table></figure>
</li>
</ul>
<p>目前滚动的位置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">滚动窗口的大小：```scrollView.bounds</div></pre></td></tr></table></figure></p>
<h2 id="几个比较重要的方法："><a href="#几个比较重要的方法：" class="headerlink" title="几个比较重要的方法："></a>几个比较重要的方法：</h2><p>获取当前显示的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGRect visibleRect = [scrollView convertRect：scrollView.bounds toView:subview];</div></pre></td></tr></table></figure></p>
<p>用代码滚动视图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)scrollRectToVisible :(CGRect)aRect animated:(BOOL)animated;</div></pre></td></tr></table></figure></p>
<p>代码实现缩放：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic) CGFloat zoomScale;  </div><div class="line">- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated);</div><div class="line">- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated;</div></pre></td></tr></table></figure></p>
<p>告诉要缩放哪个<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)</div></pre></td></tr></table></figure></p>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><h4 id="设置缩放极限"><a href="#设置缩放极限" class="headerlink" title="设置缩放极限"></a>设置缩放极限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scrollView.minimumZoomSize = 0.5;</div><div class="line">scrollView.maximumZoomSize = 2.0;</div></pre></td></tr></table></figure>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>第一个页面显示三个按钮，在跳转后分别下载并显示不同图片。</li>
<li>在图片的下载过程中给予提示。</li>
<li>图片显示出来后可以移动，缩放。</li>
</ul>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-30b1dbbc035c8e1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：第一页 | 右：第二页"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-在跳转之前将图片下载的URL传给第二个页面"><a href="#1-在跳转之前将图片下载的URL传给第二个页面" class="headerlink" title="1. 在跳转之前将图片下载的URL传给第二个页面"></a>1. 在跳转之前将图片下载的URL传给第二个页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</div><div class="line">&#123;</div><div class="line">     //通过内省判断跳转的页面类</div><div class="line">     if ([segue.destinationViewController isKindOfClass:[ImageViewController class]]) &#123;       </div><div class="line"></div><div class="line">        //告诉编译期，即将跳转的页面类</div><div class="line">        ImageViewController *imageVC = (ImageViewController *)segue.destinationViewController;        </div><div class="line">        //初始化指针，将其设为nil </div><div class="line">        NSString *string = nil;</div><div class="line">        //通过identifier判断跳转界面</div><div class="line">        if ([segue.identifier isEqualToString:@&quot;paint&quot;]) &#123;            </div><div class="line">            //这张图貌似得翻墙，而且图片很大，建议换一张</div><div class="line">            string = @&quot;https://lh6.ggpht.com/ZoD88QrTxZbZnhpJgQbo9SPuosryX9ujjdRaHvjjvbUGeZcI-9C4AFQsWQm7-pVDv1E=h900&quot;;       </div><div class="line"></div><div class="line">        &#125;else if ([segue.identifier isEqualToString:@&quot;earth&quot;]) &#123;</div><div class="line">            //这张图不是很大，可以不用花很久就能显示</div><div class="line">            string = @&quot;http://news.nationalgeographic.com/content/dam/news/2016/02/12/01asteroidearth.jpg&quot;;           </div><div class="line"></div><div class="line">        &#125;else if ([segue.identifier isEqualToString:@&quot;night&quot;])  &#123;</div><div class="line">            //这张图貌似得翻墙，而且图片很大，建议换一张</div><div class="line">            string = @&quot;https://lh5.ggpht.com/j4C_pXnbRc5FnxNO90wIqodn4QA3f_6rB0cyu2sVnCeSwLDmyZf-xSrC9L8c3oxr6NE=h900&quot;;</div><div class="line"></div><div class="line">        &#125;        </div><div class="line"></div><div class="line">        imageVC.imageURL = [NSURL URLWithString:string];</div><div class="line"></div><div class="line">         //设置导航栏的标题</div><div class="line">        imageVC.title = segue.identifier;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-使UIScrollView控件能够拖动"><a href="#2-使UIScrollView控件能够拖动" class="headerlink" title="2. 使UIScrollView控件能够拖动"></a>2. 使UIScrollView控件能够拖动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  设置图片后，重新imageView的图片和自己的大小，并设置contentSize</div><div class="line"> *</div><div class="line"> *  @param image &lt;#image description#&gt;</div><div class="line"> */</div><div class="line">- (void)setImage:(UIImage *)image</div><div class="line">&#123;</div><div class="line">    self.imageView.image = image;</div><div class="line">    //根据图片大小设置imageview的大小</div><div class="line"></div><div class="line">    [self.imageView sizeToFit];</div><div class="line">    //保护机制：有图片设置size，否则size=0</div><div class="line"></div><div class="line">    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为了使UIScrollView控件能够拖动，<strong>必须</strong>要设置它的contentSize大小，否则无法滚动！</p>
</blockquote>
<h4 id="3-设置UIScrollView伸缩"><a href="#3-设置UIScrollView伸缩" class="headerlink" title="3. 设置UIScrollView伸缩"></a>3. 设置UIScrollView伸缩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)setScrollView:(UIScrollView *)scrollView</div><div class="line">&#123;</div><div class="line">    _scrollView = scrollView;</div><div class="line">    _scrollView.minimumZoomScale = 0.2;</div><div class="line">    _scrollView.maximumZoomScale = 2.0;</div><div class="line">    _scrollView.delegate = self;</div><div class="line">    //设置两次contSize的原因是我们不确保这两个方法哪个是先被调用的</div><div class="line"></div><div class="line">    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-2d0da3c643a5b7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现伸缩效果"></p>
<h4 id="4-下载图片"><a href="#4-下载图片" class="headerlink" title="4. 下载图片"></a>4. 下载图片</h4><p>错误做法：阻塞主线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setImageURL:(NSURL *)imageURL</div><div class="line">&#123;</div><div class="line">    _imageURL = imageURL;   </div><div class="line">    self.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:self.imageURL]];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>永远不要在主线程调用下载的方法！主线程负责UI相应，如果调用耗时的方法会使得其下一项任务在下载完成之前无法执行（主线程是串行队列），造成卡死的情况。<br>所以，我们应该另外开一个子线程让其负责下载：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (void)startDownloading</div><div class="line">&#123;</div><div class="line">    //先清空现有图片</div><div class="line">    self.image = nil;   </div><div class="line"></div><div class="line">    if (self.imageURL) &#123;        </div><div class="line"></div><div class="line">        //转动的小动画，提示正在下载</div><div class="line">       [self.spinner startAnimating];</div><div class="line">        NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL];</div><div class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">        NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];</div><div class="line">        NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;            </div><div class="line"></div><div class="line">            if(!error)&#123;</div><div class="line">               </div><div class="line">                //判断URL是否被更改，因为这是一个异步操作，无法保证在下载过程中一定能保持原来的数据</div><div class="line">                if ([request.URL isEqual:self.imageURL])</div><div class="line">                &#123;</div><div class="line">                    //下载完成，拿到本地的路径</div><div class="line">                    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:location]];                    </div><div class="line">                    //获得主队列</div><div class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">                        //在主队列更新UI</div><div class="line">                        self.image = image;</div><div class="line"></div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;];        </div><div class="line"></div><div class="line">        [task resume];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。</p>
<p>笔者这两天会总结一下这一系列的Demo，发布到我的个人GitHub账号上去，以后就可以方便很多了~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（九）：AutoLayout，自动布局Demo/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（九）：AutoLayout，自动布局Demo/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（九）：AutoLayout，自动布局Demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:18:19+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本节课介绍了iOS在故事版里构造AutoLayout(自动布局)的三种方法并通过沿用了第六课的<a href="http://www.jianshu.com/p/8d5a4a8ac2be" target="_blank" rel="external">Demo</a>具体演示了添加约束的过程。内容较少也比较简单，可惜的是没有讲解用纯代码构造自动布局。</p>
<p><strong>PS：严重多图预警！</strong></p>
<p>因为操作都是在故事版里进行的，所以只能通过截图来演示具体操作步骤。。。</p>
<h1 id="AutoLayout"><a href="#AutoLayout" class="headerlink" title="AutoLayout"></a>AutoLayout</h1><hr>
<h2 id="在故事版里构造AutoLayout的三种方法："><a href="#在故事版里构造AutoLayout的三种方法：" class="headerlink" title="在故事版里构造AutoLayout的三种方法："></a>在故事版里构造AutoLayout的三种方法：</h2><ol>
<li>使用蓝色辅助线，并选择系统建议约束。</li>
<li>点击底部的布局菜单，根据需求选择相应的约束。</li>
<li>按住control按键拖动触发菜单，根据需求选择相应约束。</li>
</ol>
<p>下面具体每种方法的做法：</p>
<h2 id="1-使用蓝色辅助线，并选择系统建议约束"><a href="#1-使用蓝色辅助线，并选择系统建议约束" class="headerlink" title="1. 使用蓝色辅助线，并选择系统建议约束"></a>1. 使用蓝色辅助线，并选择系统建议约束</h2><p>我们现在要将“Thing 1”和“Thing 2”两个标签放在左上角和右下角。<br><img src="http://upload-images.jianshu.io/upload_images/859001-1f209520ddccc48e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用蓝色辅助线"></p>
<blockquote>
<p>在拖动空间的时候，系统会在某些时刻给出建议的约束，用蓝色虚线表示，详情看左图。<br>在约束显示出来的前提下放下控件，再选择系统建议的约束可以添加系统建议的约束，也就是之前虚线表示出来的约束，详情看右图。</p>
</blockquote>
<h2 id="2-点击底部的布局菜单，根据需求选择相应的约束"><a href="#2-点击底部的布局菜单，根据需求选择相应的约束" class="headerlink" title="2. 点击底部的布局菜单，根据需求选择相应的约束"></a>2. 点击底部的布局菜单，根据需求选择相应的约束</h2><p>我们现在要添加“Bad Thing”按钮，将其置于屏幕正中间。<br><img src="http://upload-images.jianshu.io/upload_images/859001-38cf0f8b7dddb55b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用底部布局菜单"></p>
<blockquote>
<p>想让控件居中显示，可以根据底部的按钮弹出的菜单设置，具体看左图。</p>
<p>添加约束后，生成了黄色虚线框，如中间的图所示。黄色虚线框为控件添加该约束后，控件应有的frame。这时，应该点击左上角的黄色小三角选择“update frame”，具体看右图。</p>
</blockquote>
<p>最终效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-4ed297bd355f392e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图1"></p>
<blockquote>
<p>点击黄色小三角显示的选项的意义：  </p>
<ol>
<li>update frame：通过修改frame 来适应约束。 </li>
<li>update constrains: 修改约束 适应这个控件的frame。</li>
<li>reset to suggested constrains:使用建议约束。</li>
</ol>
</blockquote>
<h2 id="3-按住control按键拖动触发菜单，根据需求选择相应约束。"><a href="#3-按住control按键拖动触发菜单，根据需求选择相应约束。" class="headerlink" title="3. 按住control按键拖动触发菜单，根据需求选择相应约束。"></a>3. 按住control按键拖动触发菜单，根据需求选择相应约束。</h2><p>我们现在要将“Bad Thing”和”Thing 2”垂直距离固定，右边对其。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-192fcf72d0c3b71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按住control键"></p>
<p>在拖动控件”Bad Thing”后，并不会改变其原有的约束(出现了黄色虚线框)，如左图。我们需要先删除其原有的约束。<br>然后点击“Bad Thing”按住<code>control</code>拖动到<code>Thing 2</code>,弹出菜单后，设置二者的垂直距离固定，右边对其，如右图所示。</p>
<p>最终效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c292148931dab740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图2"></p>
<blockquote>
<p>拖动也有三种方式：</p>
<ol>
<li>从一个控件按住control按键到另一个控件，选择相应的排列方式。</li>
<li>从一个控件拖拽到它的父视图：水平居中，垂直居中等。</li>
<li>从一个控件拖拽到它自己：选择固定宽度等。</li>
</ol>
</blockquote>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<p>首先我们拿到之前的属性字符串Demo，按照第一种设定约束的方法，结果不尽人意：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-143c8a529cb76416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="宽度不等"></p>
<p>显然，我们需要让四个彩色按钮宽度保持一致：<br>点击下方弹出菜单，选择“Equal Width”。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-4d27907e6dc68116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置等宽"></p>
<p>现在确实是等宽了，但是控制台有报错信息，虽然运行木有问题。</p>
<p>什么问题呢？</p>
<p>因为我们在让四个彩色按钮宽度相等的同时<strong>硬编码</strong>了它们的宽度，这显然不同时适用于横屏和竖屏的情况，需要将它们的固定宽度删去：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-bf9616a1e7401713.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除固定宽度"></p>
<p>在第二个页面，我们把两个Label放到左下角：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d8c09edac6a09686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="垂直固定"></p>
<ol>
<li>首先用下方的菜单，将靠左和靠下的距离固定，如左图。</li>
<li>然后用拖动control键的方法设定第二个标签的左对齐和垂直距离，效果如右图。</li>
</ol>
<p>在这里没有固定标签的宽度，这很好，因为如果数字是多位的，固定的宽度可能无法全部显示标签内的内容。</p>
<p>那么手动固定一下其中一个标签的宽度，通过拖动control键拖动到自己的方法点击“width”，使宽度固定：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b9ab01e556babf45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="固定宽度.png"></p>
<blockquote>
<p>固定宽度的标签无法完整显示了内容，因此这是一个危险的做法。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（八）：协议，block，动画，俄罗斯方块Demo/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（八）：协议，block，动画，俄罗斯方块Demo/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（八）：协议，block，动画，俄罗斯方块Demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:17:25+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本节课介绍了协议，block，动画的相关知识，最后结合了这些知识点展示了一个类似<strong>俄罗斯方块</strong>的小游戏Demo。<br>总体来说本节课的内容比较重要，稍微摆脱了UI层面的知识，对于初学者来说理解起来不是很容易，不过笔者会尽量详细地讲解给大家。</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><hr>
<p>关于协议所介绍的知识点比较简单，而且实现起来相对容易，故不做详细介绍，各位可以参考文档或者相关博客即可。<br>在这里只强调一个知识点：</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><figcaption><span>obj``` 和 ```id<myprotocol>obj```的相同点和不同点:</myprotocol></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">**相同点**：都表示了某个对象。</div><div class="line">**不同点**：</div><div class="line">```id obj```表示```obj```是具体某一类的实例对象。</div><div class="line">```id&lt;MyProtocol&gt;obj```只表示遵守了某协议的对象 。</div><div class="line">&gt;因为有的时候我们并不需要确保某个对象一定是某个类的实例对象，而只需要它遵循了某个协议，这个时候就需要用第二行的写法来确保这个对象确实遵循了&lt;MyProtocol&gt;。</div><div class="line"></div><div class="line"># Block</div><div class="line">-----</div><div class="line">关于block的概念和语法在这里就不赘述了，因为有文档和很多牛人已经总结地很好了。</div><div class="line">在这里只强调两点关于block的使用注意事项。</div><div class="line"></div><div class="line">## 修改block内部变量的方案</div><div class="line">如果我们要在block里将```found```值设为YES,就应该在block外部添加```__block```关键字。</div></pre></td></tr></table></figure></h3><pre><code>__block BOOL found = NO;
//通过__block关键字，将found从栈中移动到堆中保证其可以被修改；block结束后，将该变量复制一份到堆中，再放回栈上

[dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop){        

    if ([targetString isEqualToString:obj]) {            

        *stop = YES; //停止
        found = YES;
    }        
}];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 存储循环的解决方案</div><div class="line">只要block存在，block内部消息中的每个对象都会被block的一个强指针指着。此时，如果这些对象里的某个或几个对象也有指向该block的指针，就会造成存储循环。</div><div class="line"></div><div class="line">问题重现：</div></pre></td></tr></table></figure>
<pre><code>//这个block有强指针指向self，而self也通过myBlocks数组有强指针指向block

[self.myBlocks addObject:^{    

    [self doSomething];

}];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">解决方案：创建弱类型的局部变量</div></pre></td></tr></table></figure>
<pre><code>__weak ViewController *weakSelf = self; //创建弱类型的局部变量

[self.myBlocks addObject:^{    

    [weakSelf doSomething];

}];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## Block的应用</div><div class="line"></div><div class="line">block可以直接保存在变量中，属性中，字典和数组中。</div><div class="line"></div><div class="line">具体使用环境：</div><div class="line"></div><div class="line">- 多线程：用于主线程，子线程的回调。</div><div class="line">- 枚举：数组，字典的枚举等。</div><div class="line">- 通知：某件事情发生后，信息的传递。</div><div class="line">- 错误时调用：“包住”错误发生后需要执行的代码。</div><div class="line">- 成功时调用：“包住”任务成功后需要执行的代码。</div><div class="line">- 动画</div><div class="line">- 排序</div><div class="line"></div><div class="line"># 通过View改变视图的属性来实现动画</div><div class="line">-----</div><div class="line">- 改变```frame</div></pre></td></tr></table></figure>
<ul>
<li>改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 改变```alpha</div></pre></td></tr></table></figure></li>
</ul>
<p>具体通过UIView的类方法来改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (void)animateWithDuration:(NSTimeInterval)duration   //动画在这个屏幕上出现的时间</div><div class="line">                                     delay:(NSTimeInterval)delay       //等待多长时间再执行</div><div class="line">                                  options:(UIViewAnimationOptions)options </div><div class="line">                             animations:(void (^)(void))animations  //在此代码块中修改frame，transform 和 alpha</div><div class="line">                             completion:(void (^ __nullable)(BOOL finished))completion;</div></pre></td></tr></table></figure>
<p>options参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    UIViewAnimationOptionLayoutSubviews            = 1 &lt;&lt;  0,</div><div class="line">    UIViewAnimationOptionAllowUserInteraction      = 1 &lt;&lt;  1, // turn on user interaction while animating</div><div class="line">    UIViewAnimationOptionBeginFromCurrentState     = 1 &lt;&lt;  2, // start all views from current value, not initial value</div><div class="line">    UIViewAnimationOptionRepeat                    = 1 &lt;&lt;  3, // repeat animation indefinitely</div><div class="line">    UIViewAnimationOptionAutoreverse               = 1 &lt;&lt;  4, // if repeat, run animation back and forth</div><div class="line">    UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt;  5, // ignore nested duration</div><div class="line">    UIViewAnimationOptionOverrideInheritedCurve    = 1 &lt;&lt;  6, // ignore nested curve</div><div class="line">    UIViewAnimationOptionAllowAnimatedContent      = 1 &lt;&lt;  7, // animate contents (applies to transitions only)</div><div class="line">    UIViewAnimationOptionShowHideTransitionViews   = 1 &lt;&lt;  8, // flip to/from hidden state instead of adding/removing</div><div class="line">    UIViewAnimationOptionOverrideInheritedOptions  = 1 &lt;&lt;  9, // do not inherit any options or animation type</div></pre></td></tr></table></figure></p>
<h1 id="通过给视图添加物理效果实现动画"><a href="#通过给视图添加物理效果实现动画" class="headerlink" title="通过给视图添加物理效果实现动画"></a>通过给视图添加物理效果实现动画</h1><hr>
<p>添加物理效果主要需要三个元素：</p>
<ol>
<li>DynamicAnimator</li>
<li>UIGravityBehavior</li>
<li>遵守<uidynamicitem>协议的item(大部分情况是UIView)</uidynamicitem></li>
</ol>
<h2 id="DynamicAnimator：动力动画"><a href="#DynamicAnimator：动力动画" class="headerlink" title="DynamicAnimator：动力动画"></a>DynamicAnimator：动力动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIDynamicAnimator *animator =[ [ UIDynamicAnimator alloc] initWithReferenceView:aView]; //aview是动画Views的顶级视图</div></pre></td></tr></table></figure>
<p>动力动画的初始化需要给其添加要进行动画的顶级视图，详细内容后面再介绍。</p>
<h2 id="UIDynamicBehavior：动力行为"><a href="#UIDynamicBehavior：动力行为" class="headerlink" title="UIDynamicBehavior：动力行为"></a>UIDynamicBehavior：动力行为</h2><p>动力行为分为重力动力行为，碰撞行为等具体的行为。<br>这个类有很多子类：</p>
<h3 id="1-UIGravityBehavior：重力行为"><a href="#1-UIGravityBehavior：重力行为" class="headerlink" title="1. UIGravityBehavior：重力行为"></a>1. UIGravityBehavior：重力行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat angle;//重力方向</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat magnitude; //重力加速度值</div></pre></td></tr></table></figure>
<h3 id="2-UICollisionBehavior：碰撞行为"><a href="#2-UICollisionBehavior：碰撞行为" class="headerlink" title="2. UICollisionBehavior：碰撞行为"></a>2. UICollisionBehavior：碰撞行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@property (nonatomic, readwrite) UICollisionBehaviorMode collisionMode;//互相碰撞弹开还是只是从边界碰撞弹开</div><div class="line"></div><div class="line">@property (nonatomic, readwrite) BOOL translatesReferenceBoundsIntoBoundary; //是否是有弹性的边界</div></pre></td></tr></table></figure>
<h3 id="3-UIAttachmentBehavior-：吸附行为"><a href="#3-UIAttachmentBehavior-：吸附行为" class="headerlink" title="3. UIAttachmentBehavior ：吸附行为"></a>3. UIAttachmentBehavior ：吸附行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (readwrite, nonatomic) CGPoint anchorPoint; //设置锚点</div><div class="line">- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item attachedToAnchor:(CGPoint)point;//将动力项吸附在锚点上</div><div class="line">- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item1 attachedToItem:(id &lt;UIDynamicItem&gt;)item2;//吸附两个动力项</div></pre></td></tr></table></figure>
<h3 id="4-UISnapBehavior：速甩行为"><a href="#4-UISnapBehavior：速甩行为" class="headerlink" title="4. UISnapBehavior：速甩行为"></a>4. UISnapBehavior：速甩行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item snapToPoint:(CGPoint)point NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<h3 id="5-UIPushBehavior：推动行为"><a href="#5-UIPushBehavior：推动行为" class="headerlink" title="5. UIPushBehavior：推动行为"></a>5. UIPushBehavior：推动行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readonly) UIPushBehaviorMode mode;</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat magnitude;//推力</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGVector pushDirection;//推动方向</div></pre></td></tr></table></figure>
<h3 id="6-UIDynamicItemBehavior：动力项行为"><a href="#6-UIDynamicItemBehavior：动力项行为" class="headerlink" title="6. UIDynamicItemBehavior：动力项行为"></a>6. UIDynamicItemBehavior：动力项行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (readwrite, nonatomic) CGFloat elasticity; // Usually between 0 (inelastic) and 1 (collide elastically) </div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat friction; // 0 being no friction between objects slide along each other</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat density; // 1 by default</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat resistance; // 0: no velocity damping</div><div class="line"></div><div class="line">- (CGPoint)linearVelocityForItem:(id &lt;UIDynamicItem&gt;)item;//线速度</div><div class="line">- (CGFloat)angularVelocityForItem:(id &lt;UIDynamicItem&gt;)item;//角速度</div></pre></td></tr></table></figure>
<h2 id="遵守协议的item-大部分情况是UIView"><a href="#遵守协议的item-大部分情况是UIView" class="headerlink" title="遵守协议的item(大部分情况是UIView)"></a>遵守<uidynamicitem>协议的item(大部分情况是UIView)</uidynamicitem></h2><p>只要是遵守了<uidynamicitem>协议（动力项协议）的对象，都可以添加动力行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id&lt;UIDynamicItem&gt;item1 = ....;</div><div class="line">id&lt;UIDynamicItem&gt;item2 = ....;</div><div class="line">[gravity addItem:itme2];</div></pre></td></tr></table></figure></uidynamicitem></p>
<p>动力项协议的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readwrite) CGPoint center;//动力项的中心</div><div class="line"></div><div class="line">@property (nonatomic, readonly) CGRect bounds; //动力项的绘制区域，只读，通过变换，居中，移动进行修改</div><div class="line"></div><div class="line">@property (nonatomic, readwrite) CGAffineTransform transform;//动力项的旋转或缩放比例</div></pre></td></tr></table></figure></p>
<p>若想与animator的动画相抗争，需要调用animator的以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)updateItemUsingCurrentState:(id &lt;UIDynamicItem&gt;)item;</div></pre></td></tr></table></figure></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>点击屏幕后，在顶部随机位置生成具有随机色的正方形，正方形显示后立即下落并停止。</li>
<li>方块排满的行会自动被炸飞，而且带动画。</li>
</ul>
<h2 id="Demo效果图"><a href="#Demo效果图" class="headerlink" title="Demo效果图"></a>Demo效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-6116d4bb61ba202a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：炸飞前 | 右：炸飞后"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><p>因为每个方块的动作行为都是一致的，所以在这里自定义了一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**1. 自定义统一行为类：DropItBehavior**</div></pre></td></tr></table></figure></p>
<ul>
<li>(instancetype)init<br>{<br>  self = [super init];<br> //重写初始化方法，同时增加重力和碰撞行为<br>  [self addChildBehavior:self.gravity];<br>  [self addChildBehavior:self.collider];<br>  return self;<br>}</li>
</ul>
<p>//同时增加重力和碰撞行为</p>
<ul>
<li>(void)addItem:(id<uidynamicitem>)item<br>{<br>  [self.gravity addItem:item];<br>  [self.collider addItem:item];<br>}</uidynamicitem></li>
</ul>
<p>//同时移除重力和碰撞行为</p>
<ul>
<li><p>(void)removeItem:(id<uidynamicitem>)item<br>{<br>  [self.gravity removeItem:item];<br>  [self.collider removeItem:item];<br>}</uidynamicitem></p>
</li>
<li><p>(UIGravityBehavior *)gravity<br>{</p>
<p>  if (!_gravity) {</p>
<pre><code>_gravity = [[UIGravityBehavior alloc] init];
 //设置重力加速度
_gravity.magnitude = 1.9;
</code></pre><p>  }<br>  return _gravity;<br>}</p>
</li>
<li><p>(UICollisionBehavior *)collider<br>{<br>  if (!_collider) {</p>
<pre><code>_collider = [[UICollisionBehavior alloc] init];
//触碰边缘弹性 
_collider.translatesReferenceBoundsIntoBoundary = YES;
</code></pre><p>  }<br>  return _collider;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**2. 初始化animator**</div></pre></td></tr></table></figure>
</li>
<li><p>(UIDynamicAnimator *)animator<br>{<br>  if (!_animator) {</p>
<pre><code>//self.gameView 是动画实现的顶级视图，它的子视图是掉落的方块
_animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.gameView];
</code></pre><p>  }<br>  return _animator;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">**3. 给```UIDynamicAnimator```添加行为**</div></pre></td></tr></table></figure>
</li>
<li><p>(DropItBehavior *)dropitBehavior<br>{<br>  if (!_dropitBehavior) {</p>
<pre><code> _dropitBehavior = [[DropItBehavior alloc] init];
[self.animator addBehavior:_dropitBehavior];
</code></pre><p>  }<br>  return _dropitBehavior;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**4. 生成随机方块并让其下落**</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>生成随机方块并下落<br>*/</p>
<ul>
<li>(void)drop<br>{<br>//1. 随机位置</li>
</ul>
<p>CGRect frame;<br>frame.origin = CGPointZero;<br>frame.size = DROP_SIZE;<br>int x = (arc4random()%(int)self.gameView.bounds.size.width)/DROP_SIZE.width;<br>frame.origin.x = x <em> DROP_SIZE.width;<br>UIView </em>dropView = [[UIView alloc] initWithFrame:frame];</p>
<p>//2. 随机颜色<br>dropView.backgroundColor = [self randomColor];<br>[self.gameView addSubview:dropView];</p>
<p>//3. 添加下落<br>[self.dropitBehavior addItem:dropView];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;目前小方块下落碰到障碍物后会旋转，所以容易让这些小方块散落成堆。这样一来，就不能计算好整行的排列情况，所以我们应该让小方块们没有旋转的特性。</div><div class="line"></div><div class="line">**5.取消旋转特性**</div><div class="line"></div><div class="line">在公用的behavior类```DropItBehavior```里增加一个```UIDynamicItemBehavior```实例，取消其旋转特性。</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>(UIDynamicItemBehavior *)animationOptions<br>{<br>  if (!_animationOptions) {</p>
<pre><code>_animationOptions = [[UIDynamicItemBehavior alloc] init];
_animationOptions.allowsRotation = NO;        
</code></pre><p>  }<br>  return _animationOptions;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">这样就能整齐排列小方块了：</div><div class="line"></div><div class="line">![左：可旋转 | 右：不可旋转](http://upload-images.jianshu.io/upload_images/859001-a6bc68132ab0425a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line">**6. 动画炸掉排满的行**</div><div class="line"></div><div class="line">最好在方块都静止了之后再判断是否有排满的行，这里需要遵守协议```&lt;UIDynamicAnimatorDelegate&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> *  监听动力动画内部的所有动画停止后调用炸飞整行的方法</div><div class="line"> *</div><div class="line"> *  @param animator 动力动画</div><div class="line"> */</div><div class="line">- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator</div><div class="line"></div><div class="line">&#123;</div><div class="line">    [self removeCompleteRows];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来看一下炸飞整行的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> *  炸飞整行的方法：包括查看是否存在整行的算法和炸飞整行的动画</div><div class="line"> */</div><div class="line">- (void)removeCompleteRows</div><div class="line">&#123;</div><div class="line">    NSMutableArray *dropsToRemove = [[NSMutableArray alloc] init];</div><div class="line">    </div><div class="line">    //遍历每一行</div><div class="line">    for (CGFloat y = self.gameView.bounds.size.height - DROP_SIZE.height/2;y &gt; 0;y-= DROP_SIZE.height) &#123;</div><div class="line">        </div><div class="line">        BOOL rowIsComplete = YES;</div><div class="line">        NSMutableArray *dropsFound = [[NSMutableArray alloc] init];</div><div class="line"></div><div class="line">        for (CGFloat x = DROP_SIZE.width/2; x &lt; self.gameView.bounds.size.width - DROP_SIZE.width/2; x+=DROP_SIZE.width) &#123;</div><div class="line">            </div><div class="line">            //移动(x,y)获取这个点所在的view</div><div class="line">            UIView *hitView = [self.gameView hitTest:CGPointMake(x, y) withEvent:NULL];</div><div class="line"></div><div class="line">            if ([hitView superview] == self.gameView) &#123;</div><div class="line">               </div><div class="line">                //如果获取的view的父视图是gameView,就说明它是方块</div><div class="line">                [dropsFound addObject:hitView];</div><div class="line">                </div><div class="line">            &#125;else&#123;</div><div class="line"></div><div class="line">                //否则这个行肯定是不完整的</div><div class="line">                rowIsComplete = NO;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (![dropsFound count]) break;</div><div class="line">        if (rowIsComplete)[dropsToRemove addObjectsFromArray:dropsFound];</div><div class="line">  </div><div class="line">    &#125;    </div><div class="line"></div><div class="line">    //如果有排满的行，则炸掉它</div><div class="line">    if ([dropsToRemove count])&#123;</div><div class="line">        for (UIView *drop in dropsToRemove)&#123;</div><div class="line">            [self.dropitBehavior removeItem:drop];</div><div class="line">        &#125;</div><div class="line">        [self animatedRemovingDrops:dropsToRemove];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  炸飞整行</div><div class="line"> *</div><div class="line"> *  @param dropsToRemove 需要炸飞的View的数组</div><div class="line"> */</div><div class="line"></div><div class="line">- (void)animatedRemovingDrops:(NSArray *)dropsToRemove</div><div class="line">&#123;</div><div class="line">    [UIView animateWithDuration:0.5 animations:^&#123;</div><div class="line">        </div><div class="line">        for (UIView *drop in dropsToRemove) &#123;</div><div class="line">           </div><div class="line">            //设定炸飞后终点的位置</div><div class="line">            int x = (arc4random()%(int)(self.gameView.bounds.size.width*5)) - (int)self.gameView.bounds.size.width*2;</div><div class="line">            int y = self.gameView.bounds.size.height;</div><div class="line">            drop.center = CGPointMake(x,-y);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line"></div><div class="line">        [dropsToRemove makeObjectsPerformSelector:@selector(removeFromSuperview)];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="思考一下"><a href="#思考一下" class="headerlink" title="思考一下"></a>思考一下</h1><hr>
<p>关于通过给view添加物理效果的方法添加动画，需要弄清楚<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">通过对代码的分析以及讲师的讲解，笔者将这三者以比喻的方法将他们的关系梳理了一下：</div><div class="line"></div><div class="line">- ```DynamicAnimator```:代表了一个游乐场。</div><div class="line">- ```UIDynamicBehavior```：代表了游乐场里的娱乐设施。</div><div class="line">- 遵守&lt;UIDynamicItem&gt;协议的item：代表了去游乐场玩儿的小孩。</div><div class="line"></div><div class="line">我们从代码看一下如何映射他们的关系：</div><div class="line"></div><div class="line">#### DynamicAnimator</div></pre></td></tr></table></figure></p>
<p>UIDynamicAnimator *animator =[ [ UIDynamicAnimator alloc] initWithReferenceView:aView];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在这里，```aView```代表了一片空地，这句话的意思是我们把游乐场建在了这片空地上。</div><div class="line"></div><div class="line">#### UIDynamicBehavior</div></pre></td></tr></table></figure></p>
<p> [self.animator addBehavior:_dropitBehavior];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在这里，代表了我们在这个游乐场里增加了某个娱乐设施。</div><div class="line"></div><div class="line">#### 遵守&lt;UIDynamicItem&gt;协议的item</div></pre></td></tr></table></figure></p>
<ul>
<li>(void)addItem:(id<uidynamicitem>)item<br>{<br>  [self.gravity addItem:item];<br>  [self.collider addItem:item];<br>}<br>```<br>在这里，代表了我们让某个小孩来玩儿某个娱乐设施。</uidynamicitem></li>
</ul>
<p>这样就理清了：我们要让一个小孩玩儿一个娱乐设施就应该:</p>
<ol>
<li>找一片空地建设游乐场。</li>
<li>在游乐场引进娱乐设备。</li>
<li>孩子来玩儿这个娱乐设备。</li>
</ol>
<p>笔者在开始看到这三者的相关代码的时候略懵逼，不知道为什么会这么设计，但是用了“比喻法”之后，顿时豁然开朗了~</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（七）：自定义视图，手势识别，绘制纸牌Demo/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Knight_SJ">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Knight_SJ">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="Knight_SJ" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/01/11/斯坦福大学iOS开发公开课总结（七）：自定义视图，手势识别，绘制纸牌Demo/" itemprop="url">
                  斯坦福大学iOS开发公开课总结（七）：自定义视图，手势识别，绘制纸牌Demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-11T15:16:20+08:00">
                2017-01-11
              </time>
            

            

            
          </span>

          

          
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本节课介绍了UIView的一些知识，自定义UIView的方法以及手势识别。最后应用本节所讲的大部分知识点向我们演示了一个绘制纸牌的Demo。</p>
<h1 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h1><hr>
<h2 id="关于UIView，你需要知道的零散知识"><a href="#关于UIView，你需要知道的零散知识" class="headerlink" title="关于UIView，你需要知道的零散知识"></a>关于UIView，你需要知道的零散知识</h2><ul>
<li>视图是可以多层嵌套的。</li>
<li>每个视图可以有多个子视图，但是只能有一个父视图。</li>
<li>控制器的view属性指向自己的顶级视图。</li>
<li>令视图透明会加大系统的开销。</li>
<li>通过判断控制器view的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## UIView的一些属性和方法</div></pre></td></tr></table></figure></li>
</ul>
<p>@property CGFloat contentScaleFactor; //返回每个点所有的像素数 ：非retina为1，retina为2</p>
<ul>
<li>(UIView *)superView; //指向自己的父视图</li>
<li><p>(NSArray *)subview; //自己的所有子视图的数组</p>
</li>
<li><p>(void)addSubview: (Uiview *)aView;// 发送给目标父视图，让其把aView作为自己的子视图</p>
</li>
<li><p>(void)removeFromSuperview;  //消息发送给要移除的vie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## View的初始化方法：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)awakeFromNib {[self setup];}  //通过故事版创建的View的初始化</p>
</li>
<li><p>(id)initWithFrame: (CGRect)aRect    //通过纯代码创建的View的初始化<br>{<br>   self = [super initWithFrame:aRect];<br>   [self setup];<br>   return self;<br>}</p>
</li>
<li><p>(void)setup {….};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## Custom View 自定义视图</div><div class="line"></div><div class="line">在iOS中，自定义是图的方法是创建一个UIView的子类并重写 ```- (void)drawInRect:(Rect)rect```方法。</div><div class="line">&gt; 注意：永远都不要自己调用这个方法，要交给系统负责！</div><div class="line">&gt;可以调用以下的方法，告诉系统这个视图要被重绘：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setNeedsDisplay;</p>
</li>
<li><p>(void)setNeedsDisplayInRect: (CGRect)aRect  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">那么具体怎样重写 ```- (void)drawInRect:(Rect)rect```方法来绘图呢？</div><div class="line">答：应用Core Graphics的相关知识。</div><div class="line"></div><div class="line">## Core Graphics</div><div class="line"></div><div class="line">Core Graphics是一套基于C的API框架，使用了Quartz作为绘图引擎，使用Core Graphics，可以创建直线、路径、渐变、文字与图像等内容，并可以做变形处理。</div><div class="line"></div><div class="line">### Core Grephics的工作步骤：</div><div class="line">1. 取得图形上下文。</div><div class="line">2. 设置绘图路径(利用UIBezierPath)。</div><div class="line">3. 设置颜色。</div><div class="line">4. 用颜色填充路径 。</div><div class="line"></div><div class="line">各位看官不用着急，具体方法在最后的Demo代码里给大家呈现。</div><div class="line"></div><div class="line"># UIGestureRecoginizer ：手势识别抽象类</div><div class="line">-----</div><div class="line"></div><div class="line">**简单介绍**：```UIGestureRecoginizer```是一个抽象类，它的各种子类可以用于识别各种不同的手势：如捏合，滑动等等。通过识别各种不同的手势，实现各种交互操作。</div><div class="line"></div><div class="line">## 使用步骤</div><div class="line">1. 在视图中添加手势识别对象。</div><div class="line">2. 提供手势发生时所需要调用的方法。</div><div class="line"></div><div class="line">## 手势种类：</div><div class="line"></div><div class="line">**1. UIPanGestureRecognizer ： 拖动手势**</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setPannableView:(UIView<em>)pannableView<br>{<br>   _pannableView = pananbleView;<br>   UIPanGestureRecognizer </em>pangr = [UIPanGestureRecognizer alloc] initWithTarget:pannableView action: @selector(pan:)];<br>   [pannableView addGestureRecognnizer:panr];<br>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**2. UIPinchGestureReccognizer ：捏合手势**</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@property CGFloat scale;   捏合手势距离<br>@property (readonly) CGFloat velocity; 每分钟变化的速度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**3. UIRotationGestureRecgnizer 旋转手势**</div></pre></td></tr></table></figure></p>
<p>@property CGFloat rotation;   弧度<br>@property (readonly) CGFloat velocity; 每秒变化的速度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**4. UISwipeGestureRecgnizer ： 滑动手势**</div></pre></td></tr></table></figure></p>
<p>@property UISwipeGestureRecognizerDirection direction 滑动方向<br>@property NSUInteger numberOfTouchesRequired; 几只手指来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**5. UITapGestureRecognizer ：点击手势**</div></pre></td></tr></table></figure></p>
<p>@property NSUInteger numberOfTapsReqired；几次点击<br>@property NSUInteger numberOfTouchesRequired;     几只手指来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;以上第4，5项手势是非连续手势；1，2，3属于连续手势。</div><div class="line">&gt;注意区分滑动手势和拖动手势。滑动手势是指短促，快速地滑动的手势，而拖动手势是相对较慢，路径较长的手势。</div><div class="line"></div><div class="line"># 绘制纸牌Demo</div><div class="line">-----</div><div class="line"></div><div class="line">## Demo需求</div><div class="line">- 绘制一张纸拍放到屏幕上，包括正面和背面。</div><div class="line">- 滑动手势可以翻牌。</div><div class="line">- 捏合手势可以伸缩纸牌正面的图案大小。</div><div class="line"></div><div class="line">## Demo效果图</div><div class="line"></div><div class="line"></div><div class="line">![左二图：翻牌 | 右二图：伸缩](http://upload-images.jianshu.io/upload_images/859001-aedaf67a6c46a092.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line">## 重要代码段</div><div class="line"></div><div class="line">#### 1. 绘制纸牌正反面</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)drawRect:(CGRect)rect {</p>
<p>  //初始化一个圆角矩形<br>  UIBezierPath *roundRect = [UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:[self cornerRadius]];</p>
<p>  //裁剪，保证不会绘制四角<br>  [roundRect addClip];</p>
<p>  //填充白色<br>  [[UIColor whiteColor] setFill];<br>   UIRectFill(self.bounds);</p>
<p>  //轮廓<br>  [[UIColor blackColor] setStroke];<br>  [roundRect stroke];</p>
<p>  if (self.faceUp) {</p>
<pre><code>//1. 纸牌正面
//1.1 纸牌正面中间的图
UIImage *faceImage = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%@%@&quot;,[self rankAsString],self.suit]];

if (faceImage) {

    CGRect imageRect = CGRectInset(self.bounds, self.bounds.size.width * (1.0 - self.faceCardScaleFactor) + 20, self.bounds.size.height * ( 1.0 - self.faceCardScaleFactor  ) + 20);
    [faceImage drawInRect:imageRect];
}

//1.2 纸牌正面四个角
[self drawCorners];
</code></pre><p>  }else{</p>
<pre><code>//2. 纸牌背面
[[UIImage imageNamed:@&quot;cardBack&quot;] drawInRect:self.bounds];
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2. 绘制纸牌边角的花色和数字</div></pre></td></tr></table></figure>
</li>
<li><p>(void)drawCorners<br>{<br>  //设定段落排列<br>  NSMutableParagraphStyle *paragraphStype = [[NSMutableParagraphStyle alloc] init];<br>  paragraphStype.alignment = NSTextAlignmentCenter;</p>
<p> //设定字体<br>  UIFont <em>cornerFont = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];<br>  cornerFont = [cornerFont fontWithSize:cornerFont.pointSize </em> [self cornerScaleFactor]]; </p>
<p>  //角落文字<br>  NSAttributedString *cornerText = [[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@”%@\n%@”, [self rankAsString], self.suit] attributes:@{NSFontAttributeName:cornerFont,NSParagraphStyleAttributeName:paragraphStype}];</p>
<p>  //左上角<br>  //1. 获得图片的rect<br>  CGRect textBounds;<br>  textBounds.origin = CGPointMake([self cornerOffset], [self cornerOffset]);<br>  textBounds.size = [cornerText size];</p>
<p>   //2.绘制文字<br>  [cornerText drawInRect:textBounds];</p>
<p>  //右下角<br>  //1. 获取上下文<br>  CGContextRef context = UIGraphicsGetCurrentContext();<br>  // 2. 移动上下文<br>  CGContextTranslateCTM(context, self.bounds.size.width, self.bounds.size.height);<br>   //3. 翻转上下文（翻转180度）<br>  CGContextRotateCTM(context, M_PI);<br>   //4. 绘制<br>  [cornerText drawInRect:textBounds];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;我们可以看到，图片和文字的绘图方法都是可以通过```drawInRect:```方法来进行：通过传入需要绘制的```rect```，可以让系统根据原始的素材（图片，文字）来绘图。</div><div class="line"></div><div class="line">#### 3. 添加手势：连线方式</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>滑动手势翻转牌<br>*</li>
<li>@param sender 滑动手势<br>*/</li>
</ul>
<ul>
<li><p>(IBAction)swipe:(id)sender {</p>
<p> //翻转牌面<br>  self.playCardView.faceUp  = !self.playCardView.faceUp;</p>
</li>
</ul>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 4. 添加手势：代码方式</div></pre></td></tr></table></figure></p>
<p>//1. 添加捏合手势<br> [self.playCardView addGestureRecognizer:[[UIPinchGestureRecognizer alloc] initWithTarget:self.playCardView<br>                                                                                    action:@selector(pinch:)]];</p>
<p>/**</p>
<ul>
<li><ol>
<li>捏合手势调用的方法<br>*</li>
</ol>
</li>
<li>@param gesture 捏合手势<br>*/</li>
</ul>
<ul>
<li><p>(void)pinch:(UIPinchGestureRecognizer *)gesture<br>{<br>  if (gesture.state == UIGestureRecognizerStateChanged || gesture.state == UIGestureRecognizerStateEnded) {</p>
<pre><code>//根据捏合的程度来伸缩图片
 self.faceCardScaleFactor *= gesture.scale;
 gesture.scale = 1.0;
</code></pre><p>  }<br>}<br>```</p>
</li>
</ul>
<blockquote>
<p>在手势识别调用的方法里，我们需要对手势本身的状态加以判断以确保各种交互的实现都是正确的。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://oih3a9o4n.bkt.clouddn.com/kightsjavatar.jpeg"
               alt="Knight_SJ" />
          <p class="site-author-name" itemprop="name">Knight_SJ</p>
          <p class="site-description motion-element" itemprop="description">在学hybrid开发的iOS开发者</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">Artikel</span>
            </a>
          </div>

          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Knight_SJ</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	




  
  

  

  

  

  


</body>
</html>

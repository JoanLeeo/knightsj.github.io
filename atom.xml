<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Knight_SJ</title>
  <subtitle>iOS开发|上海</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/knightsj/knightsj.github.io/"/>
  <updated>2017-01-11T07:22:53.000Z</updated>
  <id>https://github.com/knightsj/knightsj.github.io/</id>
  
  <author>
    <name>Knight_SJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%BA%8C%20%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9ACore-Data,%E8%A1%A8%E6%A0%BC%E8%A7%86%E5%9B%BE%EF%BC%8CFlickr%E6%91%84%E5%BD%B1%E5%B8%88%E8%B5%84%E6%96%99%E5%88%97%E8%A1%A8/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十二 十三）：Core-Data,表格视图，Flickr摄影师资料列表/</id>
    <published>2017-01-11T07:21:28.000Z</published>
    <updated>2017-01-11T07:22:53.000Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>title: 斯坦福大学iOS开发公开课总结（十二 十三）：Core-Data,表格视图，Flickr摄影师资料列表Demo</p>
<h2 id="tags-iOS-Objective-C"><a href="#tags-iOS-Objective-C" class="headerlink" title="tags: [iOS,Objective-C]"></a>tags: [iOS,Objective-C]</h2><p>第十二课和第十三课都介绍了CoreData的知识，并在十三课的中段通过一个Demo来具体实现了CoreData的操作。</p>
<p>笔者之前从未接触过Core Data的相关知识，因此学期这两节课比较吃力，这一篇总结还是有很多需要改进的地方，以后随着对Core Data认识的深入和对这两节课的反复咀嚼，会不断更新该总结。</p>
<p>开始吧！</p>
<h1 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h1><hr>
<p>Core Data是一种持久化技术，它能将模型对象的状态持久化到磁盘，但它最重要的特点是：Core Data不仅是一个加载、保存数据的框架，它还能和内存中的数据很好的共事。</p>
<p>排除错误认识：Core Data<strong>并不是数据库!</strong> 它只是连接类（Class）和数据库（SQL）的桥梁。通过Core Data的相关功能，我们可以对数据库进行增删改查的操作。</p>
<h2 id="CoreData是如何工作的呢？"><a href="#CoreData是如何工作的呢？" class="headerlink" title="CoreData是如何工作的呢？"></a>CoreData是如何工作的呢？</h2><h3 id="1-创建对象的可视化映射"><a href="#1-创建对象的可视化映射" class="headerlink" title="1. 创建对象的可视化映射"></a>1. 创建对象的可视化映射</h3><p>在看到可视化映射之前，需要了解<strong>实体</strong>的概念：</p>
<blockquote>
<p><strong>实体的概念</strong>：每个实体是一个表，每个表对应一个对象。<br>简单粗暴的理解：实体在数据库领域叫做表，在面向对象领域叫做对象。</p>
<p><strong>实体之间的关系</strong>=表之间创建关系，对象之间的关系。</p>
</blockquote>
<p><strong>注意</strong>：两个对象之间的关系在两个对象端具有不同的名称。而且关系的对应数量也是不同的：<figure class="highlight plain"><figcaption><span>one```,``` to many```。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;举个🌰 ：摄影者和照片的关系：</div><div class="line">摄影者对应多个照片，但是照片只对应一个摄影者。</div><div class="line"></div><div class="line">那么言归正传，如何创建对象的可视化映射呢？</div><div class="line">1. 创建模型文件，用来装入各种需要映射的实体。</div><div class="line">2.  在模型内部添加实体（Entity），创建实体之间的关系（必要时）。</div><div class="line"></div><div class="line">下面笔者录制了创建实体，增加实体属性，连接实体的操作：</div><div class="line"></div><div class="line"></div><div class="line">![创建实体，增加属性](http://upload-images.jianshu.io/upload_images/859001-ca646fa9e1e18f5a.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line"></div><div class="line">### 2. 为实体创建NSManagedObjectd子类</div><div class="line"></div><div class="line">我们需要将刚得到的可视化的实体“转变为”具体的类。在Core Data中，这些类都是NSManagedObjectd子类。</div><div class="line"></div><div class="line">下面演示一下其创建过程：</div><div class="line"></div><div class="line">![创建NSManagedObjectd子类](http://upload-images.jianshu.io/upload_images/859001-2eab784599ea6776.gif?imageMogr2/auto-orient/strip)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">以实体```Photo```为例，系统为我们生成了```Photo.h```和```Photo.m```。</div><div class="line"></div><div class="line">我们先看一下```Photo.h```:</div></pre></td></tr></table></figure></p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>#import <coredata coredata.h=""></coredata></p>
<p>NS_ASSUME_NONNULL_BEGIN<br>@interface Photo : NSManagedObject<br>// Insert code here to declare functionality of your managed object subclass<br>@end<br>NS_ASSUME_NONNULL_END</p>
<p>#import “Photo+CoreDataProperties.h”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">&gt;我们可以看到，```Photo```类继承了```NSManagedObject```。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">但是，有意思的是，系统还为我们自动生成了```Photo+CoreDataProperties.h```和```Photo+CoreDataProperties.m```，详情见动图左侧，创建实体类之后。</div><div class="line"></div><div class="line"></div><div class="line">**思考**：</div><div class="line">生成这两个文件的目的是什么呢？</div><div class="line">首先，我们首先要知道这两个文件是什么：</div><div class="line">他们构成了```Photo```类的分类(Category)。</div><div class="line"></div><div class="line">那么什么是分类呢？</div><div class="line">通过分类，我们可以向原有的类添加方法，而不需要通过继承的方式。分类的局限是：在分类里不能再添加属性。</div><div class="line"></div><div class="line">那么显然，通过````Photo+CoreDataProperties```，我们就可以不用继承```Photo```类来给其添加方法。因为原有的```Photo```类只具有属性，除了获取属性之外，并不能为我们做其他的事情。这时，如果可以在其他的地方给其无限地添加方法还是很具有诱惑力的。令人欣慰的是，系统可以自动为我们生成。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### 3. 通过创建NSManagedObjectContext访问，操作数据库</div><div class="line">数据库创建对象，设置对象属性，查询对象都需要```NSManagedObjectContext```。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">创建```NSManagedObjectContext```的两个不同的方法：</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">1.通过其自身的初始化：</div></pre></td></tr></table></figure></p>
<p>[NSManagedObjectContext alloc] init];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">2.通过UIManagedDocument创建：</div><div class="line"></div><div class="line">UIManagedDocument 用于管理存储的机制，将Core Data数据库放入某存储空间。</div></pre></td></tr></table></figure></p>
<p>UIManagedDocument *document = [[UIManagedDocument alloc] initWithFileURL:url];<br>//url:这个core data 数据库存储的地方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 数据库的操作：</div><div class="line"></div><div class="line">#### 1. 向数据库添加对象（实体）：</div></pre></td></tr></table></figure></p>
<p>[NSEntityDescription insertNewObjectForEntityForName:@”Photo” inManagedObjectContext:context];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 2. 从数据库删除对象（实体）：</div></pre></td></tr></table></figure></p>
<p>[aDocument.managedObjectContext deleteObject:photo];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">删除对象后，系统会向所有对象发送这个消息</div></pre></td></tr></table></figure></p>
<ul>
<li>(void)prepareForDeletion{<br>//在这里保持数据同步，比如删掉这个对象的时候会影响到其他对象的数据<br>//应该在这个对象被删除前及时更新那个数据<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3. 在数据库查询对象（实体）：</div><div class="line"></div><div class="line"></div><div class="line">我们使用```NSFetchRequest```类查询数据库的对象，通过设置其不同属性来查找符合不同标准的数据：</div><div class="line"></div><div class="line">举个🌰 ：查找出100个photo的实体：</div></pre></td></tr></table></figure>
<p>NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@”Photo”];<br>request.fetchLimit = 100;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 关于Core data的线程安全</div></pre></td></tr></table></figure></p>
<p>//让context在安全队列中执行的方法<br>[context performBlock:^{<br>    [A doSomething];<br>}];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># NSFetchedResultsController</div><div class="line"></div><div class="line">------</div><div class="line"></div><div class="line"></div><div class="line">NSFetchedResultsController的作用是将NSFetchRequest 和 UITalbleView联系到一起。</div><div class="line">和TableView的数据源方法类似：</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(NSInteger)numberOfRowsInSection:(NSInteger)section{<br>return [[self.fetchedResultsController sections] count];<br>}</p>
</li>
<li><p>(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{<br> return [[self.fetchedResultsController sections] count] objectAtIndex:section] numberOfObjects];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">详细的使用方法会在Demo讲解部分中告诉大家。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"># Demo</div><div class="line"></div><div class="line">-----</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## Demo需求</div><div class="line"></div><div class="line">- 每隔20分钟，从flickr拿回最新的摄影者数据。</div><div class="line">- 用一个TableView显示当前拿回的摄影者的名字和所照的照片数。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## Demo效果图</div><div class="line"></div><div class="line"></div><div class="line">![摄影师的信息列表](http://upload-images.jianshu.io/upload_images/859001-72dc6873f1c13917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 重要代码段</div><div class="line"></div><div class="line">#### 1. 在启动接口获取flickr的数组</div></pre></td></tr></table></figure>
</li>
<li><p>(BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions {<br>   self.photoDatabaseContext = [self createMainQueueManagedObjectContext];<br>   [self startFlickrFetch];<br>   return YES;<br>}</p>
</li>
<li><p>(void)startFlickrFetch<br>{<br>  [self.flickrDownloadSession getTasksWithCompletionHandler:^(NSArray <em>dataTasks, NSArray </em>uploadTasks, NSArray *downloadTasks) {</p>
<pre><code>if (![downloadTasks count]) {
    NSURLSessionDownloadTask *task = [self.flickrDownloadSession downloadTaskWithURL:[FlickrFetcher URLforRecentGeoreferencedPhotos]];
    task.taskDescription = FLICKR_FETCH;
    [task resume];
} else {
    for (NSURLSessionDownloadTask *task in downloadTasks) [task resume];
}
</code></pre><p>  }];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 2. 每隔20分钟获取新的内容</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setPhotoDatabaseContext:(NSManagedObjectContext *)photoDatabaseContext<br>{<br>  _photoDatabaseContext = photoDatabaseContext;</p>
<p>  //photoDatabaseContext设定成功后，每隔20分钟重新获取信息<br>  if (self.photoDatabaseContext)<br>  {</p>
<pre><code>self.flickrForegroundFetchTimer = [NSTimer scheduledTimerWithTimeInterval:FOREGROUND_FLICKR_FETCH_INTERVAL
                                                                   target:self
                                                                 selector:@selector(startFlickrFetch:)
                                                                 userInfo:nil
                                                                  repeats:YES];
</code></pre><p>  }</p>
<p>  //photoDatabaseContext设定成功后 向控制器发送消息<br>  NSDictionary *userInfo = self.photoDatabaseContext ? @{ PhotoDatabaseAvailabilityContext : self.photoDatabaseContext } : nil;<br>  [[NSNotificationCenter defaultCenter] postNotificationName:PhotoDatabaseAvailabilityNotification</p>
<pre><code>  object:self
userInfo:userInfo];
</code></pre><p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 3. 在表格视图查询所有摄影师的名字</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setManagedObjectContext:(NSManagedObjectContext *)managedObjectContext<br>{<br>  //哪个数据库<br>  _managedObjectContext = managedObjectContext;</p>
<p>  NSFetchRequest *requet = [NSFetchRequest fetchRequestWithEntityName:@”Photographer”];<br>  requet.predicate = nil;//所有的,无过滤<br>  requet.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@”name” ascending:YES selector:@selector(localizedStandardCompare:)]];</p>
<p>  self.fetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:requet managedObjectContext:managedObjectContext sectionNameKeyPath:nil cacheName:nil];</p>
</li>
</ul>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 4. 重写```tablelViwe:cellForRowAtIndex:```方法，显示摄影师数据</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath<br>{<br>  UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:@”Photographer cell”];</p>
<p>  //拿到摄影师的名字和摄影数量<br>  Photographer *photographer = [self.fetchedResultsController objectAtIndexPath:indexPath];<br>  cell.textLabel.text = photographer.name;<br>  cell.detailTextLabel.text = [NSString stringWithFormat:@”%lu photos”, [photographer.photos count]];<br>  return cell;</p>
</li>
</ul>
<p>}<br>```  </p>
<p>本Demo显然是一个未完成品，它只显示了摄影师的相关信息，并且只有一个页面。在接下来的课程中应该会对该Demo进行更多过的扩展。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title: 斯坦福大学iOS开发公开课总结（十二 十三）：Core-Data,表格视图，Flickr摄影师资料列表Demo&lt;/p&gt;
&lt;h2 id=&quot;tags-iOS-Objective-C&quot;&gt;&lt;a href=&quot;#tags-iOS-Objective-C&quot; cla
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E8%A1%A8%E6%A0%BC%E8%A7%86%E5%9B%BE%EF%BC%8CFlickr-%E7%85%A7%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo/</id>
    <published>2017-01-11T07:20:18.000Z</published>
    <updated>2017-01-11T07:20:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UITableview"><a href="#UITableview" class="headerlink" title="UITableview"></a>UITableview</h1><hr>
<p>UITableview是iOS软件中最常见的视图，用来以表格的形式显示数据。</p>
<h2 id="数据源方法"><a href="#数据源方法" class="headerlink" title="数据源方法"></a>数据源方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section;//表格的总section数，默认为返回1，可以不实现</div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; //返回当前section的行数，必须实现</div><div class="line">- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; //返回某section某row的cell，必须实现</div></pre></td></tr></table></figure>
<h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//cell被点击是调用的方法</div></pre></td></tr></table></figure>
<h2 id="根据cell获得对应的indexPath"><a href="#根据cell获得对应的indexPath" class="headerlink" title="根据cell获得对应的indexPath"></a>根据cell获得对应的indexPath</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> NSIndexPath *indexPath = [self.tableView  indexPathForCell :sender];</div></pre></td></tr></table></figure>
<h2 id="UITableView-Spinner"><a href="#UITableView-Spinner" class="headerlink" title="UITableView Spinner"></a>UITableView Spinner</h2><p>顶部加载时显示的小圆圈动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl;</div><div class="line"></div><div class="line">- (void)beginRefreshing;</div><div class="line">- (void)endRefreshing;</div></pre></td></tr></table></figure></p>
<h2 id="模型改变，刷新表格"><a href="#模型改变，刷新表格" class="headerlink" title="模型改变，刷新表格"></a>模型改变，刷新表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)reloadData; //刷新全部表格：一般在模型大部分变化的时候才调用，在某个数据变化时不推荐使用</div><div class="line"></div><div class="line">- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//只刷新某一个cell，在某行货少数行数据变化时推荐使用</div></pre></td></tr></table></figure>
<h1 id="Universal-Application"><a href="#Universal-Application" class="headerlink" title="Universal Application"></a>Universal Application</h1><hr>
<p>Universal Application通用应用是指既可以在iPhone上运行，也可以在iPad上运行的应用，它有两个故事版文件，一个是针对iphone的，另一个是针对ipad的。</p>
<p>iPad有两种独有的视图：</p>
<ol>
<li>Split View：拆分视图</li>
<li>Popover:弹窗</li>
</ol>
<p>识别是否是ipad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL iPad  = ([&#123;UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad)</div></pre></td></tr></table></figure></p>
<h1 id="UISplitViewController"><a href="#UISplitViewController" class="headerlink" title="UISplitViewController"></a>UISplitViewController</h1><hr>
<h2 id="UISplitViewController包括"><a href="#UISplitViewController包括" class="headerlink" title="UISplitViewController包括"></a>UISplitViewController包括</h2><ul>
<li>Master View Controller</li>
<li>Detail View Controller</li>
</ul>
<p>UISplitViewController是storyboard的最顶层，不能被加入到UIViewController里面</p>
<h2 id="获得SplitViewController："><a href="#获得SplitViewController：" class="headerlink" title="获得SplitViewController："></a>获得SplitViewController：</h2><p>返回当前UIViewcontroller所在的SplitViewController:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIViewController.h</div><div class="line"></div><div class="line">@property (strong) UISplitViewController  *splitViewController;</div></pre></td></tr></table></figure></p>
<h2 id="获得SplitViewController的master和detail："><a href="#获得SplitViewController的master和detail：" class="headerlink" title="获得SplitViewController的master和detail："></a>获得SplitViewController的master和detail：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (copy) NSArray *viewControllers;//0：master;1: detail</div></pre></td></tr></table></figure>
<h2 id="UISplitViewControllerDelegate"><a href="#UISplitViewControllerDelegate" class="headerlink" title="UISplitViewControllerDelegate"></a>UISplitViewControllerDelegate</h2><p>在awakeFromNib设置此代理,代理负责 控制master和detail何时出现</p>
<p>代理的几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)splitViewController:(UISplitViewController *)svc shouldHideViewController:(UIViewController *)vc inOrientation:(UIInterfaceOrientation)orientation&#123;</div><div class="line">           return NO; //永远不隐藏master，master和detail将一直在屏幕上显示，无论是横屏或竖屏 </div><div class="line">           return UIInterfaceOrientationIsPortrait(orientation);//竖屏不显示master 但是竖屏时左上角有按键可以显示master，但是</div><div class="line">不实现这个代理就不能出现按钮了。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在横屏或竖屏是否该隐藏master</p>
<h1 id="Popovers"><a href="#Popovers" class="headerlink" title="Popovers"></a>Popovers</h1><hr>
<p>Popover是弹窗控件，它的作用是控制另一个视图控制器弹出到屏幕上，也是ipad独有的控件。<br>因为ipad的面积比较大，所以有时可以只以弹窗的形式提供信息而不用跳转到下一页面。</p>
<p>注意：这个控件并没有继承UIViewController，是一个NSObject</p>
<h2 id="Popover的Segue是"><a href="#Popover的Segue是" class="headerlink" title="Popover的Segue是"></a>Popover的Segue是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在Popover出现之前：</div></pre></td></tr></table></figure></h2><ul>
<li><p>(void)prepareForSegue: (UIStoryboardSegue *)segue sender: (id)sender<br>{<br>  if([segue isKindOfClass:[UIStroyboardPopoverSegue class]]){</p>
<pre><code>UIPopoverController *popoverController = ((UIStroyboardPopoverSegue *)segue.)popoverController;
</code></pre><p>   }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 使Popover消失：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)dismissPopoverAnimated:(BOOL)animated;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">默认情况下，点击外部任何的地方都能使它消失，除非我们给它指定即使点击也不会消失的```UIVIew```。</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@property (copy) NSArray *passthroughViews;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># Demo</div><div class="line">-----------------</div><div class="line"></div><div class="line">该Demo是同时适用iPad 和iPhone的，可惜笔者没有iPad，无法调试，于是只适配了iPhone，以后有机会会补上适配iPad的代码的。</div><div class="line"></div><div class="line">## Demo需求</div><div class="line">- 第一个页面用表格显示从Flickr抓取的图片数据，只显示图片名和图片详情。</div><div class="line">- 点击第一个页面的cell，跳转到图片详情页。</div><div class="line">- 图片详情页显示具体的大图，可以伸缩，可以移动。</div><div class="line"></div><div class="line">## 效果图</div><div class="line"></div><div class="line">![效果图](http://upload-images.jianshu.io/upload_images/859001-b0a8e98131ae59b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">## 重要代码段</div><div class="line"></div><div class="line">#### 1. 获取Flickr上的数据</div><div class="line"></div><div class="line">Flickr提供了公共的接口提供了自家的照片，接口文件在本Demo里的```Flickr Fetcher```文件里，唯一注意的是需要申请```APIKEY```,[申请网址]([http://www.flickr.com/services/api/misc.api_keys.html](http://www.flickr.com/services/api/misc.api_keys.html))。</div><div class="line"></div><div class="line">解析照片数据的过程是比较耗时的，所以需要分配到子线程来进行。获得数组后，在主线程将数组赋予当前类的属性里。</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)fetchPhotos<br>{<br>  self.photos = nil;<br>  NSURL *url = [FlickrFetcher URLforRecentGeoreferencedPhotos];</p>
<p>  //手动创建一个子线程<br>  dispatch_queue_t fetchQ = dispatch_queue_create(“flickr fetcher”, NULL);</p>
<p>  dispatch_async(fetchQ, ^{</p>
<pre><code>//获得json数据，比较耗时
NSData *jsonResults = [NSData dataWithContentsOfURL:url];

//获得字典
NSDictionary *propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:NULL];
NSArray *photos = [propertyListResults valueForKeyPath:FLICKR_RESULTS_PHOTOS];

dispatch_async(dispatch_get_main_queue(), ^{

   //回到主线程     
    self.photos = photos;

});    
</code></pre><p>  });<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;NULL是C指针，代表指向OC指针的指针没有指向任何对象</div><div class="line"></div><div class="line">什么是指向OC指针的指针？：&amp;error是指向error的指针</div><div class="line">如果我们这样写，就可以获得error：</div></pre></td></tr></table></figure>
<p> NSError <em>error = nil;<br> NSDictionary </em>propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:&amp;error];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果我们不关心error，就可以传NULL。</div><div class="line"></div><div class="line">好了，现在我们获得了数据，需要刷新表格：</div><div class="line"></div><div class="line">#### 2. 刷新表格</div></pre></td></tr></table></figure>
<ul>
<li>(void)setPhotos:(NSArray *)photos<br>{<br>  _photos = photos;<br>  [self.tableView reloadData];<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">只是刷新表格是不够的，还要实现```UITableView```的数据源方法来告诉```TableView```如何显示数据。（调用```reload```方法后会调用这些数据源方法）</div><div class="line"></div><div class="line">#### 3. 实现数据源方法</div></pre></td></tr></table></figure>
</li>
</ul>
<p>#pragma mark - Table view data source</p>
<ul>
<li><p>(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {<br>  //只有一组<br>   return 1;<br>}</p>
</li>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {<br> //行数为图片的个数<br>  return self.photos.count;<br>}</p>
</li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {</p>
<p>  //从重用池中拿到cell<br>  UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@”Flickr Photo Cell” forIndexPath:indexPath];</p>
<p>  //通过indexPath来获得在数据里对应的图片数据<br>  NSDictionary *photoDict = self.photos[indexPath.row];<br>  //设置主标题和副标题</p>
<p>  cell.textLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_TITLE];</p>
<p>  cell.detailTextLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_DESCRIPTION];    </p>
<p>  return cell;</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### 4. 点击cell，实现跳转</div></pre></td></tr></table></figure>
<p>#pragma mark - Navigation</p>
<p>// In a storyboard-based application, you will often want to do a little preparation before navigation</p>
<ul>
<li><p>(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {</p>
<p>  if ([sender isKindOfClass:[UITableViewCell class]]) {</p>
<pre><code>NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];    

if (indexPath) {

    if ([segue.destinationViewController isKindOfClass:[ImageViewController class]]) {

        [self prepareImageViewController:segue.destinationViewController toDisplayPhoto:self.photos[indexPath.row]];                

    }
}
</code></pre><p>  }<br>}</p>
</li>
<li><p>(void)prepareImageViewController:(ImageViewController <em>)ivc toDisplayPhoto:(NSDictionary</em>)photo<br>{</p>
<p> //获得图像的URL传给ImageViewController<br>  ivc.imageURL = [FlickrFetcher URLforPhoto:photo format:FlickrPhotoFormatLarge];<br> //导航栏的标题为图片的名字<br>  ivc.title = [photo valueForKey:FLICKR_PHOTO_TITLE];</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;这里的```ImageViewController```复用了[斯坦福大学iOS开发公开课总结（十） ：多线程，UIScrollView，图片浏览器Demo](http://www.jianshu.com/p/ddb4f528b334)里第二个页面。</div><div class="line"></div><div class="line">#### 5. 优化</div><div class="line">每次跳转到图片详情页，将图片的原点设置在最左上端，并且大小恢复到该图片的原始大小</div></pre></td></tr></table></figure>
<ul>
<li><p>(void)setImage:(UIImage *)image<br>{</p>
<p>  //重置缩放大小为1<br>  self.scrollView.zoomScale = 1.0;<br>  self.imageView.image = image;<br>  [self.imageView sizeToFit];</p>
<p>  //将视图框的原点设在左上角<br>  self.imageView.frame = CGRectMake(0, 0, self.image.size.width, self.image.size.height);</p>
<p>  self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;</p>
<p>  [self.spinner stopAnimating];</p>
</li>
</ul>
<p>}<br>```</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UITableview&quot;&gt;&lt;a href=&quot;#UITableview&quot; class=&quot;headerlink&quot; title=&quot;UITableview&quot;&gt;&lt;/a&gt;UITableview&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;UITableview是iOS软件中最常见的视图，用来以表
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十）：多线程，UIScrollView，图片浏览器Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8CUIScrollView%EF%BC%8C%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十）：多线程，UIScrollView，图片浏览器Demo/</id>
    <published>2017-01-11T07:19:16.000Z</published>
    <updated>2017-01-11T07:19:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲授了多线程编程和UIScrollview控件，最后通过一个显示图片的Demo综合了本节课讲解的知识。通过本节课的学习，我们可以初步了解该如何处理耗时的任务来提高系统性能的方法以及通过UIScrollview控件来显示超出屏幕大小的图片并实现滚动和缩放的效果。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><hr>
<p>实现多线程编程（将不同的任务放在主线程和子线程工作），可以有效利用系统硬件优势提高系统性能。<br>首先，先介绍几个概念：</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列：在队列中放入用来执行任务的block。这些block按照队列的性质被取出到应该工作的线程(主线程，子线程)。</p>
<p>队列分为串行队列和并行队列。</p>
<ul>
<li>放入串行队列的任务将会在主线程执行，执行顺序是按照顺序执行。</li>
<li>放入并行队列的任务会在子线程执行，执行顺序是并行执行。</li>
</ul>
<p>那么什么样的任务会放在主线程或子线程执行呢？</p>
<h2 id="主线程-amp-子线程"><a href="#主线程-amp-子线程" class="headerlink" title="主线程&amp;子线程"></a>主线程&amp;子线程</h2><p>主线程：负责执行UI活动，绝大部分的UI活动都要在这里调用，不能让其阻塞，要将耗时的任务放到子线程来做。<br>子线程：负责执行耗时的运算，网络请求等不能放在主线程的任务。</p>
<p>系统为我们提供了共用的主队列(Main Dispatch Queue)和全局并行队列(Global Dispatch Queue)。我们只需将需要执行的任务放入到这两类队列里就可以实现多线程编程。</p>
<h2 id="得到主队列"><a href="#得到主队列" class="headerlink" title="得到主队列"></a>得到主队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dispatch_queue_t mainQ = dispatch_get_main_queue();</div><div class="line">NSOperationQueue *mainQ = [NSOperationQueue mainQueue];</div></pre></td></tr></table></figure>
<h2 id="得到主队列并布置任务"><a href="#得到主队列并布置任务" class="headerlink" title="得到主队列并布置任务"></a>得到主队列并布置任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//NSThread</div><div class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</div><div class="line"></div><div class="line">//GCD</div><div class="line"> dispatch_async(dispatch_get_main_queue(), ^&#123;                   </div><div class="line"></div><div class="line">                        [doSomething];</div><div class="line"></div><div class="line">                    &#125;);</div></pre></td></tr></table></figure>
<h2 id="得到全局并行队列"><a href="#得到全局并行队列" class="headerlink" title="得到全局并行队列"></a>得到全局并行队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dispatch queue_t globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);</div></pre></td></tr></table></figure>
<h2 id="得到全局并行队列并布置任务"><a href="#得到全局并行队列并布置任务" class="headerlink" title="得到全局并行队列并布置任务"></a>得到全局并行队列并布置任务</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line"> </div><div class="line">         [doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="使用多线程的例子：线程之间通信"><a href="#使用多线程的例子：线程之间通信" class="headerlink" title="使用多线程的例子：线程之间通信"></a>使用多线程的例子：线程之间通信</h2><p>很多情况下，我们需要在子线程进行下载任务，下载完成后在主线程更新UI，这时候就需要线程之间的通信：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</div><div class="line">    </div><div class="line">            //下载图片</div><div class="line">            NSData *dataFromURL = [NSData dataWithContentsOfURL:imageURL];</div><div class="line">            UIImage *imageFromData = [UIImage imageWithData:dataFromURL];</div><div class="line"></div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">            //加载完成更新view</div><div class="line">            UIImageView *imageView = [[UIImageView alloc] initWithImage:imageFromData];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在这里，我们在全局并行队列的回调block里调用了主线程，并在主线程里执行了UI操作。</p>
</blockquote>
<h2 id="使用多线程的例子：通过NSURLSession下载"><a href="#使用多线程的例子：通过NSURLSession下载" class="headerlink" title="使用多线程的例子：通过NSURLSession下载"></a>使用多线程的例子：通过NSURLSession下载</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (void)mainQueueCallBack</div><div class="line">&#123;</div><div class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL];</div><div class="line">    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:nil delegateQueue:[NSOperationQueue mainQueue]];</div><div class="line">    NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</div><div class="line">         //这里是主队列，可以更新UI        </div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    [task resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">如果没有```delegateQueue```呢？我们需要自己获取主线程</div></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li><p>(void)noDelegateQueueRequest<br>{<br>  NSURLRequest <em>request = [NSURLRequest requestWithURL:self.imageURL];<br>  NSURLSessionConfiguration </em>configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];<br>  NSURLSession <em>session = [NSURLSession sessionWithConfiguration:configuration];<br>  NSURLSessionDownloadTask </em>task = [session downloadTaskWithRequest:request completionHandler:^(NSURL <em> _Nullable location, NSURLResponse </em> _Nullable response, NSError * _Nullable error) {</p>
<p>   //获取主线程-通过NSThread<br>   [self performSelectorOnMainThread:(doUIThings) withObject:nil waitUntilDone:NO];<br>   //获取主线程-通过GCD<br>  dispatch_async(dispatch_get_main_queue(), ^{                   </p>
<pre><code>    [doUIThings]
});         
</code></pre><p>  }];<br>  [task resume];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># UIScrollView</div><div class="line">-----</div><div class="line">UIScrollView是滚动视图，可以实现滚动和缩放的功能。</div><div class="line"></div><div class="line">## 几个比较重要的属性：</div><div class="line">视图要滚动的区域：```contentSize</div></pre></td></tr></table></figure>
</li>
</ul>
<p>目前滚动的位置：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">滚动窗口的大小：```scrollView.bounds</div></pre></td></tr></table></figure></p>
<h2 id="几个比较重要的方法："><a href="#几个比较重要的方法：" class="headerlink" title="几个比较重要的方法："></a>几个比较重要的方法：</h2><p>获取当前显示的部分：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGRect visibleRect = [scrollView convertRect：scrollView.bounds toView:subview];</div></pre></td></tr></table></figure></p>
<p>用代码滚动视图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)scrollRectToVisible :(CGRect)aRect animated:(BOOL)animated;</div></pre></td></tr></table></figure></p>
<p>代码实现缩放：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic) CGFloat zoomScale;  </div><div class="line">- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated);</div><div class="line">- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated;</div></pre></td></tr></table></figure></p>
<p>告诉要缩放哪个<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)</div></pre></td></tr></table></figure></p>
<h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><h4 id="设置缩放极限"><a href="#设置缩放极限" class="headerlink" title="设置缩放极限"></a>设置缩放极限</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scrollView.minimumZoomSize = 0.5;</div><div class="line">scrollView.maximumZoomSize = 2.0;</div></pre></td></tr></table></figure>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>第一个页面显示三个按钮，在跳转后分别下载并显示不同图片。</li>
<li>在图片的下载过程中给予提示。</li>
<li>图片显示出来后可以移动，缩放。</li>
</ul>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-30b1dbbc035c8e1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：第一页 | 右：第二页"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-在跳转之前将图片下载的URL传给第二个页面"><a href="#1-在跳转之前将图片下载的URL传给第二个页面" class="headerlink" title="1. 在跳转之前将图片下载的URL传给第二个页面"></a>1. 在跳转之前将图片下载的URL传给第二个页面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</div><div class="line">&#123;</div><div class="line">     //通过内省判断跳转的页面类</div><div class="line">     if ([segue.destinationViewController isKindOfClass:[ImageViewController class]]) &#123;       </div><div class="line"></div><div class="line">        //告诉编译期，即将跳转的页面类</div><div class="line">        ImageViewController *imageVC = (ImageViewController *)segue.destinationViewController;        </div><div class="line">        //初始化指针，将其设为nil </div><div class="line">        NSString *string = nil;</div><div class="line">        //通过identifier判断跳转界面</div><div class="line">        if ([segue.identifier isEqualToString:@&quot;paint&quot;]) &#123;            </div><div class="line">            //这张图貌似得翻墙，而且图片很大，建议换一张</div><div class="line">            string = @&quot;https://lh6.ggpht.com/ZoD88QrTxZbZnhpJgQbo9SPuosryX9ujjdRaHvjjvbUGeZcI-9C4AFQsWQm7-pVDv1E=h900&quot;;       </div><div class="line"></div><div class="line">        &#125;else if ([segue.identifier isEqualToString:@&quot;earth&quot;]) &#123;</div><div class="line">            //这张图不是很大，可以不用花很久就能显示</div><div class="line">            string = @&quot;http://news.nationalgeographic.com/content/dam/news/2016/02/12/01asteroidearth.jpg&quot;;           </div><div class="line"></div><div class="line">        &#125;else if ([segue.identifier isEqualToString:@&quot;night&quot;])  &#123;</div><div class="line">            //这张图貌似得翻墙，而且图片很大，建议换一张</div><div class="line">            string = @&quot;https://lh5.ggpht.com/j4C_pXnbRc5FnxNO90wIqodn4QA3f_6rB0cyu2sVnCeSwLDmyZf-xSrC9L8c3oxr6NE=h900&quot;;</div><div class="line"></div><div class="line">        &#125;        </div><div class="line"></div><div class="line">        imageVC.imageURL = [NSURL URLWithString:string];</div><div class="line"></div><div class="line">         //设置导航栏的标题</div><div class="line">        imageVC.title = segue.identifier;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-使UIScrollView控件能够拖动"><a href="#2-使UIScrollView控件能够拖动" class="headerlink" title="2. 使UIScrollView控件能够拖动"></a>2. 使UIScrollView控件能够拖动</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  设置图片后，重新imageView的图片和自己的大小，并设置contentSize</div><div class="line"> *</div><div class="line"> *  @param image &lt;#image description#&gt;</div><div class="line"> */</div><div class="line">- (void)setImage:(UIImage *)image</div><div class="line">&#123;</div><div class="line">    self.imageView.image = image;</div><div class="line">    //根据图片大小设置imageview的大小</div><div class="line"></div><div class="line">    [self.imageView sizeToFit];</div><div class="line">    //保护机制：有图片设置size，否则size=0</div><div class="line"></div><div class="line">    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为了使UIScrollView控件能够拖动，<strong>必须</strong>要设置它的contentSize大小，否则无法滚动！</p>
</blockquote>
<h4 id="3-设置UIScrollView伸缩"><a href="#3-设置UIScrollView伸缩" class="headerlink" title="3. 设置UIScrollView伸缩"></a>3. 设置UIScrollView伸缩</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)setScrollView:(UIScrollView *)scrollView</div><div class="line">&#123;</div><div class="line">    _scrollView = scrollView;</div><div class="line">    _scrollView.minimumZoomScale = 0.2;</div><div class="line">    _scrollView.maximumZoomScale = 2.0;</div><div class="line">    _scrollView.delegate = self;</div><div class="line">    //设置两次contSize的原因是我们不确保这两个方法哪个是先被调用的</div><div class="line"></div><div class="line">    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-2d0da3c643a5b7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现伸缩效果"></p>
<h4 id="4-下载图片"><a href="#4-下载图片" class="headerlink" title="4. 下载图片"></a>4. 下载图片</h4><p>错误做法：阻塞主线程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setImageURL:(NSURL *)imageURL</div><div class="line">&#123;</div><div class="line">    _imageURL = imageURL;   </div><div class="line">    self.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:self.imageURL]];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>永远不要在主线程调用下载的方法！主线程负责UI相应，如果调用耗时的方法会使得其下一项任务在下载完成之前无法执行（主线程是串行队列），造成卡死的情况。<br>所以，我们应该另外开一个子线程让其负责下载：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">- (void)startDownloading</div><div class="line">&#123;</div><div class="line">    //先清空现有图片</div><div class="line">    self.image = nil;   </div><div class="line"></div><div class="line">    if (self.imageURL) &#123;        </div><div class="line"></div><div class="line">        //转动的小动画，提示正在下载</div><div class="line">       [self.spinner startAnimating];</div><div class="line">        NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL];</div><div class="line">        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];</div><div class="line">        NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];</div><div class="line">        NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;            </div><div class="line"></div><div class="line">            if(!error)&#123;</div><div class="line">               </div><div class="line">                //判断URL是否被更改，因为这是一个异步操作，无法保证在下载过程中一定能保持原来的数据</div><div class="line">                if ([request.URL isEqual:self.imageURL])</div><div class="line">                &#123;</div><div class="line">                    //下载完成，拿到本地的路径</div><div class="line">                    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:location]];                    </div><div class="line">                    //获得主队列</div><div class="line">                    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">                        //在主队列更新UI</div><div class="line">                        self.image = image;</div><div class="line"></div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;];        </div><div class="line"></div><div class="line">        [task resume];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。</p>
<p>笔者这两天会总结一下这一系列的Demo，发布到我的个人GitHub账号上去，以后就可以方便很多了~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲授了多线程编程和UIScrollview控件，最后通过一个显示图片的Demo综合了本节课讲解的知识。通过本节课的学习，我们可以初步了解该如何处理耗时的任务来提高系统性能的方法以及通过UIScrollview控件来显示超出屏幕大小的图片并实现滚动和缩放的效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（九）：AutoLayout，自动布局Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9AAutoLayout%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（九）：AutoLayout，自动布局Demo/</id>
    <published>2017-01-11T07:18:19.000Z</published>
    <updated>2017-01-11T07:18:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课介绍了iOS在故事版里构造AutoLayout(自动布局)的三种方法并通过沿用了第六课的<a href="http://www.jianshu.com/p/8d5a4a8ac2be" target="_blank" rel="external">Demo</a>具体演示了添加约束的过程。内容较少也比较简单，可惜的是没有讲解用纯代码构造自动布局。</p>
<p><strong>PS：严重多图预警！</strong></p>
<p>因为操作都是在故事版里进行的，所以只能通过截图来演示具体操作步骤。。。</p>
<h1 id="AutoLayout"><a href="#AutoLayout" class="headerlink" title="AutoLayout"></a>AutoLayout</h1><hr>
<h2 id="在故事版里构造AutoLayout的三种方法："><a href="#在故事版里构造AutoLayout的三种方法：" class="headerlink" title="在故事版里构造AutoLayout的三种方法："></a>在故事版里构造AutoLayout的三种方法：</h2><ol>
<li>使用蓝色辅助线，并选择系统建议约束。</li>
<li>点击底部的布局菜单，根据需求选择相应的约束。</li>
<li>按住control按键拖动触发菜单，根据需求选择相应约束。</li>
</ol>
<p>下面具体每种方法的做法：</p>
<h2 id="1-使用蓝色辅助线，并选择系统建议约束"><a href="#1-使用蓝色辅助线，并选择系统建议约束" class="headerlink" title="1. 使用蓝色辅助线，并选择系统建议约束"></a>1. 使用蓝色辅助线，并选择系统建议约束</h2><p>我们现在要将“Thing 1”和“Thing 2”两个标签放在左上角和右下角。<br><img src="http://upload-images.jianshu.io/upload_images/859001-1f209520ddccc48e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用蓝色辅助线"></p>
<blockquote>
<p>在拖动空间的时候，系统会在某些时刻给出建议的约束，用蓝色虚线表示，详情看左图。<br>在约束显示出来的前提下放下控件，再选择系统建议的约束可以添加系统建议的约束，也就是之前虚线表示出来的约束，详情看右图。</p>
</blockquote>
<h2 id="2-点击底部的布局菜单，根据需求选择相应的约束"><a href="#2-点击底部的布局菜单，根据需求选择相应的约束" class="headerlink" title="2. 点击底部的布局菜单，根据需求选择相应的约束"></a>2. 点击底部的布局菜单，根据需求选择相应的约束</h2><p>我们现在要添加“Bad Thing”按钮，将其置于屏幕正中间。<br><img src="http://upload-images.jianshu.io/upload_images/859001-38cf0f8b7dddb55b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用底部布局菜单"></p>
<blockquote>
<p>想让控件居中显示，可以根据底部的按钮弹出的菜单设置，具体看左图。</p>
<p>添加约束后，生成了黄色虚线框，如中间的图所示。黄色虚线框为控件添加该约束后，控件应有的frame。这时，应该点击左上角的黄色小三角选择“update frame”，具体看右图。</p>
</blockquote>
<p>最终效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-4ed297bd355f392e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图1"></p>
<blockquote>
<p>点击黄色小三角显示的选项的意义：  </p>
<ol>
<li>update frame：通过修改frame 来适应约束。 </li>
<li>update constrains: 修改约束 适应这个控件的frame。</li>
<li>reset to suggested constrains:使用建议约束。</li>
</ol>
</blockquote>
<h2 id="3-按住control按键拖动触发菜单，根据需求选择相应约束。"><a href="#3-按住control按键拖动触发菜单，根据需求选择相应约束。" class="headerlink" title="3. 按住control按键拖动触发菜单，根据需求选择相应约束。"></a>3. 按住control按键拖动触发菜单，根据需求选择相应约束。</h2><p>我们现在要将“Bad Thing”和”Thing 2”垂直距离固定，右边对其。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-192fcf72d0c3b71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按住control键"></p>
<p>在拖动控件”Bad Thing”后，并不会改变其原有的约束(出现了黄色虚线框)，如左图。我们需要先删除其原有的约束。<br>然后点击“Bad Thing”按住<code>control</code>拖动到<code>Thing 2</code>,弹出菜单后，设置二者的垂直距离固定，右边对其，如右图所示。</p>
<p>最终效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c292148931dab740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图2"></p>
<blockquote>
<p>拖动也有三种方式：</p>
<ol>
<li>从一个控件按住control按键到另一个控件，选择相应的排列方式。</li>
<li>从一个控件拖拽到它的父视图：水平居中，垂直居中等。</li>
<li>从一个控件拖拽到它自己：选择固定宽度等。</li>
</ol>
</blockquote>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<p>首先我们拿到之前的属性字符串Demo，按照第一种设定约束的方法，结果不尽人意：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-143c8a529cb76416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="宽度不等"></p>
<p>显然，我们需要让四个彩色按钮宽度保持一致：<br>点击下方弹出菜单，选择“Equal Width”。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-4d27907e6dc68116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置等宽"></p>
<p>现在确实是等宽了，但是控制台有报错信息，虽然运行木有问题。</p>
<p>什么问题呢？</p>
<p>因为我们在让四个彩色按钮宽度相等的同时<strong>硬编码</strong>了它们的宽度，这显然不同时适用于横屏和竖屏的情况，需要将它们的固定宽度删去：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-bf9616a1e7401713.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除固定宽度"></p>
<p>在第二个页面，我们把两个Label放到左下角：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d8c09edac6a09686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="垂直固定"></p>
<ol>
<li>首先用下方的菜单，将靠左和靠下的距离固定，如左图。</li>
<li>然后用拖动control键的方法设定第二个标签的左对齐和垂直距离，效果如右图。</li>
</ol>
<p>在这里没有固定标签的宽度，这很好，因为如果数字是多位的，固定的宽度可能无法全部显示标签内的内容。</p>
<p>那么手动固定一下其中一个标签的宽度，通过拖动control键拖动到自己的方法点击“width”，使宽度固定：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b9ab01e556babf45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="固定宽度.png"></p>
<blockquote>
<p>固定宽度的标签无法完整显示了内容，因此这是一个危险的做法。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课介绍了iOS在故事版里构造AutoLayout(自动布局)的三种方法并通过沿用了第六课的&lt;a href=&quot;http://www.jianshu.com/p/8d5a4a8ac2be&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;具体演
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（八）：协议，block，动画，俄罗斯方块Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%8D%8F%E8%AE%AE%EF%BC%8Cblock%EF%BC%8C%E5%8A%A8%E7%94%BB%EF%BC%8C%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（八）：协议，block，动画，俄罗斯方块Demo/</id>
    <published>2017-01-11T07:17:25.000Z</published>
    <updated>2017-01-11T07:17:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课介绍了协议，block，动画的相关知识，最后结合了这些知识点展示了一个类似<strong>俄罗斯方块</strong>的小游戏Demo。<br>总体来说本节课的内容比较重要，稍微摆脱了UI层面的知识，对于初学者来说理解起来不是很容易，不过笔者会尽量详细地讲解给大家。</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><hr>
<p>关于协议所介绍的知识点比较简单，而且实现起来相对容易，故不做详细介绍，各位可以参考文档或者相关博客即可。<br>在这里只强调一个知识点：</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><figcaption><span>obj``` 和 ```id<myprotocol>obj```的相同点和不同点:</myprotocol></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">**相同点**：都表示了某个对象。</div><div class="line">**不同点**：</div><div class="line">```id obj```表示```obj```是具体某一类的实例对象。</div><div class="line">```id&lt;MyProtocol&gt;obj```只表示遵守了某协议的对象 。</div><div class="line">&gt;因为有的时候我们并不需要确保某个对象一定是某个类的实例对象，而只需要它遵循了某个协议，这个时候就需要用第二行的写法来确保这个对象确实遵循了&lt;MyProtocol&gt;。</div><div class="line"></div><div class="line"># Block</div><div class="line">-----</div><div class="line">关于block的概念和语法在这里就不赘述了，因为有文档和很多牛人已经总结地很好了。</div><div class="line">在这里只强调两点关于block的使用注意事项。</div><div class="line"></div><div class="line">## 修改block内部变量的方案</div><div class="line">如果我们要在block里将```found```值设为YES,就应该在block外部添加```__block```关键字。</div></pre></td></tr></table></figure></h3><pre><code>__block BOOL found = NO;
//通过__block关键字，将found从栈中移动到堆中保证其可以被修改；block结束后，将该变量复制一份到堆中，再放回栈上

[dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop){        

    if ([targetString isEqualToString:obj]) {            

        *stop = YES; //停止
        found = YES;
    }        
}];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 存储循环的解决方案</div><div class="line">只要block存在，block内部消息中的每个对象都会被block的一个强指针指着。此时，如果这些对象里的某个或几个对象也有指向该block的指针，就会造成存储循环。</div><div class="line"></div><div class="line">问题重现：</div></pre></td></tr></table></figure>
<pre><code>//这个block有强指针指向self，而self也通过myBlocks数组有强指针指向block

[self.myBlocks addObject:^{    

    [self doSomething];

}];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">解决方案：创建弱类型的局部变量</div></pre></td></tr></table></figure>
<pre><code>__weak ViewController *weakSelf = self; //创建弱类型的局部变量

[self.myBlocks addObject:^{    

    [weakSelf doSomething];

}];
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## Block的应用</div><div class="line"></div><div class="line">block可以直接保存在变量中，属性中，字典和数组中。</div><div class="line"></div><div class="line">具体使用环境：</div><div class="line"></div><div class="line">- 多线程：用于主线程，子线程的回调。</div><div class="line">- 枚举：数组，字典的枚举等。</div><div class="line">- 通知：某件事情发生后，信息的传递。</div><div class="line">- 错误时调用：“包住”错误发生后需要执行的代码。</div><div class="line">- 成功时调用：“包住”任务成功后需要执行的代码。</div><div class="line">- 动画</div><div class="line">- 排序</div><div class="line"></div><div class="line"># 通过View改变视图的属性来实现动画</div><div class="line">-----</div><div class="line">- 改变```frame</div></pre></td></tr></table></figure>
<ul>
<li>改变<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- 改变```alpha</div></pre></td></tr></table></figure></li>
</ul>
<p>具体通过UIView的类方法来改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+ (void)animateWithDuration:(NSTimeInterval)duration   //动画在这个屏幕上出现的时间</div><div class="line">                                     delay:(NSTimeInterval)delay       //等待多长时间再执行</div><div class="line">                                  options:(UIViewAnimationOptions)options </div><div class="line">                             animations:(void (^)(void))animations  //在此代码块中修改frame，transform 和 alpha</div><div class="line">                             completion:(void (^ __nullable)(BOOL finished))completion;</div></pre></td></tr></table></figure>
<p>options参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">    UIViewAnimationOptionLayoutSubviews            = 1 &lt;&lt;  0,</div><div class="line">    UIViewAnimationOptionAllowUserInteraction      = 1 &lt;&lt;  1, // turn on user interaction while animating</div><div class="line">    UIViewAnimationOptionBeginFromCurrentState     = 1 &lt;&lt;  2, // start all views from current value, not initial value</div><div class="line">    UIViewAnimationOptionRepeat                    = 1 &lt;&lt;  3, // repeat animation indefinitely</div><div class="line">    UIViewAnimationOptionAutoreverse               = 1 &lt;&lt;  4, // if repeat, run animation back and forth</div><div class="line">    UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt;  5, // ignore nested duration</div><div class="line">    UIViewAnimationOptionOverrideInheritedCurve    = 1 &lt;&lt;  6, // ignore nested curve</div><div class="line">    UIViewAnimationOptionAllowAnimatedContent      = 1 &lt;&lt;  7, // animate contents (applies to transitions only)</div><div class="line">    UIViewAnimationOptionShowHideTransitionViews   = 1 &lt;&lt;  8, // flip to/from hidden state instead of adding/removing</div><div class="line">    UIViewAnimationOptionOverrideInheritedOptions  = 1 &lt;&lt;  9, // do not inherit any options or animation type</div></pre></td></tr></table></figure></p>
<h1 id="通过给视图添加物理效果实现动画"><a href="#通过给视图添加物理效果实现动画" class="headerlink" title="通过给视图添加物理效果实现动画"></a>通过给视图添加物理效果实现动画</h1><hr>
<p>添加物理效果主要需要三个元素：</p>
<ol>
<li>DynamicAnimator</li>
<li>UIGravityBehavior</li>
<li>遵守<uidynamicitem>协议的item(大部分情况是UIView)</uidynamicitem></li>
</ol>
<h2 id="DynamicAnimator：动力动画"><a href="#DynamicAnimator：动力动画" class="headerlink" title="DynamicAnimator：动力动画"></a>DynamicAnimator：动力动画</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIDynamicAnimator *animator =[ [ UIDynamicAnimator alloc] initWithReferenceView:aView]; //aview是动画Views的顶级视图</div></pre></td></tr></table></figure>
<p>动力动画的初始化需要给其添加要进行动画的顶级视图，详细内容后面再介绍。</p>
<h2 id="UIDynamicBehavior：动力行为"><a href="#UIDynamicBehavior：动力行为" class="headerlink" title="UIDynamicBehavior：动力行为"></a>UIDynamicBehavior：动力行为</h2><p>动力行为分为重力动力行为，碰撞行为等具体的行为。<br>这个类有很多子类：</p>
<h3 id="1-UIGravityBehavior：重力行为"><a href="#1-UIGravityBehavior：重力行为" class="headerlink" title="1. UIGravityBehavior：重力行为"></a>1. UIGravityBehavior：重力行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat angle;//重力方向</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat magnitude; //重力加速度值</div></pre></td></tr></table></figure>
<h3 id="2-UICollisionBehavior：碰撞行为"><a href="#2-UICollisionBehavior：碰撞行为" class="headerlink" title="2. UICollisionBehavior：碰撞行为"></a>2. UICollisionBehavior：碰撞行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@property (nonatomic, readwrite) UICollisionBehaviorMode collisionMode;//互相碰撞弹开还是只是从边界碰撞弹开</div><div class="line"></div><div class="line">@property (nonatomic, readwrite) BOOL translatesReferenceBoundsIntoBoundary; //是否是有弹性的边界</div></pre></td></tr></table></figure>
<h3 id="3-UIAttachmentBehavior-：吸附行为"><a href="#3-UIAttachmentBehavior-：吸附行为" class="headerlink" title="3. UIAttachmentBehavior ：吸附行为"></a>3. UIAttachmentBehavior ：吸附行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (readwrite, nonatomic) CGPoint anchorPoint; //设置锚点</div><div class="line">- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item attachedToAnchor:(CGPoint)point;//将动力项吸附在锚点上</div><div class="line">- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item1 attachedToItem:(id &lt;UIDynamicItem&gt;)item2;//吸附两个动力项</div></pre></td></tr></table></figure>
<h3 id="4-UISnapBehavior：速甩行为"><a href="#4-UISnapBehavior：速甩行为" class="headerlink" title="4. UISnapBehavior：速甩行为"></a>4. UISnapBehavior：速甩行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item snapToPoint:(CGPoint)point NS_DESIGNATED_INITIALIZER;</div></pre></td></tr></table></figure>
<h3 id="5-UIPushBehavior：推动行为"><a href="#5-UIPushBehavior：推动行为" class="headerlink" title="5. UIPushBehavior：推动行为"></a>5. UIPushBehavior：推动行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readonly) UIPushBehaviorMode mode;</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat magnitude;//推力</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGVector pushDirection;//推动方向</div></pre></td></tr></table></figure>
<h3 id="6-UIDynamicItemBehavior：动力项行为"><a href="#6-UIDynamicItemBehavior：动力项行为" class="headerlink" title="6. UIDynamicItemBehavior：动力项行为"></a>6. UIDynamicItemBehavior：动力项行为</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@property (readwrite, nonatomic) CGFloat elasticity; // Usually between 0 (inelastic) and 1 (collide elastically) </div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat friction; // 0 being no friction between objects slide along each other</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat density; // 1 by default</div><div class="line"></div><div class="line">@property (readwrite, nonatomic) CGFloat resistance; // 0: no velocity damping</div><div class="line"></div><div class="line">- (CGPoint)linearVelocityForItem:(id &lt;UIDynamicItem&gt;)item;//线速度</div><div class="line">- (CGFloat)angularVelocityForItem:(id &lt;UIDynamicItem&gt;)item;//角速度</div></pre></td></tr></table></figure>
<h2 id="遵守协议的item-大部分情况是UIView"><a href="#遵守协议的item-大部分情况是UIView" class="headerlink" title="遵守协议的item(大部分情况是UIView)"></a>遵守<uidynamicitem>协议的item(大部分情况是UIView)</uidynamicitem></h2><p>只要是遵守了<uidynamicitem>协议（动力项协议）的对象，都可以添加动力行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id&lt;UIDynamicItem&gt;item1 = ....;</div><div class="line">id&lt;UIDynamicItem&gt;item2 = ....;</div><div class="line">[gravity addItem:itme2];</div></pre></td></tr></table></figure></uidynamicitem></p>
<p>动力项协议的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readwrite) CGPoint center;//动力项的中心</div><div class="line"></div><div class="line">@property (nonatomic, readonly) CGRect bounds; //动力项的绘制区域，只读，通过变换，居中，移动进行修改</div><div class="line"></div><div class="line">@property (nonatomic, readwrite) CGAffineTransform transform;//动力项的旋转或缩放比例</div></pre></td></tr></table></figure></p>
<p>若想与animator的动画相抗争，需要调用animator的以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)updateItemUsingCurrentState:(id &lt;UIDynamicItem&gt;)item;</div></pre></td></tr></table></figure></p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>点击屏幕后，在顶部随机位置生成具有随机色的正方形，正方形显示后立即下落并停止。</li>
<li>方块排满的行会自动被炸飞，而且带动画。</li>
</ul>
<h2 id="Demo效果图"><a href="#Demo效果图" class="headerlink" title="Demo效果图"></a>Demo效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-6116d4bb61ba202a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：炸飞前 | 右：炸飞后"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><p>因为每个方块的动作行为都是一致的，所以在这里自定义了一个<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**1. 自定义统一行为类：DropItBehavior**</div></pre></td></tr></table></figure></p>
<ul>
<li>(instancetype)init<br>{<br>  self = [super init];<br> //重写初始化方法，同时增加重力和碰撞行为<br>  [self addChildBehavior:self.gravity];<br>  [self addChildBehavior:self.collider];<br>  return self;<br>}</li>
</ul>
<p>//同时增加重力和碰撞行为</p>
<ul>
<li>(void)addItem:(id<uidynamicitem>)item<br>{<br>  [self.gravity addItem:item];<br>  [self.collider addItem:item];<br>}</uidynamicitem></li>
</ul>
<p>//同时移除重力和碰撞行为</p>
<ul>
<li><p>(void)removeItem:(id<uidynamicitem>)item<br>{<br>  [self.gravity removeItem:item];<br>  [self.collider removeItem:item];<br>}</uidynamicitem></p>
</li>
<li><p>(UIGravityBehavior *)gravity<br>{</p>
<p>  if (!_gravity) {</p>
<pre><code>_gravity = [[UIGravityBehavior alloc] init];
 //设置重力加速度
_gravity.magnitude = 1.9;
</code></pre><p>  }<br>  return _gravity;<br>}</p>
</li>
<li><p>(UICollisionBehavior *)collider<br>{<br>  if (!_collider) {</p>
<pre><code>_collider = [[UICollisionBehavior alloc] init];
//触碰边缘弹性 
_collider.translatesReferenceBoundsIntoBoundary = YES;
</code></pre><p>  }<br>  return _collider;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**2. 初始化animator**</div></pre></td></tr></table></figure>
</li>
<li><p>(UIDynamicAnimator *)animator<br>{<br>  if (!_animator) {</p>
<pre><code>//self.gameView 是动画实现的顶级视图，它的子视图是掉落的方块
_animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.gameView];
</code></pre><p>  }<br>  return _animator;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">**3. 给```UIDynamicAnimator```添加行为**</div></pre></td></tr></table></figure>
</li>
<li><p>(DropItBehavior *)dropitBehavior<br>{<br>  if (!_dropitBehavior) {</p>
<pre><code> _dropitBehavior = [[DropItBehavior alloc] init];
[self.animator addBehavior:_dropitBehavior];
</code></pre><p>  }<br>  return _dropitBehavior;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**4. 生成随机方块并让其下落**</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>生成随机方块并下落<br>*/</p>
<ul>
<li>(void)drop<br>{<br>//1. 随机位置</li>
</ul>
<p>CGRect frame;<br>frame.origin = CGPointZero;<br>frame.size = DROP_SIZE;<br>int x = (arc4random()%(int)self.gameView.bounds.size.width)/DROP_SIZE.width;<br>frame.origin.x = x <em> DROP_SIZE.width;<br>UIView </em>dropView = [[UIView alloc] initWithFrame:frame];</p>
<p>//2. 随机颜色<br>dropView.backgroundColor = [self randomColor];<br>[self.gameView addSubview:dropView];</p>
<p>//3. 添加下落<br>[self.dropitBehavior addItem:dropView];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt;目前小方块下落碰到障碍物后会旋转，所以容易让这些小方块散落成堆。这样一来，就不能计算好整行的排列情况，所以我们应该让小方块们没有旋转的特性。</div><div class="line"></div><div class="line">**5.取消旋转特性**</div><div class="line"></div><div class="line">在公用的behavior类```DropItBehavior```里增加一个```UIDynamicItemBehavior```实例，取消其旋转特性。</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>(UIDynamicItemBehavior *)animationOptions<br>{<br>  if (!_animationOptions) {</p>
<pre><code>_animationOptions = [[UIDynamicItemBehavior alloc] init];
_animationOptions.allowsRotation = NO;        
</code></pre><p>  }<br>  return _animationOptions;<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">这样就能整齐排列小方块了：</div><div class="line"></div><div class="line">![左：可旋转 | 右：不可旋转](http://upload-images.jianshu.io/upload_images/859001-a6bc68132ab0425a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line">**6. 动画炸掉排满的行**</div><div class="line"></div><div class="line">最好在方块都静止了之后再判断是否有排满的行，这里需要遵守协议```&lt;UIDynamicAnimatorDelegate&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> *  监听动力动画内部的所有动画停止后调用炸飞整行的方法</div><div class="line"> *</div><div class="line"> *  @param animator 动力动画</div><div class="line"> */</div><div class="line">- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator</div><div class="line"></div><div class="line">&#123;</div><div class="line">    [self removeCompleteRows];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面来看一下炸飞整行的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> *  炸飞整行的方法：包括查看是否存在整行的算法和炸飞整行的动画</div><div class="line"> */</div><div class="line">- (void)removeCompleteRows</div><div class="line">&#123;</div><div class="line">    NSMutableArray *dropsToRemove = [[NSMutableArray alloc] init];</div><div class="line">    </div><div class="line">    //遍历每一行</div><div class="line">    for (CGFloat y = self.gameView.bounds.size.height - DROP_SIZE.height/2;y &gt; 0;y-= DROP_SIZE.height) &#123;</div><div class="line">        </div><div class="line">        BOOL rowIsComplete = YES;</div><div class="line">        NSMutableArray *dropsFound = [[NSMutableArray alloc] init];</div><div class="line"></div><div class="line">        for (CGFloat x = DROP_SIZE.width/2; x &lt; self.gameView.bounds.size.width - DROP_SIZE.width/2; x+=DROP_SIZE.width) &#123;</div><div class="line">            </div><div class="line">            //移动(x,y)获取这个点所在的view</div><div class="line">            UIView *hitView = [self.gameView hitTest:CGPointMake(x, y) withEvent:NULL];</div><div class="line"></div><div class="line">            if ([hitView superview] == self.gameView) &#123;</div><div class="line">               </div><div class="line">                //如果获取的view的父视图是gameView,就说明它是方块</div><div class="line">                [dropsFound addObject:hitView];</div><div class="line">                </div><div class="line">            &#125;else&#123;</div><div class="line"></div><div class="line">                //否则这个行肯定是不完整的</div><div class="line">                rowIsComplete = NO;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        if (![dropsFound count]) break;</div><div class="line">        if (rowIsComplete)[dropsToRemove addObjectsFromArray:dropsFound];</div><div class="line">  </div><div class="line">    &#125;    </div><div class="line"></div><div class="line">    //如果有排满的行，则炸掉它</div><div class="line">    if ([dropsToRemove count])&#123;</div><div class="line">        for (UIView *drop in dropsToRemove)&#123;</div><div class="line">            [self.dropitBehavior removeItem:drop];</div><div class="line">        &#125;</div><div class="line">        [self animatedRemovingDrops:dropsToRemove];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  炸飞整行</div><div class="line"> *</div><div class="line"> *  @param dropsToRemove 需要炸飞的View的数组</div><div class="line"> */</div><div class="line"></div><div class="line">- (void)animatedRemovingDrops:(NSArray *)dropsToRemove</div><div class="line">&#123;</div><div class="line">    [UIView animateWithDuration:0.5 animations:^&#123;</div><div class="line">        </div><div class="line">        for (UIView *drop in dropsToRemove) &#123;</div><div class="line">           </div><div class="line">            //设定炸飞后终点的位置</div><div class="line">            int x = (arc4random()%(int)(self.gameView.bounds.size.width*5)) - (int)self.gameView.bounds.size.width*2;</div><div class="line">            int y = self.gameView.bounds.size.height;</div><div class="line">            drop.center = CGPointMake(x,-y);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line"></div><div class="line">        [dropsToRemove makeObjectsPerformSelector:@selector(removeFromSuperview)];</div><div class="line"></div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="思考一下"><a href="#思考一下" class="headerlink" title="思考一下"></a>思考一下</h1><hr>
<p>关于通过给view添加物理效果的方法添加动画，需要弄清楚<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">通过对代码的分析以及讲师的讲解，笔者将这三者以比喻的方法将他们的关系梳理了一下：</div><div class="line"></div><div class="line">- ```DynamicAnimator```:代表了一个游乐场。</div><div class="line">- ```UIDynamicBehavior```：代表了游乐场里的娱乐设施。</div><div class="line">- 遵守&lt;UIDynamicItem&gt;协议的item：代表了去游乐场玩儿的小孩。</div><div class="line"></div><div class="line">我们从代码看一下如何映射他们的关系：</div><div class="line"></div><div class="line">#### DynamicAnimator</div></pre></td></tr></table></figure></p>
<p>UIDynamicAnimator *animator =[ [ UIDynamicAnimator alloc] initWithReferenceView:aView];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在这里，```aView```代表了一片空地，这句话的意思是我们把游乐场建在了这片空地上。</div><div class="line"></div><div class="line">#### UIDynamicBehavior</div></pre></td></tr></table></figure></p>
<p> [self.animator addBehavior:_dropitBehavior];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">在这里，代表了我们在这个游乐场里增加了某个娱乐设施。</div><div class="line"></div><div class="line">#### 遵守&lt;UIDynamicItem&gt;协议的item</div></pre></td></tr></table></figure></p>
<ul>
<li>(void)addItem:(id<uidynamicitem>)item<br>{<br>  [self.gravity addItem:item];<br>  [self.collider addItem:item];<br>}<br>```<br>在这里，代表了我们让某个小孩来玩儿某个娱乐设施。</uidynamicitem></li>
</ul>
<p>这样就理清了：我们要让一个小孩玩儿一个娱乐设施就应该:</p>
<ol>
<li>找一片空地建设游乐场。</li>
<li>在游乐场引进娱乐设备。</li>
<li>孩子来玩儿这个娱乐设备。</li>
</ol>
<p>笔者在开始看到这三者的相关代码的时候略懵逼，不知道为什么会这么设计，但是用了“比喻法”之后，顿时豁然开朗了~</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课介绍了协议，block，动画的相关知识，最后结合了这些知识点展示了一个类似&lt;strong&gt;俄罗斯方块&lt;/strong&gt;的小游戏Demo。&lt;br&gt;总体来说本节课的内容比较重要，稍微摆脱了UI层面的知识，对于初学者来说理解起来不是很容易，不过笔者会尽量详细地讲解给大家。&lt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（七）：自定义视图，手势识别，绘制纸牌Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%EF%BC%8C%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%EF%BC%8C%E7%BB%98%E5%88%B6%E7%BA%B8%E7%89%8CDemo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（七）：自定义视图，手势识别，绘制纸牌Demo/</id>
    <published>2017-01-11T07:16:20.000Z</published>
    <updated>2017-01-11T07:16:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课介绍了UIView的一些知识，自定义UIView的方法以及手势识别。最后应用本节所讲的大部分知识点向我们演示了一个绘制纸牌的Demo。</p>
<h1 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h1><hr>
<h2 id="关于UIView，你需要知道的零散知识"><a href="#关于UIView，你需要知道的零散知识" class="headerlink" title="关于UIView，你需要知道的零散知识"></a>关于UIView，你需要知道的零散知识</h2><ul>
<li>视图是可以多层嵌套的。</li>
<li>每个视图可以有多个子视图，但是只能有一个父视图。</li>
<li>控制器的view属性指向自己的顶级视图。</li>
<li>令视图透明会加大系统的开销。</li>
<li>通过判断控制器view的<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## UIView的一些属性和方法</div></pre></td></tr></table></figure></li>
</ul>
<p>@property CGFloat contentScaleFactor; //返回每个点所有的像素数 ：非retina为1，retina为2</p>
<ul>
<li>(UIView *)superView; //指向自己的父视图</li>
<li><p>(NSArray *)subview; //自己的所有子视图的数组</p>
</li>
<li><p>(void)addSubview: (Uiview *)aView;// 发送给目标父视图，让其把aView作为自己的子视图</p>
</li>
<li><p>(void)removeFromSuperview;  //消息发送给要移除的vie</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## View的初始化方法：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)awakeFromNib {[self setup];}  //通过故事版创建的View的初始化</p>
</li>
<li><p>(id)initWithFrame: (CGRect)aRect    //通过纯代码创建的View的初始化<br>{<br>   self = [super initWithFrame:aRect];<br>   [self setup];<br>   return self;<br>}</p>
</li>
<li><p>(void)setup {….};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## Custom View 自定义视图</div><div class="line"></div><div class="line">在iOS中，自定义是图的方法是创建一个UIView的子类并重写 ```- (void)drawInRect:(Rect)rect```方法。</div><div class="line">&gt; 注意：永远都不要自己调用这个方法，要交给系统负责！</div><div class="line">&gt;可以调用以下的方法，告诉系统这个视图要被重绘：</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setNeedsDisplay;</p>
</li>
<li><p>(void)setNeedsDisplayInRect: (CGRect)aRect  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">那么具体怎样重写 ```- (void)drawInRect:(Rect)rect```方法来绘图呢？</div><div class="line">答：应用Core Graphics的相关知识。</div><div class="line"></div><div class="line">## Core Graphics</div><div class="line"></div><div class="line">Core Graphics是一套基于C的API框架，使用了Quartz作为绘图引擎，使用Core Graphics，可以创建直线、路径、渐变、文字与图像等内容，并可以做变形处理。</div><div class="line"></div><div class="line">### Core Grephics的工作步骤：</div><div class="line">1. 取得图形上下文。</div><div class="line">2. 设置绘图路径(利用UIBezierPath)。</div><div class="line">3. 设置颜色。</div><div class="line">4. 用颜色填充路径 。</div><div class="line"></div><div class="line">各位看官不用着急，具体方法在最后的Demo代码里给大家呈现。</div><div class="line"></div><div class="line"># UIGestureRecoginizer ：手势识别抽象类</div><div class="line">-----</div><div class="line"></div><div class="line">**简单介绍**：```UIGestureRecoginizer```是一个抽象类，它的各种子类可以用于识别各种不同的手势：如捏合，滑动等等。通过识别各种不同的手势，实现各种交互操作。</div><div class="line"></div><div class="line">## 使用步骤</div><div class="line">1. 在视图中添加手势识别对象。</div><div class="line">2. 提供手势发生时所需要调用的方法。</div><div class="line"></div><div class="line">## 手势种类：</div><div class="line"></div><div class="line">**1. UIPanGestureRecognizer ： 拖动手势**</div></pre></td></tr></table></figure>
</li>
<li><p>(void)setPannableView:(UIView<em>)pannableView<br>{<br>   _pannableView = pananbleView;<br>   UIPanGestureRecognizer </em>pangr = [UIPanGestureRecognizer alloc] initWithTarget:pannableView action: @selector(pan:)];<br>   [pannableView addGestureRecognnizer:panr];<br>} </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**2. UIPinchGestureReccognizer ：捏合手势**</div></pre></td></tr></table></figure>
</li>
</ul>
<p>@property CGFloat scale;   捏合手势距离<br>@property (readonly) CGFloat velocity; 每分钟变化的速度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**3. UIRotationGestureRecgnizer 旋转手势**</div></pre></td></tr></table></figure></p>
<p>@property CGFloat rotation;   弧度<br>@property (readonly) CGFloat velocity; 每秒变化的速度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**4. UISwipeGestureRecgnizer ： 滑动手势**</div></pre></td></tr></table></figure></p>
<p>@property UISwipeGestureRecognizerDirection direction 滑动方向<br>@property NSUInteger numberOfTouchesRequired; 几只手指来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**5. UITapGestureRecognizer ：点击手势**</div></pre></td></tr></table></figure></p>
<p>@property NSUInteger numberOfTapsReqired；几次点击<br>@property NSUInteger numberOfTouchesRequired;     几只手指来完成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt;以上第4，5项手势是非连续手势；1，2，3属于连续手势。</div><div class="line">&gt;注意区分滑动手势和拖动手势。滑动手势是指短促，快速地滑动的手势，而拖动手势是相对较慢，路径较长的手势。</div><div class="line"></div><div class="line"># 绘制纸牌Demo</div><div class="line">-----</div><div class="line"></div><div class="line">## Demo需求</div><div class="line">- 绘制一张纸拍放到屏幕上，包括正面和背面。</div><div class="line">- 滑动手势可以翻牌。</div><div class="line">- 捏合手势可以伸缩纸牌正面的图案大小。</div><div class="line"></div><div class="line">## Demo效果图</div><div class="line"></div><div class="line"></div><div class="line">![左二图：翻牌 | 右二图：伸缩](http://upload-images.jianshu.io/upload_images/859001-aedaf67a6c46a092.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line">## 重要代码段</div><div class="line"></div><div class="line">#### 1. 绘制纸牌正反面</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)drawRect:(CGRect)rect {</p>
<p>  //初始化一个圆角矩形<br>  UIBezierPath *roundRect = [UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:[self cornerRadius]];</p>
<p>  //裁剪，保证不会绘制四角<br>  [roundRect addClip];</p>
<p>  //填充白色<br>  [[UIColor whiteColor] setFill];<br>   UIRectFill(self.bounds);</p>
<p>  //轮廓<br>  [[UIColor blackColor] setStroke];<br>  [roundRect stroke];</p>
<p>  if (self.faceUp) {</p>
<pre><code>//1. 纸牌正面
//1.1 纸牌正面中间的图
UIImage *faceImage = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%@%@&quot;,[self rankAsString],self.suit]];

if (faceImage) {

    CGRect imageRect = CGRectInset(self.bounds, self.bounds.size.width * (1.0 - self.faceCardScaleFactor) + 20, self.bounds.size.height * ( 1.0 - self.faceCardScaleFactor  ) + 20);
    [faceImage drawInRect:imageRect];
}

//1.2 纸牌正面四个角
[self drawCorners];
</code></pre><p>  }else{</p>
<pre><code>//2. 纸牌背面
[[UIImage imageNamed:@&quot;cardBack&quot;] drawInRect:self.bounds];
</code></pre><p>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2. 绘制纸牌边角的花色和数字</div></pre></td></tr></table></figure>
</li>
<li><p>(void)drawCorners<br>{<br>  //设定段落排列<br>  NSMutableParagraphStyle *paragraphStype = [[NSMutableParagraphStyle alloc] init];<br>  paragraphStype.alignment = NSTextAlignmentCenter;</p>
<p> //设定字体<br>  UIFont <em>cornerFont = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];<br>  cornerFont = [cornerFont fontWithSize:cornerFont.pointSize </em> [self cornerScaleFactor]]; </p>
<p>  //角落文字<br>  NSAttributedString *cornerText = [[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@”%@\n%@”, [self rankAsString], self.suit] attributes:@{NSFontAttributeName:cornerFont,NSParagraphStyleAttributeName:paragraphStype}];</p>
<p>  //左上角<br>  //1. 获得图片的rect<br>  CGRect textBounds;<br>  textBounds.origin = CGPointMake([self cornerOffset], [self cornerOffset]);<br>  textBounds.size = [cornerText size];</p>
<p>   //2.绘制文字<br>  [cornerText drawInRect:textBounds];</p>
<p>  //右下角<br>  //1. 获取上下文<br>  CGContextRef context = UIGraphicsGetCurrentContext();<br>  // 2. 移动上下文<br>  CGContextTranslateCTM(context, self.bounds.size.width, self.bounds.size.height);<br>   //3. 翻转上下文（翻转180度）<br>  CGContextRotateCTM(context, M_PI);<br>   //4. 绘制<br>  [cornerText drawInRect:textBounds];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;我们可以看到，图片和文字的绘图方法都是可以通过```drawInRect:```方法来进行：通过传入需要绘制的```rect```，可以让系统根据原始的素材（图片，文字）来绘图。</div><div class="line"></div><div class="line">#### 3. 添加手势：连线方式</div></pre></td></tr></table></figure>
</li>
</ul>
<p>/**</p>
<ul>
<li>滑动手势翻转牌<br>*</li>
<li>@param sender 滑动手势<br>*/</li>
</ul>
<ul>
<li><p>(IBAction)swipe:(id)sender {</p>
<p> //翻转牌面<br>  self.playCardView.faceUp  = !self.playCardView.faceUp;</p>
</li>
</ul>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 4. 添加手势：代码方式</div></pre></td></tr></table></figure></p>
<p>//1. 添加捏合手势<br> [self.playCardView addGestureRecognizer:[[UIPinchGestureRecognizer alloc] initWithTarget:self.playCardView<br>                                                                                    action:@selector(pinch:)]];</p>
<p>/**</p>
<ul>
<li><ol>
<li>捏合手势调用的方法<br>*</li>
</ol>
</li>
<li>@param gesture 捏合手势<br>*/</li>
</ul>
<ul>
<li><p>(void)pinch:(UIPinchGestureRecognizer *)gesture<br>{<br>  if (gesture.state == UIGestureRecognizerStateChanged || gesture.state == UIGestureRecognizerStateEnded) {</p>
<pre><code>//根据捏合的程度来伸缩图片
 self.faceCardScaleFactor *= gesture.scale;
 gesture.scale = 1.0;
</code></pre><p>  }<br>}<br>```</p>
</li>
</ul>
<blockquote>
<p>在手势识别调用的方法里，我们需要对手势本身的状态加以判断以确保各种交互的实现都是正确的。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课介绍了UIView的一些知识，自定义UIView的方法以及手势识别。最后应用本节所讲的大部分知识点向我们演示了一个绘制纸牌的Demo。&lt;/p&gt;
&lt;h1 id=&quot;UIView&quot;&gt;&lt;a href=&quot;#UIView&quot; class=&quot;headerlink&quot; title=&quot;UI
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（六）：多态，导航控制器和选项卡栏控制器Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%A4%9A%E6%80%81%EF%BC%8C%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E9%80%89%E9%A1%B9%E5%8D%A1%E6%A0%8F%E6%8E%A7%E5%88%B6%E5%99%A8Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（六）：多态，导航控制器和选项卡栏控制器Demo/</id>
    <published>2017-01-11T07:08:50.000Z</published>
    <updated>2017-01-11T07:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课的课程地址：<a href="http://open.163.com/movie/2014/1/F/D/M9H7S9F1H_M9H80B3FD.html" target="_blank" rel="external">控制器多态性、导航控制器、选项卡栏控制器</a></p>
<p>本节课通过延伸第四节课的纸牌配对Demo（详情请见：<a href="http://www.jianshu.com/p/2e9c8af048d8" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（三） ：纸牌配对游戏Demo</a>）讲解了控制器的多态性，扩展了第五节课的属性字符串Demo(详情请见:<a href="http://www.jianshu.com/p/c4e277bbad71" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（四） ：属性字符串Demo</a>)讲解了如何使用导航控制器和选项卡栏控制器。</p>
<p>建议读者先了解以上两个博客的内容，因为这样有助于对本节课笔记的理解。</p>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><hr>
<p>第四节课做的纸牌配对游戏只有一个ViewController，它导入了<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">具体看一下代码：</div></pre></td></tr></table></figure></p>
<p>#import “ViewController.h”</p>
<p>#import “PlayingCardDeck.h”</p>
<p>@implementation ViewController</p>
<ul>
<li>(CardMatchingGame *)game<br>{<br>  if (!_game) {<pre><code>_game = [[CardMatchingGame alloc] initWithCardCount:[self.cardButtons count] usingDeck:[self createDeck]];
</code></pre>  }<br>  return _game;<br>}</li>
</ul>
<ul>
<li>(Deck *)createDeck<br>{<br>  //实例化了 PlayingCardDeck 类<br>  return [[PlayingCardDeck alloc] init];<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;为了将该ViewController作为通用的控制器，我们需要将它设置为抽象类。通过创造不同的继承它的字类来实现各种各样的纸牌配对游戏。</div><div class="line"></div><div class="line">## 抽象类</div><div class="line">**抽象类**就是不能被实例化的类，它具有某种普遍性，可以通过继承它来实现基于这种普遍性并带有其他特性的字类。</div><div class="line"></div><div class="line">举个🌰：船是一个具有普遍性的抽象类。基于这个抽象来，如果我们添加了木桨，就可以造一个木桨船；如果我们给它添加了帆，就可以早一个帆船等等。。</div><div class="line"></div><div class="line">因此，在这里，我们需要将纸牌游戏的牌堆抽象出来，如果这个牌堆里是扑克牌，那么这个游戏就是扑克牌配对游戏；如果这个牌堆里的牌是塔罗牌，那么这个牌就是卡洛牌配对游戏。</div><div class="line"></div><div class="line">## 如何创建抽象类的具体子类？</div><div class="line"></div><div class="line">#### 1. 将该类抽象化：</div><div class="line"></div><div class="line">从上面的代码可以看到，控制器的实例化是基于```createDeck```方法的(这个方法将```扑克牌堆```的模型交给了控制器), 如果可以阻止模型的生成就阻止控制器的实例化。因此我们将```createDeck```的方法的返回值设为nil：</div></pre></td></tr></table></figure>
<p>#import “ViewController.h”</p>
<p>#import “PlayingCardDeck.h”</p>
<p>@implementation ViewController</p>
<ul>
<li><p>(CardMatchingGame *)game<br>{<br>  if (!_game) {</p>
<pre><code>_game = [[CardMatchingGame alloc] initWithCardCount:[self.cardButtons count] usingDeck:[self createDeck]];
</code></pre><p>  }<br>  return _game;<br>}</p>
</li>
<li><p>(Deck *)createDeck<br>{<br>  return nil;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;这样一来，该类无法取得自己的模型实例，就无法正常工作，变得“抽象”。</div><div class="line"></div><div class="line">#### 2. 将需要字类实现的方法放在抽象类的公共API中：</div></pre></td></tr></table></figure>
<p>#import <uikit uikit.h=""></uikit></p>
<p>#import “Deck.h”</p>
<p>@interface ViewController : UIViewController</p>
<p>/**</p>
<ul>
<li>abstract metod, for subclasses<br>*</li>
<li>@return 各种类型不同的纸牌堆<br>*/<ul>
<li>(Deck *)createDeck;</li>
</ul>
</li>
</ul>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;不难想到，子类将该方法实现的过程就是实例化具有不同特性的具体类的过程！这也就实现了类的多态。</div><div class="line"></div><div class="line">#### 3. 创造继承抽象的子类</div><div class="line"></div><div class="line">新建一个继承于抽象类```ViewController```的字类```PlayingCardViewController```：</div><div class="line"></div><div class="line">**PlayingCardViewController.h**</div></pre></td></tr></table></figure>
<p>#import “ViewController.h”</p>
<p>@interface PlayingCardViewController : ViewController</p>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">**PlayingCardViewController.m**</div></pre></td></tr></table></figure>
<p>#import “PlayingCardViewController.h”</p>
<p>#import “PlayingCardDeck.h”</p>
<p>@interface PlayingCardViewController ()</p>
<p>@end</p>
<p>@implementation PlayingCardViewController</p>
<p>//只需要实现</p>
<ul>
<li>(Deck *)createDeck<br>{<br>  return [[PlayingCardDeck alloc] init];<br>}</li>
</ul>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt;这样一来，我们就获得了一个扑克牌配对游戏的ViewController。</div><div class="line">&gt;将来，如果我们还有别的继承与```Deck```的牌，就可以用相同的方法：通过创建继承该抽象类并实现```createDeck```的方法来完成。</div><div class="line"></div><div class="line"></div><div class="line"># 多MVC的实现：通过导航控制器管理多个ViewController</div><div class="line">----</div><div class="line"></div><div class="line">**导航控制器**拥有一个**栈数据结构**，它可以将多个控制器压入自己的栈结构中来管理这些控制器。我们经常看到的界面**滑入滑出**的过程就是导航控制器的栈结构在**压入弹出**控制器的过程。而每个控制器管理一个MVC模型，导航控制器通过管理这些控制器实现了管理多MVC的目的。</div><div class="line"></div><div class="line">**需要注意的是**：手机的屏幕每次只能显示一个MVC模型的View。在view的切换过程中，手机界面显示的是**当前处于导航控制器栈顶的控制器的视图！**当该视图被移除界面的时候，该MVC的数据就会被释放。因此，每次要显示一个新的MVC的时候，都会创建一个新的MVC。</div><div class="line"></div><div class="line">## 控制器在导航控制器的栈结构中弹出</div></pre></td></tr></table></figure>
<ul>
<li>(void)popViewController<br>{<br>  //self是当前的控制器，它的navigationController属性指向管理自己的导航控制器<br> [self.navigationController popViewControllerAnimitaed:YES];</li>
</ul>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 跳转到下一个控制器之前执行的方法：</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)prepareForSegue:(UIStroyboardSegue *)segue sender: (id)sender<br>{</p>
<p>//segue的identifier属性用来区分不同的控制器<br>if ([segue.identifier isEqualToString:@”DoSomething”])<br>{ </p>
<pre><code>//segue的destinationViewController指向的是下一个要滑入界面的控制器
if ([segue.destinationViewController isKindOfClass:[DoSomethingVC class]]){

 DoSomethingVC *doVC = (DoSomethingVC *)segue.desitinationViewController；
 doVC.infoString = self.infoString;
}
</code></pre><p>  }</p>
</li>
</ul>
<p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 判断是否可以跳转的方法</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(BOOL)shouldPerformSegueWithIdentifier: (NSString *)identifier sender: (id)sender<br>{</p>
<p>if([segue.identifier isEqualToString:@”DoAParticularThing”])<br>{<br>   //此方法是用来确定跳转的可行性，因为有时如果缺少下一个界面的数据是不能跳转的<br>  return [self canDoAParticularThing]? YES:NO;<br>}</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># 多MVC Demo</div><div class="line"></div><div class="line">## DEMO需求：</div><div class="line"></div><div class="line">- 在第一个页面可以设置字符属性</div><div class="line">- 点击第一个页面导航栏右侧的按钮跳转到第二个页面</div><div class="line">- 在第二个页面统计第一个页面中添加色彩和边框的字符数量</div><div class="line"></div><div class="line">## Demo效果图</div><div class="line"></div><div class="line">![|导航控制器|  左：第一个页面；右：第二个页面](http://upload-images.jianshu.io/upload_images/859001-35ed7fcc54dc0c69.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">![|选项卡栏控制器| 左：第一个Tab；右：第二个Tab](http://upload-images.jianshu.io/upload_images/859001-5788b1865e19247c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">## 重要代码与知识点</div><div class="line"></div><div class="line">#### 跳转页面传值</div><div class="line"></div><div class="line">实现跳转页面传值一共有两个步骤：</div><div class="line"></div><div class="line">1.  我们先通过在第二个页面的公共API中设置属性</div><div class="line">2. 然后在第一个页面跳转到第二个页面之前将数据赋予第二个页面的这个公共属性实现传值。</div><div class="line"></div><div class="line">**1. 在第二个页面设置公共属性**：</div></pre></td></tr></table></figure>
<p>#import “ViewController.h”</p>
<p>@interface TextAnylizeViewController : UIViewController</p>
<p>@property (nonatomic, retain) NSAttributedString *textToAnalyze;</p>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">**2. 在第一个页面跳转到第二个页面之前执行传值**</div></pre></td></tr></table></figure>
<ul>
<li>(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender<br>{<br>  //1. 首先判断segue的identifier<br>  if ([segue.identifier isEqualToString:@”Analyze Text”]) {<pre><code> //2. 然后判断目标控制器的类型
if ([segue.destinationViewController isKindOfClass:[TextAnylizeViewController class]]) {
    //3. 在1和2都确定的情况下，实例化第二个页面
    TextAnylizeViewController *analyzeVC = (TextAnylizeViewController*)segue.destinationViewController;
    //4. 将第一个页面的字符串赋予第二个页面，用于第二个页面的分析
    analyzeVC.textToAnalyze = self.body.textStorage;
}
</code></pre>  }<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 获取一段字符中，具有某种属性的字符串</div></pre></td></tr></table></figure>
<ul>
<li><p>(NSAttributedString <em>)charactersWithAttribute: (NSString </em>)attributedName<br>{<br>  NSMutableAttributedString *characters = [[NSMutableAttributedString alloc] init];</p>
<p>  NSUInteger index = 0;</p>
<p>  while (index &lt; [self.textToAnalyze length]) {</p>
<pre><code>NSRange range;

//查找一段字符串中，具有某种相同属性的值
id value = [self.textToAnalyze attribute:attributedName atIndex:index effectiveRange:&amp;range];

if (value) {
    //如果值存在，获取具有该相同属性的字符串
    [characters appendAttributedString:[self.textToAnalyze attributedSubstringFromRange:range]];

    //将index移动到具有该相同属性的字符串的下一位
    index = range.location + range.length;

}else{
    index ++;
}
</code></pre><p>  }</p>
<p>  return characters;<br>}</p>
</li>
</ul>
<p>```</p>
<h4 id="搭建导航控制器-Navigation-Controller"><a href="#搭建导航控制器-Navigation-Controller" class="headerlink" title="搭建导航控制器(Navigation Controller)"></a>搭建导航控制器(Navigation Controller)</h4><p><img src="http://upload-images.jianshu.io/upload_images/859001-7a518741341460be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导航控制器"></p>
<h4 id="搭建选项卡栏控制器-Tab-Bar-Controller"><a href="#搭建选项卡栏控制器-Tab-Bar-Controller" class="headerlink" title="搭建选项卡栏控制器(Tab Bar Controller)"></a>搭建选项卡栏控制器(Tab Bar Controller)</h4><p><img src="http://upload-images.jianshu.io/upload_images/859001-c477e12dc9779726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="选项卡栏控制器"></p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课的课程地址：&lt;a href=&quot;http://open.163.com/movie/2014/1/F/D/M9H7S9F1H_M9H80B3FD.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;控制器多态性、导航控制器、选项卡栏控制器&lt;/a&gt;&lt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（四 五）：属性字符串Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%20%E4%BA%94%EF%BC%89%EF%BC%9A%E5%B1%9E%E6%80%A7%E5%AD%97%E7%AC%A6%E4%B8%B2Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（四 五）：属性字符串Demo/</id>
    <published>2017-01-11T07:07:50.000Z</published>
    <updated>2017-01-11T07:14:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲解了iOS框架里几个重要的知识点：动态绑定，控制器的生命周期，属性字符串等。最后演示了一个Demo用来讲解属性字符串的几个功能。</p>
<h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><hr>
<p>在OC的编译期，所有的指针都是id类型，只有在运行时，对象的类型才会被确定。</p>
<p>举个🌰 ：<br>在编译期，<figure class="highlight plain"><figcaption><span>实际上与id相同，但是加上去的好处是让编译器知道你至少是**意图让该指针指向一个字符串**。所以如果尝试发送非字符串消息给该指针，它会发出警告，但是不会提示错误，仍可以通过编译。但是如果在运行时就会“露馅”，因为此时如果向该对象发送非字符串消息时，就会引起崩溃。</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">再举个具体的🌰：</div></pre></td></tr></table></figure></p>
<p>NSString <em>hellow = @”hello”;<br>Ship </em>hellowShip = (Ship *)hello;<br>[helloShip shoot];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;编译器会认为```hellowShip```是```ship```类型，因此向```hellowShip```发送```shoot```消息时，在编译器期是可以通过的。</div><div class="line">但是，```hellowShip```实际上指向的是字符串，所以会导致在运行时崩溃。</div><div class="line"></div><div class="line">所以就引出了**类型保护机制**用来确定对象的类型：</div><div class="line"></div><div class="line"># 类型保护机制</div><div class="line">---</div><div class="line">### 没有添加类型保护机制：</div></pre></td></tr></table></figure>
<p>PlayingCard *otherCard = [otherCards firstObject];<br>[otherCard play];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;firstObject 方法返回的是id类型，这里需要保护机制确保取出的对象是```PlayingCard```的实例，以防止向其发送消息时导致程序崩溃。</div><div class="line"></div><div class="line">### 添加了类型保护机制：</div></pre></td></tr></table></figure>
<p>PlayingCard *otherCard = [otherCards firstObject];</p>
<p>id card = [otherCards firstObjct];<br>if ([card isKindOfClass:[PlayingCard class]])<br>{<br>   PlayingCard <em>otherCard = (PlaytingCard </em>)card;<br>   [otherCard play];</p>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;我们可以看到```card```指针通过```isKindOfClass:```方法被确认了是```PlayingCard```类的实例，那么如果我们给```card```实例发送其消息时，就不会发生崩溃。反之，若```card```是其他类的实例，如果向其发送```card```类的消息就会非常危险！</div><div class="line"></div><div class="line"># NSRange</div><div class="line">---</div><div class="line">NSRange是一个表示“范围”的结构体，包括起点和长度,主要用于字符串。</div><div class="line"></div><div class="line">常用方法：</div><div class="line"></div><div class="line">#### 字符串所有的字符：</div></pre></td></tr></table></figure>
<p>NSString *title = @”好好学习天天向上”;<br>NSMakeRange(0, [title length])</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 判断某个字符串里包含某个字符：</div></pre></td></tr></table></figure>
<p>NSString <em>greeting = @”hellow world”;<br>Nsstring </em>hi = @”hi”;<br>NSRange r = [greeting rangeOfString:hi];<br>if(r.location != NSNotFound)<br>{<br>    NSLog(@”Found”);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># 控制器生命周期</div><div class="line">---</div><div class="line">在控制器(ViewController)的生命周期里，处于某个特定的时间点会执行某个特定的方法。通过在这些方法里之行某些特定的任务，可以正确地实现其应实现的功能。</div><div class="line"></div><div class="line"></div><div class="line">### viewDidLoad</div><div class="line"></div><div class="line">控制器的```viewDidLoad```方法在控制器的view为nil的时候被调用，在控制器的生命周期中只调用一次。</div></pre></td></tr></table></figure></p>
<ul>
<li><p>（voidviewDidLoad<br>{<br> [super viewDidLoad];    </p>
<p> //可执行：<br> //1. 控制器的初始化数据<br> //2. 网络请求</p>
</li>
</ul>
<p>   //不可执行：<br>   //1. 视图形状的初始化信息<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">### viewWillAppear:</div><div class="line"></div><div class="line">控制器的```viewWillAppear:```在UIViewController对象的视图即将加入窗口时调用。只要该控制器的view即将要出现，都会调用，在控制器的生命周期中可以调用多次。</div><div class="line">而且，如果该方法被调用，就说明视图**一定**会出现在屏幕上。</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)viewWillAppear:(BOOL)animated<br>{<br>  [super viewWillAppear:animated];</p>
<p>  //可执行：<br>  //1. 更新view离开界面后可能会改变的数据。<br>  //2. view的几何变化。</p>
</li>
</ul>
<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">### viewWillDisappear:</div><div class="line"></div><div class="line">控制器的```viewWillDisappear:```在UIViewController的view即将不显示的时候调用，在控制器的生命周期中可以调用多次。</div></pre></td></tr></table></figure>
<ul>
<li><p>(void)viewWillDisappear:(BOOL)animated<br>{<br>  [super viewWillDisappear:animated];</p>
<p>  //可执行：<br>  //1. 记录滚动视图的偏移量(因为要记住滚动位置，便于下次查看)<br>  //2. 存储数据，便于再次显示该控制器时使用。<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"># 属性字符串Demo</div><div class="line">---</div><div class="line"></div><div class="line"></div><div class="line">## 设计需求</div><div class="line"></div><div class="line">- 布局为TextView下方有四个颜色按钮，再下方有添加轮廓按钮和去除轮廓按钮。</div><div class="line">- 选中TextView的文本后，点击色彩按钮，选中的文本的颜色变成点击的色彩按钮的背景色。</div><div class="line">- 选中TextView的文本后，点击添加轮廓，选中的文本增加了轮廓，再点击色彩按钮，轮廓变成了相应的颜色。</div><div class="line">- 文本有轮廓的状态下，点击去除轮廓按钮，轮廓消失。</div><div class="line">- 在设置选项来改变系统字体，再回到本Demo界面，字体会做相应改变。</div><div class="line"></div><div class="line"></div><div class="line">## 效果图</div><div class="line"></div><div class="line">![属性字符串效果图](http://upload-images.jianshu.io/upload_images/859001-4660010abbea2854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 知识点详解</div><div class="line"></div><div class="line">#### 属性字符串的设置</div><div class="line"></div><div class="line">属性字符串分为不可变属性字符串```NSAttributedString```和```NSMutableAttributedString```。</div><div class="line"></div><div class="line">设置属性字符串的一般步骤为：</div><div class="line"></div><div class="line">1. 初始化可变属性字符串。</div><div class="line">2. 向其添加属性字典和制定属性字典被应用的范围。</div><div class="line"></div><div class="line">举个🌰：</div></pre></td></tr></table></figure>
<p>//1. 由现有字符串初始化可变属性字符串<br>NSMutableAttributedString *title = [[NSMutableAttributedString alloc] initWithString:self.outLineButton.currentTitle];</p>
<p>//2. 添加属性字典和范围<br>[title setAttributes:@{NSStrokeWidthAttributeName : @3,<br>                      NSStrokeColorAttributeName  : self.outLineButton.tintColor}<br>                                             range: NSMakeRange(0, [title length])];</p>
<p>//3. 将属性字符串赋给按钮的属性字符串属性<br>[self.outLineButton setAttributedTitle:title forState:UIControlStateNormal];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>//设定选中的字都被设置为和点击的按钮一样的背景颜色<br>[self.textView.textStorage  addAttribute:NSForegroundColorAttributeName value:sender.backgroundColor range:self.body.selectedRange];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">#### 关于按钮的操作</div></pre></td></tr></table></figure>
<p>//获取按钮的背景色<br>self.button.backgroundColor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>//获取按钮当前的标题<br>self.button.currentTitle</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>//设定按钮当前的属性字符串标题<br>[self.button setAttributedTitle:title forState:UIControlStateNormal];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">#### 属性字典里的key：</div><div class="line"></div><div class="line">- ```NSForegroundColorAttributeName```:属性字符串字符的颜色</div><div class="line">- ```NSStrokeColorAttributeName```:属性字符串字符轮廓的颜色</div><div class="line">- ```NSStrokeWidthAttributeName```:属性字符串字符轮廓的宽度</div><div class="line"></div><div class="line"></div><div class="line">#### 获取TextView被选中的范围</div></pre></td></tr></table></figure>
<p>self.textView.selectedRange</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 通知机制</div><div class="line"></div><div class="line">为了实现本Demo最后一个需求，我们需要监听系统字体何时被改变了。所以需要注册一个能收听“系统改变”广播的频道：</div><div class="line"></div><div class="line">注册通知：</div></pre></td></tr></table></figure>
<p> [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(prefredFontsChaged:) name:UIContentSizeCategoryDidChangeNotification object:nil];</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这样一来，当系统字体发生变化时，注册该频道的对象会收到通知并执行自定义的方法。</div><div class="line">当改变系统字体的大小后，该类会收到通知，并调用```prefredFontsChaged: ```方法，此时Demo上的字体也要做相应的改变：</div></pre></td></tr></table></figure>
<ul>
<li><p>(void)prefredFontsChaged: (NSNotification *)notification<br>{<br>  //收到通知后，调用本地自定义的方法<br>  [self userPreferredFonts];<br>}</p>
</li>
<li><p>(void)userPreferredFonts<br>{<br>  //使用被改变后的系统字体<br>  self.body.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];<br>  self.headLine.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];</p>
</li>
</ul>
<p>}</p>
<p>```</p>
<blockquote>
<p>这里，显然又是一个MVC的流程：系统字体(模型)被改变了，通过广播(通知)的机制来告诉控制器，然后控制器再调用更改View的方法。还记得在第一篇（详情请见：<a href="http://www.jianshu.com/p/eb58ab21080a" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（一） ：iOS的MVC框架</a>）里强调的，从模型到控制器的通信是通过广播或KVO机制完成的么？</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到此Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲解了iOS框架里几个重要的知识点：动态绑定，控制器的生命周期，属性字符串等。最后演示了一个Demo用来讲解属性字符串的几个功能。&lt;/p&gt;
&lt;h1 id=&quot;动态绑定&quot;&gt;&lt;a href=&quot;#动态绑定&quot; class=&quot;headerlink&quot; title=&quot;动态绑定&quot;&gt;&lt;/
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（三）：纸牌配对游戏Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E7%BA%B8%E7%89%8C%E9%85%8D%E5%AF%B9%E6%B8%B8%E6%88%8FDemo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（三）：纸牌配对游戏Demo/</id>
    <published>2017-01-11T07:05:23.000Z</published>
    <updated>2017-01-11T07:05:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课知识点内容不多，主要是延续了上一节课翻单张纸牌的游戏(详情请见：<a href="http://www.jianshu.com/p/332324bff10a" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（二） ：翻纸牌Demo</a>），将一张纸牌扩展到一个多张纸牌并进行配对和打分的小游戏。</p>
<p>本节课的内容虽然简单，但是十分重要，讲师强调了MVC的设计原则并实际运用到了代码中，本文就Demo的具体代码来讲解本节课提到的知识点。</p>
<h1 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h1><hr>
<ul>
<li>显示多张纸牌，点击任意一张牌可以翻牌。</li>
<li>两张牌都显示正面后可以进行配对：<ul>
<li>花色匹配得1分；数字匹配得4分，匹配后，两张牌切换为不可点击状态（置灰）。</li>
<li>都不匹配扣2分。</li>
<li>每次翻牌都减一分。</li>
</ul>
</li>
<li>每次翻牌都要更新分数。</li>
</ul>
<h1 id="效果图："><a href="#效果图：" class="headerlink" title="效果图："></a>效果图：</h1><hr>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6371568b2e366281.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：初始界面 ；右：游戏中界面"></p>
<h1 id="重要代码段与知识点"><a href="#重要代码段与知识点" class="headerlink" title="重要代码段与知识点"></a>重要代码段与知识点</h1><hr>
<h2 id="模型类：CardMatchingGame"><a href="#模型类：CardMatchingGame" class="headerlink" title="模型类：CardMatchingGame"></a>模型类：CardMatchingGame</h2><h4 id="1-在公共接口设置只读属性"><a href="#1-在公共接口设置只读属性" class="headerlink" title="1. 在公共接口设置只读属性"></a>1. 在公共接口设置只读属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//CardMatchingGame.h</div><div class="line">@property (nonatomic, readonly) NSInteger score;</div><div class="line"></div><div class="line">//CardMatchingGame.m</div><div class="line">@property (nonatomic, readwrite) NSInteger score;</div></pre></td></tr></table></figure>
<blockquote>
<p>在.h文件中将分数属性设置为只读，并在.m文件中设定该属性为读写，以便在内部计算。</p>
<p>原因：不希望其他类更改此属性，只能获取该属性。通俗一点地说：“你们就拿我给你算好的分数就好了，你们是不能更改它的！”</p>
</blockquote>
<h4 id="2-指定初始化器：Designated-initializer"><a href="#2-指定初始化器：Designated-initializer" class="headerlink" title="2. 指定初始化器：Designated initializer"></a>2. 指定初始化器：Designated initializer</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (instancetype)initWithCardCount:(NSUInteger)count usingDeck:(Deck *)deck</div><div class="line">&#123;</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">            </div><div class="line">            Card *card = [deck drawRandomCard];</div><div class="line">            </div><div class="line">            if (card) &#123;</div><div class="line">               </div><div class="line">                [self.cards addObject:card];</div><div class="line">                </div><div class="line">            &#125;else&#123;</div><div class="line">                </div><div class="line">                self = nil;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>有些时候，我们需要在类实例化的时候就要求对象持有某些数据,这就需要设计<strong>指定初始化器</strong>，因为原始的初始化方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;在这段代码里，该模型类通过数量```count```和一堆纸牌```deck```中拿到了自己持有的数组```self.cards```。</div><div class="line"></div><div class="line">&gt;举个🌰 ：想要从一个有52张牌的堆里抽取了12张牌来作为自己的一堆纸牌的话，就要设置Deck为具有52张牌的数组；而设置count为12即可。</div><div class="line"></div><div class="line"></div><div class="line">#### 3. 设定常量</div></pre></td></tr></table></figure></p>
</blockquote>
<p>#define MISMATCH_PENALTY 2 //简单的替换，不具有数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>static const int MISMATCH_PENALTY = 2; //非简单替换，具有数据类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 控制器类：CardMathcingGameViewController</div><div class="line">---</div><div class="line">#### 1. 接收来自View的点击事件并更新UI</div></pre></td></tr></table></figure></p>
<p>/**</p>
<ul>
<li>接收用户的点击事件<br>*</li>
<li><p>@param sender 点击的按钮对象<br>*/</p>
<ul>
<li>(IBAction)touchCardButton:(UIButton *)sender {</li>
</ul>
<p>//1. 找到界面中所点击的按钮index<br>NSInteger cardIndex = [self.cardButtons indexOfObject:sender];</p>
<p>//2. 找到模型中相同index的纸牌数据，并判断是否匹配，计算分数<br>[self.game chooseCardAtIndex: cardIndex];</p>
<p>//3. 更新UI<br>[self updateUI];<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li><p>更新UI<br>*/</p>
<ul>
<li><p>(void)updateUI<br>{<br>//1. 更新view上所有牌面<br>for (UIButton *cardButton in self.cardButtons) {</p>
<p>  //1.1 找到界面中的一张纸牌(按照枚举的顺序)<br>  NSInteger cardIndex = [self.cardButtons indexOfObject:cardButton];</p>
<p>  //1.2 找到模型中对应的纸牌数据<br>  Card *card  = [self.game cardAtIndex:cardIndex];</p>
<p>  //1.3 根据数据更新纸牌的UI和可点击性<br>  [cardButton setTitle:[self titleForCard:card] forState:UIControlStateNormal];<br>  [cardButton setBackgroundImage: [self backgroundImageForCard:card] forState:UIControlStateNormal];<br>   cardButton.enabled = !card.isMatched;<br>}</p>
</li>
</ul>
<p>//2. 更新分数<br>self.scoreLabel.text = [NSString stringWithFormat:@”Score: %ld”, (long)self.game.score];<br>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;在这里，我们可以很容易看到MVC的工作流程：</div><div class="line">1. 在View里发生了点击事件并通知给了Controller。</div><div class="line">2. Controller告诉Model发生了点击。</div><div class="line">3. Model根据点击事件更新自己，然后将更新后的自己告诉Controller。</div><div class="line">4. Controller根据更新后的模型去更新UI。</div><div class="line"></div><div class="line">这里笔者有一张自己画的图，略逗逼，掩面贴出，独乐乐不如众乐乐~</div><div class="line"></div><div class="line"></div><div class="line">![MVC流程图.png](http://upload-images.jianshu.io/upload_images/859001-0c8b70fd62292aa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line">## 零散知识点</div><div class="line">---</div><div class="line"></div><div class="line">#### 1. 在数组里传入其包含的对象返回其所在序号</div></pre></td></tr></table></figure>
</li>
</ul>
<p>NSInteger cardIndex = [self.cardButtons indexOfObject:cardButton];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 2. 在数组中找到第一个元素</div></pre></td></tr></table></figure></p>
<p>//应该使用：<br>PlayingCard *otherCard = [otherCards firstObject];</p>
<p>//不应该使用：<br>PlayingCard *otherCard = otherCards[0];</p>
<p>//不应该使用：<br>PlayingCard *otherCard = [otherCards objectAtIndex:0];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;应该使用第一种情况。</div><div class="line">因为如果数组为空，那么如果使用第一种情况会返回nil,而向nil发送消息是不会造成崩溃的。</div><div class="line">但是如果使用后两种方法，一旦数组为空，就会立刻造成程序崩溃！而且同样适用与取数组的最后一个元素的情况。</div><div class="line">在数组中找到最后一个元素：</div></pre></td></tr></table></figure></p>
<p>PlayingCard *otherCard = [otherCards lastObject];<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 3. 在数组中是否包含某元素</div></pre></td></tr></table></figure></p>
<p>if ([ [PlayingCard ValidSuits] containsObject:suit]) {<br>        _suit = suit;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;containsObject:是NSArray的方法，返回布尔值，用来判断是否包含某个元素。</div><div class="line"></div><div class="line">#### 4. JPG格式图片的读取</div></pre></td></tr></table></figure></p>
<ul>
<li>(UIImage <em>)backgroundImageForCard: (Card </em>)card<br>{<br>  //默认是png，如果是jpg需要加上.jpg的后缀<br>  return [UIImage imageNamed:card.isChosen? @”cardFront.jpg”:@”CardBack.png”];<br>}<br>```</li>
</ul>
<blockquote>
<p>如果使用<code>imageNamed:</code>方法，仅传入jpg格式的文件名是无法显示出图片的，应该讲后缀<code>.jpg</code>拼接后传入才可以哦~而相同情况下，若要显示<code>png</code>格式的图片的话是不需要另外加后缀的。</p>
</blockquote>
<h1 id="最后的话："><a href="#最后的话：" class="headerlink" title="最后的话："></a>最后的话：</h1><hr>
<p>如果哪位小伙伴想拿到此Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课知识点内容不多，主要是延续了上一节课翻单张纸牌的游戏(详情请见：&lt;a href=&quot;http://www.jianshu.com/p/332324bff10a&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;斯坦福大学iOS开发公开课总结（二） ：翻纸牌
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（二）：翻纸牌Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%BF%BB%E7%BA%B8%E7%89%8CDemo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（二）：翻纸牌Demo/</id>
    <published>2017-01-11T07:01:11.000Z</published>
    <updated>2017-01-11T07:01:11.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课简单介绍了控件的懒加载(lazy instantiation)，数组，字典，类方法的使用，在最后展示了翻转卡牌的小demo。</p>
<h2 id="懒加载-lazy-instantiation"><a href="#懒加载-lazy-instantiation" class="headerlink" title="懒加载(lazy instantiation)"></a>懒加载(lazy instantiation)</h2><hr>
<p><strong>懒加载</strong>：在实例变量被使用之前的那一刻初始化。防止大量的实例变量(属性)在同一时间初始化(尤其是不用将创建对象的方法全部写在<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>@interface ViewController ()</p>
<p>@property (nonatomic, strong) NSMutableArray *cards;</p>
<p>@end</p>
<p>@implementation ViewController</p>
<ul>
<li>(NSMutableArray *)cards<br>{<br>  //如果此实例变量为空，则初始化；否则，直接调用<br>  if (!_cards) {<pre><code>_cards = [[NSMutableArray alloc] init];
</code></pre>  }<br>  return _cards;<br>}</li>
</ul>
<p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">## 数组的使用</div><div class="line">---</div><div class="line">#### 在可变数组中插入元素</div><div class="line">在数组中插入元素是可变数组的方法，因为不可变数组在初始化以后就无法再更改。</div><div class="line">尤其注意的是：在数组中插入元素时，插入的元素必须不能为空，否则会引起程序崩溃。需要对要插入的元素做是否为空的判断！</div></pre></td></tr></table></figure></p>
<ul>
<li><p>(void)addCard: (Card *)card atTop:(BOOL)atTop<br>{<br>  if (atTop) {</p>
<pre><code>//插入到数组第一个位置
[self.cards insertObject:card atIndex:0];
</code></pre><p>  }else{</p>
<pre><code>//添加到数组末尾
[self.cards addObject:card];
</code></pre><p>  }<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 在可变数组中引用和移除数组元素</div><div class="line"></div><div class="line">在数组中，提取和移除元素的时候需要注意的是需要判断数组是否为空，如果**在数组为空的情况下引用或移除某个元素会引起程序的崩溃！** 所以要先进行目标数组元素数量判断。</div></pre></td></tr></table></figure>
<ul>
<li><p>(Card <em>)drawRandomCard<br>{<br>  //如果数组为空数组，则直接放回nil，因为没有可以抽取的元素。<br>  Card </em>randomCard = nil;</p>
<p>  //判断数组元素个数是否不为0，如果为0，则返回nil<br>  if ([self.cards count]) {</p>
<pre><code>//生成0到[self.cards count]的随机数
NSUInteger index = arc4random() % [self.cards count];

//引用下标为index的元素
randomCard = self.cards[index];

//移除下标为index的元素
[self.cards removeObjectAtIndex:index];
</code></pre><p>  }</p>
<p>  return randomCard;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## 类方法</div><div class="line">---</div><div class="line">**类方法**也叫工厂方法，类方法主要包括两种：</div><div class="line"></div><div class="line">1. **类的初始化**：形成类的实例。</div><div class="line">2. **工具方法**：不经过实例化获得某些数据。</div><div class="line"></div><div class="line">**应用**：用类方法生成四种不同花色：</div></pre></td></tr></table></figure>
<ul>
<li>(NSArray *)ValidSuits<br>{<br>  return @[@”♥︎”,@”♦︎”,@”♣︎”,@”♠︎”];<br>}</li>
</ul>
<ul>
<li>(void)setSuit:(NSString *)suit<br>{<br>  if ([ [PlayingCard ValidSuits] containsObject:suit]) {<pre><code>_suit = suit;
</code></pre>  }<br>}</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">## instancetype</div><div class="line">---</div><div class="line">instancetype的使用目的是确保返回的对象同这条消息要发送到的对象一样。</div><div class="line"></div><div class="line">怎么说？</div><div class="line"></div><div class="line">常用在类的初始化方法的返回值中，因为如果类的初始化返回值是```id```,那么这个指针可以指向任何对象，所以有可能指向非此类的对象类型；</div><div class="line"></div><div class="line">所以，```instancetype```作为初始化方法的返回值后，那么初始化的结果一定会同此类的类型一致。</div><div class="line"></div><div class="line">举个🌰：</div></pre></td></tr></table></figure>
<ul>
<li><p>(instancetype)init<br>{<br>  //检查父类是否初始化成功<br>  self = [super init];</p>
<p>  if (self) {</p>
<pre><code>//初始化代码
</code></pre><p>  }</p>
<p>  return self;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">## 翻牌Demo</div><div class="line">---</div><div class="line">#### 设计需求：</div><div class="line">在界面上显示一张扑克牌，点击后翻牌：如果是正面，点击后就显示背面；如果是背面，点击后显示正面。</div><div class="line"></div><div class="line">#### 效果图：</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">![左：纸牌背面；右：纸牌正面](http://upload-images.jianshu.io/upload_images/859001-191d3037dd166754.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">#### 实现代码：</div><div class="line"></div><div class="line">**1. 点击按钮翻牌**</div></pre></td></tr></table></figure>
<ul>
<li><p>(IBAction)touchCardButton:(UIButton *)sender {</p>
<p>  //先判断牌面：如果按钮的title有字，则为正面<br>  if ([sender.currentTitle length]) {</p>
<pre><code>//1. 背面的UI效果:

//1.1 设置背景图片为背面的图片
[sender setBackgroundImage:[UIImage imageNamed:@&quot;cardBack&quot;] forState:UIControlStateNormal];

//1.2 设置按钮title为空，因为要翻到背面
[sender setTitle:@&quot;&quot; forState:UIControlStateNormal];
</code></pre><p>  }else{</p>
<pre><code>//2. 正面的UI效果:

//2.1 设置背景图片为空
[sender setBackgroundImage:[UIImage imageNamed:@&quot;&quot;] forState:UIControlStateNormal];

//2.2 设置背景颜色为白色
[sender setBackgroundColor:[UIColor whiteColor]];

//2.3 设置按钮title为牌的花色
[sender setTitle:@&quot;A♣︎&quot; forState:UIControlStateNormal];
</code></pre><p>  }</p>
<p>  //翻牌次数记录。同时存在setter和getter方法。首先getter方法取到当前的翻拍次数，然后用setter方法让翻拍次数+1<br>  self.flipCount++;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">**2. 更新按钮UI**</div><div class="line"></div><div class="line">更新按钮的UI的代码放到了属性```flipCount```的setter方法里。</div></pre></td></tr></table></figure>
<ul>
<li><p>(void)setFlipCount:(int)flipCount<br>{<br>  _flipCount = flipCount;</p>
<p>  //在setter方法完成后，设置标签的显示数字<br>  self.flipsLabel.text = [NSString stringWithFormat:@”Flips: %d”, self.flipCount];<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">但是笔者个人认为这种处理方式并不好，因为**一个方法最好只做一件事情**，所以应该将更新按钮UI的代码单独提取出来作为另一个方法:</div></pre></td></tr></table></figure>
<ul>
<li><p>(IBAction)touchCardButton:(UIButton *)sender {</p>
<p>  //先判断牌面：如果按钮的title有字，则为正面<br>  if ([sender.currentTitle length]) {</p>
<pre><code>//背面的UI效果
[sender setBackgroundImage:[UIImage imageNamed:@&quot;cardBack&quot;] forState:UIControlStateNormal];
[sender setTitle:@&quot;&quot; forState:UIControlStateNormal];
</code></pre><p>  }else{</p>
<pre><code>//正面的UI效果
[sender setBackgroundImage:[UIImage imageNamed:@&quot;&quot;] forState:UIControlStateNormal];
[sender setBackgroundColor:[UIColor whiteColor]];
[sender setTitle:@&quot;A♣︎&quot; forState:UIControlStateNormal];
</code></pre><p>  }</p>
<p>  //翻牌次数+1。<br>  self.flipCount++;</p>
<p>  //更新Label显示的数字<br>  [self updateFlipsLabel];<br>}</p>
</li>
</ul>
<p>/**</p>
<ul>
<li>单独提取出更新Label显示的数字的方法<br>*/<ul>
<li>(void)updateFlipsLabel<br>{<br>self.flipsLabel.text = [NSString stringWithFormat:@”Flips: %d”, self.flipCount];<br>}</li>
</ul>
</li>
</ul>
<p>```</p>
<p>这样一来，程序的可读性更高了一点。而且我们还不用重写<code>flipsCount</code>的setter方法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课简单介绍了控件的懒加载(lazy instantiation)，数组，字典，类方法的使用，在最后展示了翻转卡牌的小demo。&lt;/p&gt;
&lt;h2 id=&quot;懒加载-lazy-instantiation&quot;&gt;&lt;a href=&quot;#懒加载-lazy-instantiation&quot; c
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（一）：iOS的MVC框架</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AiOS%E7%9A%84MVC%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（一）：iOS的MVC框架/</id>
    <published>2017-01-11T06:58:09.000Z</published>
    <updated>2017-01-11T06:58:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><hr>
<p>入职iOS开发也有半年了，一直没有积极更新技术博客，感到甚是惭愧。虽然这期斯坦福公开课内容相对基础一些，但是笔者还是想把每一课的内容都总结一下然后分享出去，也算是对自己的锻炼以及对这一经典的课程致敬吧。</p>
<p>课程地址：<a href="http://open.163.com/special/opencourse/ios7.html" target="_blank" rel="external">斯坦福大学公开课：iOS 7应用开发</a></p>
<p>废话少说，开始！</p>
<h2 id="MVC架构介绍"><a href="#MVC架构介绍" class="headerlink" title="MVC架构介绍"></a>MVC架构介绍</h2><hr>
<h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ul>
<li><strong>视图</strong>(View)：构建UI的类；例如：按钮，标签，进度条等。</li>
<li><strong>模型</strong>(Model)：视图类所需要的数据；例如：表格需要显示的文字。</li>
<li><strong>控制器</strong>(Controller)：连接视图类和模型类，任务是使数据显示在屏幕上。例如：控制器将表格需要使用的数据“填入”表格视图中，将表格视图显示出来。</li>
</ul>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul>
<li><strong>控制器可以直接访问模型</strong>：将模型直接作为控制器的属性。</li>
<li><strong>控制器可以直接访问视图</strong>：将视图直接作为控制器的属性。</li>
<li><p><strong>模型与视图无法直接访问对方</strong>：二者完全解耦，不能引用对方，把对方设置为属性。</p>
</li>
<li><p><strong>视图到控制器的通信</strong>：</p>
<ol>
<li><p><strong>目标动作机制</strong>(target - action)：用户与视图交互触发控制器的方法。例如：点击按钮后实现视界面跳转，网络请求，刷新UI等。</p>
</li>
<li><p><strong>委托机制</strong>(delegate)：视图向控制器询问某些自己无法决定的事情，或是让控制器帮助自己做一些自己独立无法完成的事情。 因为控制器才是掌握全局的角色，很多时候视图是无法自己做决定的。例如：表格问控制器：我可以滚动么？然后控制器给予回答告知是否可以继续滚动。 如果表格的高度很小，那么就可以不让它滚动。但是如果表格的高度已经超过了屏幕的高度，这时候如果让它自作主张无法滚动久不好了。                                             </p>
</li>
<li><strong>数据源机制</strong>(dataSource):视图让控制器给它将要显示的数据。例如：音乐的数据存在于模型里，控制器访问模型，从模型里拿到数据后告诉视图如何显示出歌曲。</li>
</ol>
</li>
<li><p><strong>模型到控制器的通信</strong></p>
<ol>
<li><strong>广播机制</strong>(Notification)：控制器注册监听某模型数据变化的广播频道，当此模型数据变化后向该控制器发送广播，告知模型变化情况。</li>
<li><strong>KVO机制</strong>(Key-Value Observing)：模型作为控制器的属性，当模型属性被修改后，持有此模型属性的控制器就会收到通知。</li>
</ol>
</li>
</ul>
<p>下面一张图可以直观看出上述的通信方式。图片来自本课程配套的<a href="https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewPodcast?id=480479762" target="_blank" rel="external">课件</a><br><img src="http://upload-images.jianshu.io/upload_images/859001-492c53ebbb43ad76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS MVC架构"></p>
<h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><hr>
<h3 id="类文件类型："><a href="#类文件类型：" class="headerlink" title="类文件类型："></a>类文件类型：</h3><ul>
<li><strong>.h文件</strong>(头文件):公开API，其他类可以调用的方法，告诉其他类“我能做些什么：<strong>what I can do</strong>。</li>
<li><strong>.m文件</strong>(实现文件):非公开API，如何实现.h文件的方法，查看实现文件可以知道该类具体是如何实现公开API的方法的:<strong>how to do</strong>。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><strong>strong</strong>：在堆中保持这个所指的东西，至少有一个强指针指向它，否则就会释放。</li>
<li><strong>weak</strong>：如果没有强指针指向它，清理指向的内存后，会被设置成nil指针。</li>
<li><strong>nonatomic</strong>：不能有两个线程同时设置该属性。</li>
</ul>
<h3 id="零散知识"><a href="#零散知识" class="headerlink" title="零散知识"></a>零散知识</h3><ul>
<li>所有对象都在堆里，OC会为我们管理这些内存。</li>
<li>访问实例变量，就是访问对象的实例数据。</li>
<li>OC里，可以先实现方法再声明。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><hr>
<p>第一讲里的内容比较基础，重点是介绍了MVC模型的通信机制，需要反复推敲并且在实际操作中<strong>严格遵守</strong>。因为只有这样做才能降低类之间的耦合性，写出易于维护和扩展的代码。</p>
<p>比如在模型类里是不能调用控制器的方法的，模型类只能被控制器调用并且当所拥有的数据改变后通知使用自己的控制器数据的改变。更不能直接给视图通知让视图自己更新UI。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;入职iOS开发也有半年了，一直没有积极更新技术博客，感到甚是惭愧。虽然这期斯坦福公开课内容相对基础一些，但是笔者还
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>程序员的职业素养 - 读书笔记</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%81%8C%E4%B8%9A%E7%B4%A0%E5%85%BB%20-%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/10/程序员的职业素养 - 读书笔记/</id>
    <published>2017-01-10T11:42:23.000Z</published>
    <updated>2017-01-11T05:31:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久木有读书了，因为前两次迭代比较忙，工作下来也在一直写代码。不过还好现在把握好了节奏，有时间读书了。</p>
<p>我找了这本《程序员的职业素养》，内容比较简单，但是涵盖了一些程序员在工作过程中需要注意的一些细节问题，如果读者是程序员的话会对职业有很大帮助的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7f961cd28e79379f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序员的职业素养"></p>
<p>本书一直围绕着“专业”二字展开，以作者的观点阐述了何为”专业的程序员”：专业的程序员是如何思考，如何解决问题，如何承担责任。笔者将一些比较有体会的部分摘录出来，结合自己的心得整理出这篇读书笔记。内容的顺序和书中的顺序基本不符，完全按照笔者按照几大块归类整理而成。</p>
<h1 id="专业的程序员如何写代码"><a href="#专业的程序员如何写代码" class="headerlink" title="专业的程序员如何写代码"></a>专业的程序员如何写代码</h1><hr>
<h2 id="应该写出易于修改的软件"><a href="#应该写出易于修改的软件" class="headerlink" title="应该写出易于修改的软件"></a>应该写出易于修改的软件</h2><blockquote>
<p>所有软件项目的知道原则是，软件要易于修改。如果你希望自己的软件灵活可变，那就应该市场修改它！要证明软件易于修改，唯一的办法就是做些实际的修改。如果你发现这些改动并不像你预想的那样简单，你就应该改进设计，使后续修改改变简单。</p>
</blockquote>
<p>有时开发期已过进入测试阶段，可能还会加一点需求(大家有体会吧)，在开始入职的时候笔者个人是很反感的，因为如果是影响到逻辑上的改动会比较麻烦，每次都要改一些时间。但是反过来想，如果每次改都要很长时间，是否是因为我本来的代码不易扩展和修改呢？所以，今后在写代码的时候要考虑多种可扩展的情况，让代码的可扩展性，可定制性达到很高的水平，这样一来，以后如果要增加需求或者更改需求的时候能够应付自如。</p>
<h2 id="应该尽力让QA找不出任何问题"><a href="#应该尽力让QA找不出任何问题" class="headerlink" title="应该尽力让QA找不出任何问题"></a>应该尽力让QA找不出任何问题</h2><blockquote>
<p>什么样的代码是有缺陷的呢？那些你没把握的代码都是！把自己没有把握的代码发送给QA这么做本身就是不专业的。<br>尽管公司可能设有独立的QA小组专门测试软件，但是开发小组仍然要把“QA应该找不到任何错误”作为努力的目标。</p>
</blockquote>
<p>以笔者短暂的职业经验来看，出bug的地方一定是自己没有完全理解的地方，没有之一，全部命中。所以渐渐的，养成先好好看代码，将逻辑都理清了再重构或者再写代码的习惯，显然出错率少了很多。</p>
<h2 id="应该以零bug为目标"><a href="#应该以零bug为目标" class="headerlink" title="应该以零bug为目标"></a>应该以零bug为目标</h2><blockquote>
<p>没人能写出完美的软件，但这并不表示你不用对不完美负责。不能一而再，再而三犯同样的错误，职业经验多了以后，你的失误率应该快速减少，甚至渐进于零。失误率不可能等于零，但是你有责任让它无线接近于零。</p>
</blockquote>
<h2 id="不应该单打独斗"><a href="#不应该单打独斗" class="headerlink" title="不应该单打独斗"></a>不应该单打独斗</h2><blockquote>
<p>也许你认为自己一个人工作时会做得更好。也许确实如此，但这并不意味着你一个人工作时，整个团队会做得更好。况且，，事实上，一个人单独工作时，不太可能会工作得更好。</p>
</blockquote>
<p>确实是这样的，笔者前一段时间一直是半脱离团队的，有问题也很少请教别人，虽然明知道这样可以节省很多的时间，但是由于笔者的性格比较喜欢独立解决问题，所以经常做一些“自负的行为”。后来渐渐的发现自己做确实吃不消，而且听到团队其他人互相帮助的时候确实为自己省下来不少时间，改掉了这个毛病，效果甚好</p>
<h2 id="应该明确代码的业务价值"><a href="#应该明确代码的业务价值" class="headerlink" title="应该明确代码的业务价值"></a>应该明确代码的业务价值</h2><blockquote>
<p>专业程序员的首要职责是满足雇主的需求。这意味着要和你的经理们，业务分析师们，测试工程师们和其他团队成员很好地协作，深刻理解业务目标。你需要理解手上正在编写的代码的业务价值是什么了解你的企业将如何从你的工作中获得回报。</p>
<p>专业程序员会花时间去理解业务。他们会和用户讨论他们正在使用的软件，会和销售人员和市场人员讨论所遭遇的问题，会和经理沟通，明确团队的短期目标和长期目标。</p>
</blockquote>
<h1 id="专业的程序员如何沟通"><a href="#专业的程序员如何沟通" class="headerlink" title="专业的程序员如何沟通"></a>专业的程序员如何沟通</h1><hr>
<h2 id="应该准确把握“完成”的定义"><a href="#应该准确把握“完成”的定义" class="headerlink" title="应该准确把握“完成”的定义"></a>应该准确把握“完成”的定义</h2><blockquote>
<p>专业开发人员的“完成”只有一个含义：完成，就是完成。<br>完成意味着所有的代码都写完了，所有的测试都通过了，QA和需求方已经认可，这，才是完成。</p>
</blockquote>
<h2 id="应该准确预估"><a href="#应该准确预估" class="headerlink" title="应该准确预估"></a>应该准确预估</h2><blockquote>
<p>将大任务分成许多小任务，分开预估再加总，结果回避单独评估大任务要准确很多。这样做之所以能提高准确度，是因为小人物的预估错误几乎可以忽略不会对总的结果产生明显影响。</p>
</blockquote>
<h2 id="不应为了保住颜面而虚报事实"><a href="#不应为了保住颜面而虚报事实" class="headerlink" title="不应为了保住颜面而虚报事实"></a>不应为了保住颜面而虚报事实</h2><blockquote>
<p>我忽略了测试环节，整个过程中只考虑如何保全自己的颜面，却没有估计客户和雇主的声誉。我本该早点担起责任，告诉Tom测试还未完成，自己不能按时交付产品。</p>
</blockquote>
<p>其实刚进公司的时候自己也是蛮好面子的，生怕同事觉得自己技术不过关，有的时候跟人家说完全做完了，但是实际上晚上回家后开夜车写代码才给搞定。其实这种习惯是不好的，虽然表面上看来还不错，但是实际上为了颜面而不考虑效率将工作推到回家之后显然是不专业的。做完了就说做完了，没做完就说没做完，没有任何借口，就算做不完也要好好想想为什么没有及时完成，找到提高效率的方法才是专业的态度。而不是想着“反正有晚上呢”，通过时间的积累来解决问题。</p>
<blockquote>
<p>专业人士敢于说明真相而不屈从于权势。专业人士有勇气对他们的经理说“不”。你的经理期望的是，你能像他那样竭尽所能地捍卫自己的目标，这样你们才能得到可能的最好结果。      </p>
</blockquote>
<p>当你的能力明显达不到经理的期望的工期的时候，要敢于说“不可能”。要说明自己尽力所能达到的效果，要让经理知道实际情况，跟经理一起找到双方都能接受的解决方案，而不是屈服于权势而打肿脸充胖子，因为如果你没能实现你的“豪言壮语”，背锅的就是你。</p>
<h2 id="应该提供真正的承诺"><a href="#应该提供真正的承诺" class="headerlink" title="应该提供真正的承诺"></a>应该提供真正的承诺</h2><blockquote>
<p>真正的承诺：对自己将会做的事情做了清晰的陈述，还明确说明了完成期限。</p>
</blockquote>
<p>没能履行承诺的原因以及解决方法：</p>
<ol>
<li>依赖其他的事情，只承诺自己完全掌控的事情。</li>
<li>如果不确信是否能完成，应该全力前进，使用可以支配的全部时间来完成。</li>
<li>如果遇到突发事件导致无法按时完成，要及时向承诺对象发出预警，越早越好，以便于整个团队采取措施作出对策。</li>
</ol>
<h2 id="应该用数据争论。"><a href="#应该用数据争论。" class="headerlink" title="应该用数据争论。"></a>应该用数据争论。</h2><blockquote>
<p>凡是不能在5分钟内解决的争论，都不能靠辩说解决。争论之所以要花这么多时间，是因为各方都拿不出足够有力的证据。所以这类争论依据的不是事实，而是信念。在没有数据的情况下，如果观点无法在短时间达成一致，就永远无法达成一致，唯一的出路是，用数据争论。</p>
<p>切忌用个人能力赢得争论。他们可能提高嗓门，近距离与你对视，或者摆出不屑的姿态。但这都不重要，长期来看，强力是无法解决争论的，最终还是要需要数据。</p>
</blockquote>
<h1 id="专业的程序员如何自我管理"><a href="#专业的程序员如何自我管理" class="headerlink" title="专业的程序员如何自我管理"></a>专业的程序员如何自我管理</h1><hr>
<h2 id="应该不断的学习"><a href="#应该不断的学习" class="headerlink" title="应该不断的学习"></a>应该不断的学习</h2><blockquote>
<p>在工作余下的时间里花点时间为雇主工作也是合理的，但是别忘了，那20个小时是为你自己的，它们会让你成为更有价值的专业人士。</p>
</blockquote>
<p>我通常会把学习的时间分为两种：第一种是学习纯iOS知识，另一种是学习提高代码能力的知识。</p>
<p>前一种知识我选择相对于自己目前的水平稍微难一点的知识，这样一来，学习起来也不累，而且提升效果也比较明显。就好比敏捷开发：对于自己的学习，也就着轻量迭代，快速迭代的原则。</p>
<p>后一种知识我选择一些能提高代码效率和质量的书，而且还有一些提升程序员素质和视野的书(就好比这一本)，因为我认为人不论做什么事情，都要跳出这件事本身，以更高的层次来思考。</p>
<h2 id="应该勤于练习"><a href="#应该勤于练习" class="headerlink" title="应该勤于练习"></a>应该勤于练习</h2><blockquote>
<p>只完成日常工作是不足以成为练习的，那只能算是种执行性质的操作，而不是练习。练习指的是日常工作之余专门练习技能，以自我提升。</p>
</blockquote>
<p>说来惭愧，入职这段时间只是总结之而已，包括工作中学到的知识和下来自己学习的知识。但是从未刻意练习过某项技术。前一阵子看到一篇文章说是将一本书的代码抄7遍来练习，效果显著，而那本书恰是iOS领域的:《Effective Objective-C 2.0  编写高质量iOS与OS X代码的52个有效方法》。等这次迭代结束之后我打算尝试一下。</p>
<h2 id="应该保持精力充沛"><a href="#应该保持精力充沛" class="headerlink" title="应该保持精力充沛"></a>应该保持精力充沛</h2><blockquote>
<p>疲劳的时候，千万不要写代码。奉献精神和职业素养，更多意义上指要遵循纪律原则而非成为长时间工作的工作狂。要确保自己已经将睡眠，健康和生活方式调整到最佳状况，这样才能在每天8个小时的工作时间内全力以赴。</p>
</blockquote>
<p>关于这一点，笔者需要好好检讨自己了。之前因为独立负责公司一个项目，为了要项目如期上线，每天都工作到2点以后，虽然产品如期上线，但是回想一下过程发现，完成的效率并不是很高，由于有些地方需要重写，浪费了不少时间。在这之后，尽量调整自己的生物钟，将睡觉的时间渐渐提前，效果甚好。</p>
<h2 id="专业程序员的时间管理"><a href="#专业程序员的时间管理" class="headerlink" title="专业程序员的时间管理"></a>专业程序员的时间管理</h2><blockquote>
<p>邀请你参加会议的人并不负责管理你的时间，为时间负责的只有你，所以，如果你收到会议邀请，务必确保出席会议可以给自己目前的工作带来切实显著的成效，否则不参与。</p>
<p>你应当明白，继续待在会议室里是浪费时间；就行参加对你没有太多意义的会议，是不专业的行为。因为你有责任合理分配老板给你的时间和金钱，所以，选个何时的机会行亮如何离席，并非不专业的做法。</p>
</blockquote>
<p>书的作者在最后推崇了学徒制，呼吁了在专业毕业生毕业后进公司时不应该马上投入工作，而是应该采取学徒制来对毕业生进行大学内无法提供的教育。</p>
<h2 id="推崇学徒制"><a href="#推崇学徒制" class="headerlink" title="推崇学徒制"></a>推崇学徒制</h2><blockquote>
<p>学校能够传授的是计算机编程的理论。但是学校并不会也无法传授作为一名编程匠者所需要掌握的原则，实践和技能。这些东西只有经由师徒个体间多年的细心度到和辅导才能获得。软件行业中像我们这样的一批人必须要面对这一事实，即指引下一代软件开发人员成熟起来的重任无法寄希望于大学教育，现在这个重任已经落到了我们的肩上。建立一种包含学徒期，实习期和长期指引的机制已经是迫在眉睫。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久木有读书了，因为前两次迭代比较忙，工作下来也在一直写代码。不过还好现在把握好了节奏，有时间读书了。&lt;/p&gt;
&lt;p&gt;我找了这本《程序员的职业素养》，内容比较简单，但是涵盖了一些程序员在工作过程中需要注意的一些细节问题，如果读者是程序员的话会对职业有很大帮助的。&lt;/p&gt;
&lt;
    
    </summary>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="IT" scheme="https://github.com/knightsj/knightsj.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>程序员的修炼：从优秀到卓越 - 读书笔记</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/10/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BF%AE%E7%82%BC%EF%BC%9A%E4%BB%8E%E4%BC%98%E7%A7%80%E5%88%B0%E5%8D%93%E8%B6%8A%20-%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/10/程序员的修炼：从优秀到卓越 - 读书笔记/</id>
    <published>2017-01-10T11:41:15.000Z</published>
    <updated>2017-01-11T05:32:01.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-f3a3b8377fa20a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="程序员的修炼 - 从优秀到卓越"></p>
<p>本书是笔者上一篇读书笔记<a href="http://www.jianshu.com/p/33933a3ba977" target="_blank" rel="external">高效能程序员的修炼</a>的姊妹篇，同样介绍了一些程序员需要了解的，有关于编程本身以外的一些事情。</p>
<p>和上一篇读书笔记的风格类似，笔者摘录了几段原书内容并结合了作者的感悟写下了这篇读书笔记。笔者还是深切希望各路英雄能提出宝贵的意见和想法。</p>
<hr>
<h3 id="关于-To-Do-list"><a href="#关于-To-Do-list" class="headerlink" title="关于 To-Do list"></a>关于 To-Do list</h3><blockquote>
<p>这个冗长的To-Do列表始终存在着，像一把悬挂在我头顶上的利刃，而且每天都在变得更加沉重和锋利。</p>
<p>每天早上使劲想出这天你需要做的最重要的3件事。</p>
</blockquote>
<p>其实对于待办事项列表，笔者也读过相关的书籍，一般都是不推荐使用待办事项列表的。笔者总结出原因有二：</p>
<ul>
<li><p>待办事项列表上面的待办事项只是列出了还未完成的事情而已，并不带有“何时开始进行”和“何时完成“的信息。简单说，就是只有“what to do”而没有“when to do”和“when to finish”。也就是它本身能带给列表主人的驱动力不够高。</p>
</li>
<li><p>正是因为待办事项列表带给主人的驱动力不高，那么结果就是它们一直会躺在列表里持续很长时间。那么它们的主人在潜意识中一直挂念着它们，分散了主人的精力。因为主人“知道”总有一些事情还是没有完成的。 </p>
</li>
</ul>
<hr>
<h3 id="关于探索的态度"><a href="#关于探索的态度" class="headerlink" title="关于探索的态度"></a>关于探索的态度</h3><blockquote>
<p>比起专业技能或者智商，成功更需要一种探索的态度，它是一种对于可能性和失败后果的执着。那些具备良好潜质的人总是会做出类似的回答“我总是在犯一些作物。昨天刚发生了一件挺严重的事情，前因后果是这样的。。。”。</p>
<p>相反，那些回答“我并没有犯过大错误”或者“我犯过一些严重的错误，但是错误的原因并不在于我”的人是不会成为杰出的外科医生的。</p>
</blockquote>
<p>探索的态度对于程序员也是尤为重要的。笔者在开始写代码的时候总是以“解决问题就万事大吉”的标准，遇到了可能的坑却睁一只眼闭一只眼。但是每每这样的时候，后来总是会出bug。</p>
<p>其实这就是逃避，就是一种缺乏探索精神的表现。其实我把那些坑弄懂了也不需要多少时间嘛。弄懂了，以后再遇到就稳稳当当搞定了。没弄懂，就还是踩坑。突然想到了一句话：遇到问题，你硬着头皮解决了一半，就只剩下一半的问题。但是你逃避，就是两个问题了。</p>
<blockquote>
<p>不管你在做什么项目，怀揣着学习和锻炼的态度去完成它吧，这是绝对值得的！与项目结果相比，过程才是最大的财富。如果你没能从一个项目的过程中学到一点东西，这才是真正失败的项目。</p>
</blockquote>
<hr>
<h3 id="关于专家"><a href="#关于专家" class="headerlink" title="关于专家"></a>关于专家</h3><blockquote>
<p>这个世界上只有少数的专家，却有大量的普通人。当你想要建立一个包含各种信息的网站时，这些普通人的贡献是最重要的。这是一个不规则的世界，里面装满了无穷无尽的细节。</p>
<p>作为专家，重要的是不是告诉别人你知道什么。而是要清楚你应该问什么样的问题，并且灵活运用你所掌握的知识去解决眼下的具体问题。作为专家，你的作用是提供明确的，可执行的方向。</p>
</blockquote>
<p>读到这些，笔者觉得专家理应受到种种质疑，而为了能经得起这些质疑，那么就不应该跟人家说“我读了神马神马著作，精通神马神马技术，你看我的论文，你看我的研究成果等等”，真正证明自己是专家的途径，一般只有帮助非专家人士或者别的专家高效地解决问题。</p>
<p>其实，庞大的知识体系也是对解决问题帮助很大的：因为这些有着庞大知识体系的专家的晶体智力水平很高，很多时候，他们并不需要动脑子(也就是流体智力)，直接调出相应知识就能解决。所以说，那些自称专家的人如果连连无法解决问题的话，那么真的是low爆了。</p>
<hr>
<h3 id="关于软件项目管理"><a href="#关于软件项目管理" class="headerlink" title="关于软件项目管理"></a>关于软件项目管理</h3><blockquote>
<p>鼓励并强制要求程序员创建一张他们所要做的全部事情的列表，然后尽可能添加所有的子项，这样就能估算这个任务话费多少时间了。</p>
<p>如果有人问你的时间表，你应该拿出一张你要做的所有事情的列表。如果拿不出来，你所要做的第一件事情，就是要做出这么一张列表。</p>
</blockquote>
<p>这种列表和待办事项列表稍有不同。这种列表属于“时间表”，它的目的是监控进度:所以说，它的时间总长度是不变的。但是待办事项列表的时间总长度是趋于“无限的”(当然，只对于执行力很差的人来说)。</p>
<hr>
<h3 id="关于“一夜成名”"><a href="#关于“一夜成名”" class="headerlink" title="关于“一夜成名”"></a>关于“一夜成名”</h3><blockquote>
<p>一夜成名的传说容易让人误入歧途，并且遗毒不浅。如果你打算做一个全新的东西，要有打持久战的准备。</p>
<p>勤于练习：不是一遍又一遍的简单重复，而是要不断挑战略微超出自身能力之外的任务-努力尝试，并在做的同时以及之后对自己的表现进行评估，然后纠正错误，如此反复。</p>
</blockquote>
<p>这里谈到了程序员对自己本身的迭代：快速迭代。其实同软件开发是一个道理：软件迭代的速度远重要于迭代的质量。也就是说，我们在学习的过程中，对自己的提升也应该是快速而轻盈的。</p>
<p>切忌一口气吃个胖子，肯定是吃不消的。应该结合自己已有的知识水平，再寻找对自己来说稍微有点挑战性的技术来攻克，一来学习效率高，二来可以提升自信，进入到新一轮的学习中去。</p>
<hr>
<h3 id="关于优秀和平庸程序员之间的鸿沟"><a href="#关于优秀和平庸程序员之间的鸿沟" class="headerlink" title="关于优秀和平庸程序员之间的鸿沟"></a>关于优秀和平庸程序员之间的鸿沟</h3><blockquote>
<ul>
<li>成为更加优秀的程序员的方法是抛开编程。</li>
<li>你的兴趣越广泛，就能越胜任你的工作。</li>
<li>为了真正地成为一名更好的程序员，你必须培养自己对于编程周边所有事情的热情。</li>
<li>单单靠编程，你只能补足或者增强自己已有的变成技能，永远也无法成为一名优秀的程序员。你需要尝试去了解你的客户，你所处的行业以及相关的业务。</li>
<li>聪明的开发者知道，他们的工作远远不止编写代码和发布产品：他们的工作是开发出人们真正想要使用的软件。这当然包括编码，但还有大量全局性的其他事情，比如撰写技术文档，交互设计，培养用户社区，乃至产品愿景，这些对于软件的全貌成功都是至关重要的。</li>
</ul>
<hr>
</blockquote>
<h3 id="关于修复bug"><a href="#关于修复bug" class="headerlink" title="关于修复bug"></a>关于修复bug</h3><blockquote>
<p>在对报告数据的广泛分析之后，我们看到：80%的客服问题在修复了用户报得最多的20%的bug之后就得到解决。即使修复用户报的最多的1%的bug，也能解决50%的客服问题。这个分析结果通常对于各家公司都是成立的。</p>
<p>如果你修复了一个真实用户永远也碰不到的bug，那你修复有什么价值呢？</p>
<p>你越快将你的软件推到真实用户面前，就会得到越多的数据来改进你的软件。问题不在于你在发布软件的时候带去了多少bug，而是在于你能多快地修复那些bug。</p>
</blockquote>
<p>因此，笔者认为在bug管理的问题上，要注意两点：</p>
<ul>
<li>不要怕将bug暴露在用户面前，尽早地收集用户的反馈数据是关键。</li>
<li>而且，在收到大量的反馈数据之后，也应遵循二八定律，要以bug的影响程度来划分bug的优先级,不应盲目排列修改bug的顺序。</li>
</ul>
<hr>
<h3 id="关于衡量软件的成功"><a href="#关于衡量软件的成功" class="headerlink" title="关于衡量软件的成功"></a>关于衡量软件的成功</h3><blockquote>
<p>多少用户在真正使用你的软件？这才是衡量成功的终极标准。</p>
</blockquote>
<p>其实无论交互多绚丽，功能多么吊炸天，一旦用户不需要，用户不喜欢，不掏钱，其实是没有任何卵用的。而且在一定的技术水准上，如果无法“说服”大量客户使用产品，也同样是让人心痛的。</p>
<ul>
<li>技术再牛也要从用户体验出发，少做一些中看不中用的东西。想出数百个功能很容易，但是从中挑出几个可以提升用户体验，真正能吸引用户，让用户掏腰包的功能实在不易。</li>
</ul>
<ul>
<li>产品做出来了，产品有没有人用，营销和推广同时占有举足轻重的作用。突然想到以前在一本营销书籍看到的：能做出比麦当劳好吃的汉堡包很容易，但是能比麦当劳卖得好却是很难得，众人难以模仿麦当劳整体的营销模式。相同的，像ZARA品牌的生产模式和营销模式之高效，是其他品牌无法超越的，这也是其风靡全球的原因。</li>
</ul>
<hr>
<h3 id="关于用户的谎言"><a href="#关于用户的谎言" class="headerlink" title="关于用户的谎言"></a>关于用户的谎言</h3><blockquote>
<ul>
<li>我们必须根据用户的实际行为模式来设计产品。</li>
<li>他们会说喜欢你的软件。但是我们应该去观察他们是否使用了软件，以及他们是怎么使用的。基于行为数据去设计软件，而不是靠用户说的“谎言”。</li>
</ul>
</blockquote>
<p>笔者认为，我们很少能从用户言语上得到用户特别真实的感受。那些善良的客户们有时碍于面子，有时想当和事老，凭着“你好我好大家好”的原则，说一些心里没有的，善意的谎言。</p>
<p>所以那些问卷调查什么的，走街串巷访问什么的其实意义不大。真正能“窥视”用户内心的是那些技术埋点。我记得有一次参加一个分享会，触宝科技的CEO跟大家分享了他们的埋点:他们通过埋点的方式，甚至会知道导致用户删掉app的是哪几个界面和动作。这让我感触很大，既然能做到这些，那么如果想知道用户喜欢点击那里，喜欢看哪里，喜欢做那几个动作，岂不是轻而易举？知己知彼，百战岂殆？</p>
<hr>
<h3 id="最后作者推荐的书籍"><a href="#最后作者推荐的书籍" class="headerlink" title="最后作者推荐的书籍"></a>最后作者推荐的书籍</h3><ol>
<li>《代码大全(第二版)》</li>
<li>《点石成金：访客至上的网页设计秘籍》</li>
<li>《人件》</li>
<li>《程序员修炼之道：从小工到专家》</li>
<li>《软件工程的事实与谬误》</li>
</ol>
<p>其中第1本和第4本笔者在看。第1本对于非科班出身的笔者来说实在是晦涩难懂。不过既然作者说读完此书就能超过90%的程序员，那么不失为一个节省时间的好方法。以后有机会的话，希望能和各路英雄讨论讨论个中奥妙。</p>
<hr>
<h3 id="笔者最后的话"><a href="#笔者最后的话" class="headerlink" title="笔者最后的话"></a>笔者最后的话</h3><p>其实还是希望能和各位相互讨论，其实相比于文章被“喜欢”，笔者更希望诸位能留下评论，毫不留情地指出小弟想法中的不妥之处，这些是远比“打赏”和“喜欢”更让小弟高兴的呢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-f3a3b8377fa20a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
    
    </summary>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="IT" scheme="https://github.com/knightsj/knightsj.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>高效能程序员的修炼 - 读书笔记</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/10/%E9%AB%98%E6%95%88%E8%83%BD%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E4%BF%AE%E7%82%BC%20-%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/10/高效能程序员的修炼 - 读书笔记/</id>
    <published>2017-01-10T11:39:48.000Z</published>
    <updated>2017-01-11T05:31:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-d4f6ace667765fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="高效能程序员的修炼"></p>
<p>俗话说：程序员不能只想着写代码。在编程以外的闲暇时间，读一点这种有助于程序员扩展视野和提高素养的书籍是很好的。</p>
<p>笔者找到了这本《高效能程序员的修炼》：本书作者是大名鼎鼎<a href="http://stackoverflow.com/" target="_blank" rel="external">Stack Overflow</a>的创始人Jeff Atwood，内容是有关代码以外的，需要每个程序员思考和注意的事情。</p>
<p>这本书是笔者在今年1月份看的，因为忙于项目开发，所以没有整理好笔记。正好这周五公司app提交过审，有空宅在家里整理一下。笔记内容没有提到书中所说的每个方面，<strong>只是针对了笔者觉得比较重要的几点并结合了笔者自己的想法和感悟整理而成</strong>。</p>
<p>笔者的<strong>读书笔记的格式</strong>：<br><strong>标题</strong>：与书中目录不符，完全由笔者自己列出。<br><strong>正文</strong>：浅灰色框中的文字为书中摘录，其他部分均为笔者个人观点。</p>
<p><strong>欢迎各路大侠指点！欢迎各路大侠指点！欢迎各路大侠指点！</strong></p>
<hr>
<h2 id="关于选择工作"><a href="#关于选择工作" class="headerlink" title="关于选择工作"></a>关于选择工作</h2><blockquote>
<p>我更建议人们先花时间想想，什么样的问题才是他们真正热爱和感兴趣的，然后再好好研究这些问题。生命中最难的，是想清楚你真正想要做的事情，而不是学上一堆假设将来会有用的东西。</p>
</blockquote>
<p>所以说在决定这种人生大事上，确实要花上心思，就好比笔者自己在通信工程专业从本科一直念完了硕士，拿到硕士学位证后花了一周的时间苦思冥想，探求内心后，毅然决定做软件，顶住各方压力(因为毕竟是换专业择业，不过还好父母还是一直很支持我的)三个月的时间自学了iOS开发。<br>如今已经入职4个月，在工作学习中甚感愉快，虽然有时会有压力，但是每天都过得很开心，因为这正是我想做的。</p>
<hr>
<h2 id="关于程序员的表达能力"><a href="#关于程序员的表达能力" class="headerlink" title="关于程序员的表达能力"></a>关于程序员的表达能力</h2><blockquote>
<p>杰出的程序员和勉强过得去的程序员之间的差别是他们能不能把他们的想法表达清楚。</p>
</blockquote>
<p>大家应该不会怀疑程序员的平均智商，但是程序员中每个人的表达能力却参差不齐，差别极大。其实有些时候头脑中想到的方法可能是在潜意识下想到的，如果这时候需要我们有条理地说出来，确实不是一件容易的事。</p>
<p>像这种用意识层面的语言来表达潜意识的思考的能力确实是值得锻炼的。试想一下，如果我们能把自己潜意识层面的思考准确地再现于意识层面，那么这显然会有助于帮助我们检查思维的缜密性和正确性，而且也会锻炼我们的逻辑思维，从而能更好地去思考，形成良性循环。</p>
<hr>
<h2 id="关于程序员的学习："><a href="#关于程序员的学习：" class="headerlink" title="关于程序员的学习："></a>关于程序员的学习：</h2><blockquote>
<p>勤加练习固然重要，但是只顾着买头写代码，没有讨论和反思的时间，那么是无法得到真正的进步的。在阅读博客和相关书籍的过程中，从自身利益出发去考虑，如果我们能从中找到哪怕一点对我们有用的东西，其实就已经很赚了。</p>
</blockquote>
<p>复习和反思是学习过程中很重要的环节，如果没有及时的复习与反思，那么往往事倍公半：忘记知识，而且就算不忘，也无法高效地将知识提取出来。作为程序员，应该适当脱离键盘反复思考，将学到的知识高效地整合到自己的知识结构中，有助于知识的提取和运用。</p>
<hr>
<h3 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h3><ul>
<li>评价及代码的几个维度:从简洁性开始，依据测试的结果按需提升其他的维度。<blockquote>
<ol>
<li>代码简洁度</li>
<li>功能完整性</li>
<li>执行速度</li>
<li>编码所花费时间</li>
<li>健壮性</li>
<li>灵活性</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li>你的代码越多，bug能藏身的地方就越多。</li>
<li>最好的代码就是完全没有代码。</li>
</ul>
<hr>
<h2 id="关于代码的注释"><a href="#关于代码的注释" class="headerlink" title="关于代码的注释"></a>关于代码的注释</h2><blockquote>
<ul>
<li>注释需要说：程序<strong>为什么</strong>这样工作。</li>
<li>你应该总是专注于编写代码，而忘了还有注释这种东西的存在。</li>
<li>当我脑子里了一个明确的目标，并且有一段复杂的代码要写时，我会把时间花在时间代码上面，而不是写下他的故事，讲给我自己听。</li>
<li>如果你的代码在没有注释的情况下显得过于复杂，很难被人理解，那只能说明你的代码写得太早了，重写代码，直到它不再需要任何注释。</li>
</ul>
</blockquote>
<p>读到这里的时候笔者很是惭愧。因为笔者在写代码的时候，是将代码和注释一起写的。所以应该将这个习惯改过来：写代码的时候忘记注释，应该尽全力用代码自己解释逻辑。到最后逻辑达到很清晰的程度后，再加上必要的注释：为什么用的是这个逻辑。</p>
<hr>
<h3 id="关于请教问题"><a href="#关于请教问题" class="headerlink" title="关于请教问题"></a>关于请教问题</h3><blockquote>
<ul>
<li><p>向别人请教问题：</p>
<ol>
<li>提供足够多的细节描述发生的状况</li>
<li>说明你为什么需要这个答案</li>
<li>表述你所做的研究和发现</li>
</ol>
</li>
<li><p>如果你想让别人花上宝贵的时间来帮助你，你也要花了宝贵的时间酝酿出一个合格的问题才算公平。</p>
</li>
</ul>
</blockquote>
<p>笔者在工作中也会请教同事问题，前几次问的时候发现自己将问题说出来之后，自己头脑里已经有了解决的办法，而且觉得很简单。所以后来想问问题的时候，保证自己先解决一般问题，将问题深入，然后尽可能问出高质量的问题来。</p>
<hr>
<h3 id="关于提出问题"><a href="#关于提出问题" class="headerlink" title="关于提出问题"></a>关于提出问题</h3><blockquote>
<ul>
<li>提出正确的问题差不多已经把问题解决了一半。</li>
<li>完全投入地向一个假想中的人或者是没有生命的物体问一个透彻而相近的问题。</li>
</ul>
</blockquote>
<p>笔者认为如果是对一个无生命体，大脑中负责情感的部分会被抑制，会更加促进理性分析，更加清晰地表述问题(因为你的潜意识知道<em>小黄鸭*</em>是不会“理解”你的话里半点遗漏的点)。</p>
<hr>
<h2 id="关于创意和执行"><a href="#关于创意和执行" class="headerlink" title="关于创意和执行"></a>关于创意和执行</h2><blockquote>
<ul>
<li>如果你想要赚钱，你必须把这两者相乘，除非创意被执行，否则它一文不值，执行是创意的倍增器，真正价值巨大的是执行。</li>
</ul>
<ul>
<li>与其担心你全心投入等下一个创意是否足够出色，不如担心你能执行的多好。</li>
</ul>
<ul>
<li>在软件开发领域，执行意味着专注于构成你的应用程序的所有微小细节，如果你不是始终沉迷于你的应用程序的每个方面，不去优化和赶紧它的每一处细节，那么你就不是在执行，至少，不是在很好地执行。</li>
</ul>
</blockquote>
<hr>
<h2 id="关于团队"><a href="#关于团队" class="headerlink" title="关于团队"></a>关于团队</h2><blockquote>
<ul>
<li>如果你把一个好的创意给一个普通的团队，他们会把它搞砸。如果你把一个普通的创意给一个好的团队，他们会对它加以完善，或者他们会把那个创意丢掉，然后相处一些更棒的 - Catmull”</li>
</ul>
<ul>
<li>如果你想取得成功，不要担心没有伟大的创意，转而去专注于培养卓越的团队。</li>
</ul>
</blockquote>
<hr>
<h3 id="关于会议："><a href="#关于会议：" class="headerlink" title="关于会议："></a>关于会议：</h3><blockquote>
<p>会议绝不应该超过一个小时。<br>每个会议都要有一个清晰的目标声明。<br>在开户之前做好功课：提前知道将要讨论和分享的内容。<br>把会议变成可选的：每一个人都因为他们想要在那里，或者需要在那里。<br>会议结束后，概括一下待办事项。</p>
</blockquote>
<p>其实会议确实比较耗费时间，所以就要为了提升会议的效率和价值：</p>
<ol>
<li>在会议开始前：熟悉会议内容并提前思考。</li>
<li>在会议结束前：整理会议结果，列个待办事项。</li>
<li>在会议结束后：执行！执行！执行！</li>
</ol>
<hr>
<h2 id="关于用户和产品"><a href="#关于用户和产品" class="headerlink" title="关于用户和产品"></a>关于用户和产品</h2><blockquote>
<ul>
<li><p>用户不会阅读你屏幕上的任何东西。用户只会读取屏幕上足以让他们完成任务的，最少量的文字。</p>
</li>
<li><p>与世隔绝在实验室花上三个月的时间修复第一版里的问题，不如把这3个月的时间用于倾听来自真实世界里使用你的软件的用户提出的反馈。</p>
</li>
</ul>
</blockquote>
<p>这两条分别告诉我们：</p>
<ol>
<li>我们在做产品的时候，应该把用户当成“弱视不会思考”的人。</li>
<li>用户可以“为我们所用”。</li>
</ol>
<p>看似是矛盾的两点，但确是提升用户体验的“黄金理论”。<br>对于第一条，笔者深有体验:笔者做了一个类似新手引导的教程，因为队友修改了页面加载的逻辑，导致了用户只能通过，点击，滑动，手动加载后才能出现看到教程的情况，而刚看到页面时，教程是不会自动出来的，其实这个体验是很差的，因为用户需要自己动手。但是当时由于已经处于测试末尾阶段，我个人也没有在意。</p>
<p>在跟产品经理交流后，产品经理人很好，只是说了最好要加上。我想了想还是加了，添加的方法很简单，只是在<code>viewWillAppear</code>方法里加了触发的逻辑，但却发现体验直线上升。这件事对我感触很大，只是一两行代码就能明显改善用户体验，那么为什么不去做呢？为什么一定要去麻烦用户去动脑，去动手呢？</p>
<hr>
<h3 id="笔者结语："><a href="#笔者结语：" class="headerlink" title="笔者结语："></a>笔者结语：</h3><p>本书中，作者说的点还是蛮多的，比较杂，但确是引发程序员代码之外思考的好的启蒙，有助于不让程序员局限于代码之中，能够多角度，多层面考虑问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-d4f6ace667765fd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
    
    </summary>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="IT" scheme="https://github.com/knightsj/knightsj.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>如何高效学习 - 读书笔记</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/10/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%20-%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/10/如何高效学习 - 读书笔记/</id>
    <published>2017-01-10T11:29:01.000Z</published>
    <updated>2017-01-11T05:32:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-19e2323f8483e093.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="如何高效学习"></p>
<p>笔者的话：本书介绍了整体性学习法，强调在学习过程中，需要通过比喻和抽象的方法，将新知识与旧知识相互联系，以提高学习效率和深度的学习方法。笔者亲测，甚是有效，在此强烈推荐给大家。</p>
<h1 id="Part-1-整体性学习策略"><a href="#Part-1-整体性学习策略" class="headerlink" title="Part 1 整体性学习策略"></a>Part 1 整体性学习策略</h1><hr>
<h2 id="1-1-什么是整体性学习"><a href="#1-1-什么是整体性学习" class="headerlink" title="1.1 什么是整体性学习"></a>1.1 什么是整体性学习</h2><ul>
<li>整体性学习需要采取多种途径综合学习，而不是试图在大脑中复制一个完美的拷贝。</li>
<li>整体性学习是运用你大脑里已有的丰富的神经元网络吸收、整合信息。</li>
<li>整体性学习在于创造<strong>信息的网络</strong>，一个知识与另一个知识相互关联，那些相互关联的知识网络使你真正做到对知识的完全理解，从而轻松地驾驭知识。</li>
</ul>
<p>##1.2 整体性学习基于三种主要观点</p>
<ol>
<li>结构</li>
<li>模型</li>
<li>高速公路</li>
</ol>
<h3 id="1-21-结构"><a href="#1-21-结构" class="headerlink" title="1.21 结构"></a>1.21 结构</h3><p>结构就是说一系列紧密联系的知识体系。</p>
<blockquote>
<p>打个比方：结构就好像你思想中的一座城市，在城市中有很多建筑物，建筑物之间有道路相连，有些建筑高大而且重要，与城市中的其他建筑有上百条路相连。理解就是结构<strong>高度发达完善</strong>的结果。</p>
</blockquote>
<ul>
<li><p>是不是有些学科你可以轻松“拿下”？你读起这些科目的书毫不费力、兴趣盎然，一切内容看起来那么浅显、通俗，原因何在？因为你的脑袋里已经有这些科目的发达知识结构。假如说结构就是脑袋里的城市的话，那么这些城市一定是道路四通八达、路面整洁而且交通井然有序，虽然车水马龙，却从不见交通堵塞。</p>
</li>
<li><p>相反，为什么有些学科理解起来那么困难呢？这说明城市简陋，道路不畅，甚至乱建一气，违章建筑、豆腐渣工程比比皆是，有些道路甚至无所指向。建立良好的知识结构就是绘制一份优秀的地图，就是建造一座设计良好的城市。所以建立知识结构时，你的目标就是<strong>在各种知识之间建立尽可能多的联系</strong>，聪明的人会很自然地这么做，每学习一个新概念，都会自动地与其他知识相联系。</p>
</li>
</ul>
<p>###1.22 模型<br>模型是简化的结构，是结构的快照，更为简单和更易储存。通过将一些<strong>核心概念</strong>联系在一起，就可以创建一个模型。打个比方：书的目录。模型是一种压缩形式，它把多个关键思想压至一处。模型就像是结构的种子，是一座建筑的地基和框架，是知识最核心的概念，在此基础上将引出全部的知识。</p>
<p>###1.23 高速公路<br>高速公路是知识体系(结构)间的联系。</p>
<blockquote>
<p>打个比方：城市之间的高速公路。高速公路能激发创造力。“跳出盒子”之外思考最恰当地描述了那些在结构之外思考的人们。高速公路让他们以前所未有的方式思考，以不曾想过的方式将常人眼里风马牛不相及的专业联系在一起思考，这就是创造。利用高速公路可以在专业交叉的领域建立起新的结构。</p>
</blockquote>
<p>##1.3 整体性学习的顺序</p>
<ol>
<li>获取</li>
<li>理解</li>
<li>拓展</li>
<li>纠错</li>
<li>应用</li>
</ol>
<p>###1.31 获取</p>
<ul>
<li>获取指信息从采集进入到大脑的过程。</li>
<li>获取信息有三个主要目标:<ol>
<li>简化：将无用的东西尽量删除，只有那些对于形成模型有帮助的例子才需要认真学习。</li>
<li>容量：尽可能获得更多的信息。</li>
<li>速度：尽可能提高获取信息的速度。</li>
</ol>
</li>
</ul>
<p>###1.32 理解</p>
<ul>
<li>理解不能指停留在信息的表面意思，还要了解信息(公式)是如何得来的，与其它信息(公式)的关系。</li>
</ul>
<p>###1.33 拓展</p>
<ul>
<li>拓展：利用模型来建华和扩展你的知识结构，也要拓展对知识的理解。</li>
<li><p>一名整体性学习者在学习新公式时会问道：</p>
<ul>
<li>公式是怎么来的？</li>
<li>公式中的每个成分代表的真实含义是什么？</li>
<li>公式中的什么成分可以做些改变？</li>
<li>这种改变会导致结果发生什么样的变化？</li>
<li>其他公式与这个公式有什么相同之处，又有什么不同之处？</li>
</ul>
</li>
<li><p>拓展有三种主要方式：</p>
<ol>
<li>深度拓展(知识背景探究)：在信息内部创造联系。</li>
<li>横向拓展(类似知识探究)：与此类似的结论有哪些？那些地方类似？那些地方不同？</li>
<li>纵向拓展(创造性探究)：在结构间建立高速通道，联系不同知识体系。</li>
</ol>
</li>
</ul>
<p>###1.34 纠错</p>
<ul>
<li>纠错可以看作在整体性知识网络中做修剪工作，添加一些特殊的例子，删除一些现实中不存在的联系，这不是一个完美的过程，修剪工作是必要的。</li>
</ul>
<p>###1.35 应用阶段</p>
<ul>
<li>应用是学习的最终目的，能做到学以致用方能更好地适应现实世界。对概念不仅仅停留在理解上，而是要<strong>形成一种感觉</strong>。</li>
</ul>
<p>###1.36 测试阶段</p>
<ul>
<li>五个阶段都要进行测试，测试可以让你了解弱点是什么，该如何改进它。<ol>
<li>获取阶段的测试──我以前看过或听过这个知识吗？</li>
<li>理解阶段的测试──我理解知识的含义吗？</li>
<li>拓展阶段的测试──我知道知识从何而来，与哪些知识有关系吗？</li>
<li>纠错阶段的测试──我删除了那些不恰当的联系吗？我删除了那些错误结论吗？</li>
<li>应用阶段的测试──我将知识用到实际生活中了吗？</li>
</ol>
</li>
</ul>
<p>##1.4 找出薄弱环节</p>
<ol>
<li>获取阶段──养成良好的学习，阅读和记笔记的习惯。</li>
<li>理解阶段──放慢阅读速度，寻找不同的说法。</li>
<li>拓展阶段──提高灵活性，做到举一反三，触类旁通。</li>
<li>纠错阶段──对建立的联系做足够严谨的检查。</li>
<li>应用阶段──抛开书本，做实验，接触生活。</li>
</ol>
<p>##1.5 信息结构</p>
<ol>
<li>随意信息：缺少逻辑分类多零散知识。</li>
<li>观点信息：存在争论的信息。</li>
<li>过程信息：讲述一系列动作，操作的信息。</li>
<li>具体信息：实际生活中可以观察到，听到，触到的信息。</li>
<li>抽象信息：难以理解，但是逻辑性很强，需要抽象思维理解的信息。</li>
</ol>
<h1 id="Part-2-整体性学习技术"><a href="#Part-2-整体性学习技术" class="headerlink" title="Part 2 整体性学习技术"></a>Part 2 整体性学习技术</h1><hr>
<p>##2.1 获取知识</p>
<ol>
<li>快速阅读</li>
<li>笔记流</li>
</ol>
<p>###2.11 快速阅读</p>
<ol>
<li>指读法:用手指帮助阅读</li>
<li>练习阅读法:两次在相同时间里阅读相同的资料，比较理解程度</li>
<li>积极阅读法(针对难以理解的知识) - 这一节主要观点是什么 - 我怎样才能记住主要观点 - 我要怎样将主要观点拓展开以及应用它</li>
</ol>
<p>###2.12 笔记流笔记流的制作：</p>
<ol>
<li>使用笔记流时，首先写下最主要的观点，尽量用很短的单词来替换完整的句子。</li>
<li>一旦你写下了一个观点，下一步就是在这个观点和其他观点之间画上一些箭头，观点不是建立成金字塔式的结构，而是呈现出相互关联的关系。两种笔记流：- 课下笔记流：课堂上按常规记笔记，下课后根据笔记内容制作标准的笔记流。- 评注流：首先写下最关键的信息，然后在信息之间加入联系</li>
</ol>
<p>##2.2 联系观点</p>
<ul>
<li>在获得知识之后，仅仅理解知识的表面意思一般是记不牢的，我们需要利用技巧理解和拓展这些知识。</li>
</ul>
<p>###2.21 比喻</p>
<ul>
<li>比喻就是在不熟悉的知识和熟悉的知识之间架起一座沟通的桥梁。</li>
<li>找出比喻的步骤：<ol>
<li>确定你要深入理解和记忆的信息。</li>
<li>在你的个人经验中寻找与信息部分相似的东西，要达到完全符合不太可能，所以与其寻找一个完全符合的东西，不如稍作让步，找到十几个部分符合的“不完美比喻”，在上面的例子里我想到的是雪中行走。</li>
<li>重复上述过程，检查比喻不恰当的地方。例如，雪中行走是线性的痕迹，而脑神经却是错综复杂的网络。运用比喻法的技巧-  要有寻找比喻的欲望-  注意第一个出现在脑海中的念头- 优化和测试你的比喻(多找几个比喻)</li>
</ol>
</li>
</ul>
<p>###2.22 内在化</p>
<ul>
<li>内在化：在脑海中出现图像，而且有声音，触觉和情感。</li>
<li><p>注意：具体信息的内在化效果最好，而抽象信息最适合比喻法怎样进行内在化</p>
<ol>
<li>明确你要内在化的概念。这是一个生物过程，还是编程中的函数或者是一个数学概念？</li>
<li>从建立脑海中的图像开始。如果你不习惯内在化，可以先试着在纸上画出概念的粗略图，多次尝试后，你就会直接在脑海中想象了。</li>
<li>脑海中的图像是静态的，还是栩栩如生的动态场景？掌握一个行列式需要好几个步骤，所以要让图像动起来，就仿佛在看一部电影一样。</li>
<li>现在开始加上其他感官。试着用手去拿它，去摸它，去打开它，去嗅它的味道，去听它的声音，动用你身体的所有感官，将所有的感觉与运动的图像相联系。</li>
<li>加入更多的感觉或情感。</li>
<li>不断重复和优化图像，直到你一想到它就能很快地回忆起知识。 </li>
</ol>
</li>
</ul>
<p>###2.23 图表法</p>
<ol>
<li>流程图：一系列的步骤；历史事件；一个系统。</li>
<li>概念图：观点之间的内在关系3. 图像：用粗糙简单的涂鸦来代替文字，包括观点和观点之间的联系。</li>
</ol>
<p>##2.3 随意信息的处理</p>
<ol>
<li>联想法</li>
<li>挂钩法</li>
<li>信息压缩技术</li>
</ol>
<p>###2.31 联想法联想法：将一系列观点串在一起，就像链条。</p>
<p>联想法的步骤：</p>
<ol>
<li>创造顺序</li>
<li>给每一项预设一个符号</li>
<li>创建属于自己的联想，前后项的联系</li>
</ol>
<h3 id="2-32-挂钩法"><a href="#2-32-挂钩法" class="headerlink" title="2.32 挂钩法"></a>2.32 挂钩法</h3><ul>
<li>挂钩法：将要记忆的信息与数字联系在一起。</li>
</ul>
<h3 id="2-33-信息压缩技术"><a href="#2-33-信息压缩技术" class="headerlink" title="2.33 信息压缩技术"></a>2.33 信息压缩技术</h3><ul>
<li>信息压缩：减少信息的容量，寻找信息的逻辑关系信息压缩的三种方式：<ol>
<li>记忆术:用一个短语储存数个信息的方法</li>
<li>图像联系：简单的符号替代每一个信息，然后将这些符号放在一张图像中</li>
<li>笔记压缩:  <ul>
<li>拿几张空白纸。准备好要压缩的笔记，这个练习可能会花费一两小时，所以要确保你有这么多时间。 </li>
<li>用最小的字，写下笔记中的主要观点。使用尽可能少的字。 - 接着写下与之相联系的观点、公式、概念或定义。尽可能写小一点和写少一点，节省空间。 </li>
<li>持续上述自由写下观点的过程，直到将笔记中的每一个主要观点都写了下来为止。最后你得到大约1～3张密密麻麻写满信息的纸。 </li>
<li>有时候，还可以更进一步，将上面压缩后的内容加工、修饰得更有条理，更好看一些。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="2-4-以项目为基础的学习"><a href="#2-4-以项目为基础的学习" class="headerlink" title="2.4 以项目为基础的学习"></a>2.4 以项目为基础的学习</h2><ul>
<li>以项目为基础的学习方式简单地说就是设定一个需要1～3个月达成的目标，达成目标的过程就是学习的过程，达成了目标也就达到了学习的效果。为了完成项目，你必须围绕着目标努力学习，以项目为基础的学习符合整体性学习的每一个过程。</li>
</ul>
<h2 id="2-5-整体性学习技术的实际应用"><a href="#2-5-整体性学习技术的实际应用" class="headerlink" title="2.5 整体性学习技术的实际应用"></a>2.5 整体性学习技术的实际应用</h2><p>费曼技巧：<br>第一步：选择要学习的概念首先选好你打算深入理解的概念，拿一张空白纸，在最上方写下概念的名称。<br>第二步：设想你是老师，正在试图教会一名新生这个知识点这一步你要假想自己费尽口舌让一名毫无这方面知识的学生听懂，并把你的解释记录下来。这一步至关重要，因为在自我解释那些你理解或不理解的知识过程中，你会理解得更好，而原先不明白的地方也得以理清。<br>第三步：当你感到疑惑时，返回去吧。每当你碰到难题感到疑惑时，别急着往下走，学习不是单行道，回过头来，重新阅读参考材料、听讲座或找老师解答，直到你觉得搞懂了为止，然后把解释记到纸上。<br>第四步：简单化和比喻如果你的解释很啰唆或者艰涩，尽量用简单直白的语言重新表述它，或者找到一个恰当的比喻以更好地理解它。你可以通过这种技术仔细地查明到底是什么地方你不明白，然后你可以去翻阅教材、笔记或询问老师，弄清楚到底你遗漏了哪些关键知识。费曼技巧对于自我测试、考察对知识点的理解程度，是一个真正的好方法。因为如果你不翻阅教科书就能用自己的话把观点解释清楚，那么就意味着你真正理解了该观点。</p>
<h2 id="Part-3-超越整体性学习"><a href="#Part-3-超越整体性学习" class="headerlink" title="#Part 3 超越整体性学习"></a>#Part 3 超越整体性学习</h2><h2 id="3-1-成为高效学生的关键点："><a href="#3-1-成为高效学生的关键点：" class="headerlink" title="3.1 成为高效学生的关键点："></a>3.1 成为高效学生的关键点：</h2><ol>
<li>能量管理</li>
<li>不要“学习”（Don’t study）</li>
<li>绝不拖延时间</li>
<li>批处理</li>
<li>有组织</li>
</ol>
<h3 id="3-11-能量管理"><a href="#3-11-能量管理" class="headerlink" title="3.11 能量管理"></a>3.11 能量管理</h3><ul>
<li>增加你的能量储备</li>
<li>坚持运动 </li>
<li>充足的睡眠 </li>
<li>多吃粗纤维，粗加工的食物 </li>
<li>多喝水 </li>
<li>少吃多餐</li>
<li>将日程表由线性的改为循环式的 </li>
<li>一周休息一天 </li>
<li>工作在白天集中完成 </li>
<li>设定90分钟集中完成某任务 </li>
</ul>
<p>###3.12 不要学习</p>
<p>大多数学生认为如果不能一直待在图书馆、坐在书桌前沉思苦读，就会有负罪感。于是学生生活变成了一种持久的自我斗争过程──总是试图多‘学习’，但总是感到收获少。这就好像总是做出一副吃饭的样子，但是吃下去得不多，消化得不够，吸收得也不好，如此这般学习效果怎么可能好呢？不用“学习”（学习就好比整个食物经过咀嚼、消化、吸收的过程，它不是表面看起来“吃”的动作。人们不可能永远吃个不停，所以学习也不是坐在书桌前越长越好，学习需要挑选要吃的食物（获取信息）、咀嚼（明白阶段）、消化（理解阶段）、吸收（应用阶段）。</p>
<p> 学习的定义：学习不是指坐在书桌前12个小时，也不是指每天坚持看书。这些是学习的表象，不是学习的实质。</p>
<p>###3.13 绝不拖延周/日目标体系:</p>
<ol>
<li>每周周末，列一个清单，包括所有的任务、作业以及你想在下周完成的读书和学习活动。</li>
<li>每天晚上，检查周计划，列出每日目标清单。</li>
</ol>
<p>###3.14 批处理<br>批处理的意思就是将那些类似的、散在的工作集中起来一次做完。批处理有助于节省时间，因为你可以集中时间和精力。例如：某个时间把一周需要阅读的材料一次性读完，而抽出另外一个时间连续写三四篇文章。批处理的使用技巧：</p>
<ul>
<li>批处理最适用于将那些需要时间不长的零散工作放在一起做。 </li>
<li>一次性完成作业。如果一项作业花费的时间不会超过8小时，我就坐在凳子上一鼓作气完成它。将一个花3小时就可以写完的文章，分成15次零散时间内完成，肯定会浪费很多时间，每一次都要花时间重新鼓起写作的激情才能开始正式的写作。 </li>
<li>提髙注意力阈值。注意力阈值就是指集中完成某项工作的最长时间，超过这个时间，注意力就急剧下降。通过不断接受越来越多的批处理，你可以逐渐提高你的注意力阈值。阈值越高，表示能一次完成的工作量也越大。 </li>
</ul>
<p>###3.15 有组织让你变得有组织：</p>
<ul>
<li>所有的物品都放在固定的位置。作业、课外作业以及约会日期都记录在固定的地方。没有固定地方的结果就是混乱。专门找一个地方放东西，这样会更容易放得有序。</li>
<li>随身携带一个记事本。每天随时记录，日积月累，必有所获。</li>
<li>坚持日历和做事清单。应用做事清单记录任务和目标，使用日历来记录要做的事和截止日期。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-19e2323f8483e093.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
    
    </summary>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="Mind" scheme="https://github.com/knightsj/knightsj.github.io/tags/Mind/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J_Knight_</title>
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/knightsj/knightsj.github.io/"/>
  <updated>2018-06-28T17:32:12.504Z</updated>
  <id>https://github.com/knightsj/knightsj.github.io/</id>
  
  <author>
    <name>J_Knight_</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构 &amp; 算法 in Swift （二）：算法概述和排序算法</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20&amp;%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/08/数据结构 &amp; 算法 in Swift （二）：算法概述和排序算法/</id>
    <published>2018-02-08T00:53:22.000Z</published>
    <updated>2018-06-28T17:32:12.504Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/da_header_2.png" alt=""></p>
<p>本篇是《数据结构 &amp; 算法 in Swift》系列连载的第二篇，内容分为如下两个部分：</p>
<ul>
<li>算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。</li>
<li>排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。</li>
</ul>
<a id="more"></a>
<h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><blockquote>
<p>该部分是给那些对算法以及相关知识不了解的读者准备的，如果已经对算法的相关知识有所了解，可以略过该部分，直接看本文的第二部分：排序算法。</p>
</blockquote>
<p>关于该部分的讨论不属于本文介绍的重点，因此没有过多非常专业的论述，只是让那些对算法不了解的读者可以对算法先有一个基本的认识，为阅读和理解本文的第二部分做好准备。</p>
<h2 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h2><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p>
<blockquote>
<p>摘自《大话数据结构》</p>
</blockquote>
<p>简单说来，算法就是“一个问题的解法”。对于相同一个问题，可能会有多种不同的解法。这些解法虽然可以得到相同的结果，但是每个算法的执行所需要的时间和空间资源却可以是千差万别的。</p>
<p>以消耗的时间的角度为出发点，我们看一下对于同一个问题，两种不同的解法的效率会相差多大：</p>
<p>现在让我们解决这个问题：<strong>计算从1到100数字的总和</strong>。</p>
<p>把比较容易想到的下面两种方法作为比较：</p>
<ol>
<li>1到100循环遍历逐步相加</li>
<li>等差数列求和</li>
</ol>
<p>用Swift函数来分别实现一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOpration1</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ... n &#123;</div><div class="line">        sum += i</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> sum</div><div class="line">&#125;</div><div class="line">sumOpration1(<span class="number">100</span>)<span class="comment">//5050</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOpration2</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * n/<span class="number">2</span></div><div class="line">&#125;</div><div class="line">sumOpration2(<span class="number">100</span>)<span class="comment">//5050</span></div></pre></td></tr></table></figure>
<p>上面的代码中，<code>sumOpration1</code>使用的是循环遍历的方式；<code>sumOpration2</code>使用的是等差数列求和的公式。</p>
<p>虽然两个函数都能得到正确的结果，但是不难看出两个函数实现的效率是有区别的:</p>
<p><strong>遍历求和所需要的时间是依赖于传入函数的n的大小的，而等差数列求和的方法所需要的时间对传入的n的大小是完全不依赖的。</strong></p>
<p>在遍历求和中，如果传入的n值是100，则需要遍历100次并相加才能得到结果，那么如果传入的n值是一百万呢？</p>
<p>而在等差数列求和的函数中，无论n值有多大，只需要一个公式就可以解决。</p>
<p>我们对此可以以小见大：世上千千万万种问题（算法题）可能也有类似的情况：相同的问题，相同的结果，但是执行效率缺差之千里。那么有没有什么方法可以度量某种算法的执行效率以方便人们去选择或是衡量算法之间的差异呢？ 答案是肯定的。</p>
<p>下面笔者就向大家介绍算法所消耗资源的两个维度：时间复杂度和空间复杂度。</p>
<h2 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模!n的函数f(n)，算法的时间复杂度也因此记做：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175d7ca0cf3a" alt=""></p>
<p>常见的时间复杂度有：常数阶O(1)，对数阶O(log n），线性阶 O(n)，线性对数阶O(nlog n)，平方阶O(n^{2})，立方阶O(n^{3})，!k次方阶O(n^{k})，指数阶 O(2^{n})}。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p>
<p>拿其中几个复杂度做对比：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175e46a4baf6?w=840&amp;h=460&amp;f=png&amp;s=366231" alt=""></p>
<p>从上图中我们可以看到，平方阶O(n^{2})随着n值的增大，其复杂度近乎直线飙升；而线性阶 O(n)随着n的增大，复杂度是线性增长的；我们还可以看到常数阶 O(1)随着n增大，其复杂度是不变的。</p>
<p>参考上一节的求和问题，我们可以看出来遍历求和的算法复杂度是线性阶O(n)：随着求和的最大数值的大小而线性增长；而等差数列求和算法的复杂度为常数阶 O(1)其算法复杂度与输入n值的大小无关。</p>
<p>读者可以试着想一个算法的复杂度与输入值n的平方成正比的算法。</p>
<p>在这里笔者举一个例子：求一个数组中某两个元素和为某个值的元素index的算法。数组为<code>[0,2,1,3,6]</code>，和为8：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTwoSum</span><span class="params">(<span class="number">_</span> array: [Int], target: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)? &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;array.<span class="built_in">count</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> <span class="keyword">left</span> = array[i]</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> (i + <span class="number">1</span>)..&lt;array.<span class="built_in">count</span> &#123;</div><div class="line">            <span class="keyword">let</span> <span class="keyword">right</span> = array[j]</div><div class="line">            <span class="keyword">if</span> <span class="keyword">left</span> + <span class="keyword">right</span> == target &#123;</div><div class="line">                <span class="keyword">return</span> (i, j)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> array = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> indexes = findTwoSum(array, target: <span class="number">8</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(indexes) <span class="comment">//1， 4</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"No pairs are found"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的算法准确地计算出了两个元素的index为1和4。因为使用了两层的遍历，所以这里算法的复杂度是平方阶O(n^{2}。关于算法复杂度的详细推倒方法，可以参考网上和算法相关书籍的资料。</p>
<p>而其实，不需要遍历两层，只需要遍历一层即可：在遍历的时候，我么知道当前元素的值a，那么只要其余元素里面有值等于（target - a）的值即可。所以这次算法的复杂度就是线性阶O(n)了。</p>
<p>同样地，上面两种算法虽然可以达到相同的效果，但是当n非常大的时候，二者的计算效率就会相差更大：n = 1000的时候，二者得到结果所需要的时间可能会差好几百倍。可以说平方阶O(n^{2})复杂度的算法在数据量很大的时候是无法让人接受的。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。而且控件复杂度不属于本文讨论的重点，因此在这里不展开介绍了。</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在算法的实现中，遍历与递归是经常出现的两种操作。</p>
<p>对于遍历，无非就是使用一个for循环来遍历集合里的元素，相信大家已经非常熟悉了。但是对于递归操作就可能比较陌生。而且由于本文第二部分讲解算法的是时候有两个算法（也是比较重要）的算法使用了递归操作，所以为了能帮助大家理解这两个算法，笔者觉得有必要将递归单独拿出来讲解。</p>
<p>先看一下递归的概念。</p>
<h3 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h3><p>递归的概念是：在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6" target="_blank" rel="external">数学</a>与<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="external">计算机科学</a>中，是指在函数的定义中使用函数自身的方法摘自维基百科</p>
<blockquote>
<p>摘自维基百科</p>
</blockquote>
<p>通过使用递归，可以把一个<strong>大型复杂的问题逐层转化为一个与原问题相似的规模较小的问题来求解</strong>。因此如果使用递归，可以达到使用少量的代码就可描述出解题过程所需的多次重复计算的目的，减少了程序的代码量 。</p>
<p>下面用一个例子来具体感受一下递归操作：</p>
<p>大家应该都比较熟悉阶乘的算法：3！= 3 <em> 2 </em> 1 ； 4！= 4 <em> 3 </em> 2 * 1</p>
<p>不难看出，在这里反复执行了一个逐渐-1和相乘的操作，如果可以使用某段代码达到重复调用的效果就很方便了，在这里就可以使用递归：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</div><div class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span>: n * factorial(n-<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">factorial(<span class="number">3</span>) <span class="comment">//6</span></div></pre></td></tr></table></figure>
<p>在上面的代码里，<code>factorial</code>函数调用了它自己，并且在n&lt;2的时候返回了1；否则继续调用自己。</p>
<p>从代码本身其实不难理解函数调用的方式，但是这个6究竟是怎么算出来的呢？这就涉及到递归的实现原理了。</p>
<h3 id="递归的实现原理"><a href="#递归的实现原理" class="headerlink" title="递归的实现原理"></a>递归的实现原理</h3><p>递归的调用实际上是通过调用栈（callback stack）来实现的，笔者用一张图从factorial(3)开始调用到最后得出6这个顺序之间发生的事情画了出来：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175e51624070?w=941&amp;h=429&amp;f=png&amp;s=31535" alt=""></p>
<p>由上图可以看出，整个递归的过程和栈的入栈出栈的操作非常类似：橘黄色背景的圆角矩形代表了栈顶元素，也就是正在执行的操作，而灰色背景的圆角矩形则代表了其余的元素，它们的顺序就是当初被调用的顺序，而且在内容上保持了当时被调用时执行的代码。</p>
<p>现在笔者按照时间顺序从左到右来说明一下整个调用的过程：</p>
<ul>
<li>最开始传入3之后，3满足了n&gt;=2的条件，继续调用自己：3 * factorial(2) ，入栈。</li>
<li>传入2之后，2满足了n&gt;=2的条件，继续调用自己：2 * factorial(1) ，入栈。</li>
<li>传入1之后，1满足了n&lt;2的条件，停止调用自己，返回了1，出栈。</li>
<li>此时的栈顶元素为2 <em> factorial(1) ，而刚刚factorial(1)返回了1，所以现在这里变成了2 </em> 1 = 2，出栈。</li>
<li>同样地，此时栈顶元素为3 <em> factorial(2)里的 factorial(2)返回了2，所以现在这里变成了3 </em> 2 = 6，出栈。</li>
<li>最后，factorial(3)返回了6，出栈，递归结束。</li>
</ul>
<p>按照笔者个人的理解：整个递归的过程可以大致理解为：在使递归继续的条件为false之前，持续递归调用，以栈的形式保存调用上下文（临时变量，函数等）。一旦这个条件变为true，则立即按照出栈的顺序（入栈顺序的逆序）来返回值，逐个传递，最终传递到最开始调用的那一层返回最终结果。</p>
<p>再简单点，递归中的“递”就是入栈，传递调用信息；“归”就是出栈，输出返回值。</p>
<p>而这个分界线就是递归的终止条件。很显然，这个终止条件在整个递归过程中起着举足轻重的作用。试想一下，如果这个条件永远不会改变，那么就会一直入栈，就会发生栈溢出的情况。</p>
<h3 id="使用递归时需要注意的问题"><a href="#使用递归时需要注意的问题" class="headerlink" title="使用递归时需要注意的问题"></a>使用递归时需要注意的问题</h3><p>基于上面递归的例子，我们将递归终止条件去掉：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorialInfinite</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</div><div class="line">    <span class="keyword">return</span> n * factorialInfinite(n-<span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">factorialInfinite(<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>这段代码如果放在playground里，经过一小段时间（几秒钟或更多）后，会报一个运行时错误。也可以在return语句上面写一个print函数打印一些字符串，接着就会看到不停的打印，直到运行时错误，栈溢出。</p>
<p>所以说在今后写关于递归的代码的时候，一定要注意递归的终止条件是否合理，因为即使条件存在也不一定就是合理的条件。我们看一下下面这个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOperation</span><span class="params">( <span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> n + sumOperation(n - <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">sumOperation(<span class="number">2</span>) <span class="comment">//3</span></div></pre></td></tr></table></figure>
<p>上面的代码跟阶乘类似，也是和小于当前参数的值相加，如果传入2，那么知道 n=0时就开始出栈，</p>
<p>2 + 1 + 0 = 3。看似没什么问题，但是如果一开始传入 - 1 呢？结果就是不停的入栈，直到栈溢出。因为 n == 0 这个条件在传入 - 1 的时候是无法终止入栈的，因为 - 1 之后的 -1 操作都是非0的。</p>
<p>所以说这个条件就不是合理的，一个比较合理的条件是 n &lt; = 0。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOperation</span><span class="params">( <span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</div><div class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> n + sumOperation(n - <span class="number">1</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">sumOperation(-<span class="number">1</span>) <span class="comment">//0</span></div></pre></td></tr></table></figure>
<p>相信到这里，读者应该对递归的使用，调用过程以及注意事项有个基本的认识了。</p>
<p>那么到这里，关于算法的基本介绍已经讲完了，下面正式开始讲解排序算法。</p>
<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>讲解算法之前，我们先来看一下几个常见的排序算法的对比：</p>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均情况下</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>稳定性</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>冒泡</td>
<td>O(n^2)</td>
<td>O(n）</td>
<td>O(n^2)</td>
<td>稳定</td>
<td>1</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>不稳定</td>
<td>1</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n）</td>
<td>O(n^2)</td>
<td>稳定</td>
<td>1</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn)</td>
<td>依赖步长</td>
<td>依赖步长</td>
<td>稳定</td>
<td>1</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>稳定</td>
<td>1</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>稳定</td>
<td>O(n）</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>不稳定</td>
<td>O(logn)</td>
</tr>
</tbody>
</table>
<blockquote>
<p>最好情况和最坏情况以及稳定性的概念不在本文的讨论范围之内，有兴趣的读者可以查阅相关资料。</p>
</blockquote>
<p>现在只看平均情况下的性能：</p>
<ul>
<li>冒泡排序，选择排序，插入排序的时间复杂度为平方阶O(n^{2})</li>
<li>希尔排序，堆排序，归并排序，快速排序的时间复杂度为线性对数阶O(nlog n)</li>
</ul>
<p>本篇要给大家介绍的是冒泡排序，选择排序，插入排序，归并排序和快速排序。</p>
<p>希尔排序是基于插入排序，理解了插入排序以后，理解希尔排序会很容易，故在本文不做介绍。堆排序涉及到一个全新的数据结构：堆，所以笔者将堆这个数据结构和堆排序放在下一篇来做介绍。</p>
<h2 id="排序初探"><a href="#排序初探" class="headerlink" title="排序初探"></a>排序初探</h2><p>在讲排序算法之前，我们先看一种最简单的排序算法（也是性能最低的，也是最好理解的），在这里先称之为“交换排序”。</p>
<blockquote>
<p>注意，这个名称是笔者自己起的，在互联网和相关技术书籍上面没有对该算法起名。</p>
</blockquote>
<h3 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>用两个循环来嵌套遍历：</p>
<ul>
<li>外层遍历数组从0到末尾的元素，索引为i.</li>
<li>里层遍历数组从i+1至数组末尾的元素，索引为j。</li>
<li>当i上的元素比j上的元素大的时候，交换i和j的元素，目的是保持index为i的元素是最小的。</li>
</ul>
<p>我们用一个例子看一下是怎么做交换的：</p>
<p>给定一个初始数组：<code>array = [4, 1, 2, 5, 0]</code></p>
<p><strong>i = 0 时</strong>：</p>
<ul>
<li>array[0] &gt; array[1] : 交换4和1：<code>[1, 4, 2, 5, 0]</code>，内层的j继续遍历，j++。</li>
<li>array[0] &gt; array[4] : 交换0和1：<code>[0, 4, 2, 5, 1]</code>，i = 0的外层循环结束，i++。</li>
</ul>
<p><strong>i  = 1时</strong>：</p>
<ul>
<li>array[1] &gt; array[2] : 交换2和4：<code>[0, 2, 4, 5, 1]</code>，内层的j继续遍历，j++。</li>
<li>array[1] &gt; array[4] : 交换1和2：<code>[0, 1, 4, 5, 2]</code>，i = 1的外层循环结束，i++。</li>
</ul>
<p><strong>i = 2 时</strong>：</p>
<ul>
<li>array[2] &gt; array[4] : 交换2和4：<code>[0, 1, 2, 5, 4]</code>，i = 2的外层循环结束，i++。</li>
</ul>
<p><strong>i = 3 时</strong>：</p>
<ul>
<li>array[3] &gt; array[4] : 交换5和4：<code>[0, 1, 2, 4, 5]</code>，i = 3的外层循环结束，i++。</li>
</ul>
<p><strong>i = 4 时</strong>：不符合内循环的边界条件，不进行内循环，排序结束。</p>
<p>那么用代码如何实现呢？</p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span> ..&lt; array.<span class="built_in">count</span> &#123;</div><div class="line">          </div><div class="line">            <span class="keyword">if</span> array[i] &gt; array[j] &#123;</div><div class="line">                array.swapAt(i, j) </div><div class="line">                <span class="built_in">print</span>(<span class="string">"\(array)"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> array </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面<code>swapAt</code>函数是使用了Swift内置的数组内部交换两个index的函数，在后面会经常用到。</p>
<p>为了用代码验证上面所讲解的交换过程，可以在<code>swapAt</code>函数下面将交换元素后的数组打印出来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> originalArray = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>]</div><div class="line"><span class="built_in">print</span>(<span class="string">"original array:\n\(originalArray)\n"</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span> ..&lt; array.<span class="built_in">count</span> &#123;</div><div class="line">          </div><div class="line">            <span class="keyword">if</span> array[i] &gt; array[j] &#123;</div><div class="line">                array.swapAt(i, j) </div><div class="line">                <span class="built_in">print</span>(<span class="string">"\(array)"</span>)</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> array   </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">switchSort(&amp;originalArray)</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">original array:</div><div class="line">[4, 1, 2, 5, 0]</div><div class="line"></div><div class="line"></div><div class="line">switch sort...</div><div class="line">[1, 4, 2, 5, 0]</div><div class="line">[0, 4, 2, 5, 1]</div><div class="line">[0, 2, 4, 5, 1]</div><div class="line">[0, 1, 4, 5, 2]</div><div class="line">[0, 1, 2, 5, 4]</div><div class="line">[0, 1, 2, 4, 5]</div></pre></td></tr></table></figure>
<p>验证后我们可以看到，结果和上面分析的结果是一样的。</p>
<p>各位读者也可以自己设置原数组，然后在运行代码之前按照自己的理解，把每一次交换的结果写出来，接着和运行算法之后进行对比。该方法对算法的理解很有帮助，推荐大家使用~</p>
<blockquote>
<p>请务必理解好上面的逻辑，可以通过动笔写结果的方式来帮助理解和巩固，有助于对下面讲解的排序算法的理解。</p>
</blockquote>
<p>大家看上面的交换过程（排序过程）有没有什么问题？相信细致的读者已经看出来了：<strong>在原数组中，1和2都是比较靠前的位置，但是经过中间的排序以后，被放在了数组后方，然后再次又交换回来</strong>。这显然是比较低效的，给人的感觉像是做了无用功。</p>
<p>那么有没有什么方法可以优化一下交换的过程，让交换后的结果与元素最终在数组的位置基本保持一致呢？</p>
<p>答案是肯定的，这就引出了笔者要第一个正式介绍的排序算法冒泡排序：</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法讲解-1"><a href="#算法讲解-1" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>与上面讲的交换排序类似的是，冒泡排序也是用两层的循环来实现的；但与其不同的是：</p>
<ul>
<li>循环的边界条件：冒泡排序的外层是[0,array.count-1);内层是[0,array.count-1-i)。可以看到内层的范围是不断缩小的，而且范围的前端不变，后端在向前移。</li>
</ul>
<ul>
<li>交换排序比较的是内外层索引的元素（array[i] 和 array[j]）,但是冒泡排序比较的是两个相邻的内层索引的元素：array[j]和array[j+1]。</li>
</ul>
<p>笔者用和上面交换排序使用的同一个数组来演示下元素是如何交换的：</p>
<p>初始数组：<code>array = [4, 1, 2, 5, 0]</code></p>
<p><strong>i = 0 时</strong>：</p>
<ul>
<li>array[0] &gt; array[1] : 交换4和1：<code>[1, 4, 2, 5, 0]</code>，内层的j继续遍历，j++。</li>
<li>array[1] &gt; array[2] : 交换4和2：<code>[1, 2, 4, 5, 0]</code>，内层的j继续遍历，j++。</li>
<li>array[2] &lt; array[3] : 不交换，内层的j继续遍历，j++。</li>
<li>array[3] &gt; array[4] : 交换5和0：<code>[1, 2, 4, 0, 5]</code>，i = 0的外层循环结束，i++。</li>
</ul>
<p><strong>i  = 1时</strong>：</p>
<ul>
<li>array[2] &gt; array[3] : 交换2和4：<code>[1, 2, 0, 4, 5]</code>，内层的j继续遍历，j++。</li>
<li>array[3] &lt; array[4] : 不交换，i = 1的外层循环结束，i++。</li>
</ul>
<p><strong>i = 2 时</strong>：</p>
<ul>
<li>array[1] &gt; array[2] : 交换2和0：<code>[1, 0, 2, 4, 5]</code>，内层的j继续遍历，j++，直到退出i=2的外层循环，i++。</li>
</ul>
<p><strong>i = 3 时</strong>：</p>
<ul>
<li>array[0] &gt; array[1] : 交换1和0：<code>[0, 1, 2, 4, 5]</code>，内层的j继续遍历，j++，直到退出i=3的外层循环，i++。</li>
</ul>
<p>i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们来看一下冒泡排序的代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> - i &#123;</div><div class="line">          </div><div class="line">            <span class="keyword">if</span> array[j] &gt; array[j+<span class="number">1</span>] &#123;</div><div class="line">                array.swapAt(j, j+<span class="number">1</span>)                 </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码我们可以清楚地看到循环遍历的边界条件和交换时机。同样地，我们添加上log，将冒泡排序每次交换后的数组打印出来（为了进行对比，笔者将交换排序的log也打印了出来）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">original array:</div><div class="line">[4, 1, 2, 5, 0]</div><div class="line"></div><div class="line">switch sort...</div><div class="line">[1, 4, 2, 5, 0]</div><div class="line">[0, 4, 2, 5, 1]</div><div class="line">[0, 2, 4, 5, 1]</div><div class="line">[0, 1, 4, 5, 2]</div><div class="line">[0, 1, 2, 5, 4]</div><div class="line">[0, 1, 2, 4, 5]</div><div class="line"></div><div class="line">bubble sort...</div><div class="line">[1, 4, 2, 5, 0]</div><div class="line">[1, 2, 4, 5, 0]</div><div class="line">[1, 2, 4, 0, 5]</div><div class="line">[1, 2, 0, 4, 5]</div><div class="line">[1, 0, 2, 4, 5]</div><div class="line">[0, 1, 2, 4, 5]</div></pre></td></tr></table></figure>
<p>从上面两组打印可以看出，冒泡排序算法解决了交换排序算法的不足：</p>
<ul>
<li>原来就处于靠前位置的1，2两个元素，在排序的过程中一直是靠前的。</li>
<li>原来处于末尾的0元素，在冒泡排序的过程中一点一点地向前移动，最终到了应该处于的位置。</li>
</ul>
<p>现在我们知道冒泡排序是好于交换排序的，而且它的做法是相邻元素的两两比较：如果是逆序（左大右小）的话就做交换。</p>
<p>那么如果在排序过程中，数组已经变成有序的了，那么再进行两两比较就很不划算了。</p>
<p>为了证实上面这个排序算法的局限性，我们用新的测试用例来看一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> originalArray = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div></pre></td></tr></table></figure>
<p>而且这次我们不仅仅在交换以后打log，也记录一下作比较的次数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;    </div><div class="line">    <span class="keyword">var</span> compareCount = <span class="number">0</span></div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> - i &#123;</div><div class="line"></div><div class="line">            compareCount += <span class="number">1</span></div><div class="line">            <span class="built_in">print</span>(<span class="string">"No.\(compareCount) compare \(array[j]) and \(array[j+1])"</span>)</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> array[j] &gt; array[j+<span class="number">1</span>] &#123;</div><div class="line">                array.swapAt(j, j+<span class="number">1</span>) <span class="comment">//keeping index of j is the smaller one</span></div><div class="line">                <span class="built_in">print</span>(<span class="string">"after swap: \(array)"</span>)</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">original array:</div><div class="line">[2, 1, 3, 4, 5]</div><div class="line"></div><div class="line"></div><div class="line">bubble sort...</div><div class="line">No.1 compare 2 and 1</div><div class="line">after swap: [1, 2, 3, 4, 5] //already sorted, but keep comparing</div><div class="line">No.2 compare 2 and 3</div><div class="line">No.3 compare 3 and 4</div><div class="line">No.4 compare 4 and 5</div><div class="line">No.5 compare 1 and 2</div><div class="line">No.6 compare 2 and 3</div><div class="line">No.7 compare 3 and 4</div><div class="line">No.8 compare 1 and 2</div><div class="line">No.9 compare 2 and 3</div><div class="line">No.10 compare 1 and 2</div></pre></td></tr></table></figure>
<p>从打印的结果可以看出，其实在第一次交换过之后，数组已经是有序的了，但是该算法还是继续在比较，做了很多无用功，能不能有个办法可以让这种两两比较在已知有序的情况下提前结束呢？答案是肯定的。</p>
<p>提前结束这个操作很容易，我们只需要跳出最外层的循环就好了。关键是这个时机：我们需要让算法自己知道<strong>什么时候数组已经是有序的了</strong>。</p>
<p>是否已经想到了呢？就是在一次内循环过后，如果没有发生元素交换，就说明数组已经是有序的，不需要再次缩小内循环的范围继续比较了。所以我们需要在外部设置一个布尔值的变量来标记“该数组是否有序”：</p>
<p>我们将这个算法称为：advanced bubble sort</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSortAdvanced</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//bool switch</span></div><div class="line">        <span class="keyword">var</span> swapped = <span class="literal">false</span></div><div class="line">      </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - i - <span class="number">1</span> &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> array[j] &gt; array [j+<span class="number">1</span>] &#123;</div><div class="line">                array.swapAt(j, j+<span class="number">1</span>) </div><div class="line">                swapped = <span class="literal">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//if there is no swapping in inner loop, it means the the part looped is already sorted,</span></div><div class="line">        <span class="comment">//so it's time to break</span></div><div class="line">        <span class="keyword">if</span> (swapped == <span class="literal">false</span>)&#123; <span class="keyword">break</span> &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> array</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，在第一个冒泡排序的算法之内，只添加了一个<code>swapped</code>这个布尔值，默认为false：</p>
<ul>
<li>如果在当前内循环里面没有发生过元素交换，则说明当前内循环范围的元素都是有序的；那么就说明后续的内循环范围的元素也是有序的（因为内循环每次迭代后都会缩小），就可以跳出循环了。</li>
<li>反之，如果在当前内循环里发生过元素交换，则说明当前内循环很可能是无序的（也可能是有序的，但是有序性需要在下一个内循环中验证，所以还是不能提前退出，还需要进行一次内循环）。</li>
</ul>
<p>为了验证上面这个改进冒泡排序是否能解决最初给出的冒泡排序的问题，我们添加上对比次数的log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">original array:</div><div class="line">[2, 1, 3, 4, 5]</div><div class="line"></div><div class="line"></div><div class="line">bubble sort...</div><div class="line">No.1 compare 2 and 1</div><div class="line">after swap: [1, 2, 3, 4, 5]</div><div class="line">No.2 compare 2 and 3</div><div class="line">No.3 compare 3 and 4</div><div class="line">No.4 compare 4 and 5</div><div class="line">No.5 compare 1 and 2</div><div class="line">No.6 compare 2 and 3</div><div class="line">No.7 compare 3 and 4</div><div class="line">No.8 compare 1 and 2</div><div class="line">No.9 compare 2 and 3</div><div class="line">No.10 compare 1 and 2</div><div class="line">bubble sort time duration : 1.96ms</div><div class="line"></div><div class="line">advanced bubble sort...</div><div class="line">No.1 compare 2 and 1</div><div class="line">after swap: [1, 2, 3, 4, 5]</div><div class="line">No.2 compare 2 and 3</div><div class="line">No.3 compare 3 and 4</div><div class="line">No.4 compare 4 and 5</div><div class="line">No.5 compare 1 and 2</div><div class="line">No.6 compare 2 and 3</div><div class="line">No.7 compare 3 and 4</div></pre></td></tr></table></figure>
<p>我们可以看到，在使用改进的冒泡排序后，对比的次数少了3次。之所以没有立即返回，是因为即使在交换完变成有序数组以后，也无法在当前内循环判断出是有序的。需要在下次内循环才能验证出来。</p>
<p>因为数组的元素数量比较小，所以可能对这个改进所达到的效果体会得不是很明显。现在我们增加一下数组元素的个数，并用记录<strong>比较总和</strong>的方式来看一下二者的区别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">original array:</div><div class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</div><div class="line"></div><div class="line">bubble <span class="built_in">sort</span>...</div><div class="line">total compare <span class="built_in">count</span>： <span class="number">91</span></div><div class="line"></div><div class="line"></div><div class="line">advanced bubble <span class="built_in">sort</span>...</div><div class="line">total compare <span class="built_in">count</span>： <span class="number">25</span></div></pre></td></tr></table></figure>
<p>从比较结果可以看出，这两种算法在该测试样本下的差距是比较大的，而且随着元素个数的增多这个差距会越来越大（因为做了更多没有意义的比较）。</p>
<p>虽然这种测试样本比较极端，但是在某种意义上还是优化了最初的冒泡排序算法。一般在网上的冒泡排序算法应该都能看到这个优化版的。</p>
<p>现在我们知道这个优化版的冒泡排序算法可以在知道当前数组已经有序的时候提前结束，但是毕竟不断的交换还是比较耗费性能的，有没有什么方法可以只移动一次就能做好当前元素的排序呢？答案又是肯定的，这就引出了笔者即将介绍的选择排序算法。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法讲解-2"><a href="#算法讲解-2" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>选择排序也是两层循环：</p>
<ul>
<li>外层循环的边界是[0,array.count-1)，index为i。</li>
<li>内层循环的边界是[i+1,array.count)，index为j。可以看到内层的范围也是不断缩小的，而且范围的前端一直后移，后端保持不变。</li>
</ul>
<p>具体做法是：</p>
<ul>
<li>在外层循环的开始，将i作为最小值index（很可能不是该数组的最小值）。</li>
<li>在内层循环里面找到当前内层循环范围内的最小值，并与已经记录的最小值作比较：<ul>
<li>如果与当前记录的最小值index不同，则替换</li>
<li>如果与当前记录的最小值index相同，则不替换</li>
</ul>
</li>
</ul>
<p>我们还是用手写迭代的方式看一下选择排序的机制，使用的数组和上面交换排序和冒泡排序（非优化版）的数组一致：<code>[4, 1, 2, 5, 0]</code></p>
<p>i = 0 时：</p>
<ol>
<li>记录当前的最小值的index为0，当前最小值为4。</li>
<li>内层循环开始，找到[1,5)之间的最小值为0，0的index为4，与当前最小值的index0不同，所以二者要做交换。交换后的数组：<code>[0, 1, 2, 5, 4]</code>。当前内层循环结束，i++。</li>
</ol>
<p><strong>i = 1 时</strong>：</p>
<ol>
<li>记录当前的最小值的index为1，当前最小值为1。</li>
<li>内层循环开始，找到[2,5)之间的最小值为1，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。</li>
</ol>
<p><strong>i = 2 时</strong>：</p>
<ol>
<li>记录当前的最小值的index为2，当前最小值为2。</li>
<li>内层循环开始，找到[3,5)之间的最小值为2，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。</li>
</ol>
<p><strong>i = 3 时</strong>：</p>
<ol>
<li>记录当前的最小值的index为3，当前最小值为2。</li>
<li>内层循环开始，找到[4,5)之间的最小值为4，4的index为4，与当前记录的最小值index3不同，所以二者要做交换。交换后的数组：<code>[0, 1, 2, 4, 5]</code>。当前内层循环结束，i++。</li>
</ol>
<p><strong>i = 4 时</strong>：不符合外层循环的边界条件，不进行外层循环，排序结束。</p>
<p>我们可以看到，同样的初始序列，使用选择排序只进行了2次交换，因为它知道需要替换的最小值是什么，做了很少没意义的交换。</p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们用代码来实现一下上面选择排序的算法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span>&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> <span class="built_in">min</span> = i</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span> ..&lt; array.<span class="built_in">count</span> &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> array[j] &lt; array[<span class="built_in">min</span>] &#123;</div><div class="line">                <span class="built_in">min</span> = j </div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//if min has changed, it means there is value smaller than array[min]</span></div><div class="line">        <span class="comment">//if min has not changed, it means there is no value smallter than array[min]</span></div><div class="line">        <span class="keyword">if</span> i != <span class="built_in">min</span> &#123;</div><div class="line">            array.swapAt(i, <span class="built_in">min</span>) </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看到，在这里使用了<code>min</code>这个变量记录了当前外层循环所需要被比较的index值，如果当前外层循环的内层循环内部找到了比这个最小值还小的值，就替换他们。</p>
<p>下面我们使用log来看一下此时选择排序作替换的次数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">original array:</div><div class="line">[4, 1, 2, 5, 0]</div><div class="line"></div><div class="line">advanced bubble sort...</div><div class="line">after swap: [1, 4, 2, 5, 0]</div><div class="line">after swap: [1, 2, 4, 5, 0]</div><div class="line">after swap: [1, 2, 4, 0, 5]</div><div class="line">after swap: [1, 2, 0, 4, 5]</div><div class="line">after swap: [1, 0, 2, 4, 5]</div><div class="line">after swap: [0, 1, 2, 4, 5]</div><div class="line"></div><div class="line">selection sort...</div><div class="line">after swap: [0, 1, 2, 5, 4]</div><div class="line">after swap: [0, 1, 2, 4, 5]</div></pre></td></tr></table></figure>
<p>从上面的log可以看出二者的对比应该比较明显了。</p>
<p>为了进一步验证选择排序的性能，笔者在网上找到了两个工具：</p>
<ul>
<li>计算程序运行时间的类：<code>executionTimeInterval.swift</code></li>
<li>生成各种类型随机数的Array的分类：<code>Array+Extension.swift</code></li>
</ul>
<p>首先看<code>executionTimeInterval.swift</code>的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//time interval</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">executionTimeInterval</span><span class="params">(block: <span class="params">()</span></span></span> -&gt; ()) -&gt; <span class="type">CFTimeInterval</span> &#123;</div><div class="line">    <span class="keyword">let</span> start = <span class="type">CACurrentMediaTime</span>()</div><div class="line">    block();</div><div class="line">    <span class="keyword">let</span> end = <span class="type">CACurrentMediaTime</span>()</div><div class="line">    <span class="keyword">return</span> end - start</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//formatted time</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">CFTimeInterval</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> formattedTime: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span> &gt;= <span class="number">1000</span> ? <span class="type">String</span>(<span class="type">Int</span>(<span class="keyword">self</span>)) + <span class="string">"s"</span></div><div class="line">            : <span class="keyword">self</span> &gt;= <span class="number">1</span> ? <span class="type">String</span>(format: <span class="string">"%.3gs"</span>, <span class="keyword">self</span>)</div><div class="line">            : <span class="keyword">self</span> &gt;= 1e-<span class="number">3</span> ? <span class="type">String</span>(format: <span class="string">"%.3gms"</span>, <span class="keyword">self</span> * 1e3)</div><div class="line">            : <span class="keyword">self</span> &gt;= 1e-<span class="number">6</span> ? <span class="type">String</span>(format: <span class="string">"%.3gµs"</span>, <span class="keyword">self</span> * 1e6)</div><div class="line">            : <span class="keyword">self</span> &lt; 1e-<span class="number">9</span> ? <span class="string">"0s"</span></div><div class="line">            : <span class="type">String</span>(format: <span class="string">"%.3gns"</span>, <span class="keyword">self</span> * 1e9)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个函数以block的形式传入需要测试运行时间的函数，返回了函数运行的时间。</p>
<p>第二个函数是<code>CFTimeInterval</code>的分类，将秒数添加了单位：毫秒级的以毫秒显示，微秒级的以微秒显示，大于1秒的以秒单位显示。</p>
<p>使用方法是：将两个swift文件拖进playground里面的Sources文件夹里，并点击二者后，进入playground内部：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> selectionSortedArray = [<span class="type">Int</span>]()</div><div class="line"><span class="keyword">var</span> time4 = executionTimeInterval&#123;</div><div class="line">    selectionSortedArray = selectionSort(&amp;originalArray4) <span class="comment">//要测试的函数</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"selection sort time duration : \(time4.formattedTime)"</span>) <span class="comment">//打印出时间</span></div></pre></td></tr></table></figure>
<p>再来看一下<code>Array+Extension.swift</code>类：</p>
<p>先介绍其中的一个方法，生成随机数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> Foundation</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">randomArray</span><span class="params">(size: Int, maxValue: UInt)</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">        <span class="keyword">var</span> result = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>:size)</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; size &#123;</div><div class="line">            result[i] = <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(maxValue)))</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> result</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法只需要传入数组的大小以及最大值就可以生成一个不超过这个最大值的随机数组。</p>
<p>比如我们要生成一个数组长度为10，最大值为100的数组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> originalArray = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;.randomArray(size: inputSize, maxValue:<span class="number">100</span>)</div><div class="line"><span class="comment">//originalArray:[87, 56, 54, 20, 86, 33, 41, 9, 88, 55]</span></div></pre></td></tr></table></figure>
<p>那么现在有了上面两个工具，我们就可以按照我们自己的意愿来生成测试用例数组，并且打印出所用算法的执行时间。我们现在生成一个数组长度为10，最大值为100的数组，然后分别用优化的冒泡排序和选择排序来看一下二者的性能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">original array:</div><div class="line">[1, 4, 80, 83, 92, 63, 83, 23, 9, 85]</div><div class="line"></div><div class="line">advanced bubble sort...</div><div class="line">advanced bubble sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 8.53ms</div><div class="line"></div><div class="line">selection sort...</div><div class="line">selection sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 3.4ms</div></pre></td></tr></table></figure>
<p>我们现在让数组长度更长一点:一个长度为100，最大值为200：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">advanced bubble sort...</div><div class="line">advanced bubble sort sorted elemets: 100 time duration : 6.27s</div><div class="line"></div><div class="line">selection sort...</div><div class="line">selection sort sorted elemets: 100 time duration : 414ms</div></pre></td></tr></table></figure>
<p>可以看到，二者的差别大概在12倍左右。这个差别已经很大了，如果说用选择排序需要1天的话，冒泡排序需要12天。</p>
<p>现在我们学习了选择排序，知道了它是通过减少交换次数来提高排序算法的性能的。</p>
<p>但是关于排序，<strong>除了交换操作以外，对比操作也是需要时间的</strong>：选择排序通过内层循环的不断对比才得到了当前内层循环的最小值，然后进行后续的判断和操作。</p>
<p>那么有什么办法可以减少对比的次数呢？猜对了，答案又是肯定的。这就引出了笔者下面要说的算法：插入排序算法。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法讲解-3"><a href="#算法讲解-3" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>插入排序的基本思想是：从数组中拿出一个元素（通常就是第一个元素）以后，再从数组中按顺序拿出其他元素。如果拿出来的这个元素比这个元素小，就放在这个元素左侧；反之，则放在右侧。整体上看来有点和玩儿扑克牌的时候将刚拿好的牌来做排序差不多。</p>
<p>选择排序也是两层循环：</p>
<ul>
<li>外层循环的边界是[1,array.count)，index为i。</li>
<li>内层循环开始的时候初始index j = i，然后使用一个while循环，循环条件是<code>j&gt;0 &amp;&amp; array[j] &lt; array[j - 1]</code>,循环内侧是交换j-1和j的元素，并使得j-1。可以简单理解为如果当前的元素比前一个元素小，则调换位置；反之进行下一个外层循环。</li>
</ul>
<p>下面我们还是用手写迭代的方式看一下插入排序的机制，使用的数组和上面选择排序的数组一致：<code>[4, 1, 2, 5, 0]</code></p>
<p><strong>i = 1 时</strong>：</p>
<ol>
<li>j = 1：array[1] &lt; array[0]， 交换4和1：<code>[1, 4, 2, 5, 0]</code>，j-1之后不符合内层循环条件，退出内层循环，i+1。</li>
</ol>
<p><strong>i = 2 时</strong>：</p>
<ol>
<li>j = 2，array[3] &lt; array[2]，交换4和2：<code>[1, 2, 4, 5, 0]</code>，j向左移动，array[2] &gt; array[1]，不符合内层循环条件，退出内层循环，i+1。</li>
</ol>
<p><strong>i = 3 时</strong>：</p>
<ol>
<li>j = 3，array[3] &gt; array[2]，不符合内层循环条件，退出内层循环，i+1。</li>
</ol>
<p><strong>i = 4 时</strong>：</p>
<ol>
<li>j = 4，array[4] &lt; array[3]，交换5和0：<code>[1, 2, 4, 0, 5]</code>，j -1。</li>
<li>j = 3，array[3] &lt; array[2]，交换4和0：<code>[1, 2, 0, 4, 5]</code>，j -1。</li>
<li>j = 2，array[2] &lt; array[1]，交换4和0：<code>[1, 0, 2, 4, 5]</code>，j -1。</li>
<li>j = 1，array[1] &lt; array[0]，交换1和0：<code>[0, 1, 2, 4, 5]</code>，j -1 = 0，不符合内层循环条件，退出内层循环，i+1 = 5，不符合外层循环条件，排序终止。</li>
</ol>
<p>从上面的描述可以看出，和选择排序相比，<strong>插入排序的内层循环是可以提前推出的</strong>，其条件就是<code>array[j] &gt;= array[j - 1]</code>,也就是说，当前index为j的元素只要比前面的元素大，那么该内层循环就立即退出，不需要再排序了，因为该算法从一开始就是小的放前面，大的放后面。</p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面我们通过代码来看一下如何实现插入排序算法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;array.<span class="built_in">count</span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> j = i</div><div class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> &amp;&amp; array[j] &lt; array[j - <span class="number">1</span>] &#123;</div><div class="line">             array.swapAt(j - <span class="number">1</span>, j)</div><div class="line">            j -= <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> array</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出插入排序内层循环的条件：<code>j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]</code>。只要当前元素比前面的元素小，就会一直交换下去；反之，当大于等于前面的元素，就会立即跳出循环。</p>
<p>之前笔者有提到相对于选择排序，说插入排序可以减少元素之间对比的次数，下面我们通过打印对比次数来对比一下两种算法：</p>
<p>使用元素个数为50，最大值为50的随机数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">selection sort...</div><div class="line">compare times:1225</div><div class="line">selection sort time duration : 178ms</div><div class="line"></div><div class="line">insertion sort...</div><div class="line">compare times:519</div><div class="line">insertion sort time duration : 676ms</div></pre></td></tr></table></figure>
<p>我们可以看到，使用选择排序的比较次数比插入排序的比较次数多了2倍。但是遗憾的是整体的性能选择排序要高于插入排序。</p>
<p>也就是说虽然插入排序的比较次数少了，但是交换的次数却比选择排序要多，所以性能上有时可能不如选择排序。</p>
<blockquote>
<p>注意，这不与笔者之前的意思相矛盾，笔者只是说在减少比较次数上插入排序是优于选择排序的，但没有说插入排序整体上优于选择排序。</p>
</blockquote>
<p>那么有何种特性的数组可以让排序算法有其用武之地呢？</p>
<p>从上面使用插入排序来排序<code>[4, 1, 2, 5, 0]</code>这个数组的时候，我们可以看到，因为0这个元素已经在末尾了，所以在j=4的时候我们费了好大劲才把它移到前面去。</p>
<p>那么将这个情况作为一个极端，我们可以这样想：如果这个数组里的元素里的index大致于最终顺序差不多的情况是不是就不用做这么多的搬移了？。这句话听起来像是理所当然的话，但是有一种数组属于“基本有序”的数组，这种数组也是无需的，但是它在整体上是有序的，比如：</p>
<p><code>[2,1,3,6,4,5,9,7,8]</code></p>
<p>用笔者的话就叫做整体有序，部分无序。</p>
<p>我们可以简单用这个数组来分别进行选择排序和插入排序做个比较：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">selection sort...</div><div class="line">compare times:36</div><div class="line">selection sort time duration : 4.7ms</div><div class="line"></div><div class="line">insertion sort...</div><div class="line">compare times:5</div><div class="line">insertion sort time duration : 3.2ms</div></pre></td></tr></table></figure>
<p>我们可以看到插入排序在基本有序的测试用例下表现更好。为了让差距更明显，笔者在<code>Array+Extension.swift</code>文件里增加了一个生成基本有序随机数组的方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">nearlySortedArray</span><span class="params">(size: Int, gap:Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>:size)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; size &#123;</div><div class="line">        result[i] = i</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> <span class="built_in">count</span> : <span class="type">Int</span> = size / gap</div><div class="line">    <span class="keyword">var</span> arr = [<span class="type">Int</span>]()</div><div class="line"></div><div class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="built_in">count</span> &#123;</div><div class="line">        arr.append(i*gap)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; arr.<span class="built_in">count</span> &#123;</div><div class="line">        <span class="keyword">let</span> swapIndex = arr[j]</div><div class="line">        result.swapAt(swapIndex,swapIndex+<span class="number">1</span>)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数需要传入数组的长度以及需要打乱顺序的index的跨度，它的实现是这样子的：</p>
<ul>
<li>首先生成一个完全有序的序列。</li>
<li>将数组长度除以跨度来得出需要交换的index的个数count。</li>
<li>根据这个count可以得出需要交换的index，把这些index放在一个新的arr里面</li>
<li>便利这个arr来取出index，将之前生成好的w安全有序的数组的index于index+1做交换。</li>
</ul>
<p>举个例子，如果我们生成一个数组长度为12，跨度为3的基本有序的数组，就可以这么调用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> originalArray = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;.nearlySortedArray(size: <span class="number">12</span>, gap: <span class="number">3</span>)</div><div class="line"><span class="comment">//[1, 0, 2, 4, 3, 5, 7, 6, 8, 10, 9, 11]</span></div></pre></td></tr></table></figure>
<p>跨度为3，说明有12/3 = 4 - 1 = 3 个元素需要调换位置，序号分别为0，3，6，9。所以序号为0，1；3，4；6，7；9，10的元素被调换了位置，可以看到调换后的数组还是基本有序的。</p>
<p>现在我们可以用一个比较大的数组来验证了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> originalArray = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;.nearlySortedArray(size: <span class="number">100</span>, gap: <span class="number">10</span>)</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">selection sort...</div><div class="line">compare times:4950</div><div class="line">selection sort time duration : 422ms</div><div class="line"></div><div class="line">insertion sort...</div><div class="line">compare times:10</div><div class="line">insertion sort time duration : 56.4ms</div></pre></td></tr></table></figure>
<p>我们可以看到差距是非常明显的，插入排序的性能是选择排序的性能的近乎10倍</p>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法讲解-4"><a href="#算法讲解-4" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>归并排序使用了算法思想里的<strong>分治思想</strong>（divide conquer）。顾名思义，就是将一个大问题，分成类似的小问题来逐个攻破。在归并排序的算法实现上，首先逐步将要排序的数组等分成最小的组成部分（通常是1各元素），然后再反过来逐步合并。</p>
<p>用一张图来体会一下归并算法的实现过程： </p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175e83e236cf?w=944&amp;h=637&amp;f=png&amp;s=70522" alt=""></p>
<p>上图面的虚线箭头代表拆分的过程；实线代表合并的过程。仔细看可以发现，拆分和归并的操作都是重复进行的，在这里面我们可以使用递归来操作。</p>
<p>首先看一下归并的操作：</p>
<p>归并的操作就是把两个数组（在这里这两个数组的元素个数通常是一致的）合并成一个完全有序数组。</p>
<p>归并操作的实现步骤是：</p>
<ul>
<li>新建一个空数组，该数组用于存放合并后的有序数组。</li>
<li>两个传入的数组从index 0 开始两两比较，较小的元素放在新建的空数组中，index + 1; 较大的元素不作操作，index 不变，然后继续两两比较。知道index移到末尾为止。</li>
<li>个别情况当两个数组长度不一致的情况下需要将数组里剩余的元素放在新建的数组中。</li>
</ul>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们来看一下归并排序算法的代码实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">_merge</span><span class="params">(leftPile: [Int], rightPile: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> leftIndex = <span class="number">0</span>   <span class="comment">//left pile index, start from 0</span></div><div class="line">    <span class="keyword">var</span> rightIndex = <span class="number">0</span>  <span class="comment">//right pile index, start from 0</span></div><div class="line">    </div><div class="line">    <span class="keyword">var</span> sortedPile = [<span class="type">Int</span>]() <span class="comment">//sorted pile, empty in the first place</span></div><div class="line">    </div><div class="line">    <span class="keyword">while</span> leftIndex &lt; leftPile.<span class="built_in">count</span> &amp;&amp; rightIndex &lt; rightPile.<span class="built_in">count</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//append the smaller value into sortedPile</span></div><div class="line">        <span class="keyword">if</span> leftPile[leftIndex] &lt; rightPile[rightIndex] &#123;</div><div class="line">            </div><div class="line">            sortedPile.append(leftPile[leftIndex])</div><div class="line">            leftIndex += <span class="number">1</span></div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> leftPile[leftIndex] &gt; rightPile[rightIndex] &#123;</div><div class="line">            </div><div class="line">            sortedPile.append(rightPile[rightIndex])</div><div class="line">            rightIndex += <span class="number">1</span></div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//same value, append both of them and move the corresponding index</span></div><div class="line">            sortedPile.append(leftPile[leftIndex])</div><div class="line">            leftIndex += <span class="number">1</span></div><div class="line">            sortedPile.append(rightPile[rightIndex])</div><div class="line">            rightIndex += <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//left pile is not empty</span></div><div class="line">    <span class="keyword">while</span> leftIndex &lt; leftPile.<span class="built_in">count</span> &#123;</div><div class="line">        sortedPile.append(leftPile[leftIndex])</div><div class="line">        leftIndex += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//right pile is not empty</span></div><div class="line">    <span class="keyword">while</span> rightIndex &lt; rightPile.<span class="built_in">count</span> &#123;</div><div class="line">        sortedPile.append(rightPile[rightIndex])</div><div class="line">        rightIndex += <span class="number">1</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">return</span> sortedPile</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>因为该函数是归并排序函数内部调用的函数，所以在函数名称的前面添加了下划线。仅仅是为了区分，并不是必须的。</p>
</blockquote>
<p>从上面代码可以看出合并的实现逻辑：</p>
<ul>
<li>新建空数组，初始化两个传入数组的index为0</li>
<li>两两比较两个数组index上的值，较小的放在新建数组里面并且index+1。</li>
<li>最后检查是否有剩余元素，如果有则添加到新建数组里面。</li>
</ul>
<p>理解了合并的算法，下面我们看一下拆分的算法。拆分算法使用了递归：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(<span class="number">_</span> array: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> middleIndex = array.<span class="built_in">count</span> / <span class="number">2</span></div><div class="line">    <span class="keyword">let</span> leftArray = mergeSort(<span class="type">Array</span>(array[<span class="number">0</span>..&lt;middleIndex]))             <span class="comment">// recursively split left part of original array</span></div><div class="line">    <span class="keyword">let</span> rightArray = mergeSort(<span class="type">Array</span>(array[middleIndex..&lt;array.<span class="built_in">count</span>]))  <span class="comment">// recursively split right part of original array</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> _merge(leftPile: leftArray, rightPile: rightArray)             <span class="comment">// merge left part and right part</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到<code>mergeSort</code>调用了自身，它的递归终止条件是<code>!(array.count &gt;1)</code>，也就是说当数组元素个数 = 1的时候就会返回，会触发调用栈的出栈。</p>
<p>从这个递归函数的实现可以看到它的作用是不断以中心店拆分传入的数组。根据他的递归终止条件，当数组元素 &gt; 1的时候，拆分会继续进行。而下面的合并函数只有在递归终止，开始出栈的时候才开始真正执行。也就是说在拆分结束后才开始进行合并，这样符合了上面笔者介绍的归并算法的实现过程。</p>
<p>上段文字需要反复体会。</p>
<p>为了更形象体现出归并排序的实现过程，可以在合并函数(<code>_merge</code>)内部添加log来验证上面的说法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">_merge</span><span class="params">(leftPile: [Int], rightPile: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">print</span>(<span class="string">"\nmerge left pile:\(leftPile)  |  right pile:\(rightPile)"</span>)</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="built_in">print</span>(<span class="string">"sorted pile：\(sortedPile)"</span>)</div><div class="line">    <span class="keyword">return</span> sortedPile</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而且为了方便和上图作比较，初始数组可以取图中的<code>[3, 5, 9, 2, 7, 4, 8, 0]</code>。运行一下看看效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">original array:</div><div class="line">[3, 5, 9, 2, 7, 4, 8, 0]</div><div class="line"></div><div class="line">merge sort...</div><div class="line"></div><div class="line">merge left pile:[3]  |  right pile:[5]</div><div class="line">sorted pile：[3, 5]</div><div class="line"></div><div class="line">merge left pile:[9]  |  right pile:[2]</div><div class="line">sorted pile：[2, 9]</div><div class="line"></div><div class="line">merge left pile:[3, 5]  |  right pile:[2, 9]</div><div class="line">sorted pile：[2, 3, 5, 9]</div><div class="line"></div><div class="line">merge left pile:[7]  |  right pile:[4]</div><div class="line">sorted pile：[4, 7]</div><div class="line"></div><div class="line">merge left pile:[8]  |  right pile:[0]</div><div class="line">sorted pile：[0, 8]</div><div class="line"></div><div class="line">merge left pile:[4, 7]  |  right pile:[0, 8]</div><div class="line">sorted pile：[0, 4, 7, 8]</div><div class="line"></div><div class="line">merge left pile:[2, 3, 5, 9]  |  right pile:[0, 4, 7, 8]</div><div class="line">sorted pile：[0, 2, 3, 4, 5, 7, 8, 9]</div></pre></td></tr></table></figure>
<p>我们可以看到，拆分归并的操作是先处理原数组的左侧部分，然后处理原数组的右侧部分。这是为什么呢？</p>
<p>我们来看下最初函数是怎么调用的：</p>
<p>最开始我们调用函数：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(<span class="number">_</span> array: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> middleIndex = array.<span class="built_in">count</span> / <span class="number">2</span></div><div class="line">    <span class="keyword">let</span> leftArray = mergeSort(<span class="type">Array</span>(array[<span class="number">0</span>..&lt;middleIndex]))             <span class="comment">//1 </span></div><div class="line">    <span class="keyword">let</span> rightArray = mergeSort(<span class="type">Array</span>(array[middleIndex..&lt;array.<span class="built_in">count</span>]))  <span class="comment">//2</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> _merge(leftPile: leftArray, rightPile: rightArray)            <span class="comment">//3</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在//1这一行开始了递归，这个时候数组是原数组，元素个数是8，而调用mergeSort时原数组被拆分了一半，是4。而4&gt;1，不满足递归终止的条件，继续递归，直到符合了终止条件（[3]）,递归开始返回。以为此时最初被拆分的是数组的左半部分，所以左半部分的拆分会逐步合并，最终得到了<code>[2,3,5,9]</code>。</p>
<p>同理，再回到了最初被拆分的数组的右半部分（上面代码段中的//2），也是和左测一样的拆分和归并，得到了右侧部分的归并结果：<code>[0,4,7,8</code>。</p>
<p>而此时的递归调用栈只有一个mergeSort函数了，mergeSort会进行最终的合并（上面代码段中的//3），调用<code>_merge</code>函数，得到了最终的结果：<code>[0, 2, 3, 4, 5, 7, 8, 9]</code>。</p>
<p>关于归并排序的性能：由于使用了分治和递归并且利用了一些其他的内存空间，所以其性能是高于上述介绍的所有排序的，不过前提是初始元素量不小的情况下。</p>
<p>我们可以将选择排序和归并排序做个比较：初始数组为长度500，最大值为500的随机数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">selection sort...</div><div class="line">selection sort time duration : 12.7s</div><div class="line"></div><div class="line">merge sort...</div><div class="line">merge sort time duration : 5.21s</div></pre></td></tr></table></figure>
<p>可以看到归并排序的算法是优与选择排序的。</p>
<p>现在我们知道归并排序使用了分治思想而且使用了递归，能够高效地将数组排序。其实还有一个也是用分治思想和递归，但是却比归并排序还要优秀的算法 - 快速排序算法。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序算法被称之为20世纪十大算法之一，也是各大公司面试比较喜欢考察的算法。</p>
<h3 id="算法讲解-5"><a href="#算法讲解-5" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>快速排序的基本思想是：通过一趟排序将带排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p>
<blockquote>
<p>上述文字摘自《大话数据结构》</p>
</blockquote>
<p>它的实现步骤为：</p>
<ol>
<li>从数列中挑出一个元素（挑选的算法可以是随机，也可以作其他的优化），称为”基准”（pivot）。</li>
<li>重新对数组进行排序：所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面，相同的放两边。</li>
<li>递归地进行分区操作，继续把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ol>
<p>从上面的描述可以看出，分区操作是快速排序中的核心算法。下面笔者结合实例来描述一下分区操作的过程。</p>
<p>首先拿到初始的数组：<code>[5,4,9,1,3,6,7,8,2]</code></p>
<ul>
<li>选择5作为pivot。</li>
<li>从剩下部分的两端开始：左侧1的标记为low，最右侧2的标记为high。</li>
<li>先看j：2 &lt; 5 , 交换5和2，j不变 ：<code>[2,4,9,1,3,6,7,8,5]</code> ；</li>
<li>再看i：2 &lt; 5 , i ++ ；4 &lt; 5, i++；9 &gt; 5，交换 9 和 5，i不变<code>[2,4,5,1,3,6,7,8,9]</code>。</li>
</ul>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="使用Swift的filter函数"><a href="#使用Swift的filter函数" class="headerlink" title="使用Swift的filter函数"></a>使用Swift的filter函数</h4><p>因为在Swift中有一个数组的filter函数可以找出数组中符合某范围的一些数值，所以笔者先介绍一个会用该函数的简单的快速排序的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort0</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> array: [T])</span></span> -&gt; [<span class="type">T</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> pivot = array[array.<span class="built_in">count</span>/<span class="number">2</span>]</div><div class="line">    <span class="keyword">let</span> less = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &lt; pivot &#125;</div><div class="line">    <span class="keyword">let</span> greater = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; pivot &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> quickSort0(less) + quickSort0(greater)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不难看出这里面使用了递归：选中pivot以后，将数组分成了两个部分，最后将它们合并在一起。虽然这里面使用了Swift里面内置的函数来找出符合这两个个部分的元素，但是读者可以通过这个例子更好地理解快速排序的实现方式。</p>
<h4 id="使用取index-0-的partition函数"><a href="#使用取index-0-的partition函数" class="headerlink" title="使用取index = 0 的partition函数"></a>使用取index = 0 的partition函数</h4><p>除了使用swift内置的filter函数，当然我们也可以自己实现分区的功能，通常使用的是自定义的partition函数。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">_partition</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int], low: Int, high: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> low       = low</div><div class="line">    <span class="keyword">var</span> high      = high</div><div class="line"></div><div class="line">    <span class="keyword">let</span> pivotValue = array[low]</div><div class="line"></div><div class="line">    <span class="keyword">while</span> low &lt; high &#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> low &lt; high &amp;&amp; array[high] &gt;= pivotValue &#123;</div><div class="line">            high -= <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        array[low] = array[high]</div><div class="line">        </div><div class="line">        <span class="keyword">while</span> low &lt; high &amp;&amp; array[low] &lt;= pivotValue &#123;</div><div class="line">            low += <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        array[high] = array[low]</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    array[low] = pivotValue</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> low</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码实现可以看出，最初在这里选择的pivotValue是当前数组的第一个元素。</p>
<p>然后从数组的最右侧的index逐渐向左侧移动，如果值大于pivotValue，那么index-1；否则直接将high与low位置上的元素调换；同样左侧的index也是类似的操作。</p>
<p>该函数执行的最终效果就是将最初的array按照选定的pivotValue前后划分。</p>
<p>那么<code>_partition</code>如何使用呢？</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort1</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int], low: Int, high: Int)</span></span>&#123;</div><div class="line">  </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> low &lt; high &#123;        </div><div class="line">        <span class="keyword">let</span> pivotIndex = _partition(&amp;array, low: low, high: high)</div><div class="line">        quickSort1(&amp;array, low: low, high: pivotIndex - <span class="number">1</span>)</div><div class="line">        quickSort1(&amp;array, low: pivotIndex + <span class="number">1</span>, high: high)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>外层调用的<code>quickSort1</code>是一个递归函数，不断地进行分区操作，最终得到排好序的结果。</p>
<p>我们将上面实现的归并排序，使用swift内置函数的快速排序，以及自定义partition函数的快速排序的性能作对比：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">merge <span class="built_in">sort</span>...</div><div class="line">merge <span class="built_in">sort</span> time duration : <span class="number">4</span>.85s</div><div class="line"></div><div class="line">quick <span class="built_in">sort</span>...</div><div class="line">quick sort0 time duration : 984ms <span class="comment">//swift filter function</span></div><div class="line">quick sort1 time duration : <span class="number">2</span>.64s <span class="comment">//custom partition</span></div></pre></td></tr></table></figure>
<p>上面的测试用例是选择随机数组的，我们看一下测试用例为元素个数一致的基本有序的数组试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">merge sort...</div><div class="line">merge sort time duration : 4.88s</div><div class="line"></div><div class="line">quick sort...</div><div class="line">quick sort0 time duration : 921ms</div><div class="line">quick sort1 time duration : 11.3s</div></pre></td></tr></table></figure>
<p>虽然元素个数一致，但是性能却差了很多，是为什么呢？因为我们在分区的时候，pivot的index强制为第一个。那么如果这个第一个元素的值本来就非常小，那么就会造成分区不均的情况（前重后轻），而且由于是迭代操作，每次分区都会造成分区不均，导致性能直线下降。所以有一个相对合理的方案就是在选取pivot的index的时候随机选取。</p>
<h4 id="使用随机选择pivotValue的partition函数"><a href="#使用随机选择pivotValue的partition函数" class="headerlink" title="使用随机选择pivotValue的partition函数"></a>使用随机选择pivotValue的partition函数</h4><p>实现方法肯简单，只需在分区函数里将pivotValue的index随机生成即可：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">_partitionRandom</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int], low: Int, high: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> x      = <span class="type">UInt32</span>(low)</div><div class="line">    <span class="keyword">let</span> y      = <span class="type">UInt32</span>(high)</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> pivotIndex = <span class="type">Int</span>(arc4random() % (y - x)) + <span class="type">Int</span>(x)</div><div class="line">    <span class="keyword">let</span> pivotValue = array[pivotIndex] </div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在用一个数组长度和上面的测试用例一致的基本有序的数组来测试一下随机选取pivotValue的算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">merge sort...</div><div class="line">merge sort time duration : 4.73s</div><div class="line"></div><div class="line">quick sort...</div><div class="line">quick sort0 time duration : 866ms</div><div class="line">quick sort1 time duration : 15.1s  //fixed pivote index</div><div class="line">quick sort2 time duration : 4.28s  //random pivote index</div></pre></td></tr></table></figure>
<p>我们可以看到当随机抽取pivot的index的时候，其运行速度速度是上面方案的3倍。</p>
<p>现在我们知道了3种快速排序的实现，都是根据pivotValue将原数组一分为二。但是如果数组中有大量的重复的元素，而且pivotValue很有可能落在这些元素里，那么显然上面这些算法对于这些可能出现多次于pivotValue重复的情况没有单独做处理。而为了很好解决存在与pivot值相等的元素很多的数组的排序，使用三路排序算法会比较有效果。</p>
<h4 id="三路快速排序"><a href="#三路快速排序" class="headerlink" title="三路快速排序"></a>三路快速排序</h4><p>三路快速排序将大于，等于，小于pivotValue的元素都区分开，我们看一下具体的实现。先看一下partition函数的实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(<span class="number">_</span> arr: <span class="keyword">inout</span> [Int],  <span class="number">_</span> j: Int, <span class="number">_</span> k: Int)</span></span> &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> j != k <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> temp = arr[j]</div><div class="line">    arr[j] = arr[k]</div><div class="line">    arr[k] = temp</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort3W</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int], low: Int, high: Int)</span></span> &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> high &lt;= low &#123; <span class="keyword">return</span> &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">var</span> lt = low       <span class="comment">// arr[low+1...lt] &lt; v</span></div><div class="line">    <span class="keyword">var</span> gt = high + <span class="number">1</span>  <span class="comment">// arr[gt...high] &gt; v</span></div><div class="line">    <span class="keyword">var</span> i  = low + <span class="number">1</span>   <span class="comment">// arr[lt+1...i) == v</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> pivoteIndex = low</div><div class="line">    <span class="keyword">let</span> pivoteValue = array[pivoteIndex]</div><div class="line">    </div><div class="line">    <span class="keyword">while</span> i &lt; gt &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> array[i] &lt; pivoteValue &#123;</div><div class="line">          </div><div class="line">            <span class="built_in">swap</span>(&amp;array, i, lt + <span class="number">1</span>)</div><div class="line">            i += <span class="number">1</span></div><div class="line">            lt += <span class="number">1</span></div><div class="line">           </div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> pivoteValue &lt; array[i]&#123;</div><div class="line">       </div><div class="line">            <span class="built_in">swap</span>(&amp;array, i, gt - <span class="number">1</span>)</div><div class="line">            gt -= <span class="number">1</span></div><div class="line">            </div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            i += <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">swap</span>(&amp;array, low, lt)</div><div class="line">    quickSort3W(&amp;array, low: low, high: lt - <span class="number">1</span>)</div><div class="line">    quickSort3W(&amp;array, low: gt, high: high)</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort3</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int] )</span></span>&#123;</div><div class="line">    </div><div class="line">    quickSort3W(&amp;array, low: <span class="number">0</span>, high: array.<span class="built_in">count</span> - <span class="number">1</span>)</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>主要看<code>quickSort3W</code>方法，这里将数组分成了三个区间，分别是大于，等于，小于pivote的值，对有大量重复元素的数组做了比较好的处理。</p>
<p>我们生成一个元素数量为500，最大值为5的随机数组看一下这些快速排序算法的性能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">quick sort1 time duration : 6.19s //fixed pivote index</div><div class="line">quick sort2 time duration : 8.1s  //random pivote index</div><div class="line">quick sort3 time duration : 4.81s //quick sort 3 way</div></pre></td></tr></table></figure>
<p>可以看到三路快速排序（quick sort 3 way）在处理大量重复元素的数组的表现最好。</p>
<p>对于三路快速排序，我们也可以使用Swift内置的filter函数来实现:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort4</span><span class="params">(<span class="number">_</span> array: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> pivot = array[array.<span class="built_in">count</span>/<span class="number">2</span>]</div><div class="line">    <span class="keyword">let</span> less = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &lt; pivot &#125;</div><div class="line">    <span class="keyword">let</span> <span class="built_in">equal</span> = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == pivot &#125;</div><div class="line">    <span class="keyword">let</span> greater = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; pivot &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> quicksort4(less) + <span class="built_in">equal</span> + quicksort4(greater)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上，介绍完了快速排序在Swift中的5中实现方式。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲解了算法的一些基本概念以及结合了Swift代码的实现讲解了冒泡排序，选择排序，插入排序，归并排序，快速排序。相信认真阅读本文的读者能对这些算法有进一步的了解。</p>
<h2 id="关于算法学习的思考"><a href="#关于算法学习的思考" class="headerlink" title="关于算法学习的思考"></a>关于算法学习的思考</h2><p>关于算法的学习，笔者有一些思考想分享出来，也有可能有不对的地方，但笔者觉得有必要在这里说出来，希望可以引发读者的思考：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175e884d80a7?w=580&amp;h=378&amp;f=png&amp;s=19270" alt=""></p>
<p>上图的Question是指问题；Mind是指想法，或者解决问题的思路；Code是指代码实现。</p>
<p>在阅读资料或书籍的算法学习过程，往往是按照图中1，2，3这些实线的路径进行的：</p>
<ul>
<li>路径1：给出一个既定的问题后，马上给出解题策略</li>
<li>路径2：给出一个既定的问题后，马上给出算法实现</li>
<li>路径3：给出一个算法实现后，马上告诉你这些实现代码的意思</li>
</ul>
<p>这些路径在算法的学习中虽然也是必不可少的，但是很容易给人一个错觉，这个错觉就是“<strong>我已经学会了这个算法了</strong>”。但是，仅仅是通过这些路径，对于真正理解算法，和今后对算法的应用还是远远不够的，原因是：</p>
<ul>
<li>今后遇到的问题，几乎不可能与现在学习的问题一模一样，所以应该知其所以然，将问题本身抽象出来，达到触类旁通，举一反三。</li>
<li>有了一个新想法，如果没有足够的代码实现经验，很难以非常合理的方式用代码将其实现出来。所以应该增强将想法转化为代码的能力。</li>
</ul>
<p>上面所说的两点的第一点，对应的是上图的路径4：给定一个策略或是设计，要思考这个策略或是设计是解决什么样的问题的，这样也就理解了这个策略或是设计的意义在哪里；而第二点对应的是上图中的路径5：怎样根据一个给定的策略来正确地，合理地用代码地实现出来；而上图中的路径6，笔者觉得也很重要：给定一份解决问题的代码，是否可以想到它所对应的问题是什么。</p>
<p>综上所述，笔者认为对于算法的学习，需要经常反复在问题，策略以及代码之间反复思考，这样才能真正地达到学以致用。</p>
<p>因为笔者也刚刚接触这一领域的知识，所以难免会在有些地方的表述有不妥当的地方，还需读者多多给出意见和建议。</p>
<hr>
<p><strong>Swift代码</strong></p>
<p>本篇中出现的代码已经放在GitHub仓库中：</p>
<ul>
<li>算法基础部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B3%5D.Algorithm">Algorithm Introduction</a></li>
<li>排序算法部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B4%5D.Sort%20algorithms">Sort Algorithms</a></li>
</ul>
<p><strong>参考文献&amp;网站</strong></p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95" target="_blank" rel="external">维基百科：算法</a></p>
<p>《大话数据结构》</p>
<p>《数据结构与算法分析：C语言描述》</p>
<p><strong>下篇预告</strong></p>
<p>下篇会介绍堆这个数据结构以及堆排序算法。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/da_header_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇是《数据结构 &amp;amp; 算法 in Swift》系列连载的第二篇，内容分为如下两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。&lt;/li&gt;
&lt;li&gt;排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data Structure &amp; Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/categories/Data-Structure-Algorithm/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://github.com/knightsj/knightsj.github.io/tags/Swift/"/>
    
      <category term="Data Structure" scheme="https://github.com/knightsj/knightsj.github.io/tags/Data-Structure/"/>
    
      <category term="Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 &amp; 算法 in Swift （一）：Swift基础和数据结构</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20&amp;%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASwift%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/数据结构 &amp; 算法 in Swift （一）：Swift基础和数据结构/</id>
    <published>2018-02-03T08:25:26.000Z</published>
    <updated>2018-07-15T15:00:09.738Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/da_header_2.png" alt=""></p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>从本文标题中的序号可以看出，本文是一个连载的开篇。</p>
<p>而且这个连载的标题是：数据结构 &amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：</p>
<h2 id="第一：为什么学习数据结构和算法？"><a href="#第一：为什么学习数据结构和算法？" class="headerlink" title="第一：为什么学习数据结构和算法？"></a>第一：为什么学习数据结构和算法？</h2><p><strong>学习通用性知识，突破技能瓶颈</strong>：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。</p>
<h2 id="第二：为什么用Swift语言来实现？"><a href="#第二：为什么用Swift语言来实现？" class="headerlink" title="第二：为什么用Swift语言来实现？"></a>第二：为什么用Swift语言来实现？</h2><ol>
<li><p><strong>选择哪个语言并不重要，重要的是数据结构和算法本身的理解</strong>：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？</p>
</li>
<li><p><strong>如今Swift的势头还在上涨</strong>：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。</p>
</li>
</ol>
<a id="more"></a>
<p>基于上面这些原因，在今年年初把<strong>数据结构，算法和Swift</strong>的学习提上了日程，并且计划以连载的形式把学习过程中的笔记和知识分享出来。</p>
<p>该系列的<strong>最佳受众</strong>是那些已经会Swift，但是对数据结构和算法还没有过多接触过的iOS开发者。其次是那些不会Swift也不会数据结构和算法的iOS开发者，毕竟Swift是大势所趋。</p>
<p>不过对于那些非iOS开发者来说也同样适合，因为还是那句话：<strong>重点不在于使用哪种语言，而是数据结构和算法本身</strong>。除了第一篇会讲解一些在这个系列文章会使用到的Swift基础语法以外，后续的文章我会逐渐<strong>弱化对Swift语言的讲解，将重点放在数据结构和算法这里</strong>。而且后续我还会不断增加其他语言的实现（Java语言是肯定要加的，其他的语言还待定）。</p>
<p>好了，背景介绍完了，现在正式开始：</p>
<p>作为该系列的开篇，本文分为两个部分：</p>
<ol>
<li><strong>Swift语法基</strong>础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。</li>
<li><strong>数据结构</strong>：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列）</li>
</ol>
<blockquote>
<p>注：该系列涉及到的Swift语法最低基于Swift4.0。</p>
</blockquote>
<h1 id="Swift-语法基础"><a href="#Swift-语法基础" class="headerlink" title="Swift 语法基础"></a>Swift 语法基础</h1><p>Swift语法基础从以下几点来展开：</p>
<ol>
<li>循环语句</li>
<li>泛型</li>
<li>guard</li>
<li>函数</li>
<li>集合</li>
</ol>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="循环条件的开闭区间"><a href="#循环条件的开闭区间" class="headerlink" title="循环条件的开闭区间"></a>循环条件的开闭区间</h3><p>Swift将循环的开闭区间做了语法上的简化：</p>
<h4 id="闭区间："><a href="#闭区间：" class="headerlink" title="闭区间："></a>闭区间：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// index : 1</span></div><div class="line"><span class="comment">// index : 2</span></div><div class="line"><span class="comment">// index : 3</span></div><div class="line"><span class="comment">// index : 4</span></div><div class="line"><span class="comment">// index : 5</span></div></pre></td></tr></table></figure>
<h4 id="半开闭区间："><a href="#半开闭区间：" class="headerlink" title="半开闭区间："></a>半开闭区间：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// index : 1</span></div><div class="line"><span class="comment">// index : 2</span></div><div class="line"><span class="comment">// index : 3</span></div><div class="line"><span class="comment">// index : 4</span></div></pre></td></tr></table></figure>
<h3 id="循环的升序与降序"><a href="#循环的升序与降序" class="headerlink" title="循环的升序与降序"></a>循环的升序与降序</h3><p>上面两个例子都是升序的（index从小到大），我们来看一下降序的写法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> index <span class="keyword">in</span> (<span class="number">1</span>..&lt;<span class="number">5</span>).reversed() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// index : 4</span></div><div class="line"><span class="comment">// index : 3</span></div><div class="line"><span class="comment">// index : 2</span></div><div class="line"><span class="comment">// index : 1</span></div></pre></td></tr></table></figure>
<blockquote>
<p>降序的应用可以在下篇的冒泡排序算法中可以看到。</p>
</blockquote>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>使用泛型可以定义一些可复用的函数或类型，Swift中的Array和Dictionary都是泛型的集合。</p>
<p>为了体现出泛型的意义，下面举一个例子来说明一下：</p>
<blockquote>
<p>实现这样一个功能:将传入该函数的两个参数互换。</p>
</blockquote>
<p>整型的交换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tmp = a</div><div class="line">    a = b</div><div class="line">    b = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>字符串的交换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoStrings</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> String, <span class="number">_</span> b: <span class="keyword">inout</span> String)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tmp = a</div><div class="line">    a = b</div><div class="line">    b = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>浮点型的交换：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Double, <span class="number">_</span> b: <span class="keyword">inout</span> Double)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tmp = a</div><div class="line">    a = b</div><div class="line">    b = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这三种情况的实现部分其实都是一样的，但仅仅是因为传入类型的不一致，导致对于不同的类型还要定义一个新的函数。所以如果类型有很多的话，定义的新函数也会很多，这样显然是不够优雅的。</p>
<p>此类问题可以使用泛型来解决：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> tmp = a</div><div class="line">    a = b</div><div class="line">    b = tmp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面函数中的T是泛型的固定写法，可以理解为“所有类型”。这样一来，我们可以传入任何相同的类型来作交换了。</p>
<p>泛型还有其他比较强大的功能，由于在后续的数据结构和算法的讲解里面可能不会涉及到，所以在这里先不赘述了。有兴趣的朋友可以参考官方文档：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" target="_blank" rel="external">Swift：Generics</a></p>
<h2 id="guard"><a href="#guard" class="headerlink" title="guard"></a>guard</h2><blockquote>
<p>guard是 swift 2.0推出的新的判断语句的用法。</p>
<p>与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃</p>
</blockquote>
<p>使用guard语法，可以先对每个条件逐一做检查，如果不符合条件判断就退出（或者进行其他某些操作）。这就会让人容易看出来什么条件会让这个函数退出（或者进行其他某些操作）。</p>
<p>可以用一个例子来分别使用if和guard来实现，体会二者的区别：</p>
<h3 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//money:    holding moneny (用户持有的钱数)</span></div><div class="line"><span class="comment">//price:    product price  (商品的价格)</span></div><div class="line"><span class="comment">//capacity: bag capacity   (用户用来装商品的袋子容量)</span></div><div class="line"><span class="comment">//volume:   product size   (商品的大小)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">buying1</span><span class="params">( money: Int , price: Int , capacity: Int , volume: Int)</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> money &gt;= price&#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> capacity &gt;= volume&#123;</div><div class="line">            </div><div class="line">            <span class="built_in">print</span>(<span class="string">"Start buying..."</span>)</div><div class="line">            <span class="built_in">print</span>(<span class="string">"\(money-price) money left after buying."</span>)</div><div class="line">            <span class="built_in">print</span>(<span class="string">"\(capacity-volume) capacity left after buying."</span>)</div><div class="line">        </div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            </div><div class="line">            <span class="built_in">print</span>(<span class="string">"No enough capacity"</span>)</div><div class="line">        &#125;</div><div class="line">    </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"No enough money"</span>)</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的逻辑可以看出，当同时满足：</p>
<ol>
<li>用户的钱数&gt;商品价格</li>
<li>用户用来装商品的袋子容量&gt;商品的大小</li>
</ol>
<p>这两个情况的时候，购买才会进行，其他所有情况都无法引发购买。</p>
<p>对于大多数习惯使用if-else的朋友来说，上面的代码立即起来并没有难度，但是相同的逻辑，我们看一下使用guard之后的效果：</p>
<h3 id="使用guard"><a href="#使用guard" class="headerlink" title="使用guard"></a>使用guard</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">buying2</span><span class="params">( money: Int , price: Int , capacity: Int , volume: Int)</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> money &gt;= price <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"No enough money"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">guard</span> capacity &gt;= volume <span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"No enough capacity"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">print</span>(<span class="string">"Start buying..."</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(money-price) money after buying."</span>)</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(capacity-volume) capacity left after buying."</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的实现可以看出：</p>
<ul>
<li>使用guard以后，将<code>money &lt; price</code>和<code>capacity &lt; volume</code> 这两个情况首先排除掉并填上了相应的处理代码。</li>
<li>在两个guard下面才是真正正确逻辑后的处理代码。</li>
</ul>
<p>因此通过两个guard判断的语句，我们知道该函数所处理的正确逻辑是什么，非常清晰。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>因为后续的数据结构和算法的讲解是离不开函数的使用的，所以在这里简单介绍一下Swift中函数的使用。</p>
<ul>
<li>无返回值的函数</li>
<li>有返回值的函数</li>
<li>省略函数的外部参数名</li>
<li>值传递和引用传递</li>
</ul>
<h3 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a>无返回值的函数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: String)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"log: \(message)!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">log(message: <span class="string">"memory warning"</span>)</div><div class="line"><span class="comment">// output: log: memory warning!</span></div></pre></td></tr></table></figure>
<h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">logString</span><span class="params">(string: String)</span></span> -&gt; <span class="type">String</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"log: "</span> + string</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> logStr = logString(string: <span class="string">"memory warning!"</span>)</div><div class="line"><span class="built_in">print</span>(<span class="string">"\(logStr)"</span>)</div><div class="line"><span class="comment">// output: log: memory warning!</span></div></pre></td></tr></table></figure>
<h3 id="省略函数外部参数名"><a href="#省略函数外部参数名" class="headerlink" title="省略函数外部参数名"></a>省略函数外部参数名</h3><p>通过在函数形参前面加上<code>_</code>,可以起到在调用时省略外部参数的作用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">logMessage</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"log: \(message)!"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">logMessage(<span class="string">"memory warning"</span>)</div><div class="line"><span class="comment">// output: log: memory warning!</span></div></pre></td></tr></table></figure>
<p>再来看一下两个参数的情况：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">addInt</span><span class="params">(<span class="number">_</span> a : Int ,<span class="number">_</span> b : Int)</span></span>&#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"sum is \(a + b)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line">addInt(<span class="number">3</span>, <span class="number">4</span>)</div><div class="line"><span class="comment">//output : sum is 7</span></div></pre></td></tr></table></figure>
<h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>Swift中，struct是按值传递，class是按引用传递。数组和字典在Swift里是属于struct，所以需要如果在一个函数里要修改传入的数组，需要做特殊处理：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> originalArr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeLastInArray</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span>&#123;</div><div class="line">    array.removeLast()</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(<span class="string">"\n============ before removing: \(originalArr)"</span>)</div><div class="line"><span class="comment">//[2, 1, 3]</span></div><div class="line"></div><div class="line">removeLastInArray(&amp;originalArr)</div><div class="line"></div><div class="line"><span class="built_in">print</span>(<span class="string">"============ after   removing: \(originalArr)"</span>)</div><div class="line"><span class="comment">//[2, 1]</span></div></pre></td></tr></table></figure>
<p>在这里使用的<code>inout</code>关键字就是将传入的数组改为引用传递了。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Swift里的集合类型有：数组，集合，字典，下面来分别讲一下。</p>
<blockquote>
<p>这三种类型都支持泛型，也就是说里面的元素可以是整数，字符串，浮点等等。</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>Swift’s <code>Array</code> type is bridged to Foundation’s <code>NSArray</code> class.</p>
</blockquote>
<h4 id="可变数组与不可变数组"><a href="#可变数组与不可变数组" class="headerlink" title="可变数组与不可变数组"></a>可变数组与不可变数组</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// immutable array</span></div><div class="line"><span class="keyword">let</span> immutableNumbers: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</div><div class="line"></div><div class="line"><span class="comment">// mutable array</span></div><div class="line"><span class="keyword">var</span> mutableNumbers : [<span class="type">Int</span>] = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure>
<blockquote>
<p>Swift中可以用<code>let</code>和<code>var</code>来分别声明可变和不可变数组：数组的添加删除等操作只能作用于可变数组。</p>
</blockquote>
<h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iteration 1</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> mutableNumbers &#123;</div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> index = mutableNumbers.index(of: value) &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Index of \(value) is \(index)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iteration 2</span></div><div class="line">mutableNumbers.forEach &#123; value <span class="keyword">in</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> index = mutableNumbers.index(of: value) &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"Index of \(value) is \(index)"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iteration 3</span></div><div class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> mutableNumbers.enumerated() &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Item \(index + 1): \(value)"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">mutableNumbers.append(<span class="number">11</span>)</div><div class="line"><span class="comment">// Output: [2, 1, 5, 4, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.insert(<span class="number">42</span>, at: <span class="number">4</span>)</div><div class="line"><span class="comment">// Output: [2, 1, 5, 4, 42, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.swapAt(<span class="number">0</span>, <span class="number">1</span>)</div><div class="line"><span class="comment">// Output: [1, 2, 5, 4, 42, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.remove(at: <span class="number">1</span>)</div><div class="line"><span class="comment">// Output: [2, 5, 4, 42, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.removeFirst()</div><div class="line"><span class="comment">// Output: [5, 4, 42, 1, 3, 11]</span></div><div class="line"></div><div class="line">mutableNumbers.removeLast()</div><div class="line"><span class="comment">// Output: [5, 4, 42, 1, 3]</span></div><div class="line"></div><div class="line">mutableNumbers.removeAll()</div><div class="line"><span class="comment">//[]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>append函数的作用是在数组的末尾添加元素</p>
<p>swapAt函数的作用是交换在传入的两个index上的元素，该方法在下篇的排序算法中使用得非常频繁。</p>
</blockquote>
<h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><blockquote>
<p>Swift’s <code>Set</code> type is bridged to Foundation’s <code>NSSet</code> class.</p>
</blockquote>
<h4 id="集合的无序性，值的唯一性"><a href="#集合的无序性，值的唯一性" class="headerlink" title="集合的无序性，值的唯一性"></a>集合的无序性，值的唯一性</h4><p>关于集合与数组的区别，除了数组有序，集合无序以外，数组内部的元素的数值可以不是唯一的；但是集合里元素的数值必须是唯一的，如果有重复的数值会算作是一个：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//value in set is unique</span></div><div class="line"><span class="keyword">let</span> onesSet: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line"><span class="built_in">print</span>(onesSet)</div><div class="line"><span class="comment">// Output: [1]</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> onesArray: <span class="type">Array</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</div><div class="line"><span class="built_in">print</span>(onesArray)</div><div class="line"><span class="comment">// Output: [1, 1, 1, 1]</span></div></pre></td></tr></table></figure>
<h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbersSet: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line"><span class="built_in">print</span>(numbersSet)</div><div class="line"><span class="comment">// Output: undefined order, e.g. [5, 2, 3, 1, 4]</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// iteration 1</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> numbersSet &#123;</div><div class="line">    <span class="built_in">print</span>(value)</div><div class="line">&#125;</div><div class="line"><span class="comment">// output is in undefined order</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// iteration 2</span></div><div class="line">numbersSet.forEach &#123; value <span class="keyword">in</span></div><div class="line">    <span class="built_in">print</span>(value)</div><div class="line">&#125;</div><div class="line"><span class="comment">// output is in undefined order</span></div></pre></td></tr></table></figure>
<h4 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mutableStringSet: <span class="type">Set</span> = [<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>]</div><div class="line"><span class="keyword">let</span> item = <span class="string">"Two"</span></div><div class="line"></div><div class="line"><span class="comment">//contains</span></div><div class="line"><span class="keyword">if</span> mutableStringSet.<span class="built_in">contains</span>(item) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(item) found in the set"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(item) not found in the set"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//isEmpty</span></div><div class="line"><span class="keyword">let</span> strings = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">if</span> strings.isEmpty &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Set is empty"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//count</span></div><div class="line"><span class="keyword">let</span> emptyStrings = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">if</span> emptyStrings.<span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Set has no elements"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//insert</span></div><div class="line">mutableStringSet.insert(<span class="string">"Four"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//remove 1</span></div><div class="line">mutableStringSet.remove(<span class="string">"Three"</span>)</div><div class="line"></div><div class="line"><span class="comment">//remove 2</span></div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedElement = mutableStringSet.remove(<span class="string">"Six"</span>) &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(removedElement) was removed from the Set"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"Six is not found in the Set"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//removeAll()</span></div><div class="line">mutableStringSet.removeAll()</div><div class="line"><span class="comment">// []</span></div></pre></td></tr></table></figure>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><blockquote>
<p>A dictionary <code>Key</code> type must conform to the <code>Hashable</code> protocol, like a set’s value type.</p>
</blockquote>
<h4 id="字典的声明"><a href="#字典的声明" class="headerlink" title="字典的声明"></a>字典的声明</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//empty dictionary</span></div><div class="line"><span class="keyword">var</span> dayOfWeek = <span class="type">Dictionary</span>&lt;<span class="type">Int</span>, <span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">var</span> dayOfWeek2 = [<span class="type">Int</span>: <span class="type">String</span>]()</div><div class="line"></div><div class="line"><span class="comment">//not empty dictionary</span></div><div class="line"><span class="keyword">var</span> dayOfWeek3: [<span class="type">Int</span>: <span class="type">String</span>] = [<span class="number">0</span>: <span class="string">"Sun"</span>, <span class="number">1</span>: <span class="string">"Mon"</span>, <span class="number">2</span>: <span class="string">"Tue"</span>]</div><div class="line"><span class="built_in">print</span>(dayOfWeek3)</div><div class="line"><span class="comment">//output:[2: "Tue", 0: "Sun", 1: "Mon"]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到字典的键值对也是无序的，它与声明时的顺序不一定一致。</p>
</blockquote>
<h4 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iteration 1</span></div><div class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dayOfWeek &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"\(key): \(value)"</span>)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iteration 2</span></div><div class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dayOfWeek.keys &#123;</div><div class="line">    <span class="built_in">print</span>(key)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iteration 3</span></div><div class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dayOfWeek.values &#123;</div><div class="line">    <span class="built_in">print</span>(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// find value</span></div><div class="line">dayOfWeek = [<span class="number">0</span>: <span class="string">"Sun"</span>, <span class="number">1</span>: <span class="string">"Mon"</span>, <span class="number">2</span>: <span class="string">"Tue"</span>]</div><div class="line"><span class="keyword">if</span> <span class="keyword">let</span> day = dayOfWeek[<span class="number">2</span>] &#123;</div><div class="line">    <span class="built_in">print</span>(day)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// addValue 1</span></div><div class="line">dayOfWeek[<span class="number">3</span>] = <span class="string">"Wed"</span></div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// updateValue 1</span></div><div class="line">dayOfWeek[<span class="number">2</span>] = <span class="string">"Mardi"</span></div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [2: "Mardi", 0: "Sun", 1: "Mon", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// updateValue 2</span></div><div class="line">dayOfWeek.updateValue(<span class="string">"Tue"</span>, forKey: <span class="number">2</span>)</div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// removeValue 1</span></div><div class="line">dayOfWeek[<span class="number">1</span>] = <span class="literal">nil</span></div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// removeValue 2</span></div><div class="line">dayOfWeek.removeValue(forKey: <span class="number">2</span>)</div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Prints: [0: "Sun", 3: "Wed"]</span></div><div class="line"></div><div class="line"><span class="comment">// removeAll</span></div><div class="line">dayOfWeek.removeAll()</div><div class="line"></div><div class="line"><span class="built_in">print</span>(dayOfWeek)</div><div class="line"><span class="comment">// Output: [:]</span></div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到从字典里面删除某个键值对有两个方法：</p>
<ol>
<li>使用<code>removeValue</code>方法并传入要删除的键值对里的键。</li>
<li>将字典取下标之后将nil赋给它。</li>
</ol>
</blockquote>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>这一部分内容主要是对连载的后续文章作铺垫，让大家对数据结构先有一个基本的认识，因此在概念上不会深入讲解。该部分由以下三点展开：</p>
<ul>
<li><p>数据结构的基本概念</p>
</li>
<li><p>抽象数据类型</p>
</li>
<li><p>链表，栈和队列的实现</p>
<p>​</p>
</li>
</ul>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先我们来看一下数据结构的概念：</p>
<blockquote>
<p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p>
</blockquote>
<p>由数据结构这个词汇的本身（数据的结构）以及它的概念可以看出，它的重点在于“结构”和“关系”。所以说，数据是何种数据并不重要，重要的是这些数据<strong>是如何联系起来</strong>的。</p>
<p>而这些联系，可以从两个维度来展开：</p>
<ol>
<li>逻辑结构：指数据对象中元素之间的相互关系。</li>
<li>物理结构：指数据的逻辑结构在计算机中的存储形式。</li>
</ol>
<p>可以看出，逻辑结构是抽象的联系，而物理结构是实际在计算机内存里的具体联系。那么它们自己又细分为哪些结构呢？</p>
<p>逻辑结构：</p>
<ul>
<li>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。</li>
<li>线性结构：线性结构中的数据元素之间是一对一的关系。</li>
<li>树形结构：数据结构中的元素存在一对多的相互关系。</li>
<li>图形结构：数据结构中的元素存在多对多的相互关系。</li>
</ul>
<p>物理结构：</p>
<ul>
<li>顺序存储结构：把数据元素粗放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）。</li>
<li>链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</li>
</ul>
<p>为了便于记忆，用思维导图总结一下上面所说的：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8da77739?w=501&amp;h=337&amp;f=png&amp;s=29900" alt=""></p>
<p>而通过结合这两个维度中的某个结构，可以定义出来一个实际的数据结构的实现：</p>
<p>比如线性表就是线性结构的一种实现：</p>
<ul>
<li>顺序存储结构的线性表就是<strong>数组</strong>：它的内存分布是连续的，元素之间可以通过内存地址来做关联；</li>
<li>链式存储结构的线性表就是<strong>链表</strong>：它的内存分布可以是不连续的，元素之间通过指针来做关联：<ul>
<li>如果每个元素（在链表中称作节点）只持有指向后面节点的指针，那此链表就是单链表。</li>
<li>如果每个元素（在链表中称作节点）持有指向前后节点的两个指针，那此链表就是双链表。</li>
</ul>
</li>
</ul>
<p>为什么会有链表这么麻烦的东西？像数组这样，所有内存地址都是连续的不是很方便么？既生瑜何生亮呢？</p>
<p>对于获取元素（节点）这一操作，使用数组这个数据结构确实非常方便：因为所有元素在内存中是连续的，所以只需要知道数组中第一个元素的地址以及要获取元素的index就能算出该index内存的地址，一步到位非常方便。</p>
<p>但是对于向数组中某个index中插入新的元素的操作恐怕就没有这么方便了：恰恰是因为数组中所有元素的内存是连续的，所以如果想在中间插入一个新的元素，那么这个位置后面的所有元素都要后移，显然是非常低效的。如果插在数组尾部还好，如果插在第一位的话成本就太高了。</p>
<p>而如果使用链表，只要把要插入到的index前后节点的指针赋给这个新的节点就可以了，不需要移动原有节点在内存中的位置。</p>
<blockquote>
<p>关于链表的这种插入操作会在后面用代码的形式体现出来。</p>
</blockquote>
<p>既然有这么多的数据结构，那么有没有一个标准的格式来将这些特定的数据结构（也可以说是数学模型）抽象出来呢？答案是肯定的，它就是我们下一节要讲的<strong>抽象数据类型</strong>。</p>
<h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>首先来看一下抽象数据类型的概念，摘自《大话数据结构》:</p>
<blockquote>
<p>抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。</p>
</blockquote>
<p>需要注意的是：抽象数据类型的定义仅仅取决于它的一组<strong>逻辑特性</strong>，而与其在计算机内部如何表示和实现没有关系。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还尅是计算机编程者<strong>自己定义的数据类型</strong>。</p>
<p>我们看一下数据类型的标准格式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ADT 抽象数据类型名</div><div class="line"></div><div class="line">Data</div><div class="line">   数据元素之间逻辑关系的定义</div><div class="line">   </div><div class="line">Operation</div><div class="line">   操作1</div><div class="line">      初始条件</div><div class="line">      操作结果描述</div><div class="line"> </div><div class="line">   操作2</div><div class="line">      初始条件</div><div class="line">      操作结果描述</div><div class="line">      </div><div class="line">   操作n</div><div class="line"></div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>其实看上去和面向对象编程里的类的定义相似：</p>
<ul>
<li>可以把抽象数据类型的Data 和 类的成员变量联系起来。</li>
<li>可以把抽象数据类型的操作和类的函数联系起来。</li>
</ul>
<p>简单来说，抽象数据类型描述了一个数据模型所使用的数据和数据之间的逻辑关系，以及它可以执行的一些操作。因此，如果知道了一个数学模型的抽象数据类型，那么在真正接触数学模型的实现（代码）之前，就可以对该数学模型能做的事情有一个大致的了解。</p>
<p>下一章笔者会介绍链表，栈和队列这三个数学模型，在讲解每个数学模型的实现之前都会给出它们各自的抽象数据类型，让读者可以先对当前数学模型有个大致的了解。</p>
<blockquote>
<p>注意：书本文归纳的所有抽象数据类型是笔者自己根据网上资料和相关书籍而定下来的，所以严格来说它们并不是“最官方”的抽象数据类型。读者也可以参考网上的资料或是相关书籍，结合自己的思考来定义自己对着三个数据模型的抽象数据类型。</p>
</blockquote>
<h2 id="链表，栈和队列的实现"><a href="#链表，栈和队列的实现" class="headerlink" title="链表，栈和队列的实现"></a>链表，栈和队列的实现</h2><p>通过上一节的介绍，我们知道了数据结构的概念以及分类，还知道了不同的数据结构在不同的场景下会发挥不同的优势，我们要根据实际的场景来选择合适的数据结构。</p>
<p>下面就来介绍几种在实际应用中使用的比较多的数学模型：</p>
<ul>
<li>链表</li>
<li>栈</li>
<li>队列</li>
</ul>
<h3 id="链表（Linked-list）"><a href="#链表（Linked-list）" class="headerlink" title="链表（Linked list）"></a>链表（Linked list）</h3><p>说到链表就不得不提线性表这一数据结构，在介绍链表之前，首先看一下线性表的定义：</p>
<blockquote>
<p>线性表：零个或多个数据元素的有限序列。</p>
</blockquote>
<p>而根据物理结构的不同，线性表有两种具体的实现方式：</p>
<ul>
<li>线性表的顺序存储结构：线性表的数据元素是被一段<strong>地址连续</strong>的存储单存储起来的。</li>
<li>线性表的链式存储结构: 线性表的数据元素是被用一组<strong>连续或不连续</strong>的存储单元存储起来的，这些元素通过指针来作为逻辑上的连接。</li>
</ul>
<blockquote>
<p>注：上面两个概念是笔者用自己的话总结出来的。</p>
</blockquote>
<p>在这里，线性表的顺序存储结构的实现就是我们熟悉的数组；而线性表的链式存储结构的实现就是笔者即将要介绍的链表。</p>
<h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><p>相信对于读完上一节的朋友来说，应该对链表有一个比较清晰的认识了。关于链表的定义有很多不同的版本，笔者个人比较喜欢百度百科里的定义：</p>
<blockquote>
<p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p>
</blockquote>
<p>而且由于数据元素所持有的指针个数和链接特性可以将链表分为：</p>
<ul>
<li>单向链表：单向链表的链接方向是单向的，其中每个结点都有指针成员变量指向列表中的下一个结点；</li>
<li>双向链表：双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点，它的链接方向是双向的。</li>
<li>循环链表：循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。</li>
</ul>
<p>笔者从中挑选出双向链表来进行讲解，它的难度适中，而且能够很好地让读者体会出链表的优势。</p>
<h4 id="双向链表的抽象数据类型"><a href="#双向链表的抽象数据类型" class="headerlink" title="双向链表的抽象数据类型"></a>双向链表的抽象数据类型</h4><p>因为节点是链表的基本组成单元，所以想要实现链表，必须先要介绍链表的组成部分-节点。</p>
<p>节点：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">ADT 节点(node)</div><div class="line"></div><div class="line">Data</div><div class="line">  value:持有的数据</div><div class="line"></div><div class="line">Operation</div><div class="line">   init:初始化</div><div class="line">   previous:指向上一节点的指针</div><div class="line">   next:指向下一节点的指针</div><div class="line">   </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>再来看一下链表的抽象数据类型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">ADT 链表（linked list）</div><div class="line"></div><div class="line">Data</div><div class="line">  linked list:持有的线性表</div><div class="line"></div><div class="line">Operation</div><div class="line">   init:初始化</div><div class="line">   count:持有节点总个数</div><div class="line">   isEmpty:是否为空</div><div class="line">   first:头节点</div><div class="line">   last:尾节点</div><div class="line">   node:传入index返回节点</div><div class="line">   insert:插入node到指定index</div><div class="line">   insertToHead:插入节点到表头</div><div class="line">   appendToTail:插入节点到表尾</div><div class="line">   removeAll:移除所有节点</div><div class="line">   remove:移除传入的节点</div><div class="line">   removeAt:移除传入index的节点</div><div class="line">   </div><div class="line">endADT</div></pre></td></tr></table></figure>
<h4 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h4><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//value of a node</span></div><div class="line">    <span class="keyword">var</span> value: <span class="type">T</span></div><div class="line">  </div><div class="line">   <span class="comment">//pointer to previous node</span></div><div class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> previous: <span class="type">LinkedListNode</span>?</div><div class="line">  </div><div class="line">    <span class="comment">//pointer to next node</span></div><div class="line">    <span class="keyword">var</span> next: <span class="type">LinkedListNode</span>?</div><div class="line">  </div><div class="line">    </div><div class="line">    <span class="comment">//init</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(value: <span class="type">T</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.value = value</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再来看一下链表的实现：</p>
<p>因为整个链表的插入，删除等操作比较多，整个链表的定义超过了200行代码，所以为了看着方便一点，在这里来分段说明一下。</p>
<p>首先看一下链表的成员变量:</p>
<h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> = <span class="type">LinkedListNode</span>&lt;<span class="type">T</span>&gt;</div><div class="line">    </div><div class="line">    <span class="comment">//if empty</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> head == <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//total count of nodes</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</div><div class="line">      </div><div class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> node = head <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next = node.next &#123;</div><div class="line">            node = next</div><div class="line">            <span class="built_in">count</span> += <span class="number">1</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//pointer to the first node, private</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">var</span> head: <span class="type">Node</span>?</div><div class="line">    </div><div class="line">    <span class="comment">//pointer to the first node, public</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> first: <span class="type">Node</span>? &#123;</div><div class="line">        <span class="keyword">return</span> head</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//pointer to the last node</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> last: <span class="type">Node</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> node = head <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//until node.next is nil</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next = node.next &#123;</div><div class="line">            node = next</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> node</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ...</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相信看上面的命名以及注释大家可以对链表的成员变量有个初步的理解，这里面需要说三点：</p>
<ol>
<li><code>typealias</code>是用来重新为已经存在的类型命名的：这里用<code>Node</code>代替了<code>LinkedListNode&lt;T&gt;</code>（节点类型），降低了不少阅读代码的成本。</li>
<li>在获取<code>count</code>和<code>last</code>的实现，都先判断了<code>head</code>这个指针是否为nil，如果是则判定为空链表，自然也就不存在节点个数和最后的节点对象了。</li>
<li>同样地，也是在获取<code>count</code>和<code>last</code>的实现里，使用了<code>while</code>控制语句来判断node.next节点是否存在：如果存在，则继续+1或者继续往下寻找，直到node.next为nil时才停止。在这里我们可以看到链表的寻址方式：是通过头结点开始，以节点的.next指针来寻找下一个节点的。而且作为链表的尾节点，它的.next指针不指向任何对象，因为它本来就是链表的最后一项。</li>
</ol>
<blockquote>
<p>最下方的…代表即将在下面介绍的一些函数，这些函数都定义在的<code>LinkedList</code>这个class里面。</p>
</blockquote>
<h5 id="获取index上node"><a href="#获取index上node" class="headerlink" title="获取index上node"></a>获取index上node</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get node of index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">node</span><span class="params">(atIndex index: Int)</span></span> -&gt; <span class="type">Node</span>? &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</div><div class="line">        <span class="comment">//head node</span></div><div class="line">        <span class="keyword">return</span> head!</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">var</span> node = head!.next</div><div class="line"></div><div class="line">        <span class="keyword">guard</span> index &lt; <span class="built_in">count</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;index &#123;</div><div class="line">            <span class="comment">// go on finding by .next</span></div><div class="line">            node = node?.next</div><div class="line">            <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</div><div class="line">                <span class="keyword">break</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> node!</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意在这里返回的node是可以为nil的，而且在这里可以看出来，链表在寻找特定node的时候，是根据节点的.next指针来一个一个寻找的。这个与顺序存储结构的数组是不同的，在后面我会重点讲解一下这二者的不同。</p>
<h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//insert node to last index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">appendToTail</span><span class="params">(value: T)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newNode = <span class="type">Node</span>(value: value)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastNode = last &#123;</div><div class="line"></div><div class="line">        <span class="comment">//update last node: newNode becomes new last node;</span></div><div class="line">        <span class="comment">//the previous last node becomes the second-last node</span></div><div class="line">        newNode.previous = lastNode</div><div class="line">        lastNode.next = newNode</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">//blank linked list</span></div><div class="line">        head = newNode</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//insert node to index 0</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insertToHead</span><span class="params">(value: T)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newHead = <span class="type">Node</span>(value: value)</div><div class="line"></div><div class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</div><div class="line">		<span class="comment">//blank linked list</span></div><div class="line">        head = newHead</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        newHead.next = head</div><div class="line">        head?.previous = newHead</div><div class="line">        head = newHead</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//insert node in specific index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> node: Node, atIndex index: Int)</span></span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"invalid input index"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> newNode = node</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</div><div class="line"></div><div class="line">        head = newNode</div><div class="line"></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</div><div class="line"></div><div class="line">            newNode.next = head</div><div class="line">            head?.previous = newNode</div><div class="line">            head = newNode</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> index &gt; <span class="built_in">count</span> &#123;</div><div class="line"></div><div class="line">                <span class="built_in">print</span>(<span class="string">"out of range"</span>)</div><div class="line">                <span class="keyword">return</span></div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">let</span> prev = <span class="keyword">self</span>.node(atIndex: index-<span class="number">1</span>)</div><div class="line">            <span class="keyword">let</span> next = prev?.next</div><div class="line"></div><div class="line">            newNode.previous = prev</div><div class="line">            newNode.next = prev?.next</div><div class="line">            prev?.next = newNode</div><div class="line">            next?.previous = newNode</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>链表的插入节点的操作分为三种，按照从上到下的顺序依次是：</p>
<ol>
<li>在头部插入</li>
<li>在尾部插入</li>
<li>指定index插入</li>
</ol>
<p>需要注意的是</p>
<ul>
<li>在前两种插入函数中，需要先判断该链表是否是空的，如果是，则要将链表的该节点赋给链表的<code>head</code>指针。</li>
<li>在第三种插入函数中，还是先判断该链表是否是空的，如果是，则无论index是多少(只要不小于0)，都插在链表的头部。如果不是空的，再判断index是否为0，如果是，则直接插在头部；如果index不为0，则判断index是否大于count，如果是，则无法插入；如果不是，则获取插入位置的前后节点进行重连。</li>
</ul>
<blockquote>
<p>在这里判断链表为空链表后的处理是笔者自己加上去的，笔者在网上的资料里没有看到过。大家不必纠结于这种处理方式，毕竟链表操作的重点在于前后节点的重连。</p>
</blockquote>
<h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//removing all nodes</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">()</span></span> &#123;</div><div class="line">    head = <span class="literal">nil</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//remove the last node</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeLast</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> !isEmpty <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> remove(node: last!)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//remove a node by it's refrence</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(node: Node)</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> prev = node.previous</div><div class="line">    <span class="keyword">let</span> next = node.next</div><div class="line"></div><div class="line">    <span class="keyword">if</span> <span class="keyword">let</span> prev = prev &#123;</div><div class="line">        prev.next = next</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        head = next</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    next?.previous = prev</div><div class="line"></div><div class="line">    node.previous = <span class="literal">nil</span></div><div class="line">    node.next = <span class="literal">nil</span></div><div class="line">    <span class="keyword">return</span> node.value</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//remove a node by it's index</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAt</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> node = <span class="keyword">self</span>.node(atIndex: index)</div><div class="line">    <span class="keyword">guard</span> node != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> remove(node: node!)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>如果要移除链表上所有节点，只需要将head指针置空就可以了，因为它是所有节点的“源头”，是链表寻址的第一个节点。</li>
<li>在持有某个节点的指针的时候可以指定链表来移除这个节点（使用<code>remove</code>函数）。在这个函数内部，首先需要将该节点的前后节点对接，然后将该几点的前后指针置空。</li>
<li>当有要移除节点的指针但是知道该节点在链表中的index，可以使用<code>removeAt</code>函数。在这个函数内部，首先根据index来获取对应的node的指针，然后再调用<code>remove</code>函数删除这个node。</li>
</ul>
<h5 id="打印所有节点"><a href="#打印所有节点" class="headerlink" title="打印所有节点"></a>打印所有节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllNodes</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> node = head</div><div class="line"></div><div class="line">    <span class="built_in">print</span>(<span class="string">"\nstart printing all nodes:"</span>)</div><div class="line"></div><div class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</div><div class="line">            <span class="keyword">break</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">print</span>(<span class="string">"[\(index)]\(node!.value)"</span>)</div><div class="line">        node = node!.next</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该函数只是为了方便调试，为了跟踪链表的状态而定义的，它并不存在于链表的模型里。</p>
<p>为了验证上面这些方法的有效性，我们来实例化一个链表后实际操作一下，读者可以结合注释来看一下每一步对应的结果：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> list = <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;()</div><div class="line">list.isEmpty   <span class="comment">// true</span></div><div class="line">list.first     <span class="comment">// nil</span></div><div class="line">list.<span class="built_in">count</span>     <span class="comment">// 0</span></div><div class="line"></div><div class="line">list.appendToTail(value: <span class="string">"Swift"</span>)</div><div class="line">list.isEmpty         <span class="comment">// false</span></div><div class="line">list.first!.value    <span class="comment">// "Swift"</span></div><div class="line">list.last!.value     <span class="comment">// "Swift"</span></div><div class="line">list.<span class="built_in">count</span>           <span class="comment">//1</span></div><div class="line"></div><div class="line">list.appendToTail(value:<span class="string">"is"</span>)</div><div class="line">list.first!.value    <span class="comment">// "Swift"</span></div><div class="line">list.last!.value     <span class="comment">// "is"</span></div><div class="line">list.<span class="built_in">count</span>           <span class="comment">// 2</span></div><div class="line"></div><div class="line">list.appendToTail(value:<span class="string">"great"</span>)</div><div class="line">list.first!.value    <span class="comment">// "Swift"</span></div><div class="line">list.last!.value     <span class="comment">// "great"</span></div><div class="line">list.<span class="built_in">count</span>           <span class="comment">// 3</span></div><div class="line"></div><div class="line"></div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]Swift</span></div><div class="line"><span class="comment">//[1]is</span></div><div class="line"><span class="comment">//[2]Great</span></div><div class="line"></div><div class="line">list.node(atIndex: <span class="number">0</span>)?.value <span class="comment">// Swift</span></div><div class="line">list.node(atIndex: <span class="number">1</span>)?.value <span class="comment">// is</span></div><div class="line">list.node(atIndex: <span class="number">2</span>)?.value <span class="comment">// great</span></div><div class="line">list.node(atIndex: <span class="number">3</span>)?.value <span class="comment">// nil</span></div><div class="line"></div><div class="line"></div><div class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"language"</span>), atIndex: <span class="number">1</span>)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]Swift</span></div><div class="line"><span class="comment">//[1]language</span></div><div class="line"><span class="comment">//[2]is</span></div><div class="line"><span class="comment">//[3]great</span></div><div class="line"></div><div class="line"></div><div class="line">list.remove(node: list.first!)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]language</span></div><div class="line"><span class="comment">//[1]is</span></div><div class="line"><span class="comment">//[2]great</span></div><div class="line"></div><div class="line"></div><div class="line">list.removeAt(<span class="number">1</span>)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]language</span></div><div class="line"><span class="comment">//[1]great</span></div><div class="line"></div><div class="line">list.removeLast()</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]language</span></div><div class="line"></div><div class="line">list.insertToHead(value: <span class="string">"study"</span>)</div><div class="line">list.<span class="built_in">count</span>             <span class="comment">// 2</span></div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]study</span></div><div class="line"><span class="comment">//[1]language</span></div><div class="line"></div><div class="line"></div><div class="line">list.removeAll()</div><div class="line">list.printAllNodes()<span class="comment">//linked list is empty</span></div><div class="line"></div><div class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">3</span>)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]new</span></div><div class="line"></div><div class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">3</span>) <span class="comment">//out of range</span></div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]new</span></div><div class="line"></div><div class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">1</span>)</div><div class="line">list.printAllNodes()</div><div class="line"><span class="comment">//[0]new</span></div><div class="line"><span class="comment">//[1]new</span></div></pre></td></tr></table></figure>
<h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈的讲解从</p>
<ul>
<li>栈的定义</li>
<li>栈的抽象数据类型</li>
<li>栈的实现</li>
</ul>
<p>三个部分来展开。</p>
<h4 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h4><p>首先来看一下栈的定义：</p>
<blockquote>
<p>栈是限定仅在表的尾部进行插入和删除操作的线性表。</p>
</blockquote>
<p>从定义中可以看出，我们知道我们只能在栈的一端来操作栈：</p>
<ul>
<li>允许插入和删除的一端成为栈顶</li>
<li>另一端成为栈底</li>
</ul>
<p>用一张图来看一下栈的操作：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8db5eaf6?w=618&amp;h=432&amp;f=png&amp;s=73000" alt=""></p>
<blockquote>
<p>图源：《维基百科：Stack (abstract data type)》</p>
</blockquote>
<p>从上图可以看出，最先压入栈里面的只能最后访问，也就是说，栈遵循后进先出（Last In First Out, LIFO）的原则。</p>
<h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ADT 栈（Stack）</div><div class="line"></div><div class="line">Data</div><div class="line">  linked list:持有的线性表</div><div class="line"></div><div class="line">Operation</div><div class="line">   init:初始化</div><div class="line">   count:栈的元素个数</div><div class="line">   isEmpty:是否为空</div><div class="line">   push:入栈</div><div class="line">   pop:出栈</div><div class="line">   top:返回顶部元素</div><div class="line">   </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。</p>
<h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>笔者将数组（顺序存储）作为栈的线性表的实现，同时支持泛型。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//array</span></div><div class="line">    fileprivate <span class="keyword">var</span> stackArray = [<span class="type">T</span>]()</div><div class="line">    </div><div class="line">    <span class="comment">//count</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> stackArray.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//is empty ?</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> stackArray.isEmpty</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//top element</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">T</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> isEmpty&#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> stackArray.last</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//push operation</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> element: T)</span></span> &#123;</div><div class="line">        stackArray.append(element)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//pop operation</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> isEmpty&#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"stack is empty"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> stackArray.removeLast()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//print all</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllElements</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">guard</span> <span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"stack is empty"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"\nprint all stack elemets:"</span>)</div><div class="line">        <span class="keyword">for</span> (index, value) <span class="keyword">in</span> stackArray.enumerated() &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"[\(index)]\(value)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>fileprivate</code>：是Swift3.0新增的访问控制，表示在定义的声明文件里可访问。它代替了过去意义上的<code>private</code>。而有了<code>fileprivate</code>以后，新的<code>private</code>则代表了真正的私有：在这个类或结构体的外部无法访问。</li>
<li>这里<code>printAllElements</code>方法也不属于抽象数据类型里的方法，也是为了方便调试，可以打印出所有的数据元素。</li>
</ul>
<p>我们来实例化上面定义的栈实际操作一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stack = <span class="type">Stack</span>.<span class="keyword">init</span>(stackArray: [])</div><div class="line">stack.printAllElements() <span class="comment">//stack is empty</span></div><div class="line">stack.isEmpty <span class="comment">//true</span></div><div class="line"></div><div class="line">stack.push(<span class="number">2</span>)</div><div class="line">stack.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"></div><div class="line">stack.isEmpty <span class="comment">//false</span></div><div class="line">stack.top     <span class="comment">//2</span></div><div class="line"></div><div class="line"></div><div class="line">stack.push(<span class="number">3</span>)</div><div class="line">stack.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"><span class="comment">//[1]3</span></div><div class="line"></div><div class="line">stack.isEmpty <span class="comment">//false</span></div><div class="line">stack.top     <span class="comment">//3</span></div><div class="line"></div><div class="line"></div><div class="line">stack.pop()</div><div class="line">stack.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"></div><div class="line">stack.isEmpty <span class="comment">//false</span></div><div class="line">stack.top     <span class="comment">//2</span></div><div class="line"></div><div class="line"></div><div class="line">stack.pop()</div><div class="line">stack.printAllElements() <span class="comment">//stack is empty</span></div><div class="line">stack.top <span class="comment">//nil</span></div><div class="line">stack.isEmpty <span class="comment">//true</span></div><div class="line"></div><div class="line">stack.pop() <span class="comment">//stack is empty</span></div></pre></td></tr></table></figure>
<h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列的讲解从</p>
<ul>
<li>队列的定义</li>
<li>队列的抽象数据类型</li>
<li>队列的实现</li>
</ul>
<p>三个部分来展开。</p>
<h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8db00b50?w=618&amp;h=432&amp;f=png&amp;s=95179" alt=""></p>
<blockquote>
<p>图源：《维基百科：FIFO (computing and electronics)》</p>
</blockquote>
<h4 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ADT 队列（Queue）</div><div class="line"></div><div class="line">Data</div><div class="line">  linked list:持有的线性表</div><div class="line"></div><div class="line">Operation</div><div class="line">   init:初始化</div><div class="line">   count:栈的元素个数</div><div class="line">   isEmpty:是否为空</div><div class="line">   front:获取队列头元素</div><div class="line">   enqueue:插入到队尾</div><div class="line">   dequeue:删除队列头元素并返回</div><div class="line">   </div><div class="line">endADT</div></pre></td></tr></table></figure>
<p>和上面的栈的实现一致，队列的实现也使用数组来实现队列内部的线性表。</p>
<h4 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//array</span></div><div class="line">    fileprivate <span class="keyword">var</span> queueArray = [<span class="type">T</span>]()</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//count</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</div><div class="line">        <span class="keyword">return</span> queueArray.<span class="built_in">count</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//is empty?</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> queueArray.isEmpty</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//front element</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">var</span> front: <span class="type">T</span>? &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> isEmpty &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> queueArray.first</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//add element</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(<span class="number">_</span> element: T)</span></span> &#123;</div><div class="line">        queueArray.append(element)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="comment">//remove element</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</div><div class="line">        <span class="keyword">if</span> isEmpty &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> queueArray.removeFirst()</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//print all</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllElements</span><span class="params">()</span></span> &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">guard</span> <span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</div><div class="line">            <span class="keyword">return</span></div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">print</span>(<span class="string">"\nprint all queue elemets:"</span>)</div><div class="line">        <span class="keyword">for</span> (index, value) <span class="keyword">in</span> queueArray.enumerated() &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"[\(index)]\(value)"</span>)</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们初始化一个队列后实际操作一下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> queue = <span class="type">Queue</span>.<span class="keyword">init</span>(queueArray: [])</div><div class="line">queue.printAllElements()<span class="comment">//queue is empty</span></div><div class="line">queue.isEmpty <span class="comment">//true</span></div><div class="line">queue.<span class="built_in">count</span>   <span class="comment">//0</span></div><div class="line"></div><div class="line"></div><div class="line">queue.enqueue(<span class="number">2</span>)</div><div class="line">queue.printAllElements()</div><div class="line">queue.isEmpty  <span class="comment">//false</span></div><div class="line"><span class="comment">//[0]2</span></div><div class="line"></div><div class="line">queue.enqueue(<span class="number">3</span>)</div><div class="line">queue.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"><span class="comment">//[1]3</span></div><div class="line"></div><div class="line"></div><div class="line">queue.enqueue(<span class="number">4</span>)</div><div class="line">queue.printAllElements()</div><div class="line"><span class="comment">//[0]2</span></div><div class="line"><span class="comment">//[1]3</span></div><div class="line"><span class="comment">//[2]4</span></div><div class="line">queue.front <span class="comment">//2</span></div><div class="line"></div><div class="line"></div><div class="line">queue.dequeue()</div><div class="line">queue.printAllElements()</div><div class="line"><span class="comment">//[0]3</span></div><div class="line"><span class="comment">//[1]4</span></div><div class="line">queue.front <span class="comment">//3</span></div><div class="line"></div><div class="line"></div><div class="line">queue.dequeue()</div><div class="line">queue.printAllElements()</div><div class="line"><span class="comment">//[0]4</span></div><div class="line">queue.front <span class="comment">//4</span></div><div class="line"></div><div class="line">queue.dequeue()</div><div class="line">queue.printAllElements() <span class="comment">//queue is empty</span></div><div class="line">queue.front <span class="comment">//return nil, and print : queue is empty</span></div><div class="line">queue.isEmpty <span class="comment">//true</span></div><div class="line">queue.<span class="built_in">count</span><span class="comment">//0</span></div></pre></td></tr></table></figure>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>这两周学习数据结构和算法让我收获很多，除了强化了Swift语法以外，感觉自己看代码的感觉变了：看到一个设计就会想到里面所用到的数据结构，或是算法上面有没有可以优化的可能等等。</p>
<p>我相信对我来说编程的一扇新的门被打开了，希望自己可以坚持下去～</p>
<p>该系列的所有代码会放在我的GitHub的一个项目里面，项目地址：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift">Github:data-structure-and-algorithm-in-Swift</a></p>
<p>本篇文章的代码：</p>
<ul>
<li>Swift语法部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B1%5D.Swift%20syntax">[1].Swift syntax</a></li>
<li>数据结构部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B2%5D.Data%20structure">[2].Data structure</a></li>
</ul>
<p>下篇预告：</p>
<p>从下一篇会开始正式讲解算法。本系列第二篇的主题是<strong>排序算法</strong>，内容是用Swift语言实现并讲解几种比较常见的排序算法：冒泡排序，选择排序，插入排序，希尔排序，堆排序，快速排序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/da_header_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;从本文标题中的序号可以看出，本文是一个连载的开篇。&lt;/p&gt;
&lt;p&gt;而且这个连载的标题是：数据结构 &amp;amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：&lt;/p&gt;
&lt;h2 id=&quot;第一：为什么学习数据结构和算法？&quot;&gt;&lt;a href=&quot;#第一：为什么学习数据结构和算法？&quot; class=&quot;headerlink&quot; title=&quot;第一：为什么学习数据结构和算法？&quot;&gt;&lt;/a&gt;第一：为什么学习数据结构和算法？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;学习通用性知识，突破技能瓶颈&lt;/strong&gt;：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。&lt;/p&gt;
&lt;h2 id=&quot;第二：为什么用Swift语言来实现？&quot;&gt;&lt;a href=&quot;#第二：为什么用Swift语言来实现？&quot; class=&quot;headerlink&quot; title=&quot;第二：为什么用Swift语言来实现？&quot;&gt;&lt;/a&gt;第二：为什么用Swift语言来实现？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;选择哪个语言并不重要，重要的是数据结构和算法本身的理解&lt;/strong&gt;：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如今Swift的势头还在上涨&lt;/strong&gt;：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Data Structure &amp; Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/categories/Data-Structure-Algorithm/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://github.com/knightsj/knightsj.github.io/tags/Swift/"/>
    
      <category term="Data Structure" scheme="https://github.com/knightsj/knightsj.github.io/tags/Data-Structure/"/>
    
      <category term="Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>浅显易懂讲解iOS多线程技术-GCD</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%E8%AE%B2%E8%A7%A3%E7%9A%84iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF-GCD/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/浅显易懂讲解的iOS多线程技术-GCD/</id>
    <published>2018-02-02T16:21:25.000Z</published>
    <updated>2018-02-02T16:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>励志打造一篇浅显易懂地介绍iOS中GCD的文章！<br>笔者见过很多其他讲解GCD的博客，有些写得非常详细非常专业，几乎涵盖了GCD大大小小的全部知识，细致庞杂的内容容易让人摸不清主次，笔者觉得这类文章<strong>并不适合初学者学习</strong>，于是决定写一篇针对一些只是听过，但是对GCD还不了解的童鞋们。</p>
<p>本文排除了一些细枝末节，扰乱人头绪的东西，着重讲解了GCD中重要的知识点，并在最后展示了GCD中<strong>经常使用的函数</strong>并附上结果图和讲解，简单明了。</p>
<a id="more"></a>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><hr>
<p>在了解多线程之前，需要弄清进程和线程的概念和他们之间的区别。</p>
<h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>系统中正在运行的一个程序，进程之间是相互独立的，每个进程都有属于自己的内存空间。比如手机中的<strong>微信</strong>应用和<strong>印象笔记</strong>应用，他们都是iOS系统中独立的进程，有着自己的内存空间。</p>
<h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>进程内部执行任务所需要的执行路径。进程若想执行任务，则必须得在线程下执行。也就是说进程至少有一个线程才能执行任务。但是，我们使用软件的时候，很少有只让它做一件事的时候：</p>
<p>举个<strong>印象笔记</strong>的🌰 ： 当你正在编辑一则笔记的时候点击了同步按钮，那么编辑任务（线程）和同步任务（线程）一定是不能按照顺序执行的。因为同步任务的完成时间是不可控的，如果在同步的过程中无法进行别的任务（线程）那就太糟糕了！</p>
<p>因此，我们需要让一些任务可以同时进行。既然任务是在线程上执行的，那么多任务的执行就意味着需要多线程的开启和使用。</p>
<p>来一张图直观地展示一下内存，进程和线程的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-a1e6c65eda0d3aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存，进程和线程"></p>
<h1 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h1><hr>
<p>多线程的实现原理：虽然在同一时刻，CPU只能处理1条线程，但是CPU可以快速地在多条线程之间调度（切换），造成了多线程并发执行的假象。</p>
<h2 id="1-多线程的优点"><a href="#1-多线程的优点" class="headerlink" title="1. 多线程的优点"></a>1. 多线程的优点</h2><ul>
<li>能适当提高程序的执行效率。</li>
<li>能适当提高资源利用率（CPU、内存利用率）。</li>
</ul>
<h2 id="2-多线程的缺点"><a href="#2-多线程的缺点" class="headerlink" title="2. 多线程的缺点"></a>2. 多线程的缺点</h2><ul>
<li>创建线程是需要成本的：iOS下主要成本包括：在栈空间的子线程512KB、主线程1MB，创建线程大约需要90毫秒的创建时间。</li>
<li>线程越多，CPU在调度线程上的开销就越大。</li>
<li>线程越多，程序设计就越复杂：因为要考虑到线程之间的通信，多线程的数据共享。</li>
</ul>
<h1 id="多线程在iOS开发中的应"><a href="#多线程在iOS开发中的应" class="headerlink" title="多线程在iOS开发中的应"></a>多线程在iOS开发中的应</h1><hr>
<h2 id="1-iOS的主线程"><a href="#1-iOS的主线程" class="headerlink" title="1. iOS的主线程"></a>1. iOS的主线程</h2><p>一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</p>
<h4 id="主线程的作用"><a href="#主线程的作用" class="headerlink" title="主线程的作用:"></a>主线程的作用:</h4><ul>
<li>显示\刷新UI界面</li>
<li>处理UI事件（比如点击事件、滚动事件、拖拽事件等）</li>
</ul>
<blockquote>
<p>主线程的使用<strong>注意事项</strong>:<br>不能把比较耗时的操作放到主线程中，，严重影响UI的流畅度，给用户一种程序“卡顿”的体验。<br>因此，要将耗时的操作放在子线程中异步执行。这样一来，及时开始执行了耗时的操作，也不会影响主线程中UI交互的体验。</p>
</blockquote>
<h2 id="2-iOS的子线程"><a href="#2-iOS的子线程" class="headerlink" title="2. iOS的子线程"></a>2. iOS的子线程</h2><p>子线程是异步执行的，不影响主线程。在iOS开发中，我们需要将耗时的任务（网络请求，复杂的运算）放在子线程进行，不让其影响UI的交互体验。</p>
<h2 id="3-多线程安全"><a href="#3-多线程安全" class="headerlink" title="3. 多线程安全"></a>3. 多线程安全</h2><p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。就好比好几个人在同时修改同一个表格，造成数据的错乱。</p>
<h4 id="3-1-资源抢夺的解决方案"><a href="#3-1-资源抢夺的解决方案" class="headerlink" title="3.1 资源抢夺的解决方案"></a>3.1 资源抢夺的解决方案</h4><p>我们需要给数据添加<strong>互斥锁</strong>。也就是说，当某线程访问一个数据之前就要给数据加锁，让其不被其他的线程所修改。就好比一个人修改表格的时候给表格设置了密码，那么其他人就无法访问文件了。当他修改文件之后，再讲密码撤销，第二个人就可以访问该文件了。</p>
<blockquote>
<p><strong>注意</strong>：<br>这里的线程都为子线程，如果给数据加了锁，就等于将这些异步的子线程变成同步的了，这也叫做线程同步技术。</p>
</blockquote>
<h4 id="3-2-互斥锁使用："><a href="#3-2-互斥锁使用：" class="headerlink" title="3.2 互斥锁使用："></a>3.2 互斥锁使用：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span>(锁对象) &#123; <span class="comment">// 需要锁定的代码  &#125;;</span></div></pre></td></tr></table></figure>
<h4 id="3-3-互斥锁的优缺点"><a href="#3-3-互斥锁的优缺点" class="headerlink" title="3.3 互斥锁的优缺点"></a>3.3 互斥锁的优缺点</h4><p>优点：能有效防止因多线程抢夺资源造成的数据安全问题<br>缺点：需要消耗大量的CPU资源</p>
<p>互斥锁的使用前提：多条线程抢夺同一块资源的时候使用。</p>
<h4 id="3-4互斥锁在iOS开发中的使用"><a href="#3-4互斥锁在iOS开发中的使用" class="headerlink" title="3.4互斥锁在iOS开发中的使用"></a>3.4互斥锁在iOS开发中的使用</h4><p>OC在定义属性时有<code>nonatomic</code>和<code>atomic</code>两种选择</p>
<ul>
<li>atomic：原子属性，为setter方法加锁（默认就是atomic）</li>
<li>nonatomic：非原子属性，不会为setter方法加锁</li>
</ul>
<h4 id="3-5-nonatomic和atomic对比"><a href="#3-5-nonatomic和atomic对比" class="headerlink" title="3.5 nonatomic和atomic对比"></a>3.5 nonatomic和atomic对比</h4><p>atomic：线程安全，需要消耗大量的资源<br>nonatomic：非线程安全，适合内存小的移动设备</p>
<blockquote>
<p><strong>建议：</strong><br>所有属性都声明为nonatomic，尽量避免多线程抢夺同一块资源，将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力。</p>
</blockquote>
<h1 id="多线程在iOS中的应用：GCD"><a href="#多线程在iOS中的应用：GCD" class="headerlink" title="多线程在iOS中的应用：GCD"></a>多线程在iOS中的应用：GCD</h1><hr>
<p>GCD，全称为 Grand Central Dispatch ，是iOS用来管理线程的技术。 纯C语言，提供了非常多强大的函数。</p>
<h2 id="1-GCD的优势"><a href="#1-GCD的优势" class="headerlink" title="1. GCD的优势"></a>1. GCD的优势</h2><p>GCD会自动利用更多的CPU内核（比如双核、四核）。<br>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。<br>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码。</p>
<h2 id="2-为什么要用GCD？"><a href="#2-为什么要用GCD？" class="headerlink" title="2. 为什么要用GCD？"></a>2. 为什么要用GCD？</h2><p>为了要提高软件性能，应该异步执行耗时任务(加载图片)，以防止影响主线程任务的执行(UI相应)。</p>
<blockquote>
<p>举个🌰 ：<br>从网络加载一张图片，如果将此任务放到主线程，那么在下载完成的时间里，软件是无法相应用户的任何操作的。特别地，如果当前是在可以滚动的页面，就会造成无法滚动这种体验非常糟的情况。</p>
</blockquote>
<p>所以：应该将网络加载放在异步执行，执行成功后，再回到主线程显示加载后的图片(详细做法马上就会讲到)。</p>
<h2 id="3-GCD的使用步骤"><a href="#3-GCD的使用步骤" class="headerlink" title="3. GCD的使用步骤"></a>3. GCD的使用步骤</h2><ol>
<li>由开发者定制将要执行的任务。</li>
</ol>
<ul>
<li>将任务添加到队列中，GCD会自动将队列中的任务取出，放到对应的线程中执行。</li>
</ul>
<blockquote>
<p><strong>注意：</strong><br>任务的取出遵循队列的FIFO原则：先进先出，后进后出。</p>
</blockquote>
<h2 id="4-什么是队列？"><a href="#4-什么是队列？" class="headerlink" title="4. 什么是队列？"></a>4. 什么是队列？</h2><p>队列是用来存放任务的，由GCD将这些任务从队列中取出并放到相应的线程中执行。</p>
<h3 id="GCD的队列可以分为2大类型："><a href="#GCD的队列可以分为2大类型：" class="headerlink" title="GCD的队列可以分为2大类型："></a>GCD的队列可以分为2大类型：</h3><h4 id="1-并发队列（Concurrent-Dispatch-Queue）"><a href="#1-并发队列（Concurrent-Dispatch-Queue）" class="headerlink" title="1. 并发队列（Concurrent Dispatch Queue）"></a>1. 并发队列（Concurrent Dispatch Queue）</h4><p>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务），并发功能只有在异步（dispatch_async）函数下才有效</p>
<h4 id="2-串行队列（Serial-Dispatch-Queue）"><a href="#2-串行队列（Serial-Dispatch-Queue）" class="headerlink" title="2. 串行队列（Serial Dispatch Queue）"></a>2. 串行队列（Serial Dispatch Queue）</h4><p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）。</p>
<p>那么队列和线程又有什么区别？</p>
<p>简单来说，队列就是用来存放任务的“暂存区”，而线程是执行任务的路径，GCD将这些存在于队列的任务取出来放到相应的线程上去执行，而队列的性质决定了在其中的任务在哪种线程上执行。</p>
<p>下面由一张图来直观地展示任务，队列和线程的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6da601dd550b8390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="任务，队列和线程"></p>
<blockquote>
<p>在这里，我们可以看到，放入串行队列的任务会一个一个地执行。而放入并行队列的任务，会在多个线程并发地执行。</p>
</blockquote>
<h2 id="5-队列的创建"><a href="#5-队列的创建" class="headerlink" title="5. 队列的创建"></a>5. 队列的创建</h2><h3 id="5-1-串行队列的创建："><a href="#5-1-串行队列的创建：" class="headerlink" title="5.1 串行队列的创建："></a>5.1 串行队列的创建：</h3><p>GCD中获得串行有2种途径：</p>
<p>1.使用<code>dispatch_queue_create</code>函数创建串行队列</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"serial_queue"</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>2.使用主队列（跟主线程相关联的队列）</p>
<p>主队列是GCD自带的一种特殊的串行队列：放在主队列中的任务，都会放到主线程中执行。<br>可以使用dispatch_get_main_queue()获得系统提供的主队列：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<h3 id="5-2-并发队列的创建："><a href="#5-2-并发队列的创建：" class="headerlink" title="5.2 并发队列的创建："></a>5.2 并发队列的创建：</h3><p>1.使用<code>dispatch_queue_create</code>函数创建并发队列。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"concurrent.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>2.使用<code>dispatch_get_global_queue</code>获得全局并发队列。</p>
<p>GCD默认已经提供了全局的并发队列，供整个应用使用，可以无需手动创建。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<h2 id="6-GCD的几种重要的应用"><a href="#6-GCD的几种重要的应用" class="headerlink" title="6. GCD的几种重要的应用"></a>6. GCD的几种重要的应用</h2><h3 id="6-1-子线程与主线程的通信"><a href="#6-1-子线程与主线程的通信" class="headerlink" title="6.1 子线程与主线程的通信"></a>6.1 子线程与主线程的通信</h3><p>需求点:我们有时需要在子线程处理一个耗时比较长的任务，而且此任务完成后，要在主线程执行另一个任务。<br>例子：从网络加载图片（在子线程），加载完成就更新UIView（在主线程）。</p>
<p>为了实现这个需求，我们需要首先拿到全局并发队列（或自己开启一个子线程）来执行耗时的操作，然后在其完成block中拿到全局串行队列来执行UI刷新的任务。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">            <span class="comment">//加载图片</span></div><div class="line">            <span class="built_in">NSData</span> *dataFromURL = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageURL];</div><div class="line">            <span class="built_in">UIImage</span> *imageFromData = [<span class="built_in">UIImage</span> imageWithData:dataFromURL];</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">            <span class="comment">//加载完成更新view</span></div><div class="line">            <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:imageFromData];          </div><div class="line">    &#125;);      </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>以笔者的拙见，除了复杂的算法，网络请求以外，大多数<code>dataWithContentsOf。。。</code>函数可能也会比较耗时，所以以后遇到与NSData交互的操作时，尽量将其放在子线程执行。</p>
</blockquote>
<h4 id="6-2-dispatch-once"><a href="#6-2-dispatch-once" class="headerlink" title="6.2 dispatch_once"></a>6.2 dispatch_once</h4><p>需求点：用于在程序启动到终止，只执行一次的代码。此代码被执行后，相当于自身全部被加上了注释，不会再执行了。<br>为了实现这个需求，我们需要使用<code>dispatch_once</code>让代码在运行一次后即刻被“雪藏”。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    <span class="comment">// 只执行1次的代码，这里默认是线程安全的：不会有其他线程可以访问到这里</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="6-3-dispatch-group"><a href="#6-3-dispatch-group" class="headerlink" title="6.3 dispatch_group"></a>6.3 dispatch_group</h4><p>需求点：执行多个耗时的异步任务，但是只能等到这些任务都执行完毕后，才能在主线程执行某个任务。<br>为了实现这个需求，我们需要让将这些异步执行的操作放在<code>dispatch_group_async</code>函数中执行，最后再调用<code>dispatch_group_notify</code>来执行最后执行的任务。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group =  dispatch_group_create();</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>让我们看一下示例代码和运行结果：</p>
<p>示例代码：</p>
<p>为了使对比明显，笔者多开了几条线程，这样更容易看清问题。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group =  dispatch_group_create();    </div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务1"</span>);                </div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务2"</span>);        </div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">200000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务3"</span>);</div><div class="line">    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">400000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务4"</span>);</div><div class="line">    </div><div class="line">&#125;);</div><div class="line"></div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务5"</span>);</div><div class="line">    </div><div class="line">&#125;);</div><div class="line">        </div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"都完成了"</span>);        </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>运行结果:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-3c8d5886442ce7b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="  dispatch_group 的使用运行结果"></p>
<blockquote>
<p>从三次运行的结果来看:</p>
<ol>
<li><p>异步执行的任务1-5的最终完成时间是与其自身完成任务所需要的时间并无绝对关联。因为任务5是最耗时的，它在第一次运行结果里并不是最后才完成的。任务1是最不耗时的，但是它在第二次运行结果里也不是最先完成的。</p>
</li>
<li><p>异步执行的任务1-5无论完成顺序如何，只有当他们都完成后才会调用主线程的打印“都完成了”。</p>
</li>
</ol>
</blockquote>
<h4 id="6-4-dispatch-barrier"><a href="#6-4-dispatch-barrier" class="headerlink" title="6.4 dispatch_barrier"></a>6.4 dispatch_barrier</h4><p>需求点：虽然我们有时要执行几个不同的异步任务，但是我们还是要将其分成两组：当第一组异步任务都执行完成后才执行第二组的异步任务。这里的组可以包含一个任务，也可以包含多个任务。</p>
<p>为了实现这个需求，我们需要使用<code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code>在两组任务之间形成“栅栏”，使其“下方”的异步任务在其“上方”的异步任务都完成之前是无法执行的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----任务 1-----"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----任务 2-----"</span>);</div><div class="line">&#125;);    </div><div class="line"></div><div class="line">dispatch_barrier_async(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----"</span>);</div><div class="line">&#125;);</div><div class="line">   </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----任务 3-----"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----任务 4-----"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">   </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务1"</span>);       </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务2"</span>);        </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">200000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务3"</span>);        </div><div class="line">&#125;);</div><div class="line">     </div><div class="line"></div><div class="line">dispatch_barrier_async(queue, ^&#123;        </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------我是分割线--------"</span>);        </div><div class="line">&#125;);</div><div class="line"></div><div class="line">    </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">400000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务4"</span>);       </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务5"</span>);        </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务6"</span>);       </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-ca923e54d3839b2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_barrier 的使用运行结果"></p>
<blockquote>
<p>从这三次运行结果来看:</p>
<ol>
<li>无论任务1-3内部的执行顺序如何，只有当三者都完成了才会执行任务4-6。</li>
<li>1-3内部的执行顺序和4-6内部的完成顺序都是不可控的，同上一个知识点类似。</li>
</ol>
</blockquote>
<p>本文介绍了需要了解GCD所需的最重要的知识，因为怕打断读者思路，并没有涵盖所有细节。以后有机会会再写一篇深入介绍GCD的文章，查缺补漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;励志打造一篇浅显易懂地介绍iOS中GCD的文章！&lt;br&gt;笔者见过很多其他讲解GCD的博客，有些写得非常详细非常专业，几乎涵盖了GCD大大小小的全部知识，细致庞杂的内容容易让人摸不清主次，笔者觉得这类文章&lt;strong&gt;并不适合初学者学习&lt;/strong&gt;，于是决定写一篇针对一些只是听过，但是对GCD还不了解的童鞋们。&lt;/p&gt;
&lt;p&gt;本文排除了一些细枝末节，扰乱人头绪的东西，着重讲解了GCD中重要的知识点，并在最后展示了GCD中&lt;strong&gt;经常使用的函数&lt;/strong&gt;并附上结果图和讲解，简单明了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>YYCache 源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/YYCache%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/YYCache 源码解析/</id>
    <published>2018-02-02T16:18:08.000Z</published>
    <updated>2018-05-15T13:08:27.561Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ibireme/YYCache">YYCache</a>是国内开发者<a href="https://blog.ibireme.com/" target="_blank" rel="external">ibireme</a>开源的一个线程安全的高性能键值缓存组件，代码风格简洁清晰，在GitHub上已经有了1600+颗星。</p>
<p>阅读它的源码有助于建立比较完整的缓存设计的思路，同时也能巩固一下双向链表，线程锁，数据库操作相关的知识。如果你还没有看过YYCache的源码，那么恭喜你，阅读此文会对理解YYCache的源码有比较大的帮助。</p>
<a id="more"></a>
<p>在正式开始讲解源码之前，先简单看一下该框架的使用方法。</p>
<h1 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h1><p>举一个缓存用户姓名的例子来看一下YYCache的几个API：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">//需要缓存的对象</span></div><div class="line"> <span class="built_in">NSString</span> *userName = <span class="string">@"Jack"</span>;</div><div class="line"></div><div class="line"><span class="comment">//需要缓存的对象在缓存里对应的键</span></div><div class="line"> <span class="built_in">NSString</span> *key = <span class="string">@"user_name"</span>;</div><div class="line"> </div><div class="line"> <span class="comment">//创建一个YYCache实例:userInfoCache</span></div><div class="line"> YYCache *userInfoCache = [YYCache cacheWithName:<span class="string">@"userInfo"</span>];</div><div class="line"> </div><div class="line"> <span class="comment">//存入键值对</span></div><div class="line"> [userInfoCache setObject:userName forKey:key withBlock:^&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"caching object succeed"</span>);</div><div class="line"> &#125;];</div><div class="line"> </div><div class="line"> <span class="comment">//判断缓存是否存在</span></div><div class="line"> [userInfoCache containsObjectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key, <span class="built_in">BOOL</span> contains) &#123;</div><div class="line">     <span class="keyword">if</span> (contains)&#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"object exists"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> <span class="comment">//根据key读取数据</span></div><div class="line"> [userInfoCache objectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;  _Nonnull object) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"user name : %@"</span>,object);</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> <span class="comment">//根据key移除缓存</span></div><div class="line"> [userInfoCache removeObjectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"remove user name %@"</span>,key);</div><div class="line"> &#125;];</div><div class="line"> </div><div class="line"> <span class="comment">//移除所有缓存</span></div><div class="line"> [userInfoCache removeAllObjectsWithBlock:^&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"removing all cache succeed"</span>);</div><div class="line"> &#125;];</div><div class="line"></div><div class="line"> <span class="comment">//移除所有缓存带进度</span></div><div class="line"> [userInfoCache removeAllObjectsWithProgressBlock:^(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount) &#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: removedCount :%d  totalCount : %d"</span>,removedCount,totalCount);</div><div class="line"> &#125; endBlock:^(<span class="built_in">BOOL</span> error) &#123;</div><div class="line">     <span class="keyword">if</span>(!error)&#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: succeed"</span>);</div><div class="line">     &#125;<span class="keyword">else</span>&#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: failed"</span>);</div><div class="line">     &#125;</div><div class="line"> &#125;];</div></pre></td></tr></table></figure>
<p>总体来看这些API与<code>NSCache</code>是差不多的。<br>下面接着看一下该框架的架构：</p>
<h1 id="架构与职责划分"><a href="#架构与职责划分" class="headerlink" title="架构与职责划分"></a>架构与职责划分</h1><p>首先看一下架构图：</p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5bd7907?w=604&amp;h=344&amp;f=png&amp;s=21874" alt=""></p>
<h2 id="职责划分"><a href="#职责划分" class="headerlink" title="职责划分"></a>职责划分</h2><p>从架构图上来看，该组件里面的成员并不多：</p>
<ul>
<li>YYCache：提供了最外层的接口，调用了YYMemoryCache与YYDiskCache的相关方法。</li>
<li>YYMemoryCache：负责处理容量小，相对高速的内存缓存。线程安全，支持自动和手动清理缓存等功能。</li>
<li>_YYLinkedMap：YYMemoryCache使用的双向链表类。</li>
<li>_YYLinkedMapNode：是_YYLinkedMap使用的节点类。</li>
<li>YYDiskCache：负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作，自动和手动清理缓存等功能。</li>
<li>YYKVStorage：YYDiskCache的底层实现类，用于管理磁盘缓存。</li>
<li>YYKVStorageItem：内置在YYKVStorage中，是YYKVStorage内部用于封装某个缓存的类。</li>
</ul>
<p>每个成员的详细的功能会在下文结合代码介绍。</p>
<h1 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h1><p>知道了YYCache的架构和职责划分以后，现在结合代码开始正式讲解。<br>讲解分为下面6个部分：</p>
<ul>
<li>YYCache</li>
<li>YYMemoryCache</li>
<li>YYDiskCache</li>
<li>保证线程安全的不同方案</li>
<li>提高缓存性能的几个尝试</li>
<li>其他知识点</li>
</ul>
<h2 id="YYCache"><a href="#YYCache" class="headerlink" title="YYCache"></a>YYCache</h2><p>YYCache给用户提供所有最外层的缓存操作接口，而这些接口的内部内部实际上是调用了YYMemoryCache和YYDiskCache对象的相关方法。</p>
<blockquote>
<p>因为YYMemoryCache和YYDiskCache的实例作为YYCache的两个公开的属性，所以用户<strong>无法直接使用YYMemoryCache和YYDiskCache对象</strong>，只能通过属性的方式来间接使用它们。</p>
</blockquote>
<p>我们来看一下YYCache的属性和接口：</p>
<h3 id="YYCache的属性和接口"><a href="#YYCache的属性和接口" class="headerlink" title="YYCache的属性和接口"></a>YYCache的属性和接口</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYCache</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;<span class="comment">//缓存名称</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;<span class="comment">//内存缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;<span class="comment">//磁盘缓存</span></div><div class="line"></div><div class="line"><span class="comment">//是否包含某缓存，无回调</span></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//是否包含某缓存，有回调</span></div><div class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</div><div class="line"></div><div class="line"><span class="comment">//获取缓存对象，无回调</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//获取缓存对象，有回调</span></div><div class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object))block;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存对象，无回调</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//写入缓存对象，有回调</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"></div><div class="line"><span class="comment">//移除某缓存，无回调</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"><span class="comment">//移除某缓存，有回调</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</div><div class="line"></div><div class="line"><span class="comment">//移除所有缓存，无回调</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects;</div><div class="line"><span class="comment">//移除所有缓存，有回调</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"><span class="comment">//移除所有缓存，有进度和完成的回调</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</div><div class="line">                                 endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从上面的接口可以看出YYCache的接口和NSCache很相近，而且在接口上都区分了有无回调的功能。<br>下面结合代码看一下这些接口是如何实现的：</p>
<h3 id="YYCache的接口实现"><a href="#YYCache的接口实现" class="headerlink" title="YYCache的接口实现"></a>YYCache的接口实现</h3><p>下面省略了带有回调的接口，因为与无回调的接口非常接近。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//先检查内存缓存是否存在，再检查磁盘缓存是否存在</span></div><div class="line">    <span class="keyword">return</span> [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//首先尝试获取内存缓存，然后获取磁盘缓存</span></div><div class="line">    <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object = [_memoryCache objectForKey:key];</div><div class="line">    </div><div class="line">    <span class="comment">//如果内存缓存不存在，就会去磁盘缓存里面找：如果找到了，则再次写入内存缓存中；如果没找到，就返回nil</span></div><div class="line">    <span class="keyword">if</span> (!object) &#123;</div><div class="line">        object = [_diskCache objectForKey:key];</div><div class="line">        <span class="keyword">if</span> (object) &#123;</div><div class="line">            [_memoryCache setObject:object forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> object;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">//先写入内存缓存，后写入磁盘缓存</span></div><div class="line">    [_memoryCache setObject:object forKey:key];</div><div class="line">    [_diskCache setObject:object forKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">//先移除内存缓存，后移除磁盘缓存</span></div><div class="line">    [_memoryCache removeObjectForKey:key];</div><div class="line">    [_diskCache removeObjectForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</div><div class="line">    <span class="comment">//先全部移除内存缓存，后全部移除磁盘缓存</span></div><div class="line">    [_memoryCache removeAllObjects];</div><div class="line">    [_diskCache removeAllObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的接口实现可以看出：在YYCache中，永远都是先访问内存缓存，然后再访问磁盘缓存（包括了写入，读取，查询，删除缓存的操作）。而且关于内存缓存（_memoryCache）的操作，是不存在block回调的。</p>
<p>现在了解了YYCache的接口以及实现，下面我分别讲解一下YYMemoryCache（内存缓存）和YYDiskCache（磁盘缓存）这两个类。</p>
<h2 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h2><p>YYMemoryCache负责处理容量小，相对高速的内存缓存：它将需要缓存的对象与传入的key关联起来，操作类似于NSCache。</p>
<p>但是与NSCache不同的是，YYMemoryCache的内部有：</p>
<ul>
<li>缓存淘汰算法：使用LRU(least-recently-used) 算法来淘汰（清理）使用频率较低的缓存。</li>
<li>缓存清理策略：使用三个维度来标记，分别是count（缓存数量），cost（开销），age（距上一次的访问时间）。YYMemoryCache提供了分别针对这三个维度的清理缓存的接口。用户可以根据不同的需求（策略）来清理在某一维度超标的缓存。</li>
</ul>
<p>一个是淘汰算法，另一个是清理维度，乍一看可能没什么太大区别。我在这里先简单区分一下：</p>
<p>缓存淘汰算法的目的在于区分出使用频率高和使用频率低的缓存，当缓存数量达到一定限制的时候会优先清理那些使用频率低的缓存。<strong>因为使用频率已经比较低的缓存在将来的使用频率也很有可能会低</strong>。</p>
<p>缓存清理维度是给每个缓存添加的标记：</p>
<ul>
<li><p>如果用户需要删除age（距上一次的访问时间）超过1天的缓存，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始查找，直到所有距上一次的访问时间超过1天的缓存都清理掉为止。</p>
</li>
<li><p>如果用户需要将缓存总开销清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。</p>
</li>
<li><p>如果用户需要将缓存总数清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。</p>
</li>
</ul>
<p>可以看出，无论是以哪个维度来清理缓存，都是从缓存使用频率最低的那个缓存开始清理。而YYMemoryCache保留的所有缓存的使用频率的高低，是由LRU这个算法决定的。</p>
<p>现在知道了这二者的区别，下面来具体讲解一下缓存淘汰算法和缓存清理策略：</p>
<h3 id="YYMemoryCache的缓存淘汰算法"><a href="#YYMemoryCache的缓存淘汰算法" class="headerlink" title="YYMemoryCache的缓存淘汰算法"></a>YYMemoryCache的缓存淘汰算法</h3><p>在详细讲解这个算法之前我觉得有必要先说一下该算法的核心：</p>
<p>我个人认为LRU缓存替换策略的核心在于<strong>如果某个缓存访问的频率越高，就认定用户在将来越有可能访问这个缓存</strong>。<br>所以在这个算法中，将那些最新访问（写入），最多次被访问的缓存移到最前面，然后那些很早之前写入，不经常访问的缓存就被自动放在了后面。这样一来，在保留的缓存个数一定的情况下，留下的缓存都是访问频率比较高的，这样一来也就提升了缓存的命中率。谁都不想留着一些很难被用户再次访问的缓存，毕竟缓存本身也占有一定的资源不是么？</p>
<p>其实这个道理和一些商城类app的商品推荐逻辑是一样的：<br>如果首页只能展示10个商品，对于一个程序员用户来说，可能推荐的是于那些他最近购买商品类似的机械键盘鼠标，技术书籍或者显示屏之类的商品，而不是一些洋娃娃或是钢笔之类的商品。</p>
<p>那么LRU算法具体是怎么做的呢？</p>
<p>在YYMemoryCache中，使用了双向链表这个数据结构来保存这些缓存：</p>
<ul>
<li>当写入一个新的缓存时，要把这个缓存节点放在链表头部，并且并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。</li>
<li>当访问一个已有的缓存时，要把这个缓存节点移动到链表头部，原位置两侧的缓存要接上，并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。</li>
<li>（根据清理维度）自动清理缓存时，要从链表的最后端逐个清理。</li>
</ul>
<p>这样一来，就可以保证链表前端的缓存是最近写入过和经常访问过的。而且该算法总是从链表的最后端删除缓存，这也就保证了留下的都是一些“比较新鲜的”缓存。</p>
<p>下面结合代码来讲解一下这个算法的实现：</p>
<p>YYMemoryCache<strong>用一个链表节点类来保存某个单独的内存缓存的信息（键，值，缓存时间等），然后用一个双向链表类来保存和管理这些节点</strong>。这两个类的名称分别是：</p>
<ul>
<li>_YYLinkedMapNode：链表内的节点类，可以看做是对某个单独内存缓存的封装。</li>
<li>_YYLinkedMap：双向链表类，用于保存和管理所有内存缓存(节点)</li>
</ul>
<h4 id="YYLinkedMapNode"><a href="#YYLinkedMapNode" class="headerlink" title="_YYLinkedMapNode"></a>_YYLinkedMapNode</h4><p>_YYLinkedMapNode可以被看做是对某个缓存的封装：它包含了该节点上一个和下一个节点的指针，以及缓存的key和对应的值（对象），还有该缓存的开销和访问时间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">@package</span></div><div class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// retained by dic</span></div><div class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// retained by dic</span></div><div class="line">    <span class="keyword">id</span> _key;              		  <span class="comment">//缓存key</span></div><div class="line">    <span class="keyword">id</span> _value;              	          <span class="comment">//key对应值</span></div><div class="line">    <span class="built_in">NSUInteger</span> _cost;                     <span class="comment">//缓存开销</span></div><div class="line">    <span class="built_in">NSTimeInterval</span> _time;                 <span class="comment">//访问时间</span></div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYLinkedMapNode</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>下面看一下双向链表类：</p>
<h4 id="YYLinkedMap"><a href="#YYLinkedMap" class="headerlink" title="_YYLinkedMap"></a>_YYLinkedMap</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</div><div class="line">    <span class="keyword">@package</span></div><div class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; 	<span class="comment">// 用于存放节点</span></div><div class="line">    <span class="built_in">NSUInteger</span> _totalCost;   		<span class="comment">//总开销</span></div><div class="line">    <span class="built_in">NSUInteger</span> _totalCount;  		<span class="comment">//节点总数</span></div><div class="line">    _YYLinkedMapNode *_head;            <span class="comment">// 链表的头部结点</span></div><div class="line">    _YYLinkedMapNode *_tail; 		<span class="comment">// 链表的尾部节点</span></div><div class="line">    <span class="built_in">BOOL</span> _releaseOnMainThread; 	        <span class="comment">//是否在主线程释放，默认为NO</span></div><div class="line">    <span class="built_in">BOOL</span> _releaseAsynchronously; 	<span class="comment">//是否在子线程释放，默认为YES</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//在链表头部插入某节点</span></div><div class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</div><div class="line"></div><div class="line"><span class="comment">//将链表内部的某个节点移到链表头部</span></div><div class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</div><div class="line"></div><div class="line"><span class="comment">//移除某个节点</span></div><div class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node;</div><div class="line"></div><div class="line"><span class="comment">//移除链表的尾部节点并返回它</span></div><div class="line">- (_YYLinkedMapNode *)removeTailNode;</div><div class="line"></div><div class="line"><span class="comment">//移除所有节点（默认在子线程操作）</span></div><div class="line">- (<span class="keyword">void</span>)removeAll;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>从链表类的属性上看：链表类内置了CFMutableDictionaryRef，用于保存节点的键值对，它还持有了链表内节点的总开销，总数量，头尾节点等数据。</p>
<p>可以参考下面这张图来看一下二者的关系：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5e027e5?w=1001&amp;h=333&amp;f=png&amp;s=34319" alt=""></p>
<p>看一下_YYLinkedMap的接口的实现：</p>
<p>将节点插入到链表头部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//设置该node的值</span></div><div class="line">    <span class="built_in">CFDictionarySetValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key), (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node));</div><div class="line">    </div><div class="line">    <span class="comment">//增加开销和总缓存数量</span></div><div class="line">    _totalCost += node-&gt;_cost;</div><div class="line">    _totalCount++;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_head) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果链表内已经存在头节点，则将这个头节点赋给当前节点的尾指针（原第一个节点变成了现第二个节点）</span></div><div class="line">        node-&gt;_next = _head;</div><div class="line">        </div><div class="line">        <span class="comment">//将该节点赋给现第二个节点的头指针（此时_head指向的节点是先第二个节点）</span></div><div class="line">        _head-&gt;_prev = node;</div><div class="line">        </div><div class="line">        <span class="comment">//将该节点赋给链表的头结点指针（该节点变成了现第一个节点）</span></div><div class="line">        _head = node;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果链表内没有头结点，说明是空链表。说明是第一次插入，则将链表的头尾节点都设置为当前节点</span></div><div class="line">        _head = _tail = node;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要看懂节点操作的代码只要了解双向链表的特性即可。在双向链表中：</p>
<ul>
<li>每个节点都有两个分别指向前后节点的指针。所以说每个节点都知道它前一个节点和后一个节点是谁。</li>
<li>链表的头部节点指向它前面节点的指针为空；链表尾部节点指向它后侧节点的指针也为空。</li>
</ul>
<p>为了便于理解，我们可以把这个抽象概念类比于幼儿园手拉手的小朋友们：<br>每个小朋友的左手都拉着前面小朋友的右手；每个小朋友的右手都拉着后面小朋友的左手；<br>而且最前面的小朋友的左手和最后面的小朋友的右手都没有拉任何一个小朋友。</p>
<p>将某个节点移动到链表头部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果该节点已经是链表头部节点，则立即返回，不做任何操作</span></div><div class="line">    <span class="keyword">if</span> (_head == node) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_tail == node) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果该节点是链表的尾部节点</span></div><div class="line">        <span class="comment">//1. 将该节点的头指针指向的节点变成链表的尾节点（将倒数第二个节点变成倒数第一个节点，即尾部节点）</span></div><div class="line">        _tail = node-&gt;_prev;</div><div class="line">        </div><div class="line">        <span class="comment">//2. 将新的尾部节点的尾部指针置空</span></div><div class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果该节点是链表头部和尾部以外的节点（中间节点）</span></div><div class="line">        <span class="comment">//1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针</span></div><div class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</div><div class="line">        </div><div class="line">        <span class="comment">//2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针</span></div><div class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//将原头节点赋给该节点的尾指针（原第一个节点变成了现第二个节点）</span></div><div class="line">    node-&gt;_next = _head;</div><div class="line">    </div><div class="line">    <span class="comment">//将当前节点的头节点置空</span></div><div class="line">    node-&gt;_prev = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//将现第二个节点的头结点指向当前节点（此时_head指向的节点是现第二个节点）</span></div><div class="line">    _head-&gt;_prev = node;</div><div class="line">    </div><div class="line">    <span class="comment">//将该节点设置为链表的头节点</span></div><div class="line">    _head = node;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一次看上面的代码我自己是懵逼的，不过如果结合上面小朋友拉手的例子就可以快一点理解。<br>如果要其中一个小朋友放在队伍的最前面，需要</p>
<ul>
<li>将原来这个小朋友前后的小朋友的手拉上。</li>
<li>然后将这个小朋友的右手和原来排在第一位的小朋友的左手拉上。</li>
</ul>
<p>上面说的比较简略，但是相信对大家理解整个过程会有帮助。</p>
<p>也可以再结合链表的图解来看一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5e027e5?w=1001&amp;h=333&amp;f=png&amp;s=34319" alt=""></p>
<p>读者同样可以利用这种思考方式理解下面这段代码：</p>
<p>移除链表中的某个节点：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//除去该node的键对应的值</span></div><div class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key));</div><div class="line">    </div><div class="line">    <span class="comment">//减去开销和总缓存数量</span></div><div class="line">    _totalCost -= node-&gt;_cost;</div><div class="line">    _totalCount--;</div><div class="line">    </div><div class="line">    <span class="comment">//节点操作</span></div><div class="line">    <span class="comment">//1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针</span></div><div class="line">    <span class="keyword">if</span> (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev;</div><div class="line">    </div><div class="line">    <span class="comment">//2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针</span></div><div class="line">    <span class="keyword">if</span> (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next;</div><div class="line">    </div><div class="line">    <span class="comment">//3. 如果该node就是链表的头结点，则将该node的尾部指针指向的节点赋给链表的头节点（第二变成了第一）</span></div><div class="line">    <span class="keyword">if</span> (_head == node) _head = node-&gt;_next;</div><div class="line">    </div><div class="line">    <span class="comment">//4. 如果该node就是链表的尾节点，则将该node的头部指针指向的节点赋给链表的尾节点（倒数第二变成了倒数第一）</span></div><div class="line">    <span class="keyword">if</span> (_tail == node) _tail = node-&gt;_prev;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>移除并返回尾部的node:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (_YYLinkedMapNode *)removeTailNode &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果不存在尾节点，则返回nil</span></div><div class="line">    <span class="keyword">if</span> (!_tail) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    _YYLinkedMapNode *tail = _tail;</div><div class="line">    </div><div class="line">    <span class="comment">//移除尾部节点对应的值</span></div><div class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(_tail-&gt;_key));</div><div class="line">    </div><div class="line">    <span class="comment">//减少开销和总缓存数量</span></div><div class="line">    _totalCost -= _tail-&gt;_cost;</div><div class="line">    _totalCount--;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_head == _tail) &#123;</div><div class="line">        <span class="comment">//如果链表的头尾节点相同，说明链表只有一个节点。将其置空</span></div><div class="line">        _head = _tail = <span class="literal">nil</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//将链表的尾节指针指向的指针赋给链表的尾指针（倒数第二变成了倒数第一）</span></div><div class="line">        _tail = _tail-&gt;_prev;</div><div class="line">        <span class="comment">//将新的尾节点的尾指针置空</span></div><div class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tail;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，现在了解了YYMemoryCache底层的节点操作的代码。现在来看一下YYMemoryCache是如何使用它们的。</p>
<h4 id="YYMemoryCache的属性和接口"><a href="#YYMemoryCache的属性和接口" class="headerlink" title="YYMemoryCache的属性和接口"></a>YYMemoryCache的属性和接口</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYMemoryCache</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Attribute</span></div><div class="line"></div><div class="line"><span class="comment">//缓存名称，默认为nil</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"></div><div class="line"><span class="comment">//缓存总数量</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCount;</div><div class="line"></div><div class="line"><span class="comment">//缓存总开销</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCost;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Limit</span></div><div class="line"></div><div class="line"><span class="comment">//数量上限，默认为NSUIntegerMax，也就是无上限</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit;</div><div class="line"></div><div class="line"><span class="comment">//开销上限，默认为NSUIntegerMax，也就是无上限</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit;</div><div class="line"></div><div class="line"><span class="comment">//缓存时间上限，默认为DBL_MAX，也就是无上限</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit;</div><div class="line"></div><div class="line"><span class="comment">//清理超出上限之外的缓存的操作间隔时间，默认为5s</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval;</div><div class="line"></div><div class="line"><span class="comment">//收到内存警告时是否清理所有缓存，默认为YES</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning;</div><div class="line"></div><div class="line"><span class="comment">//app进入后台是是否清理所有缓存，默认为YES</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground;</div><div class="line"></div><div class="line"><span class="comment">//收到内存警告的回调block</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);</div><div class="line"></div><div class="line"><span class="comment">//进入后台的回调block</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache);</div><div class="line"></div><div class="line"><span class="comment">//缓存清理是否在后台进行，默认为NO</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> releaseOnMainThread;</div><div class="line"></div><div class="line"><span class="comment">//缓存清理是否异步执行，默认为YES</span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> releaseAsynchronously;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Access Methods</span></div><div class="line"></div><div class="line"><span class="comment">//是否包含某个缓存</span></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key;</div><div class="line"></div><div class="line"><span class="comment">//获取缓存对象</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存对象</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存对象，并添加对应的开销</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line"></div><div class="line"><span class="comment">//移除某缓存</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</div><div class="line"></div><div class="line"><span class="comment">//移除所有缓存</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Trim</span></div><div class="line"></div><div class="line"><span class="comment">// =========== 缓存清理接口 =========== </span></div><div class="line"><span class="comment">//清理缓存到指定个数</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存到指定开销</span></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</div></pre></td></tr></table></figure>
<h4 id="YYMemoryCache的接口实现"><a href="#YYMemoryCache的接口实现" class="headerlink" title="YYMemoryCache的接口实现"></a>YYMemoryCache的接口实现</h4><p>在YYMemoryCache的初始化方法里，会实例化一个_YYLinkedMap的实例来赋给_lru这个成员变量。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init&#123;</div><div class="line">      ....</div><div class="line">      _lru = [_YYLinkedMap new];</div><div class="line">      ...</div><div class="line">  </div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>  然后所有的关于缓存的操作，都要用到_lru这个成员变量，因为它才是在底层持有这些缓存（节点）的双向链表类。下面我们来看一下这些缓存操作接口的实现：</p>
  <figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//是否包含某个缓存对象</span></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line"></div><div class="line">    <span class="comment">//尝试从内置的字典中获得缓存对象</span></div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    <span class="keyword">return</span> contains;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取某个缓存对象</span></div><div class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        <span class="comment">//如果节点存在，则更新它的时间信息（最后一次访问的时间）</span></div><div class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//写入某个缓存对象，开销默认为0</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    [<span class="keyword">self</span> setObject:object forKey:key withCost:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//写入某个缓存对象，并存入缓存开销</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!object) &#123;</div><div class="line">        [<span class="keyword">self</span> removeObjectForKey:key];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    </div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="built_in">NSTimeInterval</span> now = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        <span class="comment">//如果存在与传入的key值匹配的node，则更新该node的value,cost,time，并将这个node移到链表头部</span></div><div class="line">        </div><div class="line">        <span class="comment">//更新总cost</span></div><div class="line">        _lru-&gt;_totalCost -= node-&gt;_cost;</div><div class="line">        _lru-&gt;_totalCost += cost;</div><div class="line">        </div><div class="line">        <span class="comment">//更新node</span></div><div class="line">        node-&gt;_cost = cost;</div><div class="line">        node-&gt;_time = now;</div><div class="line">        node-&gt;_value = object;</div><div class="line">        </div><div class="line">        <span class="comment">//将node移动至链表头部</span></div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果不存在与传入的key值匹配的node，则新建一个node，将key,value,cost,time赋给它，并将这个node插入到链表头部</span></div><div class="line">        <span class="comment">//新建node,并赋值</span></div><div class="line">        node = [_YYLinkedMapNode new];</div><div class="line">        node-&gt;_cost = cost;</div><div class="line">        node-&gt;_time = now;</div><div class="line">        node-&gt;_key = key;</div><div class="line">        node-&gt;_value = object;</div><div class="line">        </div><div class="line">        <span class="comment">//将node插入至链表头部</span></div><div class="line">        [_lru insertNodeAtHead:node];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果cost超过了限制，则进行删除缓存操作（从链表尾部开始删除，直到符合限制要求）</span></div><div class="line">    <span class="keyword">if</span> (_lru-&gt;_totalCost &gt; _costLimit) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(_queue, ^&#123;</div><div class="line">            [<span class="keyword">self</span> trimToCost:_costLimit];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果total count超过了限制，则进行删除缓存操作（从链表尾部开始删除，删除一次即可）</span></div><div class="line">    <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; _countLimit) &#123;</div><div class="line">        _YYLinkedMapNode *node = [_lru removeTailNode];</div><div class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//移除某个缓存对象</span></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">    </div><div class="line">        <span class="comment">//内部调用了链表的removeNode：方法</span></div><div class="line">        [_lru removeNode:node];</div><div class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//内部调用了链表的removeAll方法</span></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    [_lru removeAll];</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的实现是针对缓存的查询，写入，获取操作的，接下来看一下缓存的清理策略。</p>
<h3 id="YYMemoryCache的缓存清理策略"><a href="#YYMemoryCache的缓存清理策略" class="headerlink" title="YYMemoryCache的缓存清理策略"></a>YYMemoryCache的缓存清理策略</h3><p>如上文所说，在YYCache中，缓存的清理可以从缓存总数量，缓存总开销，缓存距上一次的访问时间来清理缓存。而且每种维度的清理操作都可以分为自动和手动的方式来进行。</p>
<h4 id="缓存自动清理"><a href="#缓存自动清理" class="headerlink" title="缓存自动清理"></a>缓存自动清理</h4><p>缓存的自动清理功能在YYMemoryCache初始化之后就开始了，是一个递归调用的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init&#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//开始定期清理</span></div><div class="line">    [<span class="keyword">self</span> _trimRecursively];</div><div class="line">    </div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//递归清理，相隔时间为_autoTrimInterval，在初始化之后立即执行</span></div><div class="line">- (<span class="keyword">void</span>)_trimRecursively &#123;</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) _<span class="keyword">self</span> = <span class="keyword">self</span>;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * <span class="built_in">NSEC_PER_SEC</span>)),</div><div class="line">                   </div><div class="line">        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</div><div class="line">            </div><div class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_<span class="keyword">self</span>) <span class="keyword">self</span> = _<span class="keyword">self</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//在后台进行清理操作</span></div><div class="line">        [<span class="keyword">self</span> _trimInBackground];</div><div class="line">        </div><div class="line">        <span class="comment">//调用自己，递归操作</span></div><div class="line">        [<span class="keyword">self</span> _trimRecursively];</div><div class="line">            </div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清理所有不符合限制的缓存，顺序为：cost，count，age</span></div><div class="line">- (<span class="keyword">void</span>)_trimInBackground &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span> _trimToCost:<span class="keyword">self</span>-&gt;_costLimit];</div><div class="line">        [<span class="keyword">self</span> _trimToCount:<span class="keyword">self</span>-&gt;_countLimit];</div><div class="line">        [<span class="keyword">self</span> _trimToAge:<span class="keyword">self</span>-&gt;_ageLimit];</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.m</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> removeAllObjects];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> _trimToCount:count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost &#123;</div><div class="line">    [<span class="keyword">self</span> _trimToCost:cost];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age &#123;</div><div class="line">    [<span class="keyword">self</span> _trimToAge:age];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，YYMemoryCache是按照缓存数量，缓存开销，缓存时间的顺序来自动清空缓存的。我们结合代码看一下它是如何按照缓存数量来清理缓存的（其他两种清理方式类似，暂不给出）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.m</span></div><div class="line"></div><div class="line"><span class="comment">//将内存缓存数量降至等于或小于传入的数量；如果传入的值为0，则删除全部内存缓存</span></div><div class="line">- (<span class="keyword">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> finish = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    </div><div class="line">    <span class="comment">//如果传入的参数=0，则删除所有内存缓存</span></div><div class="line">    <span class="keyword">if</span> (countLimit == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        [_lru removeAll];</div><div class="line">        finish = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_totalCount &lt;= countLimit) &#123;</div><div class="line">    </div><div class="line">        <span class="comment">//如果当前缓存的总数量已经小于或等于传入的数量，则直接返回YES，不进行清理</span></div><div class="line">        finish = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    <span class="keyword">if</span> (finish) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    <span class="keyword">while</span> (!finish) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//==0的时候说明在尝试加锁的时候，获取锁成功，从而可以进行操作；否则等待10秒（但是不知道为什么是10s而不是2s，5s，等等）</span></div><div class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</div><div class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</div><div class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                finish = <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">            pthread_mutex_unlock(&amp;_lock);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (holder.count) &#123;</div><div class="line">        <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">            [holder count]; <span class="comment">// release in queue</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="缓存手动清理"><a href="#缓存手动清理" class="headerlink" title="缓存手动清理"></a>缓存手动清理</h4><p>其实上面这三种清理的方法在YYMemoryCache封装成了接口，所以用户也可以通过YYCache的memoryCache这个属性来手动清理相应维度上不符合传入标准的缓存：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.h</span></div><div class="line"></div><div class="line"><span class="comment">// =========== 缓存清理接口 =========== </span></div><div class="line"><span class="comment">//清理缓存到指定个数</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存到指定开销</span></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</div></pre></td></tr></table></figure>
<p>看一下它们的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//清理缓存到指定个数</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> removeAllObjects];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> _trimToCount:count];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存到指定开销</span></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost &#123;</div><div class="line">    [<span class="keyword">self</span> _trimToCost:cost];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age &#123;</div><div class="line">    [<span class="keyword">self</span> _trimToAge:age];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h2><p>YYDiskCache负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作。作为YYCache的第二级缓存，它与第一级缓存YYMemoryCache的相同点是：</p>
<ul>
<li>都具有查询，写入，读取，删除缓存的接口。</li>
<li>不直接操作缓存，也是间接地通过另一个类（YYKVStorage）来操作缓存。</li>
<li>它使用LRU算法来清理缓存。</li>
<li>支持按 cost，count 和 age 这三个维度来清理不符合标准的缓存。</li>
</ul>
<p>它与YYMemoryCache不同点是：</p>
<ul>
<li><ol>
<li>根据缓存数据的大小来采取不同的形式的缓存：</li>
</ol>
<ul>
<li>数据库sqlite: 针对小容量缓存，缓存的data和元数据都保存在数据库里。</li>
<li>文件+数据库的形式: 针对大容量缓存，缓存的data写在文件系统里，其元数据保存在数据库里。</li>
</ul>
</li>
<li><ol>
<li>除了 cost，count 和 age 三个维度之外，还添加了一个磁盘容量的维度。</li>
</ol>
</li>
</ul>
<p>这里需要说明的是：<br>对于上面的第一条：我看源码的时候只看出来有这两种缓存形式，但是从内部的缓存type枚举来看，其实是分为三种的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YYKVStorageType) &#123;</div><div class="line">    </div><div class="line">    YYKVStorageTypeFile = <span class="number">0</span>,</div><div class="line">    YYKVStorageTypeSQLite = <span class="number">1</span>,</div><div class="line">    YYKVStorageTypeMixed = <span class="number">2</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>也就是说我只找到了第二，第三种缓存形式，而第一种纯粹的文件存储（YYKVStorageTypeFile）形式的实现我没有找到：当type为<br>YYKVStorageTypeFile和YYKVStorageTypeMixed的时候的缓存实现都是一致的：都是讲data存在文件里，将元数据放在数据库里面。</p>
<p>在YYDiskCache的初始化方法里，没有发现正确的将缓存类型设置为YYKVStorageTypeFile的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.m</span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"YYDiskCache init error"</span> reason:<span class="string">@"YYDiskCache must be initialized with a path. Use 'initWithPath:' or 'initWithPath:inlineThreshold:' instead."</span> userInfo:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:<span class="string">@""</span> inlineThreshold:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:path inlineThreshold:<span class="number">1024</span> * <span class="number">20</span>]; <span class="comment">// 20KB</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</div><div class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</div><div class="line"></div><div class="line">   ...    </div><div class="line">    YYKVStorageType type;</div><div class="line">    <span class="keyword">if</span> (threshold == <span class="number">0</span>) &#123;</div><div class="line">        type = YYKVStorageTypeFile;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threshold == <span class="built_in">NSUIntegerMax</span>) &#123;</div><div class="line">        type = YYKVStorageTypeSQLite;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        type = YYKVStorageTypeMixed;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出来，当给指定初始化方法<code>initWithPath:inlineThreshold:</code>的第二个参数传入0的时候，缓存类型才是YYKVStorageTypeFile。而且比较常用的初始化方法<code>initWithPath:</code>的实现里，是将20kb传入了指定初始化方法里，结果就是将type设置成了YYKVStorageTypeMixed。</p>
<p>而且我也想不出如果只有文件形式的缓存的话，其元数据如何保存。如果有读者知道的话，麻烦告知一下，非常感谢了~~</p>
<p>在本文暂时对于上面提到的”文件+数据库的形式”在下文统一说成文件缓存了。</p>
<p>在接口的设计上，YYDiskCache与YYMemoryCache是高度一致的，只不过因为有些时候大文件的访问可能会比较耗时，所以框架作者在保留了与YYMemoryCache一样的接口的基础上，还在原来的基础上添加了block回调，避免阻塞线程。来看一下YYDiskCache的接口(省略了注释)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.h</span></div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; _Nullable object))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects;</div><div class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</div><div class="line">                                 endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSInteger</span>)totalCount;</div><div class="line">- (<span class="keyword">void</span>)totalCountWithBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> totalCount))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="built_in">NSInteger</span>)totalCost;</div><div class="line">- (<span class="keyword">void</span>)totalCostWithBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> totalCost))block;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Trim</span></div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</div><div class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</div><div class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</div></pre></td></tr></table></figure>
<p>从上面的接口代码可以看出，YYDiskCache与YYMemoryCache在接口设计上是非常相似的。但是，YYDiskCache有一个非常重要的属性，它<strong>作为用sqlite做缓存还是用文件做缓存的分水岭</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.h</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold;</div></pre></td></tr></table></figure>
<p>这个属性的默认值是20480byte，也就是20kb。即是说，如果缓存数据的长度大于这个值，就使用文件存储；如果小于这个值，就是用sqlite存储。来看一下这个属性是如何使用的：</p>
<p>首先我们会在YYDiskCache的指定初始化方法里看到这个属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</div><div class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</div><div class="line">   ...</div><div class="line">    _inlineThreshold = threshold;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里将_inlineThreshold赋值，也是唯一一次的赋值。然后在写入缓存的操作里判断写入缓存的大小是否大于这个临界值，如果是，则使用文件缓存：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.m</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">   </div><div class="line">   ...</div><div class="line">    <span class="built_in">NSString</span> *filename = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">if</span> (_kv.type != YYKVStorageTypeSQLite) &#123;</div><div class="line">        <span class="comment">//如果长度大临界值，则生成文件名称，使得filename不为nil</span></div><div class="line">        <span class="keyword">if</span> (value.length &gt; _inlineThreshold) &#123;</div><div class="line">            filename = [<span class="keyword">self</span> _filenameForKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Lock();</div><div class="line">    <span class="comment">//在该方法内部判断filename是否为nil，如果是，则使用sqlite进行缓存；如果不是，则使用文件缓存</span></div><div class="line">    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];</div><div class="line">    Unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们知道了YYDiskCache相对于YYMemoryCache最大的不同之处是缓存类型的不同。<br>细心的朋友会发现上面这个写入缓存的方法（saveItemWithKey:value:filename:extendedData:）实际上是属于_kv的。这个_kv就是上面提到的YYKVStorage的实例，它在YYDiskCache的初始化方法里被赋值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYDiskCache.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</div><div class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</div><div class="line">    ...</div><div class="line">    </div><div class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</div><div class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    _kv = kv;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样地，再举其他两个接口为例，内部也是调用了_kv的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    Lock();</div><div class="line">    <span class="built_in">BOOL</span> contains = [_kv itemExistsForKey:key];</div><div class="line">    Unlock();</div><div class="line">    <span class="keyword">return</span> contains;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    Lock();</div><div class="line">    [_kv removeItemForKey:key];</div><div class="line">    Unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以是时候来看一下YYKVStorage的接口和实现了：</p>
<h3 id="YYKVStorage"><a href="#YYKVStorage" class="headerlink" title="YYKVStorage"></a>YYKVStorage</h3><p>YYKVStorage实例负责保存和管理所有磁盘缓存。和YYMemoryCache里面的_YYLinkedMap将缓存封装成节点类_YYLinkedMapNode类似，YYKVStorage也将某个单独的磁盘缓存封装成了一个类，这个类就是YYKVStorageItem，它保存了某个缓存所对应的一些信息(key, value, 文件名，大小等等)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYKVStorageItem.h</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorageItem</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;                <span class="comment">//键</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *value;                <span class="comment">//值</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *filename; <span class="comment">//文件名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> size;                             <span class="comment">//值的大小，单位是byte</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> modTime;                          <span class="comment">//修改时间戳</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> accessTime;                       <span class="comment">//最后访问的时间戳</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *extendedData; <span class="comment">//extended data</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>既然在这里将缓存封装成了YYKVStorageItem实例，<strong>那么作为缓存的管理者，YYKVStorage就必然有操作YYKVStorageItem的接口</strong>了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYKVStorage.h</span></div><div class="line"></div><div class="line"><span class="comment">//写入某个item</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item;</div><div class="line"></div><div class="line"><span class="comment">//写入某个键值对，值为NSData对象</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value;</div><div class="line"></div><div class="line"><span class="comment">//写入某个键值对，包括文件名以及data信息</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key</div><div class="line">                  value:(<span class="built_in">NSData</span> *)value</div><div class="line">               filename:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)filename</div><div class="line">           extendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Remove Items</span></div><div class="line"></div><div class="line"><span class="comment">//移除某个键的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">//移除多个键的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</div><div class="line"></div><div class="line"><span class="comment">//移除大于参数size的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemsLargerThanSize:(<span class="keyword">int</span>)size;</div><div class="line"></div><div class="line"><span class="comment">//移除时间早于参数时间的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemsEarlierThanTime:(<span class="keyword">int</span>)time;</div><div class="line"></div><div class="line"><span class="comment">//移除item，使得缓存总容量小于参数size</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitSize:(<span class="keyword">int</span>)maxSize;</div><div class="line"></div><div class="line"><span class="comment">//移除item，使得缓存数量小于参数size</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitCount:(<span class="keyword">int</span>)maxCount;</div><div class="line"></div><div class="line"><span class="comment">//移除所有的item</span></div><div class="line">- (<span class="built_in">BOOL</span>)removeAllItems;</div><div class="line"></div><div class="line"><span class="comment">//移除所有的item，附带进度与结束block</span></div><div class="line">- (<span class="keyword">void</span>)removeAllItemsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</div><div class="line">                               endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Get Items</span></div><div class="line"><span class="comment">//读取参数key对应的item</span></div><div class="line">- (<span class="keyword">nullable</span> YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">//读取参数key对应的data</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)getItemValueForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">//读取参数数组对应的item数组</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;YYKVStorageItem *&gt; *)getItemForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</div><div class="line"></div><div class="line"><span class="comment">//读取参数数组对应的item字典</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSData</span> *&gt; *)getItemValueForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</div></pre></td></tr></table></figure>
<p>大家最关心的应该是写入缓存的接口是如何实现的，下面重点讲一下写入缓存的接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//写入某个item</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item;</div><div class="line"></div><div class="line"><span class="comment">//写入某个键值对，值为NSData对象</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value;</div><div class="line"></div><div class="line"><span class="comment">//写入某个键值对，包括文件名以及data信息</span></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key</div><div class="line">                  value:(<span class="built_in">NSData</span> *)value</div><div class="line">               filename:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)filename</div><div class="line">           extendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData;</div></pre></td></tr></table></figure>
<p>这三个接口都比较类似，上面的两个方法都会调用最下面参数最多的方法。在详细讲解写入缓存的代码之前，我先讲一下写入缓存的大致逻辑，有助于让大家理解整个YYDiskCache写入缓存的流程：</p>
<ol>
<li>首先判断传入的key和value是否符合要求，如果不符合要求，则立即返回NO，缓存失败。</li>
<li>再判断是否type==YYKVStorageTypeFile并且文件名为空字符串（或nil）：如果是，则立即返回NO，缓存失败。</li>
<li>判断filename是否为空字符串：<ol>
<li>如果不为空：写入文件，并将缓存的key，等信息写入数据库，但是不将key对应的data写入数据库。</li>
<li>如果为空：<ol>
<li>如果缓存类型为YYKVStorageTypeSQLite：将缓存文件删除<ol>
<li>如果缓存类型不为YYKVStorageTypeSQLite：则将缓存的key和对应的data等其他信息存入数据库。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> saveItemWithKey:item.key value:item.value filename:item.filename extendedData:item.extendedData];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> saveItemWithKey:key value:value filename:<span class="literal">nil</span> extendedData:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value filename:(<span class="built_in">NSString</span> *)filename extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span> || value.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_type == YYKVStorageTypeFile &amp;&amp; filename.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (filename.length) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果文件名不为空字符串，说明要进行文件缓存</span></div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _fileWriteWithName:filename data:value]) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//写入元数据</span></div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</div><div class="line">            <span class="comment">//如果缓存信息保存失败，则删除对应的文件</span></div><div class="line">            [<span class="keyword">self</span> _fileDeleteWithName:filename];</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果文件名为空字符串，说明不要进行文件缓存</span></div><div class="line">        <span class="keyword">if</span> (_type != YYKVStorageTypeSQLite) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//如果缓存类型不是数据库缓存，则查找出相应的文件名并删除</span></div><div class="line">            <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</div><div class="line">            <span class="keyword">if</span> (filename) &#123;</div><div class="line">                [<span class="keyword">self</span> _fileDeleteWithName:filename];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 缓存类型是数据库缓存，把元数据和value写入数据库</span></div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:<span class="literal">nil</span> extendedData:extendedData];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码可以看出，在底层写入缓存的方法是<code>_dbSaveWithKey:value:fileName:extendedData:</code>，这个方法使用了两次:</p>
<ul>
<li>在以文件（和数据库）存储缓存时</li>
<li>在以数据库存储缓存时</li>
</ul>
<p>不过虽然调用了两次，我们可以从传入的参数是有差别的：第二次filename传了nil。那么我们来看一下<code>_dbSaveWithKey:value:fileName:extendedData:</code>内部是如何区分有无filename的情况的：</p>
<ul>
<li>当filename为空时，说明在外部没有写入该缓存的文件：则把data写入数据库里</li>
<li>当filename不为空时，说明在外部有写入该缓存的文件：则不把data也写入了数据库里</li>
</ul>
<p>下面结合代码看一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//数据库存储</span></div><div class="line">- (<span class="built_in">BOOL</span>)_dbSaveWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value fileName:(<span class="built_in">NSString</span> *)fileName extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//sql语句</span></div><div class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@"insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);"</span>;</div><div class="line">    </div><div class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> timestamp = (<span class="keyword">int</span>)time(<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//key</span></div><div class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//filename</span></div><div class="line">    sqlite3_bind_text(stmt, <span class="number">2</span>, fileName.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//size</span></div><div class="line">    sqlite3_bind_int(stmt, <span class="number">3</span>, (<span class="keyword">int</span>)value.length);</div><div class="line">    </div><div class="line">    <span class="comment">//inline_data</span></div><div class="line">    <span class="keyword">if</span> (fileName.length == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果文件名长度==0，则将value存入数据库</span></div><div class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, value.bytes, (<span class="keyword">int</span>)value.length, <span class="number">0</span>);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果文件名长度不为0，则不将value存入数据库</span></div><div class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//modification_time</span></div><div class="line">    sqlite3_bind_int(stmt, <span class="number">5</span>, timestamp);</div><div class="line">    </div><div class="line">    <span class="comment">//last_access_time</span></div><div class="line">    sqlite3_bind_int(stmt, <span class="number">6</span>, timestamp);</div><div class="line">    </div><div class="line">    <span class="comment">//extended_data</span></div><div class="line">    sqlite3_bind_blob(stmt, <span class="number">7</span>, extendedData.bytes, (<span class="keyword">int</span>)extendedData.length, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</div><div class="line">        <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@"%s line:%d sqlite insert error (%d): %s"</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>框架作者用数据库的一条记录来保存关于某个缓存的所有信息。<br>而且数据库的第四个字段是保存缓存对应的data的，从上面的代码可以看出当filename为空和不为空的时候的处理的差别。</p>
<p>上面的<code>sqlite3_stmt</code>可以看作是一个已经把sql语句解析了的、用sqlite自己标记记录的内部数据结构。<br>而sqlite3_bind_text和sqlite3_bind_int是绑定函数，可以看作是将变量插入到字段的操作。</p>
<p>OK，现在看完了写入缓存，我们再来看一下获取缓存的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYKVSorage.m</span></div><div class="line">- (YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    YYKVStorageItem *item = [<span class="keyword">self</span> _dbGetItemWithKey:key excludeInlineData:<span class="literal">NO</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (item) &#123;</div><div class="line">        <span class="comment">//更新内存访问的时间</span></div><div class="line">        [<span class="keyword">self</span> _dbUpdateAccessTimeWithKey:key];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (item.filename) &#123;</div><div class="line">            <span class="comment">//如果有文件名，则尝试获取文件数据</span></div><div class="line">            item.value = [<span class="keyword">self</span> _fileReadWithName:item.filename];</div><div class="line">            <span class="comment">//如果此时获取文件数据失败，则删除对应的item</span></div><div class="line">            <span class="keyword">if</span> (!item.value) &#123;</div><div class="line">                [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</div><div class="line">                item = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面这段代码我们可以看到获取YYKVStorageItem的实例的方法是<code>_dbGetItemWithKey:excludeInlineData:</code><br>我们来看一下它的实现：</p>
<ol>
<li>首先根据查找key的sql语句生成stmt</li>
<li>然后将传入的key与该stmt进行绑定</li>
<li>最后通过这个stmt来查找出与该key对应的有关该缓存的其他数据并生成item。</li>
</ol>
<p>来看一下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (YYKVStorageItem *)_dbGetItemWithKey:(<span class="built_in">NSString</span> *)key excludeInlineData:(<span class="built_in">BOOL</span>)excludeInlineData &#123;</div><div class="line">    <span class="built_in">NSString</span> *sql = excludeInlineData ? <span class="string">@"select key, filename, size, modification_time, last_access_time, extended_data from manifest where key = ?1;"</span> : <span class="string">@"select key, filename, size, inline_data, modification_time, last_access_time, extended_data from manifest where key = ?1;"</span>;</div><div class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</div><div class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    YYKVStorageItem *item = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</div><div class="line">    <span class="keyword">if</span> (result == SQLITE_ROW) &#123;</div><div class="line">        <span class="comment">//传入stmt来生成YYKVStorageItem实例</span></div><div class="line">        item = [<span class="keyword">self</span> _dbGetItemFromStmt:stmt excludeInlineData:excludeInlineData];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</div><div class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@"%s line:%d sqlite query error (%d): %s"</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到最终生成YYKVStorageItem实例的是通过<code>_dbGetItemFromStmt:excludeInlineData:</code>来实现的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (YYKVStorageItem *)_dbGetItemFromStmt:(sqlite3_stmt *)stmt excludeInlineData:(<span class="built_in">BOOL</span>)excludeInlineData &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//提取数据</span></div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">char</span> *key = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, i++);</div><div class="line">    <span class="keyword">char</span> *filename = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, i++);</div><div class="line">    <span class="keyword">int</span> size = sqlite3_column_int(stmt, i++);</div><div class="line">    </div><div class="line">    <span class="comment">//判断excludeInlineData</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *inline_data = excludeInlineData ? <span class="literal">NULL</span> : sqlite3_column_blob(stmt, i);</div><div class="line">    <span class="keyword">int</span> inline_data_bytes = excludeInlineData ? <span class="number">0</span> : sqlite3_column_bytes(stmt, i++);</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">int</span> modification_time = sqlite3_column_int(stmt, i++);</div><div class="line">    <span class="keyword">int</span> last_access_time = sqlite3_column_int(stmt, i++);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *extended_data = sqlite3_column_blob(stmt, i);</div><div class="line">    <span class="keyword">int</span> extended_data_bytes = sqlite3_column_bytes(stmt, i++);</div><div class="line">    </div><div class="line">    <span class="comment">//将数据赋给item的属性</span></div><div class="line">    YYKVStorageItem *item = [YYKVStorageItem new];</div><div class="line">    <span class="keyword">if</span> (key) item.key = [<span class="built_in">NSString</span> stringWithUTF8String:key];</div><div class="line">    <span class="keyword">if</span> (filename &amp;&amp; *filename != <span class="number">0</span>) item.filename = [<span class="built_in">NSString</span> stringWithUTF8String:filename];</div><div class="line">    item.size = size;</div><div class="line">    <span class="keyword">if</span> (inline_data_bytes &gt; <span class="number">0</span> &amp;&amp; inline_data) item.value = [<span class="built_in">NSData</span> dataWithBytes:inline_data length:inline_data_bytes];</div><div class="line">    item.modTime = modification_time;</div><div class="line">    item.accessTime = last_access_time;</div><div class="line">    <span class="keyword">if</span> (extended_data_bytes &gt; <span class="number">0</span> &amp;&amp; extended_data) item.extendedData = [<span class="built_in">NSData</span> dataWithBytes:extended_data length:extended_data_bytes];</div><div class="line">    <span class="keyword">return</span> item;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码分为两个部分：</p>
<ul>
<li>获取数据库里每一个字段对应的数据</li>
<li>将数据赋给YYKVStorageItem的实例</li>
</ul>
<p>需要注意的是：</p>
<ol>
<li>字符串类型需要使用<code>stringWithUTF8String:</code>来转成NSString类型。</li>
<li>这里面会判断<code>excludeInlineData</code>：<ul>
<li>如果为TRUE，就提取存入的data数据</li>
<li>如果为FALSE，就不提取</li>
</ul>
</li>
</ol>
<h2 id="保证线程安全的方案"><a href="#保证线程安全的方案" class="headerlink" title="保证线程安全的方案"></a>保证线程安全的方案</h2><p>我相信对于某个设计来说，它的产生一定是基于某种个特定问题下的某个场景的</p>
<p>由上文可以看出：</p>
<ul>
<li>YYMemoryCache 使用了 pthread_mutex 线程锁（互斥锁）来确保线程安全</li>
<li>YYDiskCache 则选择了更适合它的 dispatch_semaphore。</li>
</ul>
<h3 id="内存缓存操作的互斥锁"><a href="#内存缓存操作的互斥锁" class="headerlink" title="内存缓存操作的互斥锁"></a>内存缓存操作的互斥锁</h3><p>在YYMemoryCache中，是使用互斥锁来保证线程安全的。<br>首先在YYMemoryCache的初始化方法中得到了互斥锁，并在它的所有接口里都加入了互斥锁来保证线程安全，包括setter，getter方法和缓存操作的实现。举几个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)totalCost &#123;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    <span class="built_in">NSUInteger</span> totalCost = _lru-&gt;_totalCost;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    <span class="keyword">return</span> totalCost;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setReleaseOnMainThread:(<span class="built_in">BOOL</span>)releaseOnMainThread &#123;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _lru-&gt;_releaseOnMainThread = releaseOnMainThread;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    <span class="keyword">return</span> contains;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        <span class="comment">//如果节点存在，则更新它的时间信息（最后一次访问的时间）</span></div><div class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</div><div class="line">        [_lru bringNodeToHead:node];</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而且需要在dealloc方法中销毁这个锁头：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//销毁互斥锁</span></div><div class="line">    pthread_mutex_destroy(&amp;_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="磁盘缓存使用信号量来代替锁"><a href="#磁盘缓存使用信号量来代替锁" class="headerlink" title="磁盘缓存使用信号量来代替锁"></a>磁盘缓存使用信号量来代替锁</h3><p>框架作者采用了信号量的方式来给<br>首先在初始化的时候实例化了一个信号量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</div><div class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</div><div class="line">    ...</div><div class="line">    _lock = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">    _queue = dispatch_queue_create(<span class="string">"com.ibireme.cache.disk"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>然后使用了宏来代替加锁解锁的代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)</span></div><div class="line"><span class="meta">#define Unlock() dispatch_semaphore_signal(self-&gt;_lock)</span></div></pre></td></tr></table></figure>
<p>简单说一下信号量：</p>
<p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是</p>
<ul>
<li>dispatch_semaphore_create：定义信号量</li>
<li>dispatch_semaphore_signal：使信号量+1</li>
<li>dispatch_semaphore_wait：使信号量-1</li>
</ul>
<p>当信号量为0时，就会做等待处理，这是其他线程如果访问的话就会让其等待。所以如果信号量在最开始的的时候被设置为1，那么就可以实现“锁”的功能：</p>
<ul>
<li>执行某段代码之前，执行dispatch_semaphore_wait函数，让信号量-1变为0，执行这段代码。</li>
<li>此时如果其他线程过来访问这段代码，就要让其等待。</li>
<li>当这段代码在当前线程结束以后，执行dispatch_semaphore_signal函数，令信号量再次+1，那么如果有正在等待的线程就可以访问了。</li>
</ul>
<p>需要注意的是：如果有多个线程等待，那么后来信号量恢复以后访问的顺序就是线程遇到dispatch_semaphore_wait的顺序。</p>
<p>这也就是信号量和互斥锁的一个区别：互斥量用于线程的互斥，信号线用于线程的同步。</p>
<ul>
<li><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但<strong>互斥无法限制访问者对资源的访问顺序，即访问是无序的</strong>。</p>
</li>
<li><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。也就是说使用信号量可以使多个线程有序访问某个资源。</p>
</li>
</ul>
<p>那么问题来了：为什么内存缓存使用的是互斥锁（pthread_mutex），而磁盘缓存使用的就是信号量（dispatch_semaphore）呢？</p>
<p>答案在框架作者的文章<a href="https://blog.ibireme.com/2015/10/26/yycache/" target="_blank" rel="external">YYCache 设计思路</a>里可以找到:</p>
<p>为什么内存缓存使用互斥锁（pthread_mutex）？</p>
<p>框架作者在最初使用的是自旋锁(OSSpinLock)作为内存缓存的线程锁，但是后来得知其不够安全，所以退而求其次，使用了pthread_mutex。</p>
<p>为什么磁盘缓存使用的是信号量（dispatch_semaphore）？</p>
<blockquote>
<p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p>
</blockquote>
<p>因为YYDiskCache在写入比较大的缓存时，可能会有比较长的等待时间，而dispatch_semaphore在这个时候是不消耗CPU资源的，所以比较适合。</p>
<h2 id="提高缓存性能的几个尝试"><a href="#提高缓存性能的几个尝试" class="headerlink" title="提高缓存性能的几个尝试"></a>提高缓存性能的几个尝试</h2><h3 id="选择合适的线程锁"><a href="#选择合适的线程锁" class="headerlink" title="选择合适的线程锁"></a>选择合适的线程锁</h3><p>可以参考上一部分YYMemoryCache 和YYDiskCache使用的不同的锁以及原因。</p>
<h3 id="选择合适的数据结构"><a href="#选择合适的数据结构" class="headerlink" title="选择合适的数据结构"></a>选择合适的数据结构</h3><p>在YYMemoryCache中，作者选择了双向链表来保存这些缓存节点。那么可以思考一下，为什么要用双向链表而不是单向链表或是数组呢？</p>
<ul>
<li><p>为什么不选择单向链表：单链表的节点只知道它后面的节点（只有指向后一节点的指针），而不知道前面的。所以如果想移动其中一个节点的话，其前后的节点不好做衔接。</p>
</li>
<li><p>为什么不选择数组：数组中元素在内存的排列是连续的，对于寻址操作非常便利；但是对于插入，删除操作很不方便，需要整体移动，移动的元素个数越多，代价越大。而链表恰恰相反，因为其节点的关联仅仅是靠指针，所以对于插入和删除操作会很便利，而寻址操作缺比较费时。由于在LRU策略中会有非常多的移动，插入和删除节点的操作，所以使用双向链表是比较有优势的。</p>
</li>
</ul>
<h3 id="选择合适的线程来操作不同的任务"><a href="#选择合适的线程来操作不同的任务" class="headerlink" title="选择合适的线程来操作不同的任务"></a>选择合适的线程来操作不同的任务</h3><p>无论缓存的自动清理和释放，作者默认把这些任务放到子线程去做：</p>
<p>看一下释放所有内存缓存的操作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeAll &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//将开销，缓存数量置为0</span></div><div class="line">    _totalCost = <span class="number">0</span>;</div><div class="line">    _totalCount = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//将链表的头尾节点置空</span></div><div class="line">    _head = <span class="literal">nil</span>;</div><div class="line">    _tail = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CFDictionaryGetCount</span>(_dic) &gt; <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CFMutableDictionaryRef</span> holder = _dic;</div><div class="line">        _dic = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</div><div class="line">        </div><div class="line">        <span class="comment">//是否在子线程操作</span></div><div class="line">        <span class="keyword">if</span> (_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CFRelease</span>(holder);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的<code>YYMemoryCacheGetReleaseQueue()</code>使用了内联函数，返回了低优先级的并发队列。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//内联函数，返回优先级最低的全局并发队列</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> YYMemoryCacheGetReleaseQueue() &#123;</div><div class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="选择底层的类"><a href="#选择底层的类" class="headerlink" title="选择底层的类"></a>选择底层的类</h3><p>同样是字典实现，但是作者使用了更底层且快速的CFDictionary而没有用NSDictionary来实现。</p>
<h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="禁用原生初始化方法并标明新定义的指定初始化方法"><a href="#禁用原生初始化方法并标明新定义的指定初始化方法" class="headerlink" title="禁用原生初始化方法并标明新定义的指定初始化方法"></a>禁用原生初始化方法并标明新定义的指定初始化方法</h3><p>YYCache有4个供外部调用的初始化接口，无论是对象方法还是类方法都需要传入一个字符串（名称或路径）。</p>
<p>而两个原生的初始化方法被框架作者禁掉了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</div><div class="line">+ (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</div></pre></td></tr></table></figure>
<p>如果用户使用了上面两个初始化方法就会在编译期报错。</p>
<p>而剩下的四个可以使用的初始化方法中，有一个是指定初始化方法，被作者用<code>NS_DESIGNATED_INITIALIZER</code>标记了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div><div class="line"></div><div class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithName:(<span class="built_in">NSString</span> *)name;</div><div class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithPath:(<span class="built_in">NSString</span> *)path;</div></pre></td></tr></table></figure>
<p>指定初始化方法就是所有可使用的初始化方法都必须调用的方法。更详细的介绍可以参考我的下面两篇文章：</p>
<ul>
<li><a href="https://juejin.im/post/5940c8befe88c2006a468ea6" target="_blank" rel="external">iOS 代码规范</a>中讲解“类”的这一部分。</li>
<li><a href="https://juejin.im/post/5a4f3710f265da3e4d728239" target="_blank" rel="external">《Effective objc》干货三部曲（三）：技巧篇</a>中的第16条。</li>
</ul>
<h3 id="异步释放对象的技巧"><a href="#异步释放对象的技巧" class="headerlink" title="异步释放对象的技巧"></a>异步释放对象的技巧</h3><p>为了异步将某个对象释放掉，可以通过在GCD的block里面给它发个消息来实现。这个技巧在该框架中很常见，举一个删除一个内存缓存的例子：</p>
<p>首先将这个缓存的node类取出，然后异步将其释放掉。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    pthread_mutex_lock(&amp;_lock);</div><div class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</div><div class="line">    <span class="keyword">if</span> (node) &#123;</div><div class="line">        [_lru removeNode:node];</div><div class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</div><div class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</div><div class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;_lock);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了释放掉这个node对象，在一个异步执行的（主队列或自定义队列里）block里给其发送了<code>class</code>这个消息。不需要纠结这个消息具体是什么，他的目的是为了避免编译错误，因为我们无法在block里面硬生生地将某个对象写进去。</p>
<p>其实关于上面这一点我自己也有点拿不准，希望理解得比较透彻的同学能在下面留个言~ ^^</p>
<h3 id="内存警告和进入后台的监听"><a href="#内存警告和进入后台的监听" class="headerlink" title="内存警告和进入后台的监听"></a>内存警告和进入后台的监听</h3><p>YYCache默认在收到内存警告和进入后台时，自动清除所有内存缓存。所以在YYMemoryCache的初始化方法里，我们可以看到这两个监听的动作：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YYMemoryCache.m</span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init&#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">      </div><div class="line">    <span class="comment">//监听app生命周期</span></div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidReceiveMemoryWarningNotification) name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidEnterBackgroundNotification) name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span> object:<span class="literal">nil</span>];</div><div class="line">   </div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实现监听到消息后的处理方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//内存警告时，删除所有内存缓存</span></div><div class="line">- (<span class="keyword">void</span>)_appDidReceiveMemoryWarningNotification &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didReceiveMemoryWarningBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.didReceiveMemoryWarningBlock(<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldRemoveAllObjectsOnMemoryWarning) &#123;</div><div class="line">        [<span class="keyword">self</span> removeAllObjects];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//进入后台时，删除所有内存缓存</span></div><div class="line">- (<span class="keyword">void</span>)_appDidEnterBackgroundNotification &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didEnterBackgroundBlock) &#123;</div><div class="line">        <span class="keyword">self</span>.didEnterBackgroundBlock(<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldRemoveAllObjectsWhenEnteringBackground) &#123;</div><div class="line">        [<span class="keyword">self</span> removeAllObjects];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="判断头文件的导入"><a href="#判断头文件的导入" class="headerlink" title="判断头文件的导入"></a>判断头文件的导入</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#if __has_include(<span class="meta-string">&lt;YYCache/YYCache.h&gt;</span>)</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYMemoryCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYDiskCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYKVStorage.h&gt;</span></span></div><div class="line"><span class="meta">#elif __has_include(<span class="meta-string">&lt;YYWebImage/YYCache.h&gt;</span>)</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYMemoryCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYDiskCache.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYKVStorage.h&gt;</span></span></div><div class="line"><span class="meta">#else</span></div><div class="line"><span class="meta">#import <span class="meta-string">"YYMemoryCache.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"YYDiskCache.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"YYKVStorage.h"</span></span></div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<p>在这里作者使用__has_include来检查Frameworks是否引入某个类。<br>因为YYWebImage已经集成YYCache,所以如果导入过YYWebImage的话就无需重再导入YYCache了。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>通过看该组件的源码，我收获的不仅有缓存设计的思路，还有：</p>
<ul>
<li>双向链表的概念以及相关操作</li>
<li>数据库的使用</li>
<li>互斥锁，信号量的使用</li>
<li>实现线程安全的方案</li>
<li>变量，方法的命名以及接口的设计</li>
</ul>
<p>相信读过这篇文章的你也会有一些收获~<br>如果能趁热打铁，下载一个<a href="https://github.com/ibireme/YYCache">YYCache</a>源码看就更好啦~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ibireme/YYCache&quot;&gt;YYCache&lt;/a&gt;是国内开发者&lt;a href=&quot;https://blog.ibireme.com/&quot;&gt;ibireme&lt;/a&gt;开源的一个线程安全的高性能键值缓存组件，代码风格简洁清晰，在GitHub上已经有了1600+颗星。&lt;/p&gt;
&lt;p&gt;阅读它的源码有助于建立比较完整的缓存设计的思路，同时也能巩固一下双向链表，线程锁，数据库操作相关的知识。如果你还没有看过YYCache的源码，那么恭喜你，阅读此文会对理解YYCache的源码有比较大的帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>YTKNetwork源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/YTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/YTKNetwork源码解析/</id>
    <published>2018-02-02T16:18:02.000Z</published>
    <updated>2018-02-02T16:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS开发来说，就算是没有用过<a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork框架</a>，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。<br>​<br>在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。</p>
<h1 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h1><hr>
<p>先上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKRequest架构图"></p>
<blockquote>
<p>在这里简单说明一下：</p>
<ol>
<li>YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 </li>
<li>YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。</li>
<li>我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。</li>
<li>YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。</li>
</ol>
</blockquote>
<p>OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。</p>
<a id="more"></a>
<h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h1><hr>
<p>YTKNetwork框架采用的设计模式是<strong>命令模式（Command Pattern）</strong>。</p>
<p>首先看一下命令模式的定义：</p>
<blockquote>
<p>命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。<br>摘自：<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">《Head First 设计模式》</a></p>
</blockquote>
<p>看一下命令模式的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c5c7e9ff32b2e647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令模式类图.png"></p>
<p>图中英文的含义：</p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td>抽象命令类</td>
</tr>
<tr>
<td>ConcreteCommand</td>
<td>命令类的实现类（子类）</td>
</tr>
<tr>
<td>Invoker</td>
<td>调用者</td>
</tr>
<tr>
<td>Receiver</td>
<td>命令接收者（执行者)</td>
</tr>
<tr>
<td>Client</td>
<td>客户端</td>
</tr>
</tbody>
</table>
<p>详细介绍一下：</p>
<ol>
<li>命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
</ol>
<p>可能还是觉得有点抽象，在这里举一个<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">《Head First 设计模式》</a>里的例子，一个客人在餐厅点餐的过程：</p>
<ol>
<li>你将点的菜写在订单里，交给了服务员。</li>
<li>服务员将订单交给厨师。</li>
<li>厨师做好菜之后将做好的菜交给服务员。</li>
<li>最后服务员把菜递给你。</li>
</ol>
<p>在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。<br>所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。</p>
<p>结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下YTKNetwork内部的职能</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Command</th>
<th>ConcreteCommand</th>
<th>Invoker</th>
<th>Receiver</th>
<th>Client</th>
</tr>
</thead>
<tbody>
<tr>
<td>餐厅</td>
<td>空白订单</td>
<td>填入菜名的订单</td>
<td>服务员</td>
<td>厨师</td>
<td>客人</td>
</tr>
<tr>
<td>YTKNetwork</td>
<td>YTKBaseRequest</td>
<td>CustomRequest</td>
<td>YTKNetworkAgent</td>
<td>AFNetworking</td>
<td>ViewController/ViewModel</td>
</tr>
</tbody>
</table>
<p>可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。</p>
<p>另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。</p>
<p>相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。</p>
<h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><hr>
<p>在真正讲解源码之前，我先详细说一下各个类的职责:</p>
<h2 id="3-1-责任介绍"><a href="#3-1-责任介绍" class="headerlink" title="3.1 责任介绍"></a>3.1 责任介绍</h2><table>
<thead>
<tr>
<th>类名</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKRequest</td>
<td>YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。</td>
</tr>
<tr>
<td>YTKNetworkConfig</td>
<td>被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。</td>
</tr>
<tr>
<td>YTKNetworkPrivate</td>
<td>提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。</td>
</tr>
<tr>
<td>YTKNetworkAgent</td>
<td>真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。</td>
</tr>
<tr>
<td>YTKBatchRequest</td>
<td>可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。</td>
</tr>
<tr>
<td>YTKBatchRequestAgent</td>
<td>负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。</td>
</tr>
<tr>
<td>YTKChainRequest</td>
<td>可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。</td>
</tr>
<tr>
<td>YTKChainRequestAgent</td>
<td>负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。</td>
</tr>
</tbody>
</table>
<p>OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。</p>
<h2 id="3-2-单个请求"><a href="#3-2-单个请求" class="headerlink" title="3.2 单个请求"></a>3.2 单个请求</h2><h3 id="3-21-单个请求的配置"><a href="#3-21-单个请求的配置" class="headerlink" title="3.21 单个请求的配置"></a>3.21 单个请求的配置</h3><p><a href="https://github.com/yuantiku/YTKNetwork/blob/master/Docs/BasicGuide_cn.md">官方的教程</a>建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application </div><div class="line">   didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">   YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig];</div><div class="line">   config.baseUrl = <span class="string">@"http://yuantiku.com"</span>;</div><div class="line">   config.cdnUrl = <span class="string">@"http://fen.bi"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RegisterApi.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"YTKRequest.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RegisterApi</span> : <span class="title">YTKRequest</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RegisterApi.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"RegisterApi.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RegisterApi</span> </span>&#123;</div><div class="line">    <span class="built_in">NSString</span> *_username;</div><div class="line">    <span class="built_in">NSString</span> *_password;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//初始化的时候将两个参数值传入</span></div><div class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _username = username;</div><div class="line">        _password = password;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//需要和baseUrl拼接的地址</span></div><div class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</div><div class="line">    <span class="comment">// “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息</span></div><div class="line">    <span class="keyword">return</span> <span class="string">@"/iphone/register"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//请求方法，某人是GET</span></div><div class="line">- (YTKRequestMethod)requestMethod &#123;</div><div class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//请求体</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"username"</span>: _username,</div><div class="line">        <span class="string">@"password"</span>: _password</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。</p>
<h3 id="3-22-单个请求的发起"><a href="#3-22-单个请求的发起" class="headerlink" title="3.22 单个请求的发起"></a>3.22 单个请求的发起</h3><p>还是刚才的注册API，在实例化以后，直接调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法）就可以发起它：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LoginViewController.m</span></div><div class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</div><div class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</div><div class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</div><div class="line">        [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123;</div><div class="line">            <span class="comment">// 你可以直接在这里使用 self</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</div><div class="line">        &#125; failure:^(YTKBaseRequest *request) &#123;</div><div class="line">            <span class="comment">// 你可以直接在这里使用 self</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是以block的形式回调，YTKNetwork也支持代理的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LoginViewController.m</span></div><div class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</div><div class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</div><div class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</div><div class="line">        api.delegate = <span class="keyword">self</span>;</div><div class="line">        [api start];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有两点需要注意的是：</p>
<ol>
<li>必须给自定义请求类（RegisterApi）调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法），才能真正发起请求。</li>
<li>在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。</li>
</ol>
<p>知道了YTKRequest请求是如何在外部发起的，我们现在从<code>startWithCompletionBlockWithSuccess:failure</code>方法开始，来看一下YTKNetwork都做了什么：</p>
<p>首先来到YTKBaseRequest类（因为最早是由它定义的该方法）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line"><span class="comment">//传入成功和失败的block,并保存起来</span></div><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</div><div class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</div><div class="line">    <span class="comment">//保存成功和失败的回调block，便于将来调用</span></div><div class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</div><div class="line">    <span class="comment">//发起请求</span></div><div class="line">    [<span class="keyword">self</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//保存成功和失败的block</span></div><div class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</div><div class="line">                              failure:(YTKRequestCompletionBlock)failure &#123;</div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当保存完成功和失败的block以后，调用<code>start</code>方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了<code>start</code>方法，但是由于YTKRequest类是它的子类并也实现了<code>start</code>方法，所以这里最先走的是YTKRequest类的<code>start</code>方法）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理）</span></div><div class="line">    _dataFromCache = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//5. 回调之前的操作</span></div><div class="line">        <span class="comment">//5.1 缓存处理</span></div><div class="line">        [<span class="keyword">self</span> requestCompletePreprocessor];</div><div class="line">        </div><div class="line">        <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></div><div class="line">        [<span class="keyword">self</span> requestCompleteFilter];</div><div class="line">        </div><div class="line">        YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//6. 执行回调</span></div><div class="line">        <span class="comment">//6.1 请求完成的代理</span></div><div class="line">        [strongSelf.delegate requestFinished:strongSelf];</div><div class="line">        </div><div class="line">        <span class="comment">//6.2 请求成功的block</span></div><div class="line">        <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">            strongSelf.successCompletionBlock(strongSelf);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">        [strongSelf clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个<code>start</code>方法里，它做的是请求之前缓存的查询和检查工作:</p>
<ul>
<li>如果忽略缓存，或者缓存获取失败，调用<code>startWithoutCache</code>方法（参考1-3的情况），发起请求。</li>
<li>如果能成功获取到缓存，则直接回调（参考4-7的情况）。</li>
</ul>
<p>我们来看一下每一步的具体实现：</p>
<ol>
<li><code>ignoreCache</code>属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。</li>
<li><code>resumableDownloadPath</code>是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。</li>
<li><code>loadCacheWithError：</code>方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒）</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache time"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 是否有缓存的元数据，如果没有，返回错误</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheMetadata]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid metadata. Cache may not exist"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有缓存，再验证是否有效</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateCacheWithError:error]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有缓存，而且有效，再验证是否能取出来</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheData]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache data"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。</p>
<p>我们来看一下上面关于缓存的元数据的获取方法：<code>loadCacheMetadata</code>方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheMetadata &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheMetadataFilePath];</div><div class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</div><div class="line">        <span class="keyword">@try</span> &#123;</div><div class="line">            <span class="comment">//将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata</span></div><div class="line">            _cacheMetadata = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">            YTKLog(<span class="string">@"Load cache metadata failed, reason = %@"</span>, exception.reason);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。<br>YTKCacheMetadata类被定义在YTKRequest.m文件里面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">long</span> <span class="keyword">long</span> version;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。<br>因此，<code>loadCacheMetadata</code>方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的<code>cacheMetadata</code>属性上。</p>
<p>现在获取了缓存的元数据并赋给了自身的cacheMetadata属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的validateCacheWithError：里面验证：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 是否大于过期时间</span></div><div class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</div><div class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</div><div class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache expired"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 缓存的版本号是否符合</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</div><div class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache version mismatch"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 敏感信息是否符合</span></div><div class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</div><div class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</div><div class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></div><div class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache sensitive data mismatch"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// app的版本是否符合</span></div><div class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</div><div class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</div><div class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"App version mismatch"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果每项元数据信息都能通过，再在<code>loadCacheData</code>方法里面验证缓存是否能被取出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheData &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheFilePath];</div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</div><div class="line">        _cacheData = data;</div><div class="line">        _cacheString = [[<span class="built_in">NSString</span> alloc] initWithData:_cacheData encoding:<span class="keyword">self</span>.cacheMetadata.stringEncoding];</div><div class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.responseSerializerType) &#123;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</div><div class="line">                <span class="comment">// Do nothing.</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</div><div class="line">                _cacheJSON = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:_cacheData options:(<span class="built_in">NSJSONReadingOptions</span>)<span class="number">0</span> error:&amp;error];</div><div class="line">                <span class="keyword">return</span> error == <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</div><div class="line">                _cacheXML = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:_cacheData];</div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。</p>
<p>当确认缓存可以成功取出后，手动设置<code>dataFromCache</code>属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。</p>
<p>然后在真正回调之前做了如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    <span class="comment">//5. 回调之前的操作</span></div><div class="line">    <span class="comment">//5.1 缓存处理</span></div><div class="line">    [<span class="keyword">self</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></div><div class="line">    [<span class="keyword">self</span> requestCompleteFilter];</div><div class="line"></div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.1：<code>requestCompletePreprocessor</code>方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</div><div class="line">            <span class="comment">//保存响应数据到缓存</span></div><div class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//保存响应数据到缓存</span></div><div class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line"><span class="comment">//保存响应数据到缓存</span></div><div class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</div><div class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                <span class="comment">// New data will always overwrite old data.</span></div><div class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</div><div class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</div><div class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</div><div class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</div><div class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到, <code>requestCompletePreprocessor</code>方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要<code>cacheTimeInSeconds</code>方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是<code>isDataFromCache</code>方法返回NO。<br>但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。</p>
</blockquote>
<p>接着看下5.2：<code>requestCompleteFilter</code>方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestCompleteFilter &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">    <span class="comment">//6. 执行回调</span></div><div class="line">    <span class="comment">//6.1 请求完成的代理</span></div><div class="line">    [strongSelf.delegate requestFinished:strongSelf];</div><div class="line">        </div><div class="line">    <span class="comment">//6.2 请求成功的block</span></div><div class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">         strongSelf.successCompletionBlock(strongSelf);</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">    [strongSelf clearCompletionBlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</div><div class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，在用户同时实现了代理和block的情况下，二者都会被调用。</p>
</blockquote>
<p>到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。</p>
<p>反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么：</p>
<p>仔细看一下上面的<code>start</code>方法，我们会发现，如果缓存不满足条件时，会直接调用<code>startWithoutCache</code>方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line"></div><div class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么在<code>startWithoutCache</code>方法里都做了什么呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)startWithoutCache &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 清除缓存</span></div><div class="line">    [<span class="keyword">self</span> clearCacheVariables];</div><div class="line">    </div><div class="line">    <span class="comment">//2. 调用父类的发起请求</span></div><div class="line">    [<span class="keyword">super</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清除当前请求对应的所有缓存</span></div><div class="line">- (<span class="keyword">void</span>)clearCacheVariables &#123;</div><div class="line">    _cacheData = <span class="literal">nil</span>;</div><div class="line">    _cacheXML = <span class="literal">nil</span>;</div><div class="line">    _cacheJSON = <span class="literal">nil</span>;</div><div class="line">    _cacheString = <span class="literal">nil</span>;</div><div class="line">    _cacheMetadata = <span class="literal">nil</span>;</div><div class="line">    _dataFromCache = <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，首先清除了关于缓存的所有数据，然后调用父类的<code>start</code>方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m:</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 告诉Accessories即将回调了（其实是即将发起请求）</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line"></div><div class="line">    <span class="comment">//2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例</span></div><div class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步里的Accessories是一些遵从<ytkrequestaccessory>代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里：</ytkrequestaccessory></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用来跟踪请求的状态的代理。</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YTKRequestAccessory</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request is about to start.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestWillStart:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request is about to stop. This method is called</span></div><div class="line"><span class="comment">///  before executing `requestFinished` and `successCompletionBlock`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestWillStop:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request has already stoped. This method is called</span></div><div class="line"><span class="comment">///  after executing `requestFinished` and `successCompletionBlock`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestDidStop:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。</p>
<p>接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获取task</span></div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取用户自定义的requestURL</span></div><div class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</div><div class="line">        </div><div class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></div><div class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">            <span class="comment">//响应的统一处理</span></div><div class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</div><div class="line">        &#125;];</div><div class="line">        request.requestTask = dataTask;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></div><div class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//序列化失败，则认定为请求失败</span></div><div class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSAssert</span>(request.requestTask != <span class="literal">nil</span>, <span class="string">@"requestTask should not be nil"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 优先级的映射</span></div><div class="line">    <span class="comment">// !!Available on iOS 8 +</span></div><div class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</div><div class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</div><div class="line">                <span class="comment">/*!!fall through*/</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Retain request</span></div><div class="line">    YTKLog(<span class="string">@"Add request: %@"</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</div><div class="line">    </div><div class="line">    <span class="comment">//2. 将request放入保存请求的字典中，taskIdentifier为key，request为值</span></div><div class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</div><div class="line">    </div><div class="line">    <span class="comment">//3. 开始task</span></div><div class="line">    [request.requestTask resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法挺长的，但是请不要被吓到，它总共分为三个部分：</p>
<ul>
<li>第一部分是获取当前请求对应的task并赋给request的<code>requestTask</code>属性（以后提到的request，都为用户自定义的当前请求类的实例）。</li>
<li>第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。</li>
<li>第三部分是启动task。</li>
</ul>
<p>下面我来依次讲解每个部分：</p>
<p><strong>第一部分：获取当前请求对应的task并赋给request</strong>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (customUrlRequest) &#123;</div><div class="line">        </div><div class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></div><div class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">            <span class="comment">//统一处理请求响应</span></div><div class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</div><div class="line">        &#125;];</div><div class="line">        request.requestTask = dataTask;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></div><div class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里判断了用户是否自定义了request：</p>
<ol>
<li>如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。</li>
<li>如果不是，则调用YTKRequest自己的生成task的方法。</li>
</ol>
<p>第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，<code>sessionTaskForRequest: error :</code>方法内部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//根据不同请求类型，序列化类型，和请求参数来返回NSURLSessionTask</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获得请求类型（GET，POST等）</span></div><div class="line">    YTKRequestMethod method = [request requestMethod];</div><div class="line"></div><div class="line">    <span class="comment">//2. 获得请求url</span></div><div class="line">    <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</div><div class="line"></div><div class="line">    <span class="comment">//3. 获得请求参数</span></div><div class="line">    <span class="keyword">id</span> param = request.requestArgument;</div><div class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</div><div class="line">    </div><div class="line">    <span class="comment">//4. 获得request serializer</span></div><div class="line">    AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</div><div class="line"></div><div class="line">    <span class="comment">//5. 根据不同的请求类型来返回对应的task</span></div><div class="line">    <span class="keyword">switch</span> (method) &#123;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodGET:</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</div><div class="line">                <span class="comment">//下载任务</span></div><div class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath requestSerializer:requestSerializer URLString:url parameters:param progress:request.resumableDownloadProgressBlock error:error];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//普通get请求</span></div><div class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"GET"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPOST:</div><div class="line">            <span class="comment">//POST请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodHEAD:</div><div class="line">            <span class="comment">//HEAD请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"HEAD"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPUT:</div><div class="line">            <span class="comment">//PUT请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PUT"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodDELETE:</div><div class="line">            <span class="comment">//DELETE请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"DELETE"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPATCH:</div><div class="line">            <span class="comment">//PATCH请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PATCH"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法：</p>
<ol>
<li>获得请求类型（GET，POST等）：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  YTKRequestMethod method = [request requestMethod];</div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>requestMethod</code>方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。</p>
<p>它的枚举类型在YTKBaseRequest.h里面定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.h</span></div><div class="line"><span class="comment">///  HTTP Request method.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestMethod) &#123;</div><div class="line">    YTKRequestMethodGET = <span class="number">0</span>,</div><div class="line">    YTKRequestMethodPOST,</div><div class="line">    YTKRequestMethodHEAD,</div><div class="line">    YTKRequestMethodPUT,</div><div class="line">    YTKRequestMethodDELETE,</div><div class="line">    YTKRequestMethodPATCH,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用户可以根据实际的需求在自定义request类里面重写这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RegisterAPI.m</span></div><div class="line">- (YTKRequestMethod)requestMethod &#123;</div><div class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.获得请求url：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//返回当前请求url</span></div><div class="line">- (<span class="built_in">NSString</span> *)buildRequestUrl:(YTKBaseRequest *)request &#123;</div><div class="line">   </div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="comment">//用户自定义的url（不包括在YTKConfig里面设置的base_url）</span></div><div class="line">    <span class="built_in">NSString</span> *detailUrl = [request requestUrl];</div><div class="line">    <span class="built_in">NSURL</span> *temp = [<span class="built_in">NSURL</span> URLWithString:detailUrl];</div><div class="line">    </div><div class="line">    <span class="comment">// 存在host和scheme的url立即返回正确</span></div><div class="line">    <span class="keyword">if</span> (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123;</div><div class="line">        <span class="keyword">return</span> detailUrl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果需要过滤url，则过滤</span></div><div class="line">    <span class="built_in">NSArray</span> *filters = [_config urlFilters];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</div><div class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *baseUrl;</div><div class="line">    <span class="keyword">if</span> ([request useCDN]) &#123;</div><div class="line">        <span class="comment">//如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN</span></div><div class="line">        <span class="keyword">if</span> ([request cdnUrl].length &gt; <span class="number">0</span>) &#123;</div><div class="line">            baseUrl = [request cdnUrl];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            baseUrl = [_config cdnUrl];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl</span></div><div class="line">        <span class="keyword">if</span> ([request baseUrl].length &gt; <span class="number">0</span>) &#123;</div><div class="line">            baseUrl = [request baseUrl];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            baseUrl = [_config baseUrl];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果末尾没有/，则在末尾添加一个／</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:baseUrl];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (baseUrl.length &gt; <span class="number">0</span> &amp;&amp; ![baseUrl hasSuffix:<span class="string">@"/"</span>]) &#123;</div><div class="line">        url = [url URLByAppendingPathComponent:<span class="string">@""</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> URLWithString:detailUrl relativeToURL:url].absoluteString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.获得请求参数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">      <span class="comment">//获取用户提供的请求参数</span></div><div class="line">    <span class="keyword">id</span> param = request.requestArgument;</div><div class="line"></div><div class="line">    <span class="comment">//获取用户提供的构造请求体的block（默认是没有的）</span></div><div class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RegisterApi.m</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"username"</span>: _username,</div><div class="line">        <span class="string">@"password"</span>: _password</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.获得request serializer</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">   <span class="comment">//4. 获得request serializer</span></div><div class="line">   AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    AFHTTPRequestSerializer *requestSerializer = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//HTTP or JSON</span></div><div class="line">    <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123;</div><div class="line">        requestSerializer = [AFHTTPRequestSerializer serializer];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123;</div><div class="line">        requestSerializer = [AFJSONRequestSerializer serializer];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//超时时间</span></div><div class="line">    requestSerializer.timeoutInterval = [request requestTimeoutInterval];</div><div class="line">    </div><div class="line">    <span class="comment">//是否允许数据服务</span></div><div class="line">    requestSerializer.allowsCellularAccess = [request allowsCellularAccess];</div><div class="line"></div><div class="line">    <span class="comment">//如果当前请求需要验证</span></div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray];</div><div class="line">    <span class="keyword">if</span> (authorizationHeaderFieldArray != <span class="literal">nil</span>) &#123;</div><div class="line">        [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject</div><div class="line">                                                          password:authorizationHeaderFieldArray.lastObject];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果当前请求需要自定义 HTTPHeaderField</span></div><div class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary];</div><div class="line">    <span class="keyword">if</span> (headerFieldValueDictionary != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *httpHeaderField <span class="keyword">in</span> headerFieldValueDictionary.allKeys) &#123;</div><div class="line">            <span class="built_in">NSString</span> *value = headerFieldValueDictionary[httpHeaderField];</div><div class="line">            [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> requestSerializer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。</p>
<p>到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:<span class="literal">nil</span> error:error];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最终返回NSURLSessionDataTask实例</span></div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">//根据有无构造请求体的block的情况来获取request</span></div><div class="line">    <span class="keyword">if</span> (block) &#123;</div><div class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获得request以后来获取dataTask</span></div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    dataTask = [_manager dataTaskWithRequest:request</div><div class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</div><div class="line">                               <span class="comment">//响应的统一处理</span></div><div class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</div><div class="line">                           &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。</p>
<p>OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在<code>addRequest：</code>方法里接下来做的是对序列化失败的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">  <span class="comment">//序列化失败</span></div><div class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。</p>
<p>继续往下走，到了优先级的映射部分：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">    <span class="comment">// 优先级的映射</span></div><div class="line">    <span class="comment">// !!Available on iOS 8 +</span></div><div class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</div><div class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</div><div class="line">                <span class="comment">/*!!fall through*/</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestPriority) &#123;</div><div class="line">    YTKRequestPriorityLow = <span class="number">-4</span>L,</div><div class="line">    YTKRequestPriorityDefault = <span class="number">0</span>,</div><div class="line">    YTKRequestPriorityHigh = <span class="number">4</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。</p>
<p>到这里，我们拿到了task的实例并设置好了优先级，紧接着就是<code>addRequest:</code>方法里的第二个部分：<br>YTKNetworkAgent将request实例放在了一个字典中，保存起来：</p>
<p><strong>第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">  <span class="comment">//将request实例放入保存请求的字典中，taskIdentifier为key，request为值</span></div><div class="line">  [<span class="keyword">self</span> addRequestToRecord:request];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addRequestToRecord:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    Lock();</div><div class="line">    _requestsRecord[@(request.requestTask.taskIdentifier)] = request;</div><div class="line">    Unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#define Lock() pthread_mutex_lock(&amp;_lock)</span></div><div class="line"><span class="meta">#define Unlock() pthread_mutex_unlock(&amp;_lock)</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。</p>
</blockquote>
<p>在当前的request被保存以后，就到了最后一步，正式发起请求：</p>
<p><strong>第三部分：启动task</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">   [request.requestTask resume];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。</p>
<p>那么接下来我们看一下YTKNetwork是如何处理请求的回调的。</p>
<p>眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：<code>handleRequestResult:responseObject:error:</code>。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//统一处理请求结果，包括成功和失败的情况</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获取task对应的request</span></div><div class="line">    Lock();</div><div class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</div><div class="line">    Unlock();</div><div class="line"></div><div class="line">    <span class="comment">//如果不存在对应的request，则立即返回</span></div><div class="line">    <span class="keyword">if</span> (!request) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    。。。</div><div class="line"></div><div class="line">    <span class="comment">//2. 获取request对应的response</span></div><div class="line">    request.responseObject = responseObject;</div><div class="line">    </div><div class="line">    <span class="comment">//3. 获取responseObject，responseData和responseString</span></div><div class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        </div><div class="line">       <span class="comment">//3.1 获取 responseData</span></div><div class="line">        request.responseData = responseObject;</div><div class="line">        </div><div class="line">        <span class="comment">//3.2 获取responseString</span></div><div class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</div><div class="line"></div><div class="line">         <span class="comment">//3.3 获取responseObject（或responseJSONObject）</span></div><div class="line">        <span class="comment">//根据返回的响应的序列化的类型来得到对应类型的响应</span></div><div class="line">        <span class="keyword">switch</span> (request.responseSerializerType)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</div><div class="line">                <span class="comment">// Default serializer. Do nothing.</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</div><div class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</div><div class="line">                request.responseJSONObject = request.responseObject;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</div><div class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调</span></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="comment">//如果该方法传入的error不为nil</span></div><div class="line">        succeed = <span class="literal">NO</span>;</div><div class="line">        requestError = error;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        <span class="comment">//如果序列化失败了</span></div><div class="line">        succeed = <span class="literal">NO</span>;</div><div class="line">        requestError = serializationError;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//即使没有error而且序列化通过，也要验证request是否有效</span></div><div class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</div><div class="line">        requestError = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></div><div class="line">    <span class="keyword">if</span> (succeed) &#123;</div><div class="line">        <span class="comment">//请求成功的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="comment">//6. 回调完成的处理</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//6.1 在字典里移除当前request</span></div><div class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">         <span class="comment">//6.2 清除所有block</span></div><div class="line">        [request clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单讲解一下上面的代码：</p>
<ul>
<li>首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。</li>
<li>然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。</li>
<li>再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。</li>
<li>最后根据succeed的值来进行成功和失败的回调。</li>
</ul>
<p>这里先重点介绍一下是如何判断json的有效性的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//判断code是否符合范围和json的有效性</span></div><div class="line">- (<span class="built_in">BOOL</span>)validateResult:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 判断code是否在200~299之间</span></div><div class="line">    <span class="built_in">BOOL</span> result = [request statusCodeValidator];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!result) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid status code"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//2. result 存在的情况判断json是否有效</span></div><div class="line">    <span class="keyword">id</span> json = [request responseJSONObject];</div><div class="line">    <span class="keyword">id</span> validator = [request jsonValidator];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (json &amp;&amp; validator) &#123;</div><div class="line">        <span class="comment">//通过json和validator来判断json是否有效</span></div><div class="line">        result = [YTKNetworkUtils validateJSON:json withValidator:validator];</div><div class="line">        </div><div class="line">        <span class="comment">//如果json无效</span></div><div class="line">        <span class="keyword">if</span> (!result) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid JSON format"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，首先，用<code>statusCodeValidator</code>方法判断响应的code是否在正确的范围:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseReqiest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)statusCodeValidator &#123;</div><div class="line">    <span class="built_in">NSInteger</span> statusCode = [<span class="keyword">self</span> responseStatusCode];</div><div class="line">    <span class="keyword">return</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt;= <span class="number">299</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSInteger</span>)responseStatusCode &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.response.statusCode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再判断json的有效性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkUtils.m</span></div><div class="line"><span class="comment">//判断json的有效性</span></div><div class="line">+ (<span class="built_in">BOOL</span>)validateJSON:(<span class="keyword">id</span>)json withValidator:(<span class="keyword">id</span>)jsonValidator &#123;</div><div class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp;</div><div class="line">        [jsonValidator isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSDictionary</span> * dict = json;</div><div class="line">        <span class="built_in">NSDictionary</span> * validator = jsonValidator;</div><div class="line">        <span class="built_in">BOOL</span> result = <span class="literal">YES</span>;</div><div class="line">        <span class="built_in">NSEnumerator</span> * enumerator = [validator keyEnumerator];</div><div class="line">        <span class="built_in">NSString</span> * key;</div><div class="line">        <span class="keyword">while</span> ((key = [enumerator nextObject]) != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">id</span> value = dict[key];</div><div class="line">            <span class="keyword">id</span> format = validator[key];</div><div class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]</div><div class="line">                || [value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                result = [<span class="keyword">self</span> validateJSON:value withValidator:format];</div><div class="line">                <span class="keyword">if</span> (!result) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> ([value isKindOfClass:format] == <span class="literal">NO</span> &amp;&amp;</div><div class="line">                    [value isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] == <span class="literal">NO</span>) &#123;</div><div class="line">                    result = <span class="literal">NO</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] &amp;&amp;</div><div class="line">               [jsonValidator isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSArray</span> * validatorArray = (<span class="built_in">NSArray</span> *)jsonValidator;</div><div class="line">        <span class="keyword">if</span> (validatorArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSArray</span> * array = json;</div><div class="line">            <span class="built_in">NSDictionary</span> * validator = jsonValidator[<span class="number">0</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> array) &#123;</div><div class="line">                <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> validateJSON:item withValidator:validator];</div><div class="line">                <span class="keyword">if</span> (!result) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:jsonValidator]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。</p>
<p>在验证返回的JSON数据是否有效以后，就可以进行回调了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></div><div class="line">    <span class="keyword">if</span> (succeed) &#123;</div><div class="line">        <span class="comment">//请求成功的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//6. 回调完成的处理</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//6.1 在字典里移除当前request</span></div><div class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">         <span class="comment">//6.2 清除所有block</span></div><div class="line">        [request clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先来分别看一下请求成功的处理和失败的处理：</p>
<p>请求成功的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block</span></div><div class="line">- (<span class="keyword">void</span>)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">//写入缓存 </span></div><div class="line">        [request requestCompletePreprocessor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></div><div class="line">        [request toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//在真正的回调之前做的处理,用户自定义</span></div><div class="line">        [request requestCompleteFilter];</div><div class="line"></div><div class="line">        <span class="comment">//如果有代理，则调用成功的代理</span></div><div class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</div><div class="line">            [request.delegate requestFinished:request];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果传入了成功回调的代码，则调用</span></div><div class="line">        <span class="keyword">if</span> (request.successCompletionBlock) &#123;</div><div class="line">            request.successCompletionBlock(request);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求已经结束了</span></div><div class="line">        [request toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下<code>requestCompletePreprocessor</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</div><div class="line">            <span class="comment">//写入缓存文件</span></div><div class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="comment">//写入缓存文件</span></div><div class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存文件</span></div><div class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</div><div class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                <span class="comment">// 1. 保存request的responseData到cacheFilePath</span></div><div class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">                <span class="comment">// 2. 保存request的metadata到cacheMetadataFilePath</span></div><div class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</div><div class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</div><div class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</div><div class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</div><div class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先看一下写入缓存操作的执行条件：当<code>cacheTimeInSeconds</code>方法返回大于0并且<code>isDataFromCache</code>为NO的时候会进行写入缓存。</p>
<p><code>cacheTimeInSeconds</code>方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。</p>
<p><code>isDataFromCache</code>属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：<code>isDataFromCache</code>的默认值是NO。在请求发起之前，-<br>查询缓存的时候：</p>
<ul>
<li>如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。</li>
<li>如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。</li>
</ul>
<p>即是说，如果发送了请求，则<code>isDataFromCache</code>一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。</p>
<p>因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。</p>
<p>我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：<br>第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种：</p>
<ol>
<li>缓存的版本，默认返回为0，用户可以自定义。</li>
<li>敏感数据，类型为id，默认返回nil，用户可以自定义。</li>
<li>NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
<li>元数据的创建时间。</li>
<li>app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
</ol>
<p>在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过<code>cacheMetadataFilePath</code>方法获取。</p>
<p>现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line"><span class="comment">//纯NSData数据缓存的文件名</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</div><div class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</div><div class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</div><div class="line">    <span class="keyword">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</div><div class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Method:%ld Host:%@ Url:%@ Argument:%@"</span>,</div><div class="line">                             (<span class="keyword">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</div><div class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</div><div class="line">    <span class="keyword">return</span> cacheFileName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//纯NSData数据的缓存位置</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheFilePath &#123;</div><div class="line">    <span class="built_in">NSString</span> *cacheFileName = [<span class="keyword">self</span> cacheFileName];</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</div><div class="line">    path = [path stringByAppendingPathComponent:cacheFileName];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//元数据的缓存位置</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</div><div class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.metadata"</span>, [<span class="keyword">self</span> cacheFileName]];</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</div><div class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建用户保存所有YTKNetwork缓存的文件夹</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//获取全路径</span></div><div class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@"LazyRequestCache"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法</span></div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</div><div class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</div><div class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//创建文件夹</span></div><div class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。</p>
<p>而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。</p>
<p>为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6c5f41fbe2993059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存和缓存元数据的文件"></p>
<p>而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。</p>
<p>OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">//6. 执行回调</span></div><div class="line">    <span class="comment">//6.1 请求完成的代理</span></div><div class="line">    [strongSelf.delegate requestFinished:strongSelf];</div><div class="line"></div><div class="line">    <span class="comment">//6.2 请求成功的block</span></div><div class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">        strongSelf.successCompletionBlock(strongSelf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">    [strongSelf clearCompletionBlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用<code>clearCompletionBlock</code>方法将block清空。该方法的实现是在YTKBaseRequest里：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</div><div class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//请求失败</span></div><div class="line">- (<span class="keyword">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    </div><div class="line">    request.error = error;</div><div class="line">    YTKLog(<span class="string">@"Request %@ failed, status code = %ld, error = %@"</span>,</div><div class="line">           <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]), (<span class="keyword">long</span>)request.responseStatusCode, error.localizedDescription);</div><div class="line"></div><div class="line">    <span class="comment">// 储存未完成的下载数据</span></div><div class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</div><div class="line">    <span class="keyword">if</span> (incompleteDownloadData) &#123;</div><div class="line">        [incompleteDownloadData writeToURL:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Load response from file and clean up if download task failed.</span></div><div class="line">    <span class="comment">//如果下载任务失败，则取出对应的响应文件并清空</span></div><div class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = request.responseObject;</div><div class="line">        </div><div class="line">        <span class="comment">//isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件</span></div><div class="line">        <span class="keyword">if</span> (url.isFileURL &amp;&amp; [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:url.path]) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//将url的data和string赋给request</span></div><div class="line">            request.responseData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">            request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</div><div class="line"></div><div class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtURL:url error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//清空request</span></div><div class="line">        request.responseObject = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">//请求失败的预处理，YTK没有定义，需要用户定义</span></div><div class="line">        [request requestFailedPreprocessor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></div><div class="line">        [request toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//在真正的回调之前做的处理</span></div><div class="line">        [request requestFailedFilter];</div><div class="line"></div><div class="line">        <span class="comment">//如果有代理，就调用代理</span></div><div class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</div><div class="line">            [request.delegate requestFailed:request];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果传入了失败回调的block代码，就调用block</span></div><div class="line">        <span class="keyword">if</span> (request.failureCompletionBlock) &#123;</div><div class="line">            request.failureCompletionBlock(request);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求已经停止了</span></div><div class="line">        [request toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到<code>resumableDownloadPath</code>里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。</p>
<p>到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-eab27afc98b324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKNetwork流程图"></p>
<p>我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.h</span></div><div class="line"><span class="comment">///  取消某个request</span></div><div class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request;</div><div class="line"></div><div class="line"><span class="comment">///  取消所有添加的request</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllRequests;</div></pre></td></tr></table></figure></p>
<p>首先我们看下取消某个request这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">///  取消某个request</span></div><div class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line">    <span class="comment">//获取request的task，并取消</span></div><div class="line">    [request.requestTask cancel];</div><div class="line">    <span class="comment">//从字典里移除当前request</span></div><div class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">    <span class="comment">//清理所有block</span></div><div class="line">    [request clearCompletionBlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从字典里移除某request</span></div><div class="line">- (<span class="keyword">void</span>)removeRequestFromRecord:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    Lock();</div><div class="line">    [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)];</div><div class="line">    YTKLog(<span class="string">@"Request queue size = %zd"</span>, [_requestsRecord count]);</div><div class="line">    Unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取消所有在字典里添加的request：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllRequests &#123;</div><div class="line">    Lock();</div><div class="line">    <span class="built_in">NSArray</span> *allKeys = [_requestsRecord allKeys];</div><div class="line">    Unlock();</div><div class="line">    <span class="keyword">if</span> (allKeys &amp;&amp; allKeys.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *copiedKeys = [allKeys <span class="keyword">copy</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *key <span class="keyword">in</span> copiedKeys) &#123;</div><div class="line">            Lock();</div><div class="line">            YTKBaseRequest *request = _requestsRecord[key];</div><div class="line">            Unlock();</div><div class="line">            <span class="comment">//stop每个请求</span></div><div class="line">            [request stop];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个stop方法是在YTKBaseRequest里面定义的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//告诉Accessories将要回调了</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//清空代理</span></div><div class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//调用agent的取消某个request的方法</span></div><div class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//告诉Accessories回调完成了</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。</p>
<h2 id="3-3-批量请求和链式请求"><a href="#3-3-批量请求和链式请求" class="headerlink" title="3.3 批量请求和链式请求"></a>3.3 批量请求和链式请求</h2><p>YTKNetwork支持的批量请求有两种：</p>
<ol>
<li>批量请求：多个请求几乎同时发起。</li>
<li>链式请求：当前个请求结束后才能发起下一个请求。</li>
</ol>
<p>其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？</p>
<p>我们首先来看一下YTKNetwork是如何实现批量请求的。</p>
<h3 id="3-31批量请求"><a href="#3-31批量请求" class="headerlink" title="3.31批量请求"></a>3.31批量请求</h3><p>YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的<code>_requestArray</code>实例变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithRequestArray:(<span class="built_in">NSArray</span>&lt;YTKRequest *&gt; *)requestArray &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//保存为属性</span></div><div class="line">        _requestArray = [requestArray <span class="keyword">copy</span>];</div><div class="line"></div><div class="line">        <span class="comment">//批量请求完成的数量初始化为0</span></div><div class="line">        _finishedCount = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败</span></div><div class="line">        <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">            <span class="keyword">if</span> (![req isKindOfClass:[YTKRequest <span class="keyword">class</span>]]) &#123;</div><div class="line">                YTKLog(<span class="string">@"Error, request item must be YTKRequest instance."</span>);</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化以后，我们就可以调用<code>start</code>方法来发起当前YTKBatchRequest实例所管理的所有请求了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line"><span class="comment">//batch请求开始</span></div><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</div><div class="line">                                    failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</div><div class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</div><div class="line">    [<span class="keyword">self</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置成功和失败的block</span></div><div class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</div><div class="line">                              failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果batch里第一个请求已经成功结束，则不能再start</span></div><div class="line">    <span class="keyword">if</span> (_finishedCount &gt; <span class="number">0</span>) &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Batch request has already started."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//最开始设定失败的request为nil</span></div><div class="line">    _failedRequest = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//使用YTKBatchRequestAgent来管理当前的批量请求</span></div><div class="line">    [[YTKBatchRequestAgent sharedAgent] addBatchRequest:<span class="keyword">self</span>];</div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//遍历所有request，并开始请求</span></div><div class="line">    <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">        req.delegate = <span class="keyword">self</span>;</div><div class="line">        [req clearCompletionBlock];</div><div class="line">        [req start];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我们可以看出：<br>1.在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的<code>start</code>方法会立即返回，否则可以无限制start。<br>2.YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequestAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addBatchRequest:(YTKBatchRequest *)request &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        [_requestArray addObject:request];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的<code>_requestArray</code>并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。</p>
<p>发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。</p>
<p>YTKRequest子类成功的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line"><span class="meta">#pragma mark - Network Request Delegate</span></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//某个request成功后，首先让_finishedCount + 1</span></div><div class="line">    _finishedCount++;</div><div class="line">    </div><div class="line">    <span class="comment">//如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功</span></div><div class="line">    <span class="keyword">if</span> (_finishedCount == _requestArray.count) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//调用即将结束的代理</span></div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//调用请求成功的代理</span></div><div class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFinished:)]) &#123;</div><div class="line">            [_delegate batchRequestFinished:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//调用批量请求成功的block</span></div><div class="line">        <span class="keyword">if</span> (_successCompletionBlock) &#123;</div><div class="line">            _successCompletionBlock(<span class="keyword">self</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//清空成功和失败的block</span></div><div class="line">        [<span class="keyword">self</span> clearCompletionBlock];</div><div class="line">        </div><div class="line">        <span class="comment">//调用请求结束的代理</span></div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></div><div class="line">        [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。</p>
<p>接下来我们看一下某个请求失败的处理：</p>
<p>YTKReques子类失败的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKRequest *)request &#123;</div><div class="line">    </div><div class="line">    _failedRequest = request;</div><div class="line">    </div><div class="line">    <span class="comment">//调用即将结束的代理</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//停止batch里所有的请求</span></div><div class="line">    <span class="keyword">for</span> (YTKRequest *req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">        [req stop];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//调用请求失败的代理</span></div><div class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFailed:)]) &#123;</div><div class="line">        [_delegate batchRequestFailed:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//调用请求失败的block</span></div><div class="line">    <span class="keyword">if</span> (_failureCompletionBlock) &#123;</div><div class="line">        _failureCompletionBlock(<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//清空成功和失败的block</span></div><div class="line">    [<span class="keyword">self</span> clearCompletionBlock];</div><div class="line"></div><div class="line">    <span class="comment">//调用请求结束的代理</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></div><div class="line">    [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。<br>而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。</p>
<p>总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。</p>
<p>现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。</p>
<h3 id="3-32链式请求"><a href="#3-32链式请求" class="headerlink" title="3.32链式请求"></a>3.32链式请求</h3><p>和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。</p>
<p>但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//下一个请求的index</span></div><div class="line">        _nextRequestIndex = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//保存链式请求的数组</span></div><div class="line">        _requestArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        </div><div class="line">        <span class="comment">//保存回调的数组</span></div><div class="line">        _requestCallbackArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        </div><div class="line">        <span class="comment">//空回调，用来填充用户没有定义的回调block</span></div><div class="line">        _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123;</div><div class="line">            <span class="comment">// do nothing</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是它提供了添加和删除request的接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//在当前chain添加request和callback</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//保存当前请求</span></div><div class="line">    [_requestArray addObject:request];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (callback != <span class="literal">nil</span>) &#123;</div><div class="line">        [_requestCallbackArray addObject:callback];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称</span></div><div class="line">        [_requestCallbackArray addObject:_emptyCallback];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。</p>
<p>我们接着看一下链式请求的发起：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="comment">//如果第1个请求已经结束，就不再重复start了</span></div><div class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Chain request has already started."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果请求队列数组里面还有request，则取出并start</span></div><div class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line">        <span class="comment">//取出当前request并start</span></div><div class="line">        [<span class="keyword">self</span> startNextRequest];</div><div class="line">        <span class="comment">//在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain）</span></div><div class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Chain request array is empty."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，YTKChainRequest用<code>_nextRequestIndex</code>来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。</p>
<p>这里<code>startNextRequest</code>方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)startNextRequest &#123;</div><div class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</div><div class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</div><div class="line">        _nextRequestIndex++;</div><div class="line">        request.delegate = <span class="keyword">self</span>;</div><div class="line">        [request clearCompletionBlock];</div><div class="line">        [request start];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法有两个作用：</p>
<ol>
<li>第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界）</li>
<li>第二个作用是如果可以进行下一个request，则发起该request。并将<code>_nextRequestIndex</code>+1。</li>
</ol>
<p>所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。</p>
<p>现在我们知道了YTKChainRequest的发送，接下来看一下回调部分:</p>
<p>和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//某个request请求成功的代理的实现</span></div><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 取出当前的request和callback，进行回调</span></div><div class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</div><div class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</div><div class="line">    callback(<span class="keyword">self</span>, request);<span class="comment">//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面</span></div><div class="line">    </div><div class="line">    <span class="comment">//2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</div><div class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</div><div class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用<code>startNextRequest</code>方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了：</p>
<ul>
<li>如果没有了，则调用当前YTKChainRequest的最终成功的回调。</li>
<li>如果还有，则发起接下来的request（按顺序）。</li>
</ul>
<p>接下来我们再看一下某个request失败的代理的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//某个reqeust请求失败的代理</span></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFailed:failedBaseRequest:)]) &#123;</div><div class="line">        [_delegate chainRequestFailed:<span class="keyword">self</span> failedBaseRequest:request];</div><div class="line">        [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。</p>
<p>现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//终止当前的chain</span></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line"></div><div class="line">    <span class="comment">//首先调用即将停止的callback</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line"></div><div class="line">    <span class="comment">//然后stop当前的请求，再清空chain里所有的请求和回掉block</span></div><div class="line">    [<span class="keyword">self</span> clearRequest];</div><div class="line"></div><div class="line">    <span class="comment">//在YTKChainRequestAgent里移除当前的chain</span></div><div class="line">    [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line"></div><div class="line">    <span class="comment">//最后调用已经结束的callback</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>stop</code>方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用<code>clearReuqest</code>方法，将当前request停止，再将请求队列数组和callback数组清空。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearRequest &#123;</div><div class="line">    <span class="comment">//获取当前请求的index</span></div><div class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (currentRequestIndex &lt; [_requestArray count]) &#123;</div><div class="line">        YTKBaseRequest *request = _requestArray[currentRequestIndex];</div><div class="line">        [request stop];</div><div class="line">    &#125;</div><div class="line">    [_requestArray removeAllObjects];</div><div class="line">    [_requestCallbackArray removeAllObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在YTKChainRequestAgent单例里面，将自己移除掉。</p>
<h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4. 最后的话"></a>4. 最后的话</h1><hr>
<p>不知不觉写了好多，请原谅我一如既往啰嗦的风格~</p>
<p>阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。</p>
<p>我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。</p>
<p>所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。</p>
<p>希望这篇文章能对读者们有所帮助~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于iOS开发来说，就算是没有用过&lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot;&gt;YTKNetwork框架&lt;/a&gt;，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。&lt;br&gt;​&lt;br&gt;在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。&lt;/p&gt;
&lt;h1 id=&quot;1-架构&quot;&gt;&lt;a href=&quot;#1-架构&quot; class=&quot;headerlink&quot; title=&quot;1. 架构&quot;&gt;&lt;/a&gt;1. 架构&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;先上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;YTKRequest架构图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这里简单说明一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 &lt;/li&gt;
&lt;li&gt;YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。&lt;/li&gt;
&lt;li&gt;我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。&lt;/li&gt;
&lt;li&gt;YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>VVeboTableView源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/VVeboTableView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/VVeboTableView源码解析/</id>
    <published>2018-02-02T16:17:55.000Z</published>
    <updated>2018-02-02T16:17:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次分享一个关于性能优化的源码。</p>
<p>我们知道<code>UITabelView</code>在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，<code>UITabelView</code>的性能将直接影响这个app的性能。</p>
<p>如果<code>UITabelView</code>里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。</p>
<p>但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。</p>
<p>最近在看一些iOS性能优化的文章，我找到了<a href="https://github.com/johnil/VVeboTableViewDemo">VVeboTableView</a>这个框架。严格来说这个不属于框架，而是作者用自己的方式优化<code>UITableView</code>的一个实现。</p>
<p>作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？</p>
<p>看了源码之后，我把作者的思路整理了出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png" alt="优化思路图"></p>
<p>下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。</p>
<a id="more"></a>
<h2 id="1-减少CPU／GPU计算量"><a href="#1-减少CPU／GPU计算量" class="headerlink" title="1. 减少CPU／GPU计算量"></a>1. 减少CPU／GPU计算量</h2><h3 id="1-1-cell的重用机制"><a href="#1-1-cell的重用机制" class="headerlink" title="1.1 cell的重用机制"></a>1.1 cell的重用机制</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//cell重用</span></div><div class="line">    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cell==<span class="literal">nil</span>) &#123;</div><div class="line">        cell = [[VVeboTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:<span class="string">@"cell"</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制</span></div><div class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分就不赘述了，相信大家都可以掌握。</p>
<h3 id="1-2-将cell高度和-cell里的控件的frame缓存在model里"><a href="#1-2-将cell高度和-cell里的控件的frame缓存在model里" class="headerlink" title="1.2 将cell高度和 cell里的控件的frame缓存在model里"></a>1.2 将cell高度和 cell里的控件的frame缓存在model里</h3><p>这一步我们需要在字典转模型里统一计算(不需要看代码细节，只需要知道这里在模型里保存了需要保存的控件的frame和整个cell的高度即可)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadData&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> temp) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *user = dict[<span class="string">@"user"</span>];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *retweet = [dict valueForKey:<span class="string">@"retweeted_status"</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (retweet) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">            ...</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</div><div class="line">                <span class="built_in">CGSize</span> size = [subData[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_SUBCONTENT) lineSpace:<span class="number">5</span>];</div><div class="line">                <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</div><div class="line">                subData[<span class="string">@"textRect"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_BIG, width, sizeHeight)];</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                <span class="keyword">if</span> (subData[<span class="string">@"pic_urls"</span>] &amp;&amp; [subData[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</div><div class="line">                    sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</div><div class="line">                &#125;</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                subData[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            data[<span class="string">@"subData"</span>] = subData;</div><div class="line">           </div><div class="line">        </div><div class="line">            <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</div><div class="line">            <span class="built_in">CGSize</span> size = [data[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_CONTENT) lineSpace:<span class="number">5</span>];</div><div class="line">            <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</div><div class="line">            ...</div><div class="line">            sizeHeight += SIZE_GAP_TOP+SIZE_AVATAR+SIZE_GAP_BIG;</div><div class="line">            <span class="keyword">if</span> (data[<span class="string">@"pic_urls"</span>] &amp;&amp; [data[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</div><div class="line">                sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [data valueForKey:<span class="string">@"subData"</span>];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (subData) &#123;</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                <span class="built_in">CGRect</span> frame = [subData[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">                ...</div><div class="line">                sizeHeight += frame.size.height;</div><div class="line">                data[<span class="string">@"subData"</span>] = subData;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            sizeHeight += <span class="number">30</span>;</div><div class="line">            data[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</div><div class="line">        &#125;</div><div class="line">        [datas addObject:data];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取高度缓存</span></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *dict = datas[indexPath.row];</div><div class="line">    <span class="keyword">float</span> height = [dict[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>].size.height;</div><div class="line">    <span class="keyword">return</span> height;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到，作者根据帖子类型的不同：原贴(subData)的存在与否），来逐渐叠加cell的高度。</p>
<p>而缓存的控件的frame，我们在下面讲解绘制cell的代码里详细介绍。</p>
<h3 id="1-3-减少cell内部控件的层级"><a href="#1-3-减少cell内部控件的层级" class="headerlink" title="1.3 减少cell内部控件的层级"></a>1.3 减少cell内部控件的层级</h3><p>我们先来看一下一个带有原贴的转发贴的布局：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_3.png" alt="布局"></p>
<p>可能有小伙伴会将上中下这三个部分各自封装成一个view，再通过每个view来管理各自的子view。但是这个框架的作者却将它们都排列到一层上。</p>
<p>减少了子view的层级，有助于减少cpu对各种约束的计算。这在子view的数量，层级都很多的情况下对cpu的压力会减轻很多。</p>
<h3 id="1-4-通过覆盖圆角图片来实现头像的圆角效果"><a href="#1-4-通过覆盖圆角图片来实现头像的圆角效果" class="headerlink" title="1.4 通过覆盖圆角图片来实现头像的圆角效果"></a>1.4 通过覆盖圆角图片来实现头像的圆角效果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头像，frame固定</span></div><div class="line">avatarView = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];<span class="comment">//[[VVeboAvatarView alloc] initWithFrame:avatarRect];</span></div><div class="line">avatarView.frame = <span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_TOP, SIZE_AVATAR, SIZE_AVATAR);</div><div class="line">avatarView.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</div><div class="line">avatarView.hidden = <span class="literal">NO</span>;</div><div class="line">avatarView.tag = <span class="built_in">NSIntegerMax</span>;</div><div class="line">avatarView.clipsToBounds = <span class="literal">YES</span>;</div><div class="line">[<span class="keyword">self</span>.contentView addSubview:avatarView];</div><div class="line"><span class="comment">//覆盖在头像上面的图片，制造圆角效果：frame</span></div><div class="line">cornerImage = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, SIZE_AVATAR+<span class="number">5</span>, SIZE_AVATAR+<span class="number">5</span>)];</div><div class="line">cornerImage.center = avatarView.center;</div><div class="line">cornerImage.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"corner_circle@2x.png"</span>];</div><div class="line">cornerImage.tag = <span class="built_in">NSIntegerMax</span>;</div><div class="line">[<span class="keyword">self</span>.contentView addSubview:cornerImage];</div></pre></td></tr></table></figure>
<p>在这里，作者没有使用任何复杂的技术来实现图片的圆角（使用layer或者裁剪图片），只是将一张圆角颜色和cell背景色一致的图片覆盖在了原来的头像上，实现了圆角的效果（但是这个方法不太适用于有多个配色方案的app）。</p>
<h2 id="2-按需加载cell"><a href="#2-按需加载cell" class="headerlink" title="2. 按需加载cell"></a>2. 按需加载cell</h2><p>上文提到过，<code>UITableView</code>持有一个<code>needLoadArr</code>数组，它保存着需要刷新的cell的<code>NSIndexPath</code>。</p>
<p>我们先来看一下<code>needLoadArr</code>是如何使用的：</p>
<h3 id="2-1-在cellForRow-方法里只加载可见cell"><a href="#2-1-在cellForRow-方法里只加载可见cell" class="headerlink" title="2.1 在cellForRow:方法里只加载可见cell"></a>2.1 在cellForRow:方法里只加载可见cell</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    ...</div><div class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)drawCell:(VVeboTableViewCell *)cell withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSDictionary</span> *data = [datas objectAtIndex:indexPath.row];    </div><div class="line">    ...</div><div class="line">    cell.data = data;</div><div class="line">    <span class="comment">//当前的cell的indexPath不在needLoadArr里面，不用绘制</span></div><div class="line">    <span class="keyword">if</span> (needLoadArr.count&gt;<span class="number">0</span>&amp;&amp;[needLoadArr indexOfObject:indexPath]==<span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        [cell clear];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//将要滚动到顶部，不绘制</span></div><div class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//真正绘制cell的代码</span></div><div class="line">    [cell draw];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"><a href="#2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引" class="headerlink" title="2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"></a>2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引</h3><p>知道了如何使用<code>needLoadArr</code>，我们看一下<code>needLoadArr</code>里面的元素师如何添加和删除。</p>
<h4 id="添加元素NSIndexPath"><a href="#添加元素NSIndexPath" class="headerlink" title="添加元素NSIndexPath"></a>添加元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//targetContentOffset ： 停止后的contentOffset</span></div><div class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</div><div class="line">    </div><div class="line">    <span class="comment">//当前可见第一行row的index</span></div><div class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</div><div class="line">    </div><div class="line">    <span class="comment">//设置最小跨度，当滑动的速度很快，超过这个跨度时候执行按需加载</span></div><div class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//快速滑动(跨度超过了8个cell)</span></div><div class="line">    <span class="keyword">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//某个区域里的单元格的indexPath</span></div><div class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</div><div class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (velocity.y&lt;<span class="number">0</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//向上滚动</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</div><div class="line">            </div><div class="line">            <span class="comment">//超过倒数第3个</span></div><div class="line">            <span class="keyword">if</span> (indexPath.row+<span class="number">3</span>&lt;datas.count) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">1</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">3</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//向下滚动</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp firstObject];</div><div class="line">            <span class="comment">//超过正数第3个</span></div><div class="line">            <span class="keyword">if</span> (indexPath.row&gt;<span class="number">3</span>) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//添加arr里的内容到needLoadArr的末尾</span></div><div class="line">        [needLoadArr addObjectsFromArray:arr];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道了如何向<code>needLoadArr</code>里添加元素，现在看一下何时（重置）清理这个array：</p>
<h4 id="移除元素NSIndexPath"><a href="#移除元素NSIndexPath" class="headerlink" title="移除元素NSIndexPath"></a>移除元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用户触摸时第一时间加载内容</span></div><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!scrollToToping) &#123;</div><div class="line">        [needLoadArr removeAllObjects];</div><div class="line">        [<span class="keyword">self</span> loadContent];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    [needLoadArr removeAllObjects];</div><div class="line">&#125;</div><div class="line"><span class="comment">//将要滚动到顶部</span></div><div class="line">- (<span class="built_in">BOOL</span>)scrollViewShouldScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//停止滚动</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> loadContent];</div><div class="line">&#125;</div><div class="line"><span class="comment">//滚动到了顶部</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewDidScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> loadContent];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，当手指触碰到tableview时 和 开始拖动tableview的时候就要清理这个数组。</p>
<p>而且在手指触碰到tableview时和 tableview停止滚动后就会执行<code>loadContent</code>方法，用来加载可见区域的cell。</p>
<p><code>loadContent</code>方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadContent&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//正在滚动到顶部</span></div><div class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//可见cell数</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.indexPathsForVisibleRows.count&lt;=<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//触摸的时候刷新可见cell</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.visibleCells&amp;&amp;<span class="keyword">self</span>.visibleCells.count&gt;<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> temp <span class="keyword">in</span> [<span class="keyword">self</span>.visibleCells <span class="keyword">copy</span>]) &#123;</div><div class="line">            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;</div><div class="line">            [cell draw];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里注意一下，tableview的<code>visibleCells</code>属性是可见的cell的数组。</p>
<h2 id="3-异步处理cell"><a href="#3-异步处理cell" class="headerlink" title="3. 异步处理cell"></a>3. 异步处理cell</h2><p>在讲解cell是如何显示出来之前，我们大致看一下这个cell都有哪些控件：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_4.png" alt="控件名称"></p>
<p>了解到控件的名称，位置之后，我们看一下作者是如何布局这些控件的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_2.png" alt="控件布局"><br>在上面可以大致看出来，除了需要异步网络加载的头像(avatarView)和帖子图片(multiPhotoScrollView)，作者都将这些控件画在了一张图上面（postBgView）。</p>
<p>而且我们可以看到，在postBgView上面需要异步显示的内容分为四种：</p>
<ol>
<li>UIImageView：本地图片（comments, more,reposts）。</li>
<li>UIView：背景，分割线(topLine)。</li>
<li>NSString：name，from字符串。</li>
<li>Label：原贴的detailLabel 和 当前贴的 label。</li>
</ol>
<p>下面结合代码来讲解这四种绘制：</p>
<p>首先看一下cell内部的核心绘制方法：</p>
<p>现在我们来看一下cell绘制的核心方法,draw方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将cell的主要内容绘制到图片上</span></div><div class="line">- (<span class="keyword">void</span>)draw&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//drawed = YES说明正在绘制，则立即返回。因为绘制是异步的，所以在开始绘制之后需要立即设为yes，防止重复绘制</span></div><div class="line">    <span class="keyword">if</span> (drawed) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//标记当前的绘制</span></div><div class="line">    <span class="built_in">NSInteger</span> flag = drawColorFlag;</div><div class="line">    </div><div class="line">    drawed = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//获取整个cell的frame，已经换存在模型里了</span></div><div class="line">        <span class="built_in">CGRect</span> rect = [_data[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//开启图形上下文</span></div><div class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">YES</span>, <span class="number">0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//获取图形上下文</span></div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        </div><div class="line">        <span class="comment">//背景颜色</span></div><div class="line">        [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">        </div><div class="line">        <span class="comment">//通过rect填充背景颜色</span></div><div class="line">        <span class="built_in">CGContextFillRect</span>(context, rect);</div><div class="line">        </div><div class="line">        <span class="comment">//如果有原帖（说明当前贴是转发贴）</span></div><div class="line">        <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">            </div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">243</span>/<span class="number">255.0</span> green:<span class="number">243</span>/<span class="number">255.0</span> blue:<span class="number">243</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGRect</span> subFrame = [_data[<span class="string">@"subData"</span>][<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, subFrame);</div><div class="line">            </div><div class="line">            <span class="comment">//原帖上面的分割线</span></div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, subFrame.origin.y, rect.size.width, <span class="number">.5</span>));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</div><div class="line">            <span class="keyword">float</span> x = leftX;</div><div class="line">            <span class="keyword">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class="number">6</span>))/<span class="number">2</span><span class="number">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class="number">-5</span>;</div><div class="line">            </div><div class="line">            <span class="comment">//绘制名字</span></div><div class="line">            [_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</div><div class="line">                             andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                                andHeight:rect.size.height];</div><div class="line">            </div><div class="line">            <span class="comment">//绘制名字下面的info</span></div><div class="line">            y += SIZE_FONT_NAME+<span class="number">5</span>;</div><div class="line">            <span class="keyword">float</span> fromX = leftX;</div><div class="line">            <span class="keyword">float</span> size = [<span class="built_in">UIScreen</span> screenWidth]-leftX;</div><div class="line">            <span class="built_in">NSString</span> *from = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@  %@"</span>, _data[<span class="string">@"time"</span>], _data[<span class="string">@"from"</span>]];</div><div class="line">            </div><div class="line">            [from drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE)</div><div class="line">                   andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                      andHeight:rect.size.height andWidth:size];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//评论角</span></div><div class="line">            <span class="built_in">CGRect</span> countRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30</span>, [<span class="built_in">UIScreen</span> screenWidth], <span class="number">30</span>);</div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, countRect);</div><div class="line">            <span class="keyword">float</span> alpha = <span class="number">1</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">float</span> x = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT<span class="number">-10</span>;</div><div class="line">            <span class="built_in">NSString</span> *comments = _data[<span class="string">@"comments"</span>];</div><div class="line">            <span class="keyword">if</span> (comments) &#123;</div><div class="line">                <span class="built_in">CGSize</span> size = [comments sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</div><div class="line">                </div><div class="line">                x -= size.width;</div><div class="line">                </div><div class="line">                <span class="comment">//图片文字</span></div><div class="line">                [comments drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                                andFont:FontWithSize(<span class="number">12</span>)</div><div class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                              andHeight:rect.size.height];</div><div class="line">                </div><div class="line">                <span class="comment">//评论图片（bundle里的图片）</span></div><div class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div><div class="line">                </div><div class="line">                commentsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, [<span class="built_in">UIScreen</span> screenWidth]-x+<span class="number">5</span>, <span class="number">50</span>);</div><div class="line">                x -= <span class="number">20</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//转发角</span></div><div class="line">            <span class="built_in">NSString</span> *reposts = _data[<span class="string">@"reposts"</span>];</div><div class="line">            <span class="keyword">if</span> (reposts) &#123;</div><div class="line">                <span class="built_in">CGSize</span> size = [reposts sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</div><div class="line">                </div><div class="line">                x -= MAX(size.width, <span class="number">5</span>)+SIZE_GAP_BIG;</div><div class="line">                </div><div class="line">                <span class="comment">//转发文字</span></div><div class="line">                [reposts drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                                andFont:FontWithSize(<span class="number">12</span>)</div><div class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                 </div><div class="line">                             andHeight:rect.size.height];</div><div class="line">               </div><div class="line">                <span class="comment">//转发图片（bundle里的图片）</span></div><div class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_repost.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">11</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div><div class="line">                repostsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, commentsRect.origin.x-x, <span class="number">50</span>);</div><div class="line">                x -= <span class="number">20</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//更多角</span></div><div class="line">            [<span class="string">@"•••"</span> drawInContext:context</div><div class="line">                     withPosition:<span class="built_in">CGPointMake</span>(SIZE_GAP_LEFT, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                          andFont:FontWithSize(<span class="number">11</span>)</div><div class="line">                     andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">.5</span>]</div><div class="line">                        andHeight:rect.size.height];</div><div class="line">            </div><div class="line">            <span class="comment">//绘制原帖底部的分割线</span></div><div class="line">            <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">                [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">                <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30.5</span>, rect.size.width, <span class="number">.5</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//将整个contex转化为图片，赋给背景imageview</span></div><div class="line">        <span class="built_in">UIImage</span> *temp = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">if</span> (flag==drawColorFlag) &#123;</div><div class="line">                postBGView.frame = rect;</div><div class="line">                postBGView.image = <span class="literal">nil</span>;</div><div class="line">                postBGView.image = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//绘制两个label的text</span></div><div class="line">    [<span class="keyword">self</span> drawText];</div><div class="line">    </div><div class="line">    <span class="comment">//加载帖子里的网路图片，使用SDWebImage</span></div><div class="line">    [<span class="keyword">self</span> loadThumb];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面抽出每一种绘制内容的代码，分别讲解：</p>
<h3 id="3-1-异步加载网络图片"><a href="#3-1-异步加载网络图片" class="headerlink" title="3.1 异步加载网络图片"></a>3.1 异步加载网络图片</h3><p>关于网络图片的异步加载和缓存，作者使用了第三方框架：<code>SDWebImage</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setData:(<span class="built_in">NSDictionary</span> *)data&#123;</div><div class="line">    _data = data;</div><div class="line">    [avatarView setBackgroundImage:<span class="literal">nil</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    <span class="keyword">if</span> ([data valueForKey:<span class="string">@"avatarUrl"</span>]) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:[data valueForKey:<span class="string">@"avatarUrl"</span>]];</div><div class="line">        [avatarView sd_setBackgroundImageWithURL:url forState:<span class="built_in">UIControlStateNormal</span> placeholderImage:<span class="literal">nil</span> options:SDWebImageLowPriority];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于<code>SDWebImage</code>，我相信大家都不会陌生，我前一阵写了一篇源码解析，有兴趣的话可以看一下：<a href="http://www.jianshu.com/p/93696717b4a3" target="_blank" rel="external">SDWebImage源码解析</a>。</p>
<h3 id="3-2-异步绘制本地图片"><a href="#3-2-异步绘制本地图片" class="headerlink" title="3.2 异步绘制本地图片"></a>3.2 异步绘制本地图片</h3><p>本地图片的绘制，只需要提供图片在bundle内部的名字和frame就可以绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div></pre></td></tr></table></figure>
<p>###3.3  异步绘制UIView</p>
<p>对于<code>UIView</code>的绘制，我们只需要知道要绘制的<code>UIView</code>的frame和颜色即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//背景颜色</span></div><div class="line">[[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">        </div><div class="line"><span class="comment">//通过rect填充背景颜色</span></div><div class="line"><span class="built_in">CGContextFillRect</span>(context, rect);</div></pre></td></tr></table></figure>
<p>讲到现在，就剩下了关于文字的绘制，包括脱离了UILabel的纯文本的绘制和UILabel里文本的绘制，我们先说一下关于简单的纯NSString的绘制：</p>
<h3 id="3-4-异步绘制NSString"><a href="#3-4-异步绘制NSString" class="headerlink" title="3.4  异步绘制NSString"></a>3.4  异步绘制NSString</h3><p>作者通过传入字符串的字体，颜色和行高，以及位置就实现了纯文本的绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘制名字</span></div><div class="line">[_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</div><div class="line">                 andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">             andHeight:rect.size.height];</div></pre></td></tr></table></figure>
<p>这个方法是作者在<code>NSString</code>的一个分类里自定义的，我们看一下它的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)context withPosition:(<span class="built_in">CGPoint</span>)p andFont:(<span class="built_in">UIFont</span> *)font andTextColor:(<span class="built_in">UIColor</span> *)color andHeight:(<span class="keyword">float</span>)height andWidth:(<span class="keyword">float</span>)width&#123;    </div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(width, font.pointSize+<span class="number">10</span>);    </div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);    </div><div class="line">    <span class="comment">//移动坐标系统，所有点的y增加了height</span></div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,height);</div><div class="line">    </div><div class="line">    <span class="comment">//缩放坐标系统，所有点的x乘以1.0，所有的点的y乘以-1.0</span></div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//文字颜色</span></div><div class="line">    <span class="built_in">UIColor</span>* textColor = color;</div><div class="line">    </div><div class="line">    <span class="comment">//生成CTFont</span></div><div class="line">    <span class="built_in">CTFontRef</span> font1 = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)font.fontName, font.pointSize,<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//用于创建CTParagraphStyleRef的一些基本数据</span></div><div class="line">    <span class="built_in">CGFloat</span> minimumLineHeight = font.pointSize,maximumLineHeight = minimumLineHeight+<span class="number">10</span>, linespace = <span class="number">5</span>;</div><div class="line">    <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByTruncatingTail;</div><div class="line">    </div><div class="line">    <span class="comment">//左对齐</span></div><div class="line">    <span class="built_in">CTTextAlignment</span> alignment = kCTLeftTextAlignment;</div><div class="line">    </div><div class="line">    <span class="comment">//创建CTParagraphStyleRef</span></div><div class="line">    <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</div><div class="line">        &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</div><div class="line">    &#125;,<span class="number">6</span>);</div><div class="line">    <span class="comment">//设置属性字典；对象，key</span></div><div class="line">    <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</div><div class="line">                                (__bridge <span class="keyword">id</span>)font1,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</div><div class="line">                                textColor.CGColor,kCTForegroundColorAttributeName,</div><div class="line">                                style,kCTParagraphStyleAttributeName,</div><div class="line">                                <span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">//生成path，添加到cgcontex上</span></div><div class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</div><div class="line">    <span class="built_in">CGPathAddRect</span>(path,<span class="literal">NULL</span>,<span class="built_in">CGRectMake</span>(p.x, height-p.y-size.height,(size.width),(size.height)));</div><div class="line">    </div><div class="line">    <span class="comment">//生成CF属性字符串</span></div><div class="line">    <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="keyword">self</span> attributes:attributes];</div><div class="line">    <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)attributedStr;</div><div class="line">    </div><div class="line">    <span class="comment">//从attributedString拿到ctframesetter</span></div><div class="line">    <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</div><div class="line">    </div><div class="line">    <span class="comment">//从framesetter拿到 core text 的 ctframe</span></div><div class="line">    <span class="built_in">CTFrameRef</span> ctframe = <span class="built_in">CTFramesetterCreateFrame</span>(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="built_in">CFAttributedStringGetLength</span>(attributedString)),path,<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//将ctframe绘制到context里面</span></div><div class="line">    <span class="built_in">CTFrameDraw</span>(ctframe,context);</div><div class="line">    </div><div class="line">    <span class="comment">//因为不是对象类型，需要释放</span></div><div class="line">    <span class="built_in">CGPathRelease</span>(path);</div><div class="line">    <span class="built_in">CFRelease</span>(font1);</div><div class="line">    <span class="built_in">CFRelease</span>(framesetter);</div><div class="line">    <span class="built_in">CFRelease</span>(ctframe);</div><div class="line">    [[attributedStr mutableString] setString:<span class="string">@""</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//恢复context坐标系统</span></div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>, height);</div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，作者根据文字的起点，颜色，字体大小和行高，使用Core Text，将文字绘制在了传入的context上面。</p>
<h3 id="3-5-异步绘制UILabel"><a href="#3-5-异步绘制UILabel" class="headerlink" title="3.5 异步绘制UILabel"></a>3.5 异步绘制UILabel</h3><p>而对于<code>UILabel</code>里面的绘制，作者也采取了类似的方法：</p>
<p>首先看一下在cell实现文件里，关于绘制label文字方法的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将文本内容绘制到图片上，也是异步绘制</span></div><div class="line">- (<span class="keyword">void</span>)drawText&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果发现label或detailLabel不存在，则重新add一次</span></div><div class="line">    <span class="keyword">if</span> (label==<span class="literal">nil</span>||detailLabel==<span class="literal">nil</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> addLabel];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//传入frame</span></div><div class="line">    label.frame = [_data[<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">    <span class="comment">//异步绘制text</span></div><div class="line">    [label setText:_data[<span class="string">@"text"</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">//如果存在原帖</span></div><div class="line">    <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">        </div><div class="line">        detailLabel.frame = [[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">        <span class="comment">//异步绘制text</span></div><div class="line">        [detailLabel setText:[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"text"</span>]];</div><div class="line">        detailLabel.hidden = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，对于帖子而言，是否存在原贴（当前贴是否是转发贴）是不固定的，所以需要在判断之后，用<code>hidden</code>属性来控制相应控件的隐藏和显示，而不是用<code>addSubView</code>的方法。</p>
<p>这里的label是作者自己封装的<code>VVeboLabel</code>。它具有高亮显示点击，利用正则表达式区分不同类型的特殊文字（话题名，用户名，网址，emoji）的功能。</p>
<p>简单介绍一下这个封装好的label：</p>
<ul>
<li>继承于<code>UIView</code>,可以响应用户点击，在初始化之后，<code>_textAlignment</code>,<code>_textColor</code>,<code>_font</code>,<code>_lienSpace</code>属性都会被初始化。</li>
<li>使用Core Text绘制文字。</li>
<li>持有两种UIImageView，用来显示默认状态和高亮状态的图片（将字符串绘制成图片）。</li>
<li>保存了四种特殊文字的颜色，用正则表达式识别以后，给其着色。</li>
</ul>
<p>这里讲一下这个label的<code>setText:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用coretext将文本绘制到图片。</span></div><div class="line">- (<span class="keyword">void</span>)setText:(<span class="built_in">NSString</span> *)text&#123;</div><div class="line">   </div><div class="line">    <span class="comment">//labelImageView 普通状态时的imageview</span></div><div class="line">    <span class="comment">//highlightImageView 高亮状态时的iamgeview</span></div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//绘制标记，初始化时赋一个随机值；clear之后更新一个随机值</span></div><div class="line">    <span class="built_in">NSInteger</span> flag = drawFlag;</div><div class="line">    </div><div class="line">    <span class="comment">//是否正在高亮（在点击label的时候设置为yes，松开的时候设置为NO）</span></div><div class="line">    <span class="built_in">BOOL</span> isHighlight = highlighting;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSString</span> *temp = text;</div><div class="line">        _text = text;</div><div class="line">        <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.frame.size;</div><div class="line">        size.height += <span class="number">10</span>;</div><div class="line">       </div><div class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, ![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]], <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="keyword">if</span> (context==<span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]]) &#123;</div><div class="line">            [<span class="keyword">self</span>.backgroundColor set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">        <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</div><div class="line">        <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//Determine default text color</span></div><div class="line">        <span class="built_in">UIColor</span>* textColor = <span class="keyword">self</span>.textColor;</div><div class="line">        </div><div class="line">        <span class="comment">//Set line height, font, color and break mode</span></div><div class="line">        <span class="built_in">CGFloat</span> minimumLineHeight = <span class="keyword">self</span>.font.pointSize,maximumLineHeight = minimumLineHeight, linespace = <span class="keyword">self</span>.lineSpace;</div><div class="line">        </div><div class="line">        <span class="built_in">CTFontRef</span> font = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)<span class="keyword">self</span>.font.fontName, <span class="keyword">self</span>.font.pointSize,<span class="literal">NULL</span>);</div><div class="line">        <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByWordWrapping;</div><div class="line">        <span class="built_in">CTTextAlignment</span> alignment = <span class="built_in">CTTextAlignmentFromUITextAlignment</span>(<span class="keyword">self</span>.textAlignment);</div><div class="line">        <span class="comment">//Apply paragraph settings</span></div><div class="line">        <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</div><div class="line">            &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</div><div class="line">        &#125;,<span class="number">6</span>);</div><div class="line">    </div><div class="line">        <span class="comment">//属性字典</span></div><div class="line">        <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:(__bridge <span class="keyword">id</span>)font,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</div><div class="line">                                    textColor.CGColor,kCTForegroundColorAttributeName,</div><div class="line">                                    style,kCTParagraphStyleAttributeName,</div><div class="line">                                    <span class="literal">nil</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//拿到CFAttributedStringRef</span></div><div class="line">        <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:text attributes:attributes];</div><div class="line">        <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)[<span class="keyword">self</span> highlightText:attributedStr];</div><div class="line">        </div><div class="line">        <span class="comment">//根据attributedStringRef 获取CTFramesetterRef</span></div><div class="line">        <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</div><div class="line">        </div><div class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">5</span>,(size.width),(size.height<span class="number">-5</span>));</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//根据 framesetter 和 attributedString 绘制text</span></div><div class="line">            [<span class="keyword">self</span> drawFramesetter:framesetter attributedString:attributedStr textRange:<span class="built_in">CFRangeMake</span>(<span class="number">0</span>, text.length) inRect:rect context:context];</div><div class="line">            </div><div class="line">            <span class="comment">//恢复context</span></div><div class="line">            <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">            <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</div><div class="line">            <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">            </div><div class="line">            <span class="comment">//截取当前图片</span></div><div class="line">            <span class="built_in">UIImage</span> *screenShotimage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">            <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                </div><div class="line">                <span class="built_in">CFRelease</span>(font);</div><div class="line">                <span class="built_in">CFRelease</span>(framesetter);</div><div class="line">                [[attributedStr mutableString] setString:<span class="string">@""</span>];</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (drawFlag==flag) &#123;</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (isHighlight) &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//高亮状态：把图片付给highlightImageView</span></div><div class="line">                        <span class="keyword">if</span> (highlighting) &#123;</div><div class="line">                            highlightImageView.image = <span class="literal">nil</span>;</div><div class="line">                            <span class="keyword">if</span> (highlightImageView.width!=screenShotimage.size.width) &#123;</div><div class="line">                                highlightImageView.width = screenShotimage.size.width;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (highlightImageView.height!=screenShotimage.size.height) &#123;</div><div class="line">                                highlightImageView.height = screenShotimage.size.height;</div><div class="line">                            &#125;</div><div class="line">                            highlightImageView.image = screenShotimage;</div><div class="line">                        &#125;</div><div class="line">                    </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//非高亮状态，把图片付给labelImageView</span></div><div class="line">                        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</div><div class="line">                            <span class="keyword">if</span> (labelImageView.width!=screenShotimage.size.width) &#123;</div><div class="line">                                labelImageView.width = screenShotimage.size.width;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (labelImageView.height!=screenShotimage.size.height) &#123;</div><div class="line">                                labelImageView.height = screenShotimage.size.height;</div><div class="line">                            &#125;</div><div class="line">                            highlightImageView.image = <span class="literal">nil</span>;</div><div class="line">                            labelImageView.image = <span class="literal">nil</span>;</div><div class="line">                            labelImageView.image = screenShotimage;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"><span class="comment">//                    [self debugDraw];//绘制可触摸区域</span></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个被作者封装好的Label里面还有很多其他的方法，比如用正则表达式高亮显示特殊字符串等等。</p>
<p>关于tableView的优化，作者做了很多处理，使得这种显示内容比较丰富的cell在4s真机上好不卡顿，非常值得学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次分享一个关于性能优化的源码。&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;UITabelView&lt;/code&gt;在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，&lt;code&gt;UITabelView&lt;/code&gt;的性能将直接影响这个app的性能。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;UITabelView&lt;/code&gt;里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。&lt;/p&gt;
&lt;p&gt;但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。&lt;/p&gt;
&lt;p&gt;最近在看一些iOS性能优化的文章，我找到了&lt;a href=&quot;https://github.com/johnil/VVeboTableViewDemo&quot;&gt;VVeboTableView&lt;/a&gt;这个框架。严格来说这个不属于框架，而是作者用自己的方式优化&lt;code&gt;UITableView&lt;/code&gt;的一个实现。&lt;/p&gt;
&lt;p&gt;作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;看了源码之后，我把作者的思路整理了出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png&quot; alt=&quot;优化思路图&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/SDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/SDWebImage源码解析/</id>
    <published>2018-02-02T16:17:50.000Z</published>
    <updated>2018-02-02T16:17:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信对于广大的iOS开发者，对<a href="https://github.com/rs/SDWebImage">SDWebImage</a>并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。</p>
<p>在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>] placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>] completed:^(<span class="built_in">UIImage</span> * _Nullable image, <span class="built_in">NSError</span> * _Nullable error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> * _Nullable imageURL) &#123;</div><div class="line">        </div><div class="line">        imageview.image = image;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图片加载完成"</span>);</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//图片下载完成后直接显示下载后的图片</span></div><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>]];</div></pre></td></tr></table></figure>
<p>在最开始先简单介绍这个框架：</p>
<p>这个框架的核心类是<code>SDWebImageManger</code>，在外部有<code>UIImageView+WebCache</code> 和 <code>UIButton+WebCache</code> 为下载图片的操作提供接口。内部有<code>SDWebImageManger</code>负责处理和协调 <code>SDWebImageDownloader</code> 和 <code>SDWebImageCache</code>：<code>SDWebImageDownloader</code>负责具体的下载任务，<code>SDWebImageCache</code>负责关于缓存的工作：添加，删除，查询缓存。</p>
<p>首先我们大致看一下这个框架的调用流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage"></p>
<p>从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。</p>
<p>OK～基本流程大概清楚了，我们看一下每个层具体实现吧～</p>
<a id="more"></a>
<hr>
<p>##UIKit层</p>
<p>该框架最外层的类是<code>UIImageView +WebCache</code>，我们将图片的URL，占位图片直接给这个类。下面是这个类的公共接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  UIImageView + WebCache.h ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>可以看出，这个类提供的接口非常灵活，可以根据我们自己的需求来调用其中某一个方法，而这些方法到最后都会走到：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>而这个方法里面，调用的是<code>UIView+WebCache</code>分类的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</div><div class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么不是UIImageView+WebCache而要上一层到UIView的分类里呢？<br>因为SDWebImage框架也支持UIButton的下载图片等方法，所以需要在它们的父类：UIView里面统一一个下载方法。</p>
</blockquote>
<p>简单看一下这个方法的实现（省略的代码用…代替）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line"></div><div class="line">   <span class="comment">//valid key：UIImageView || UIButton</span></div><div class="line">   <span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</div><div class="line">   <span class="comment">//UIView+WebCacheOperation 的 operationDictionary</span></div><div class="line">   <span class="comment">//下面这行代码是保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突</span></div><div class="line">   [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</div><div class="line">   </div><div class="line"></div><div class="line">   <span class="comment">//添加临时的占位图（在不延迟添加占位图的option下）</span></div><div class="line">   <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">       &#125;);</div><div class="line">   &#125;    </div><div class="line">   <span class="comment">//如果url存在</span></div><div class="line">   <span class="keyword">if</span> (url) &#123;     </div><div class="line">      ...</div><div class="line">       __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">      <span class="comment">//SDWebImageManager下载图片</span></div><div class="line">       <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">         </div><div class="line">           ...</div><div class="line">           <span class="comment">//dispatch_main_sync_safe : 保证block能在主线程进行</span></div><div class="line">           dispatch_main_async_safe(^&#123;</div><div class="line">               </div><div class="line">               <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;               </div><div class="line">               <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">                    <span class="comment">//image，而且不自动替换 placeholder image</span></div><div class="line">                   completedBlock(image, error, cacheType, url);</div><div class="line">                   <span class="keyword">return</span>;                    </div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                   <span class="comment">//存在image，需要马上替换 placeholder image</span></div><div class="line">                   [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                   [sself sd_setNeedsLayout];                </div><div class="line">               &#125; <span class="keyword">else</span> &#123;                    </div><div class="line">                   <span class="comment">//没有image，在图片下载完之后显示 placeholder image</span></div><div class="line">                   <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                       [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                       [sself sd_setNeedsLayout];</div><div class="line">                   &#125;</div><div class="line">               &#125;                </div><div class="line">               <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                   completedBlock(image, error, cacheType, url);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;];</div><div class="line">       </div><div class="line">       <span class="comment">//在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行</span></div><div class="line">       [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];        </div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">//如果url不存在，就在completedBlock里传入error（url为空）</span></div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           [<span class="keyword">self</span> sd_removeActivityIndicator];</div><div class="line">           <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">               <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">               completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，在这一层，使用一个字典<code>operationDictionary</code>专门用作存储操作的缓存，随时添加，删除操作任务。<br>而这个字典是<code>UIView+WebCacheOperation</code>分类的关联对象，它的存取方法使用运行时来操作：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  UIView+WebCacheOperation.m ============== //</span></div><div class="line"> <span class="comment">//获取关联对象：operations（用来存放操作的字典）</span></div><div class="line">- (SDOperationsDictionary *)operationDictionary &#123;</div><div class="line">    SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line">    <span class="comment">//存放操作的字典</span></div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">return</span> operations;</div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//如果没有，就新建一个</span></div><div class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];    </div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    <span class="keyword">return</span> operations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么不直接在<code>UIImageView+WebCache</code>里直接关联这个对象呢？我觉得这里作者应该是遵从面向对象的<strong>单一职责原则（SRP：Single responsibility principle）</strong>，就连类都要履行这个职责，何况分类呢？这里作者专门创造一个分类<code>UIView+WebCacheOperation</code>来管理操作缓存（字典）。</p>
</blockquote>
<p>到这里，<code>UIKit</code>层上面的东西都讲完了，现在开始正式讲解工具层。</p>
<h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>上文提到过，<code>SDWebImageManager</code>同时管理<code>SDImageCache</code>和<code>SDWebImageDownloader</code>两个类，它是这一层的<strong>老大哥</strong>。在下载任务开始的时候，<code>SDWebImageManager</code>首先访问<code>SDImageCache</code>来查询是否存在缓存，如果有缓存，直接返回缓存的图片。如果没有缓存，就命令<code>SDWebImageDownloader</code>来下载图片，下载成功后，存入缓存，显示图片。以上是<code>SDWebImageManager</code>大致的工作流程。</p>
<p>在详细讲解<code>SDWebImageManager</code>是如何下载图片之前，我们先看一下这个类的几个重要的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageManager.h ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDImageCache *imageCache;<span class="comment">//管理缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDWebImageDownloader <span class="comment">//下载器*imageDownloader;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSURL</span> *&gt; *failedURLs;<span class="comment">//记录失效url的名单</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDWebImageCombinedOperation *&gt; *runningOperations;<span class="comment">//记录当前正在执行的操作</span></div></pre></td></tr></table></figure>
<p><code>SDWebImageManager</code>下载图片的方法只有一个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SDWebImageManager.sharedManager loadImageWithURL:options:progress:completed:]</div></pre></td></tr></table></figure>
<p>看一下这个方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageManager.m ============== //</span></div><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">     ...                             </div><div class="line">    <span class="comment">//在SDImageCache里查询是否存在缓存的图片</span></div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;        </div><div class="line">        ...</div><div class="line">        <span class="comment">//（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片） || （代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片）</span></div><div class="line">        <span class="keyword">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;            </div><div class="line">            <span class="comment">//1. 存在缓存图片 &amp;&amp; 即使有缓存图片也要下载更新图片</span></div><div class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 2. 如果不存在缓存图片</span></div><div class="line">            ...            </div><div class="line">            <span class="comment">//开启下载器下载</span></div><div class="line">            <span class="comment">//subOperationToken 用来标记当前的下载任务，便于被取消</span></div><div class="line">            SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// 1. 如果任务被取消，则什么都不做，避免和其他的completedBlock重复</span></div><div class="line">                </div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//2. 如果有错误</span></div><div class="line">                    <span class="comment">//2.1 在completedBlock里传入error</span></div><div class="line">                    [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url];</div><div class="line"></div><div class="line">							<span class="comment">//2.2 在错误url名单中添加当前的url</span></div><div class="line">                    <span class="keyword">if</span> (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</div><div class="line">                        </div><div class="line">                       <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs addObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//3. 下载成功</span></div><div class="line">                    <span class="comment">//3.1 如果需要下载失败后重新下载，则将当前url从失败url名单里移除</span></div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="comment">//3.2 进行缓存</span></div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);                   </div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                    </div><div class="line">                        <span class="comment">//（即使缓存存在，也要刷新图片） &amp;&amp; 缓存图片 &amp;&amp; 不存在下载后的图片：不做操作</span></div><div class="line">                                           </div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        </div><div class="line">          <span class="comment">//（下载图片成功 &amp;&amp; （没有动图||处理动图） &amp;&amp; （下载之后，缓存之前处理图片）               dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span></div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">                                <span class="comment">//缓存图片</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//将图片传入completedBlock</span></div><div class="line">                            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                        &#125;);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//(图片下载成功并结束)</span></div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">					 <span class="comment">//如果完成，从当前运行的操作列表里移除当前操作</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">            <span class="comment">//取消的block</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">            </div><div class="line">                <span class="comment">//取消当前的token</span></div><div class="line">                [<span class="keyword">self</span>.imageDownloader cancel:subOperationToken];</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="comment">//从当前运行的操作列表里移除当前操作</span></div><div class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            &#125;;</div><div class="line">        </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//存在缓存图片</span></div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;            </div><div class="line">            <span class="comment">//调用完成的block</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];            </div><div class="line">            <span class="comment">//删去当前的的下载操作（线程安全）</span></div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];        </div><div class="line">        &#125; <span class="keyword">else</span> &#123;            </div><div class="line">            <span class="comment">//没有缓存的图片，而且下载被代理终止了</span></div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">           </div><div class="line">            <span class="comment">// 调用完成的block</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:<span class="literal">YES</span> url:url];            </div><div class="line">            <span class="comment">//删去当前的下载操作</span></div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;                                                             </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完了<code>SDWebImageManager</code>的回调处理，我们分别看一下<br><code>SDImageCache</code>和<code>SDWebImageDownloader</code>内部具体是如何工作的。首先看一下<code>SDImageCache</code>：</p>
<h3 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSCache</span> *memCache;<span class="comment">//内存缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;<span class="comment">//磁盘缓存路径</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;<span class="comment">//</span></div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> <span class="comment">//ioQueue唯一子线程;</span></div></pre></td></tr></table></figure>
<h4 id="核心方法：查询缓存"><a href="#核心方法：查询缓存" class="headerlink" title="核心方法：查询缓存"></a>核心方法：查询缓存</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;   </div><div class="line">    <span class="keyword">if</span> (!key) &#123;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;		</div><div class="line">    <span class="comment">//================查看内存的缓存=================//</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];    </div><div class="line">    <span class="comment">// 如果存在，直接调用block，将image，data，CaheType传进去</span></div><div class="line">    <span class="keyword">if</span> (image) &#123;    </div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;        </div><div class="line">        <span class="comment">//如果是gif，就拿到data，后面要传到doneBlock里。不是gif就传nil</span></div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;        </div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//因为图片有缓存可供使用，所以不用实例化NSOperation，直接范围nil</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//================查看磁盘的缓存=================//</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];    </div><div class="line">    <span class="comment">//唯一的子线程：self.ioQueue</span></div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;        </div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// 在用之前就判断operation是否被取消了，作者考虑的非常严谨</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;            </div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];            </div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                  <span class="comment">// cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。</span></div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);                </div><div class="line">                <span class="comment">//存入内存缓存中</span></div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;<span class="comment">//下载队列</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *lastAddedOperation;<span class="comment">//最后添加的下载操作</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) Class operationClass;<span class="comment">//操作类</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, SDWebImageDownloaderOperation *&gt; *URLOperations;<span class="comment">//操作数组</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDHTTPHeadersMutableDictionary *HTTPHeaders;<span class="comment">//HTTP请求头</span></div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;<span class="comment">//用来阻塞前面的下载线程（串行化）</span></div></pre></td></tr></table></figure>
<h4 id="核心方法：下载图片"><a href="#核心方法：下载图片" class="headerlink" title="核心方法：下载图片"></a>核心方法：下载图片</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        </div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">        </div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">        </div><div class="line">        <span class="comment">//创建下载请求</span></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//创建下载操作：SDWebImageDownloaderOperation用于请求网络资源的操作，它是一个 NSOperation 的子类</span></div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="comment">//url证书</span></div><div class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//优先级</span></div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//在下载队列里添加下载操作，执行下载操作</span></div><div class="line">        [sself.downloadQueue addOperation:operation];</div><div class="line">        </div><div class="line">        <span class="comment">//如果后进先出</span></div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            <span class="comment">//addDependency:参数opertaion倍添加到NSOperationQueue后，只有等该opertion结束后才能执行其他的operation，实现了后进先出</span></div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面还有一个<code>addProgressCallback: progressBlock: completedBlock: forURL: createCallback:</code>方法，用来保存<code>progressBlock</code>和<code>completedBlock</code>。我们看一下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123;</div><div class="line"></div><div class="line">    <span class="comment">// url 用来作为回调字典的key，如果为空，立即返回失败 </span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    __block SDWebImageDownloadToken *token = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">//串行化前面所有的操作</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;    </div><div class="line">        	<span class="comment">//当前下载操作中取出SDWebImageDownloaderOperation实例</span></div><div class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];        </div><div class="line">        <span class="keyword">if</span> (!operation) &#123;</div><div class="line">        <span class="comment">//如果没有，就初始化它</span></div><div class="line">            operation = createCallback();</div><div class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</div><div class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            </div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</div><div class="line">              <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</div><div class="line">                  [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">              &#125;;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">        <span class="comment">//这里 downloadOperationCancelToken 默认是一个字典，存放 progressBlock 和 completedBlock</span></div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里真正保存两个block的方法是<code>addHandlersForProgress: completed:</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    <span class="comment">//实例化一个SDCallbacksDictionary，存放一个progressBlock 和 completedBlock</span></div><div class="line">    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">    dispatch_barrier_async(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        <span class="comment">//添加到缓存中 self.callbackBlocks</span></div><div class="line">        [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里<code>SDWebImage</code>的核心方法都讲解完毕了，其他没有讲到的部分以后会慢慢添加上去。</p>
<h2 id="最后看一下一些比较零散的知识点："><a href="#最后看一下一些比较零散的知识点：" class="headerlink" title="最后看一下一些比较零散的知识点："></a>最后看一下一些比较零散的知识点：</h2><hr>
<h4 id="1-运行时存取关联对象："><a href="#1-运行时存取关联对象：" class="headerlink" title="1. 运行时存取关联对象："></a>1. 运行时存取关联对象：</h4><p><strong>存：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"><span class="comment">//将operations对象关联给self，地址为&amp;loadOperationKey，语义是OBJC_ASSOCIATION_RETAIN_NONATOMIC。</span></div></pre></td></tr></table></figure>
<p><strong>取：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line"><span class="comment">//将operations对象通过地址&amp;loadOperationKey从self里取出来</span></div></pre></td></tr></table></figure>
<h4 id="2-数组的写操作需要加锁（多线程访问，避免覆写）"><a href="#2-数组的写操作需要加锁（多线程访问，避免覆写）" class="headerlink" title="2. 数组的写操作需要加锁（多线程访问，避免覆写）"></a>2. 数组的写操作需要加锁（多线程访问，避免覆写）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给self.runningOperations加锁</span></div><div class="line"><span class="comment">//self.runningOperations数组的添加操作</span></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div><div class="line"><span class="comment">//self.runningOperations数组的删除操作</span></div><div class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        <span class="keyword">if</span> (operation) &#123;</div><div class="line">            [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-确保在主线程的宏："><a href="#3-确保在主线程的宏：" class="headerlink" title="3. 确保在主线程的宏："></a>3. 确保在主线程的宏：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_main_async_safe(^&#123;</div><div class="line"> 				 <span class="comment">//将下面这段代码放在主线程中</span></div><div class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line"><span class="comment">//宏定义：</span></div><div class="line"><span class="meta">#define dispatch_main_async_safe(block)\</span></div><div class="line">    <span class="keyword">if</span> (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == <span class="number">0</span>) &#123;\</div><div class="line">        block();\</div><div class="line">    &#125; <span class="keyword">else</span> &#123;\</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), block);\</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<h4 id="4-设置不能为nil的参数"><a href="#4-设置不能为nil的参数" class="headerlink" title="4. 设置不能为nil的参数"></a>4. 设置不能为nil的参数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        _imageCache = cache;</div><div class="line">        _imageDownloader = downloader;</div><div class="line">        _failedURLs = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">        _runningOperations = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果在参数里添加了nonnull关键字，那么编译器就可以检查传入的参数是否为nil，如果是，则编译器会有警告</p>
</blockquote>
<h4 id="5-容错，强制转换类型"><a href="#5-容错，强制转换类型" class="headerlink" title="5. 容错，强制转换类型"></a>5. 容错，强制转换类型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</div><div class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在传入的参数为NSString时（但是方法参数要求是NSURL），自动转换为NSURL</p>
</blockquote>
<hr>
<p>貌似还有图片解码等内容没有详细看，以后会逐渐补充哒～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信对于广大的iOS开发者，对&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。&lt;/p&gt;
&lt;p&gt;在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;] placeholderImage:[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;placeholder&quot;&lt;/span&gt;] completed:^(&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; * _Nullable image, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nullable error, SDImageCacheType cacheType, &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; * _Nullable imageURL) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        imageview.image = image;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;图片加载完成&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//图片下载完成后直接显示下载后的图片&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;]];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在最开始先简单介绍这个框架：&lt;/p&gt;
&lt;p&gt;这个框架的核心类是&lt;code&gt;SDWebImageManger&lt;/code&gt;，在外部有&lt;code&gt;UIImageView+WebCache&lt;/code&gt; 和 &lt;code&gt;UIButton+WebCache&lt;/code&gt; 为下载图片的操作提供接口。内部有&lt;code&gt;SDWebImageManger&lt;/code&gt;负责处理和协调 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 和 &lt;code&gt;SDWebImageCache&lt;/code&gt;：&lt;code&gt;SDWebImageDownloader&lt;/code&gt;负责具体的下载任务，&lt;code&gt;SDWebImageCache&lt;/code&gt;负责关于缓存的工作：添加，删除，查询缓存。&lt;/p&gt;
&lt;p&gt;首先我们大致看一下这个框架的调用流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SDWebImage&quot;&gt;&lt;/p&gt;
&lt;p&gt;从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。&lt;/p&gt;
&lt;p&gt;OK～基本流程大概清楚了，我们看一下每个层具体实现吧～&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PNChart源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/PNChart%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/PNChart源码解析/</id>
    <published>2018-02-02T16:17:45.000Z</published>
    <updated>2018-02-02T16:17:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一. 框架介绍"></a>一. 框架介绍</h2><p><a href="https://github.com/kevinzhow/PNChart">PNChart</a>是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。</p>
<p>该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类<code>PNGenericChart</code>,第二层就是所有类型的图表。提供一张图来直观感受一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png" alt="层级图"></p>
<blockquote>
<p>在这张图里，需要注意以下几点：</p>
<ol>
<li>带箭头的线和不带箭头的线的区别。</li>
<li><code>Data</code>类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有<code>Data</code>类，因为饼状图没有多组数据，而折线图<code>LineChart</code>是支持多组数据的，所以有<code>Data</code>类。</li>
<li><code>Item</code>类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。</li>
<li><code>BarChart</code>类里面的每一根柱子都是<code>PNBar</code>的实例（该类型的图表不在本篇讲解的范围之内）。</li>
</ol>
</blockquote>
<a id="more"></a>
<p>今天就来介绍一下该框架里的折线图的源码。上文提到过，该框架的折线图是支持多组数据的，也就是在同一张图表上显示多条折线。先带大家看一下效果图：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_2.png" alt="折线图"></p>
<p>折线图在效果上还是很简洁美观的，如果现在的你还不知道如何使用<code>CAShapeLayer</code>和<code>UIBezierPath</code>画图并附加动画效果，那么本篇源码解析非常适合你。</p>
<p>阅读本文之后，你可以掌握有关图形绘制的相关知识，也可以掌握自定义各种图形（<code>UIView</code>）的方法，而且你也应该有能力作出这样的图表，甚至更好！</p>
<p>在开始讲解之前，我先粗略介绍一下利用<code>CAShapeLayer</code>画图的过程。这个过程有三个大前提：</p>
<ul>
<li>因为<code>UIView</code>是对<code>CALayer</code>的封装，所以我们可以通过改变<code>UIView</code>所持有的<code>layer</code>属性来直接改变<code>UIView</code>的显示效果。</li>
<li><code>CAShapeLayer</code>是<code>CALayer</code>的子类。</li>
<li><code>CAShapeLayer</code>的使用是依赖于<code>UIBezierPath</code>的。<code>UIBezierPath</code>就是“路径”，可以理解为形状。不难理解，想象一下，如果我们想画一个图形，那么这个图形的形状（包括颜色）是必不可少的，而这个角色，就需要<code>UIBezierPath</code>来充当。</li>
</ul>
<p>那么了这三个大前提，我们就可以知道如何画图了：</p>
<ol>
<li>实例化一个<code>UIBezierPath</code>，并赋给<code>CAShapeLayer</code>实例的<code>path</code>属性。</li>
<li>将这个<code>CAShapeLayer</code>的实例添加到<code>UIView</code>的<code>layer</code>上。</li>
</ol>
<p>简单的代码演示上述过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">...自定义path...</div><div class="line"><span class="built_in">CAShapeLayer</span> *shapLayer = [<span class="built_in">CAShapeLayer</span> alloc] init];</div><div class="line">shapLayer.path = path;</div><div class="line">[<span class="keyword">self</span>.view.layer addSubLayer:shapeLayer];</div></pre></td></tr></table></figure></p>
<p>现在大致了解了画图的过程，我们来看一下该框架的作者是如何实现一个折线图的吧！</p>
<h2 id="二-源码解析"><a href="#二-源码解析" class="headerlink" title="二. 源码解析"></a>二. 源码解析</h2><p>首先看一下整个绘制折线图的步骤：</p>
<ol>
<li>图表的初始化。</li>
<li>获取横轴和纵轴的数据。</li>
<li>计算折线上所有拐点的x，y值。</li>
<li>计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）。</li>
<li>生成每个拐点上面的Label（可有可无）。</li>
<li>计算每条线段的贝塞尔曲线（UIBezierPath）。</li>
<li>将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</li>
<li>绘制所有折线（所有线段+所有圆圈）。</li>
<li>添加动画(可有可无)。</li>
<li>绘制x，y坐标轴。</li>
</ol>
<p>在集合代码具体讲解之前，我们要清楚三点（非常非常重要）：</p>
<ol>
<li>此折线图框架是可以设置拐点的样式的:可以设置为没有样式，也可以设置有样式：圆圈，方块，三角形。<ul>
<li>如果没有样式，则是简单的线段与线段的连接，在拐点处没有任何其他控件。</li>
<li>如果是有样式的，那么这条折线里的每条线段（在本篇文章里统一说成线段）之间是<strong>分离的</strong>，因为线段中间有一个拐点控件。本篇文章介绍的是圆圈样式（如上图所示，拐点控件是一个圆圈）。</li>
</ul>
</li>
<li>上文提到过，该折线图框架可以在一张图表里同时显示多条折线，也就是可以设置多组数据（一条折线对应一组数据）。因此，上面的3，4，5，6，7项都是用各自不同的一个数组保存的，数组里的每一个元素对应一条折线的数据。</li>
<li>既然同一个张图表可以显示多条折线：<ul>
<li>那么有些属性就是这些折线共有的，比如横坐标的value，这些属性保存在<code>PNLineChart</code>的实例里面。</li>
<li>有些属性是每条折线私有的，比如每条折线的颜色，纵坐标value等等，这些属性保存在<code>PNLineChartData</code>里面。每一条折线对应一个<code>PNLineChartData</code>实例。这些实例汇总到一个数组里面，这个数组由<code>PNLineChart</code>的实例管理。</li>
</ul>
</li>
</ol>
<p>在充分了解了这三点之后，我们结合一下代码来看一下具体的实现：</p>
<h3 id="1-图表的初始化"><a href="#1-图表的初始化" class="headerlink" title="1. 图表的初始化"></a>1. 图表的初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> setupDefaultValues];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setupDefaultValues &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> setupDefaultValues];</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//四个内边距</span></div><div class="line">    _chartMarginLeft = <span class="number">25.0</span>;</div><div class="line">    _chartMarginRight = <span class="number">25.0</span>;</div><div class="line">    _chartMarginTop = <span class="number">25.0</span>;</div><div class="line">    _chartMarginBottom = <span class="number">25.0</span>;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//真正绘制图表的画布（CavanWidth）的宽高</span></div><div class="line">    _chartCavanWidth = <span class="keyword">self</span>.frame.size.width - _chartMarginLeft - _chartMarginRight;</div><div class="line">    _chartCavanHeight = <span class="keyword">self</span>.frame.size.height - _chartMarginBottom - _chartMarginTop;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>上面这段代码我刻意省去了其他一些基本的设置，突出了图表布局的设置。</p>
<p>布局的设置是图表绘制的前提，因为在最开始的时候，就应该计算出“画布”，也就是图表内容（不包括坐标轴和坐标label）的具体大小和位置（内边距以内的部分）。</p>
<p>在这里，我们需要获取真正绘制图表的画布的宽高(<code>_chartCavanWidth</code>和<code>_chartCavanHeight</code>)。而且，要留意的是<code>_chartMarginLeft</code>在将来是要用作y轴Label的宽度，而<code>_chartMarginBottom</code>在将来是要用作x轴Label的高度的。</p>
</blockquote>
<p>用一张图直观看一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_4.png" alt="整个控件的大小和画布的大小"></p>
<h3 id="2-获取横轴和纵轴的数据"><a href="#2-获取横轴和纵轴的数据" class="headerlink" title="2. 获取横轴和纵轴的数据"></a>2. 获取横轴和纵轴的数据</h3><p>现在画布的位置和大小确定了，我们可以来看一下折线图是怎么画的了。<br>整个图表的绘制都基于三组数据（也可以是两组，为什么是两组，我稍后会给出解释），在讲解该框架是如何利用这些数据之前，我们来看一下这些数据是如何传进图表的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//设置x轴的数据</span></div><div class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</div><div class="line"><span class="comment">//设置y轴的数据</span></div><div class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</div><div class="line">                             <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</div><div class="line">                             ]</div><div class="line"> ];</div><div class="line"><span class="comment">// Line Chart</span></div><div class="line"><span class="comment">//设置每个点的y值</span></div><div class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</div><div class="line">PNLineChartData *data = [PNLineChartData new];</div><div class="line">data.pointLabelColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">data.color = PNTwitterColor;</div><div class="line">data.alpha = <span class="number">0.5</span>f;</div><div class="line">data.itemCount = dataArray.count;</div><div class="line">data.inflexionPointStyle = PNLineChartPointStyleCircle;</div><div class="line"><span class="comment">//这个block的作用是将上面的dataArray里的每一个值传给line chart。</span></div><div class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</div><div class="line">    <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</div><div class="line">    <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</div><div class="line">&#125;;</div><div class="line"><span class="comment">//因为只有一条折线，所以只有一组数据</span></div><div class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</div><div class="line"><span class="comment">//绘制图表</span></div><div class="line">[<span class="keyword">self</span>.lineChart strokeChart];</div><div class="line"><span class="comment">//设置代理，响应点击</span></div><div class="line"><span class="keyword">self</span>.lineChart.delegate = <span class="keyword">self</span>;</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.lineChart];</div></pre></td></tr></table></figure>
<p>上面的代码我可以略去了很多多余的设置，目的是突出图表数据的设置。</p>
<p>不难看出，这里有三个数据传给了lineChart：</p>
<p>1.x轴的数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码调用之后，实现了：</p>
<ol>
<li>根据传入的xLabel数组里元素的数量，内容宽度(<code>_chartCavanWidth</code>)和下边距（<code>_chartMarginBottom</code>），计算每个xlabel的size。</li>
<li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的xLabel（包括内容，位置）并显示出来，最后保存在<code>_xChartLabels</code>里面。</li>
</ol>
</blockquote>
<p>2.y轴的数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</div><div class="line">                <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</div><div class="line">                ]</div><div class="line">    ];</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码调用之后，实现了：</p>
<ol>
<li>根据传入的yLabel数组里元素的数量，内容高度(<code>_chartCavanHeight</code>)和左边距(<code>_chartMarginLeft</code>)，计算出每个ylabel的size。</li>
<li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的yLabel（包括内容，位置）并显示出来，最后保存在<code>_yChartLabels</code>里面。</li>
</ol>
</blockquote>
<p>3.一条折线上每个点的实际值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</div><div class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</div><div class="line">        <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</div><div class="line">        <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</div><div class="line">    &#125;;</div><div class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</div></pre></td></tr></table></figure>
<blockquote>
<p>着重讲一下block：为什么不直接把这个数组(<code>dataArray</code>)作为line chart的属性传进去呢？我认为作者是想提供一个接口给用户一个自己转化y值的机会。</p>
<p>像上文所说的，这里1，2是属于<code>lineChart</code>的数据，它适用于这张图表上所有的折线的。而3是属于某一条折线的。</p>
<p>现在回答一下为什么可以只传入两组数据：因为y轴数据可以由每个点的实际值数组得出。可以简单想一下，我们可以获取这些真实值里面的最大值，然后将它n等分，就自然得到了y轴数据了。</p>
</blockquote>
<p>我们已经布局了x轴和y轴的所有label，现在开始真正计算图表的数据了。</p>
<blockquote>
<p>注意：下面要介绍的3，4，5，6项都是在同一方法中计算出来，为了避免代码过长，我将每个部分分解开来做出解释。因为在同一方法里，所以这些涉及到for循环的语句是一致的。</p>
<p>整个图表的绘制都是依赖于数据的处理，所以3，4，5，6项也是理解该框架的一个关键！</p>
</blockquote>
<p>首先，我们需要计算每个数据点（拐点）的准确位置：</p>
<h3 id="3-计算折线上所有拐点的x，y值。"><a href="#3-计算折线上所有拐点的x，y值。" class="headerlink" title="3. 计算折线上所有拐点的x，y值。"></a>3. 计算折线上所有拐点的x，y值。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="comment">//还记得chartData属性么？它是用来保存多组折线的数据的，在这里只有一个折线，所以这个循环只循环一次）</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">   <span class="comment">//保存每条折线上的所有点的CGPoint  </span></div><div class="line">   <span class="built_in">NSMutableArray</span> *linePointsArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    <span class="comment">//遍历每条折线里的每个点    </span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//传入index，获取y值(调用的是上文提到的block)</span></div><div class="line">        yValue = chartData.getData(i).y;</div><div class="line">        <span class="comment">//当前点的x： _chartMarginLeft + _xLabelWidth / 2.0为0坐标，每多一个点就多一个_xLabelWidth</span></div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) (i * _xLabelWidth + _chartMarginLeft + _xLabelWidth / <span class="number">2.0</span>);</div><div class="line">            </div><div class="line">        <span class="comment">//当前点的y：根据当前点的值和当前点所在的数组里的最大值的比例 以及 图表的总高度，算出当前点在图表里的y坐标</span></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>)[<span class="keyword">self</span> yValuePositionInLineChart:yValue];</div><div class="line">        <span class="comment">//保存所有拐点的坐标</span></div><div class="line">        [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//保存多条折线的CGPoint（这里只有一条折线，所以该数组只有一个元素）</span></div><div class="line">  [pathPoints addObject:[linePointsArray <span class="keyword">copy</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里需要注意两点：</p>
<ol>
<li>这里的<code>pathPoints</code>对应的是<code>lineChart</code>的<code>_pathPoints</code>属性。它是一个二维数组，保存每条折线上所有点的<code>CGPoint</code>。</li>
<li>y值的计算：是需要从y的真实值转化为这个拐点在图表里的y坐标，转化方法的实现(仔细看几遍就懂了)：</li>
</ol>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)yValuePositionInLineChart:(<span class="built_in">CGFloat</span>)y &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> innerGrade;<span class="comment">//真实的最大值与最小值的差 与 当前点与最小值的差 的比值</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!(_yValueMax - _yValueMin)) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//特殊情况：当_yValueMax和_yValueMin相等的时候</span></div><div class="line">        innerGrade = <span class="number">0.5</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        innerGrade = ((<span class="built_in">CGFloat</span>) y - _yValueMin) / (_yValueMax - _yValueMin);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//innerGrade 与画布的高度（_chartCavanHeight）相乘，就能得出在画布中的高度</span></div><div class="line">    <span class="keyword">return</span> _chartCavanHeight - (innerGrade * _chartCavanHeight) - (_yLabelHeight / <span class="number">2</span>) + _chartMarginTop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"><a href="#4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）" class="headerlink" title="4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"></a>4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    <span class="comment">//每条折线所有圆圈的贝塞尔曲线</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *pointPath = [<span class="built_in">UIBezierPath</span> bezierPath];    </div><div class="line">    <span class="comment">//inflexionWidth默认是6,是两个线段中间的距离（因为中间有一个圈圈，所以需要定一个距离）</span></div><div class="line">    <span class="built_in">CGFloat</span> inflexionWidth = chartData.inflexionPointWidth;</div><div class="line">    <span class="comment">//遍历每条折线里的每个点</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;  </div><div class="line">        <span class="comment">//1. 计算圆圈的rect：已当前点为中心，以inflexionWidth为半径</span></div><div class="line">        <span class="built_in">CGRect</span> circleRect = <span class="built_in">CGRectMake</span>(x - inflexionWidth / <span class="number">2</span>, y - inflexionWidth / <span class="number">2</span>, inflexionWidth, inflexionWidth);    </div><div class="line">        <span class="comment">//2. 计算圆圈的中心：由圆圈的x，y和inflexionWidth算出</span></div><div class="line">        <span class="built_in">CGPoint</span> circleCenter = <span class="built_in">CGPointMake</span>(circleRect.origin.x + (circleRect.size.width / <span class="number">2</span>), circleRect.origin.y + (circleRect.size.height / <span class="number">2</span>));</div><div class="line">        <span class="comment">//3.1 移动到圆圈的右中部</span></div><div class="line">        [pointPath moveToPoint:<span class="built_in">CGPointMake</span>(circleCenter.x + (inflexionWidth / <span class="number">2</span>), circleCenter.y)];        </div><div class="line">        <span class="comment">//3.2 画线（圆形）</span></div><div class="line">        [pointPath addArcWithCenter:circleCenter radius:inflexionWidth / <span class="number">2</span> startAngle:<span class="number">0</span> endAngle:(<span class="built_in">CGFloat</span>) (<span class="number">2</span> * M_PI) clockwise:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//保存到pointsPath数组里</span></div><div class="line">    [pointsPath insertObject:pointPath atIndex:lineIndex];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>pointsPath</code>对应的是<code>lineChart</code>的<code>_pointsPath</code>属性。它是一个一维数组，保存每条折线上的圆圈贝塞尔曲线（UIBezierPath）。</p>
</blockquote>
<h3 id="5-生成每个拐点上面的Label（可有可无）"><a href="#5-生成每个拐点上面的Label（可有可无）" class="headerlink" title="5. 生成每个拐点上面的Label（可有可无）"></a>5. 生成每个拐点上面的Label（可有可无）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    <span class="comment">//遍历每条折线里的每一段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> (chartData.showPointLabel) &#123;</div><div class="line">            [gradePathArray addObject:[<span class="keyword">self</span> createPointLabelFor:chartData.getData(i).rawY pointCenter:circleCenter width:inflexionWidth withChartData:chartData]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，在这里，这些label的实现是通过一个<code>CATextLayer</code>实现的，并不是生成一个个<code>Label</code>放在数组里保存，具体实现方法如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CATextLayer</span> *)createPointLabelFor:(<span class="built_in">CGFloat</span>)grade pointCenter:(<span class="built_in">CGPoint</span>)pointCenter width:(<span class="built_in">CGFloat</span>)width withChartData:(PNLineChartData *)chartData &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//grade：提供textLayer显示的数值</span></div><div class="line">    <span class="comment">//pointCenter：根据pointCenter算出textLayer的x，y</span></div><div class="line">    <span class="comment">//width：根据width得到textLayer的总宽度</span></div><div class="line">    <span class="comment">//chartData：获取chartData里保存的textLayer上应该保存的字体大小和颜色</span></div><div class="line">    </div><div class="line">    <span class="built_in">CATextLayer</span> *textLayer = [[<span class="built_in">CATextLayer</span> alloc] init];</div><div class="line">    [textLayer setAlignmentMode:kCAAlignmentCenter];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的背景色</span></div><div class="line">    [textLayer setForegroundColor:[chartData.pointLabelColor <span class="built_in">CGColor</span>]];</div><div class="line">    [textLayer setBackgroundColor:<span class="keyword">self</span>.backgroundColor.CGColor];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的字体大小和颜色</span></div><div class="line">    <span class="keyword">if</span> (chartData.pointLabelFont != <span class="literal">nil</span>) &#123;</div><div class="line">        [textLayer setFont:(__bridge <span class="built_in">CFTypeRef</span>) (chartData.pointLabelFont)];</div><div class="line">        textLayer.fontSize = [chartData.pointLabelFont pointSize];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的高度</span></div><div class="line">    <span class="built_in">CGFloat</span> textHeight = (<span class="built_in">CGFloat</span>) (textLayer.fontSize * <span class="number">1.1</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> textWidth = width * <span class="number">8</span>;</div><div class="line">    <span class="built_in">CGFloat</span> textStartPosY;</div><div class="line">    </div><div class="line">    textStartPosY = pointCenter.y - textLayer.fontSize;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.layer addSublayer:textLayer];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的文字显示格式</span></div><div class="line">    <span class="keyword">if</span> (chartData.pointLabelFormat != <span class="literal">nil</span>) &#123;</div><div class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:chartData.pointLabelFormat, grade]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:_yLabelFormat, grade]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的位置和scale（1x，2x，3x）</span></div><div class="line">    [textLayer setFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, textWidth, textHeight)];</div><div class="line">    [textLayer setPosition:<span class="built_in">CGPointMake</span>(pointCenter.x, textStartPosY)];</div><div class="line">    textLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> textLayer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-计算每条线段的贝塞尔曲线（UIBezierPath）"><a href="#6-计算每条线段的贝塞尔曲线（UIBezierPath）" class="headerlink" title="6. 计算每条线段的贝塞尔曲线（UIBezierPath）"></a>6. 计算每条线段的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//每一条线段的贝塞尔曲线（UIBezierPath），用数组装起来</span></div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    </div><div class="line">    <span class="comment">//chartPath（二维数组）：保存所有折线上所有线段的贝塞尔曲线。现在只有一条折线，所以只有一个元素</span></div><div class="line">    [chartPath insertObject:progressLines atIndex:lineIndex];</div><div class="line">    </div><div class="line">    <span class="comment">//progressLinePaths的每个元素是一个字典，字典里存放每一条线段的端点（from，to）</span></div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *&gt; *progressLinePaths = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> last_x = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last_y = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//遍历每条折线里的每一段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//x，y的算法参考上文第三项</span></div><div class="line">            <span class="comment">// 计算index为0以后的点的位置</span></div><div class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) sqrt(pow(x - last_x, <span class="number">2</span>) + pow(y - last_y, <span class="number">2</span>));</div><div class="line">            <span class="keyword">float</span> last_x1 = last_x + (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</div><div class="line">            <span class="keyword">float</span> last_y1 = last_y + (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</div><div class="line">            <span class="keyword">float</span> x1 = x - (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</div><div class="line">            <span class="keyword">float</span> y1 = y - (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</div><div class="line">            </div><div class="line">            <span class="comment">//当前线段的端点</span></div><div class="line">            from = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(last_x1, last_y1)];</div><div class="line">            to = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x1, y1)];</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(from != <span class="literal">nil</span> &amp;&amp; to != <span class="literal">nil</span>) &#123;</div><div class="line">                <span class="comment">//保存每一段的端点</span></div><div class="line">                [progressLinePaths addObject:@&#123;<span class="string">@"from"</span>: from,  <span class="string">@"to"</span>:to&#125;];</div><div class="line">                <span class="comment">//保存所有的端点</span></div><div class="line">                [lineStartEndPointsArray addObject:from];</div><div class="line">                [lineStartEndPointsArray addObject:to];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//保存所有折点的坐标</span></div><div class="line">            [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</div><div class="line">            <span class="comment">//将当前的x转化为下一个点的last_x（y也一样）</span></div><div class="line">            last_x = x;</div><div class="line">            last_y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//pointsOfPath：保存所有折线里的所有线段两端的端点</span></div><div class="line">    [pointsOfPath addObject:[lineStartEndPointsArray <span class="keyword">copy</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">//根据每一条线段的两个端点，成生每条线段的贝塞尔曲线</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *calculatedRanges =</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">            [currentProgressLine moveToPoint:[range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>]];</div><div class="line">            [currentProgressLine addLineToPoint:[range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>]];</div><div class="line">            [progressLines addObject:currentProgressLine];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"><a href="#7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。" class="headerlink" title="7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"></a>7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</h3><h4 id="7-1-所有线段的layer："><a href="#7-1-所有线段的layer：" class="headerlink" title="7.1 所有线段的layer："></a>7.1 所有线段的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)populateChartLines &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//遍历每条线段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = <span class="keyword">self</span>.chartPath[lineIndex];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">//_chartLineArray:二维数组，装载每个chartData对应的一个数组。这个数组的元素是这一条折线上所有线段对应的CAShapeLayer</span></div><div class="line">        [<span class="keyword">self</span>.chartLineArray[lineIndex] removeAllObjects];</div><div class="line">        </div><div class="line">        <span class="built_in">NSUInteger</span> progressLineIndex = <span class="number">0</span>;;</div><div class="line">        </div><div class="line">        <span class="comment">//遍历含有UIBezierPath对象元素的数组。在每个循环里新建一个CAShapeLayer对象，将UIBezierPath赋给它。</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *progressLinePath <span class="keyword">in</span> progressLines) &#123;</div><div class="line">            </div><div class="line">            PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</div><div class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">            </div><div class="line">            ...</div><div class="line">            </div><div class="line">            <span class="comment">//将当前线段的UIBezierPath赋给当前线段的CAShapeLayer</span></div><div class="line">            chartLine.path = progressLinePath.CGPath;</div><div class="line">            </div><div class="line">            <span class="comment">//添加layer</span></div><div class="line">            [<span class="keyword">self</span>.layer addSublayer:chartLine];</div><div class="line">            </div><div class="line">            <span class="comment">//保存当前线段的layer</span></div><div class="line">            [<span class="keyword">self</span>.chartLineArray[lineIndex] addObject:chartLine];</div><div class="line">            progressLineIndex++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-2-所有圆圈的layer："><a href="#7-2-所有圆圈的layer：" class="headerlink" title="7.2 所有圆圈的layer："></a>7.2 所有圆圈的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)recreatePointLayers &#123;</div><div class="line">- </div><div class="line">    <span class="keyword">for</span> (PNLineChartData *chartData <span class="keyword">in</span> _chartData) &#123;</div><div class="line">    </div><div class="line">        <span class="comment">// create as many chart line layers as there are data-lines</span></div><div class="line">        [<span class="keyword">self</span>.chartLineArray addObject:[<span class="built_in">NSMutableArray</span> new]];</div><div class="line"></div><div class="line">        <span class="comment">// create point</span></div><div class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">        pointLayer.strokeColor = [[chartData.color colorWithAlphaComponent:chartData.alpha] <span class="built_in">CGColor</span>];</div><div class="line">        pointLayer.lineCap = kCALineCapRound;</div><div class="line">        pointLayer.lineJoin = kCALineJoinBevel;</div><div class="line">        pointLayer.fillColor = <span class="literal">nil</span>;</div><div class="line">        pointLayer.lineWidth = chartData.lineWidth;</div><div class="line">        [<span class="keyword">self</span>.layer addSublayer:pointLayer];</div><div class="line">        [<span class="keyword">self</span>.chartPointArray addObject:pointLayer];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里并没有将所有圆圈的<code>UIBezierPath</code>赋给对应的<code>layer</code>，而是在下一步，绘图的时候做的。</p>
</blockquote>
<h3 id="8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画"><a href="#8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画" class="headerlink" title="8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画"></a>8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)strokeChart &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 绘制所有折线（所有线段+所有圆圈）</span></div><div class="line">    <span class="comment">// 遍历所有折线</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">       </div><div class="line">        PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有线段的CAShapeLayer</span></div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">CAShapeLayer</span> *&gt; *chartLines =<span class="keyword">self</span>.chartLineArray[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有圆圈的CAShapeLayer</span></div><div class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = (<span class="built_in">CAShapeLayer</span> *) <span class="keyword">self</span>.chartPointArray[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//开始绘制折线</span></div><div class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="keyword">self</span>.frame.size);</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有线段的UIBezierPath</span></div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = _chartPath[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有圆圈的UIBezierPath</span></div><div class="line">        <span class="built_in">UIBezierPath</span> *pointPath = _pointPath[lineIndex];</div><div class="line"></div><div class="line">        <span class="comment">//7.2将圆圈的UIBezierPath赋给了圆圈的CAShapeLayer</span></div><div class="line">        pointLayer.path = pointPath.CGPath;</div><div class="line"></div><div class="line">        <span class="comment">//添加动画</span></div><div class="line">        [<span class="built_in">CATransaction</span> begin];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; progressLines.count; index++) &#123;</div><div class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = chartLines[index];</div><div class="line">            <span class="comment">//chartLine strokeColor is already set. no need to override here</span></div><div class="line">            [chartLine addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</div><div class="line">            chartLine.strokeEnd = <span class="number">1.0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// if you want cancel the point animation, comment this code, the point will show immediately</span></div><div class="line">        <span class="keyword">if</span> (chartData.inflexionPointStyle != PNLineChartPointStyleNone) &#123;</div><div class="line">            [pointLayer addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//提交动画</span></div><div class="line">        [<span class="built_in">CATransaction</span> commit];</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">        <span class="comment">//绘制完毕</span></div><div class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要注意两点：</p>
<blockquote>
<p>1.如果想给layer添加动画，只需要实例化一个animation（在这里是<code>CABasicAnimation</code>）并调用layer的<code>addAnimation:</code>方法即可。我们看一下关于<code>CABasicAnimation</code>的实例化代码：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CABasicAnimation</span> *)pathAnimation &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.displayAnimated &amp;&amp; !_pathAnimation) &#123;</div><div class="line">        _pathAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</div><div class="line">        <span class="comment">//持续时间</span></div><div class="line">        _pathAnimation.duration = <span class="number">1.0</span>;</div><div class="line">         <span class="comment">//类型</span></div><div class="line">        _pathAnimation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">        _pathAnimation.fromValue = @<span class="number">0.0</span>f;</div><div class="line">        _pathAnimation.toValue = @<span class="number">1.0</span>f;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">self</span>.displayAnimated) &#123;</div><div class="line">        _pathAnimation = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _pathAnimation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2.在这里调用了<code>setNeedsDisplay</code>方法之后，会调用<code>drawRect：</code>方法，在这个方法里，完成了x，y坐标轴的绘制：</p>
</blockquote>
<h3 id="10-绘制x，y坐标轴"><a href="#10-绘制x，y坐标轴" class="headerlink" title="10.绘制x，y坐标轴"></a>10.绘制x，y坐标轴</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制坐标轴和背景竖线</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isShowCoordinateAxis) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> yAxisOffset = <span class="number">10.</span>f;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsPopContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsPushContext</span>(ctx);</div><div class="line">        <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="keyword">self</span>.axisWidth);</div><div class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="keyword">self</span>.axisColor <span class="built_in">CGColor</span>]);</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> xAxisWidth = <span class="built_in">CGRectGetWidth</span>(rect) - (_chartMarginLeft + _chartMarginRight) / <span class="number">2</span>;</div><div class="line">        <span class="built_in">CGFloat</span> yAxisHeight = _chartMarginBottom + _chartCavanHeight;</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制xy轴</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制y轴的箭头</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset - <span class="number">3</span>, <span class="number">6</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset + <span class="number">3</span>, <span class="number">6</span>);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制x轴的箭头</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight - <span class="number">3</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight + <span class="number">3</span>);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">//绘制x轴和y轴的label</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.showLabel) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 绘制x轴的小分割线</span></div><div class="line">            <span class="built_in">CGPoint</span> point;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</div><div class="line">                point = <span class="built_in">CGPointMake</span>(<span class="number">2</span> * _chartMarginLeft + (i * _xLabelWidth), _chartMarginBottom + _chartCavanHeight);</div><div class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y - <span class="number">2</span>);</div><div class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x, point.y);</div><div class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 绘制y轴的小分割线</span></div><div class="line">            <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</div><div class="line">                point = <span class="built_in">CGPointMake</span>(_chartMarginBottom + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</div><div class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</div><div class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x + <span class="number">2</span>, point.y);</div><div class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">11</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制y轴单位</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.yUnit length]) &#123;</div><div class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.yUnit withWidth:<span class="number">30.</span>f font:font].height;</div><div class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(_chartMarginLeft + <span class="number">10</span> + <span class="number">5</span>, <span class="number">0</span>, <span class="number">30.</span>f, height);</div><div class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.yUnit inRect:drawRect font:font color:<span class="keyword">self</span>.yLabelColor];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制x轴的单位</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.xUnit length]) &#123;</div><div class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.xUnit withWidth:<span class="number">30.</span>f font:font].height;</div><div class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, _chartMarginBottom + _chartCavanHeight - height / <span class="number">2</span>, <span class="number">25.</span>f, height);</div><div class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.xUnit inRect:drawRect font:font color:<span class="keyword">self</span>.xLabelColor];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制竖线</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.showYGridLines) &#123;</div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">CGFloat</span> yAxisOffset = _showLabel ? <span class="number">10.</span>f : <span class="number">0.0</span>f;</div><div class="line">        <span class="built_in">CGPoint</span> point;</div><div class="line">        </div><div class="line">        <span class="comment">//每一条竖线的跨度</span></div><div class="line">        <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</div><div class="line">        </div><div class="line">        <span class="comment">//颜色</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.yGridLinesColor) &#123;</div><div class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, <span class="keyword">self</span>.yGridLinesColor.CGColor);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> lightGrayColor].CGColor);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//绘制每一条竖线</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; _yLabelNum; i++) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//拿到起点</span></div><div class="line">            point = <span class="built_in">CGPointMake</span>(_chartMarginLeft + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</div><div class="line">            </div><div class="line">            <span class="comment">//将画笔移动到起点</span></div><div class="line">            <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</div><div class="line">            </div><div class="line">            <span class="comment">//设置线的属性</span></div><div class="line">            <span class="built_in">CGFloat</span> dash[] = &#123;<span class="number">6</span>, <span class="number">5</span>&#125;;</div><div class="line">            <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">0.5</span>);</div><div class="line">            <span class="built_in">CGContextSetLineCap</span>(ctx, kCGLineCapRound);</div><div class="line">            <span class="built_in">CGContextSetLineDash</span>(ctx, <span class="number">0.0</span>, dash, <span class="number">2</span>);</div><div class="line">            </div><div class="line">            <span class="comment">//设置这条线的终点</span></div><div class="line">            <span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, point.y);</div><div class="line">            </div><div class="line">            <span class="comment">//画线</span></div><div class="line">            <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> drawRect:rect];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，一张完整的图表就可以画出来了。但是当前绘制的图表的折线都是直线，在上面还展示了一张曲线图。那么如果想绘制带有曲线的折线图应该怎么做呢？对，就是在贝塞尔曲线上下功夫。</p>
<p>当我们获取了所有线段的端点数组后，我们可以通过他们绘制弯曲的贝塞尔曲线（注意：该方法是对应上面对第6项的下半部分:生成每一个线段对贝塞尔曲线）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//_showSmoothLines是用来控制是否绘制曲线折线的开关属性</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.showSmoothLines &amp;&amp; chartData.itemCount &gt;= <span class="number">4</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">            <span class="built_in">CGPoint</span> segmentP1 = [range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> segmentP2 = [range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            [currentProgressLine moveToPoint:segmentP1];</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> midPoint = [PNLineChart midPointBetweenPoint1:segmentP1 andPoint2:segmentP2];</div><div class="line">            </div><div class="line">            <span class="comment">//以每条线段以中间点为分割点，分成两组。每一组形成柔和的外凸曲线，而不是内凹</span></div><div class="line">            [currentProgressLine addQuadCurveToPoint:midPoint</div><div class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP1]];</div><div class="line">            </div><div class="line">            [currentProgressLine addQuadCurveToPoint:segmentP2</div><div class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP2]];</div><div class="line">            </div><div class="line">            [progressLines addObject:currentProgressLine];</div><div class="line">            [progressLineColors addObject:range[<span class="string">@"color"</span>]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下生成弯曲的贝塞尔曲线的方法：<code>controlPointBetweenPoint1:andPoint2</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回的点的x：是两点的中间；返回的点的y：与第二个点保持一致</span></div><div class="line">+ (<span class="built_in">CGPoint</span>)controlPointBetweenPoint1:(<span class="built_in">CGPoint</span>)point1 andPoint2:(<span class="built_in">CGPoint</span>)point2 &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//线段两端的中间点</span></div><div class="line">    <span class="built_in">CGPoint</span> controlPoint = [<span class="keyword">self</span> midPointBetweenPoint1:point1 andPoint2:point2];</div><div class="line">    </div><div class="line">    <span class="comment">//末端点 和  中间点y的差</span></div><div class="line">    <span class="built_in">CGFloat</span> diffY = abs((<span class="keyword">int</span>) (point2.y - controlPoint.y));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (point1.y &lt; point2.y)</div><div class="line">    <span class="comment">//如果前端点更高</span></div><div class="line">        controlPoint.y += diffY;</div><div class="line">    </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (point1.y &gt; point2.y)</div><div class="line">    <span class="comment">//如果后端点更高</span></div><div class="line">        controlPoint.y -= diffY;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> controlPoint;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，这样一来，直线的曲线图还有曲线的曲线图就大概掌握了。不过还差一个东西，就是图表对点击的响应。</p>
<p>我们需要思考一下：既然一张图表里可以显示多条折线，所以，当手指点击图表上的点以后，应该同时返回两个数据：</p>
<ol>
<li>点击了哪条折线上的这个点。</li>
<li>点击了这条折线上的哪个点。</li>
</ol>
<p>该框架的作者很好地完成了这两个任务，我们来看一下他是如何实现的：</p>
<h3 id="响应点击的代理方法"><a href="#响应点击的代理方法" class="headerlink" title="响应点击的代理方法"></a>响应点击的代理方法</h3><h4 id="点击了哪条折线的判断"><a href="#点击了哪条折线的判断" class="headerlink" title="点击了哪条折线的判断"></a>点击了哪条折线的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="comment">// Get the point user touched</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span> *linePointsArray = _endPointsOfPath[p];</div><div class="line">        </div><div class="line">        <span class="comment">//遍历每个端点</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// Closest distance from point to line</span></div><div class="line">            <span class="comment">//触摸点到线段的距离</span></div><div class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) fabs(((p2.x - p1.x) * (touchPoint.y - p1.y)) - ((p1.x - touchPoint.x) * (p1.y - p2.y)));</div><div class="line">            distance /= hypot(p2.x - p1.x, p1.y - p2.y);</div><div class="line">            </div><div class="line">            <span class="comment">//如果距离小于5，则判断为“点击了当前的线段”，剩下的工作是判断具体点击了哪一条线段</span></div><div class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">5.0</span>) &#123;</div><div class="line">                <span class="comment">// Conform to delegate parameters, figure out what bezier path this CGPoint belongs to.</span></div><div class="line">                <span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *paths <span class="keyword">in</span> _chartPath) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *path <span class="keyword">in</span> paths) &#123;</div><div class="line">                        <span class="comment">//如果当前点处于UIBezierPath曲线上</span></div><div class="line">                        <span class="built_in">BOOL</span> pointContainsPath = <span class="built_in">CGPathContainsPoint</span>(path.CGPath, <span class="literal">NULL</span>, p1, <span class="literal">NO</span>);</div><div class="line">                        <span class="keyword">if</span> (pointContainsPath) &#123;</div><div class="line">                            <span class="comment">//点击了某一条折线</span></div><div class="line">                            [_delegate userClickedOnLinePoint:touchPoint lineIndex:lineIndex];</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    lineIndex++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="点击了哪个点的判断"><a href="#点击了哪个点的判断" class="headerlink" title="点击了哪个点的判断"></a>点击了哪个点的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchKeyPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="comment">// Get the point user touched</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *linePointsArray = _pathPoints[p];</div><div class="line">        </div><div class="line">        <span class="comment">//遍历所有的点</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            <span class="comment">//获取到前一点的距离和后一点的距离</span></div><div class="line">            <span class="keyword">float</span> distanceToP1 = (<span class="keyword">float</span>) fabs(hypot(touchPoint.x - p1.x, touchPoint.y - p1.y));</div><div class="line">            <span class="keyword">float</span> distanceToP2 = (<span class="keyword">float</span>) hypot(touchPoint.x - p2.x, touchPoint.y - p2.y);</div><div class="line">            </div><div class="line">            <span class="keyword">float</span> distance = MIN(distanceToP1, distanceToP2);</div><div class="line">            </div><div class="line">            <span class="comment">//如果较小的距离小于10，则判定为点击了某个点</span></div><div class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">10.0</span>) &#123;</div><div class="line">                <span class="comment">//点击了某一条折线上的某个点</span></div><div class="line">                [_delegate userClickedOnLineKeyPoint:touchPoint</div><div class="line">                                           lineIndex:p</div><div class="line">                                          pointIndex:(distance == distanceToP2 ? i + <span class="number">1</span> : i)];</div><div class="line">                </div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这下就完整了，一个带有响应功能的图表就做好啦！</p>
<h3 id="关于自定义UIView"><a href="#关于自定义UIView" class="headerlink" title="关于自定义UIView"></a>关于自定义UIView</h3><p>这里只是将图表的<code>layer</code>加在了<code>UIView</code>的layer上，那如果想完全自定义view的话，只需将图表的<code>layer</code>完全赋给<code>UIView</code>的layer即可，这样一来，想要画出任意形状的<code>UIView</code>都可以。</p>
<hr>
<h2 id="三-最后的话"><a href="#三-最后的话" class="headerlink" title="三. 最后的话"></a>三. 最后的话</h2><p>关于图表的绘制，相对贝塞尔曲线与<code>CALayer</code>来说，数据的处理是一个比较麻烦的点。但是一旦学会了折线图的绘制，了解了绘图原理，那么其他类型的图表就可以触类旁通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-框架介绍&quot;&gt;&lt;a href=&quot;#一-框架介绍&quot; class=&quot;headerlink&quot; title=&quot;一. 框架介绍&quot;&gt;&lt;/a&gt;一. 框架介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kevinzhow/PNChart&quot;&gt;PNChart&lt;/a&gt;是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。&lt;/p&gt;
&lt;p&gt;该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类&lt;code&gt;PNGenericChart&lt;/code&gt;,第二层就是所有类型的图表。提供一张图来直观感受一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png&quot; alt=&quot;层级图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这张图里，需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带箭头的线和不带箭头的线的区别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data&lt;/code&gt;类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有&lt;code&gt;Data&lt;/code&gt;类，因为饼状图没有多组数据，而折线图&lt;code&gt;LineChart&lt;/code&gt;是支持多组数据的，所以有&lt;code&gt;Data&lt;/code&gt;类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Item&lt;/code&gt;类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BarChart&lt;/code&gt;类里面的每一根柱子都是&lt;code&gt;PNBar&lt;/code&gt;的实例（该类型的图表不在本篇讲解的范围之内）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MJRefresh源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/MJRefresh%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/MJRefresh 源码解析/</id>
    <published>2018-02-02T16:17:40.000Z</published>
    <updated>2018-02-02T16:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a>是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。</p>
<p>该框架的结构设计得很清晰，使用一个基类<code>MJRefreshComponent</code>来做一些基本的设定，然后通过继承的方式，让<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png" alt="框架组织结构图"></p>
<a id="more"></a>
<p>首先来看一下该控件的基类：MJRefreshComponent：</p>
<h2 id="MJRefreshComponent"><a href="#MJRefreshComponent" class="headerlink" title="MJRefreshComponent"></a>MJRefreshComponent</h2><p>这个类作为该控件几类，涵盖了基类所具备的成份：状态，回调block等，大致分成下面这5种职能：</p>
<h3 id="有哪些职能"><a href="#有哪些职能" class="headerlink" title="有哪些职能?"></a>有哪些职能?</h3><ol>
<li>声明控件的所有状态。</li>
<li>声明控件的回调函数。</li>
<li>添加监听。</li>
<li>提供刷新，停止刷新接口。</li>
<li>提供子类需要实现的方法。</li>
</ol>
<h3 id="职能如何实现？"><a href="#职能如何实现？" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><h4 id="1-声明控件的所有状态"><a href="#1-声明控件的所有状态" class="headerlink" title="1. 声明控件的所有状态"></a>1. 声明控件的所有状态</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 刷新控件的状态 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, MJRefreshState) &#123;</div><div class="line">    <span class="comment">/** 普通闲置状态 */</span></div><div class="line">    MJRefreshStateIdle = <span class="number">1</span>,</div><div class="line">    <span class="comment">/** 松开就可以进行刷新的状态 */</span></div><div class="line">    MJRefreshStatePulling,</div><div class="line">    <span class="comment">/** 正在刷新中的状态 */</span></div><div class="line">    MJRefreshStateRefreshing,</div><div class="line">    <span class="comment">/** 即将刷新的状态 */</span></div><div class="line">    MJRefreshStateWillRefresh,</div><div class="line">    <span class="comment">/** 所有数据加载完毕，没有更多的数据了 */</span></div><div class="line">    MJRefreshStateNoMoreData</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="2-声明控件的回调函数"><a href="#2-声明控件的回调函数" class="headerlink" title="2. 声明控件的回调函数"></a>2. 声明控件的回调函数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 进入刷新状态的回调 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentRefreshingBlock)();</div><div class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentbeginRefreshingCompletionBlock)();</div><div class="line"><span class="comment">/** 结束刷新后的回调 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentEndRefreshingCompletionBlock)();</div></pre></td></tr></table></figure>
<h4 id="3-添加监听"><a href="#3-添加监听" class="headerlink" title="3. 添加监听"></a>3. 添加监听</h4><p>监听的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObservers</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</div><div class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset options:options context:<span class="literal">nil</span>];<span class="comment">//contentOffset属性</span></div><div class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize options:options context:<span class="literal">nil</span>];<span class="comment">//contentSize属性</span></div><div class="line">    <span class="keyword">self</span>.pan = <span class="keyword">self</span>.scrollView.panGestureRecognizer;</div><div class="line">    [<span class="keyword">self</span>.pan addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState options:options context:<span class="literal">nil</span>];<span class="comment">//UIPanGestureRecognizer 的state属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于监听的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 遇到这些情况就直接返回</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 这个就算看不见也需要处理</span></div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewContentSizeDidChange:change];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 看不见</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewContentOffsetDidChange:change];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewPanStateDidChange:change];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-提供刷新，停止刷新接口"><a href="#4-提供刷新，停止刷新接口" class="headerlink" title="4. 提供刷新，停止刷新接口"></a>4. 提供刷新，停止刷新接口</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark 进入刷新状态</span></div><div class="line">- (<span class="keyword">void</span>)beginRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.beginRefreshingCompletionBlock = completionBlock;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> beginRefreshing];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)beginRefreshing</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        <span class="keyword">self</span>.alpha = <span class="number">1.0</span>;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.pullingPercent = <span class="number">1.0</span>;</div><div class="line">    <span class="comment">// 只要正在刷新，就完全显示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.window) &#123;</div><div class="line">        <span class="comment">//将状态切换为正在刷新</span></div><div class="line">        <span class="keyword">self</span>.state = MJRefreshStateRefreshing;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 预防正在刷新中时，调用本方法使得header inset回置失败</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateRefreshing) &#123;</div><div class="line">            <span class="comment">//将状态切换为即将刷新</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStateWillRefresh;</div><div class="line">            <span class="comment">// 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</span></div><div class="line">            [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark 结束刷新状态</span></div><div class="line">- (<span class="keyword">void</span>)endRefreshing</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.state = MJRefreshStateIdle;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)endRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.endRefreshingCompletionBlock = completionBlock;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> endRefreshing];</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark 是否正在刷新</span></div><div class="line">- (<span class="built_in">BOOL</span>)isRefreshing</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == MJRefreshStateRefreshing || <span class="keyword">self</span>.state == MJRefreshStateWillRefresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>交给子类实现的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 摆放子控件frame */</span></div><div class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div></pre></td></tr></table></figure>
<h4 id="5-提供子类需要实现的方法"><a href="#5-提供子类需要实现的方法" class="headerlink" title="5. 提供子类需要实现的方法"></a>5. 提供子类需要实现的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 交给子类们去实现</span></div><div class="line"><span class="comment">/** 初始化 */</span></div><div class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 摆放子控件frame */</span></div><div class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div></pre></td></tr></table></figure>
<p>从上面等结构图可以看出，紧接着这个基类，下面分为<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>,这里顺着<code>MJRefreshHeader</code>这个分支向下展开：</p>
<h2 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h2><p><code>MJRefreshHeader</code>继承于<code>MJRefreshComponent</code>，它做了这几件事：</p>
<h3 id="有哪些职能？"><a href="#有哪些职能？" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol>
<li>初始化。</li>
<li>设置header高度。</li>
<li>重新调整y值。</li>
<li>根据<code>contentOffset</code>的变化，来切换状态（默认状态，可以刷新的状态，正在刷新的状态），实现方法是：<code>scrollViewContentOffsetDidChange:</code>。</li>
<li>在切换状态时，执行相应的操作。实现方法是：<code>setState:</code>。</li>
</ol>
<h3 id="职能如何实现？-1"><a href="#职能如何实现？-1" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化</p>
<p>初始化有两种方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock</div><div class="line">&#123;</div><div class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="comment">//传入block</span></div><div class="line">    cmp.refreshingBlock = refreshingBlock;</div><div class="line">    <span class="keyword">return</span> cmp;</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingTarget:(<span class="keyword">id</span>)target refreshingAction:(SEL)action</div><div class="line">&#123;</div><div class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="comment">//设置self.refreshingTarget 和 self.refreshingAction</span></div><div class="line">    [cmp setRefreshingTarget:target refreshingAction:action];</div><div class="line">    <span class="keyword">return</span> cmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-设置header高度"><a href="#2-设置header高度" class="headerlink" title="2. 设置header高度"></a>2. 设置header高度</h4><p>通过重写<code>prepare</code>方法来设置header的高度：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置用于在NSUserDefaults里存储时间的key</span></div><div class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</div><div class="line">    </div><div class="line">    <span class="comment">// 设置header的高度</span></div><div class="line">    <span class="keyword">self</span>.mj_h = MJRefreshHeaderHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-重新调整y值"><a href="#3-重新调整y值" class="headerlink" title="3. 重新调整y值"></a>3. 重新调整y值</h4><p>通过重写<code>placeSubviews</code>方法来重新调整y值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)</span></div><div class="line">    <span class="keyword">self</span>.mj_y = - <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.ignoredScrollViewContentInsetTop;</div><div class="line">    <span class="comment">//self.ignoredScrollViewContentInsetTop 如果是10，那么就向上移动10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-状态切换的代码："><a href="#4-状态切换的代码：" class="headerlink" title="4. 状态切换的代码："></a>4. 状态切换的代码：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> scrollViewContentOffsetDidChange:change];</div><div class="line">    <span class="comment">// 正在刷新的状态</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.window == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//- self.scrollView.mj_offsetY：-（-54-64）= 118 ： 刷新的时候，偏移量是不动的。偏移量 = 状态栏 + 导航栏 + header的高度</span></div><div class="line">        <span class="comment">//_scrollViewOriginalInset.top：64 （状态栏 + 导航栏）</span></div><div class="line">        <span class="comment">//insetT 取二者之间大的那一个</span></div><div class="line">        <span class="built_in">CGFloat</span> insetT = - <span class="keyword">self</span>.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - <span class="keyword">self</span>.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</div><div class="line">       </div><div class="line">        <span class="comment">//118</span></div><div class="line">        insetT = insetT &gt; <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top ? <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top : insetT;</div><div class="line">        </div><div class="line">        <span class="comment">//设置contentInset</span></div><div class="line">        <span class="keyword">self</span>.scrollView.mj_insetT = insetT;</div><div class="line">        </div><div class="line">        <span class="comment">// 记录刷新的时候的偏移量 -54 = 64 - 118</span></div><div class="line">        <span class="keyword">self</span>.insetTDelta = _scrollViewOriginalInset.top - insetT;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 跳转到下一个控制器时，contentInset可能会变</span></div><div class="line">     _scrollViewOriginalInset = <span class="keyword">self</span>.scrollView.contentInset;</div><div class="line">    </div><div class="line">    <span class="comment">// 记录当前的contentOffset</span></div><div class="line">    <span class="built_in">CGFloat</span> offsetY = <span class="keyword">self</span>.scrollView.mj_offsetY;</div><div class="line"></div><div class="line">    <span class="comment">// 头部控件刚好全部出现的offsetY,默认是-64（20 + 44）</span></div><div class="line">    <span class="built_in">CGFloat</span> happenOffsetY = - <span class="keyword">self</span>.scrollViewOriginalInset.top;</div><div class="line">    </div><div class="line">    <span class="comment">// 向上滚动，直接返回</span></div><div class="line">    <span class="keyword">if</span> (offsetY &gt; happenOffsetY) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 从普通 到 即将刷新 的临界距离</span></div><div class="line">    <span class="built_in">CGFloat</span> normal2pullingOffsetY = happenOffsetY - <span class="keyword">self</span>.mj_h;<span class="comment">// -64 - 54 = -118</span></div><div class="line">    </div><div class="line">    <span class="comment">//下拉的百分比：下拉的距离与header高度的比值</span></div><div class="line">    <span class="built_in">CGFloat</span> pullingPercent = (happenOffsetY - offsetY) / <span class="keyword">self</span>.mj_h;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollView.isDragging) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//记录当前下拉的百分比</span></div><div class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</div><div class="line">            <span class="comment">// 如果当前为默认状态 &amp;&amp; 下拉的距离大于临界距离（将tableview下拉得很低），则将状态切换为可以刷新</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStatePulling;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</div><div class="line">            <span class="comment">// 如果当前状态为可以刷新 &amp;&amp; 下拉的距离小于临界距离，则将状态切换为默认</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStateIdle;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling) &#123;<span class="comment">// 即将刷新 &amp;&amp; 手松开</span></div><div class="line">        <span class="comment">// 手松开 &amp;&amp; 状态为可以刷新（MJRefreshStatePulling）时 开始刷新</span></div><div class="line">        [<span class="keyword">self</span> beginRefreshing];        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pullingPercent &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//手松开后，默认状态时，恢复self.pullingPercent</span></div><div class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意三点：</p>
<ol>
<li>这里的状态有三种：默认状态（MJRefreshStateIdle），可以刷新的状态（MJRefreshStatePulling）以及正在刷新的状态（MJRefreshStateRefreshing）。</li>
<li>状态切换的因素有两个：一个是下拉的距离是否超过临界值，另一个是 手指是否离开屏幕。</li>
<li>注意:<strong>可以刷新的状态</strong>和<strong>正在刷新的状态</strong>是不同的。因为在手指还贴在屏幕的时候是不能进行刷新的。所以即使在下拉的距离超过了临界距离（状态栏 + 导航栏 + header高度），如果手指没有离开屏幕，那么也不能马上进行刷新，而是将状态切换为：可以刷新。一旦手指离开了屏幕，马上将状态切换为正在刷新。 </li>
</ol>
</blockquote>
<p>这里提供一张图来体现三个状态的不同：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_2.png" alt="三个状态"></p>
<h4 id="5-状态切换时的相应操作："><a href="#5-状态切换时的相应操作：" class="headerlink" title="5. 状态切换时的相应操作："></a>5. 状态切换时的相应操作：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">   </div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//============== 设置状态为默认状态 =============//</span></div><div class="line">        </div><div class="line">        <span class="comment">//如果当前不是正在刷新就返回，因为这个方法主要针对从正在刷新状态（oldstate）到默认状态</span></div><div class="line">        <span class="keyword">if</span> (oldState != MJRefreshStateRefreshing) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//刷新完成后，保存刷新完成的时间</span></div><div class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:[<span class="built_in">NSDate</span> date] forKey:<span class="keyword">self</span>.lastUpdatedTimeKey];</div><div class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</div><div class="line">        </div><div class="line">        <span class="comment">// 恢复inset和offset</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">            </div><div class="line">            <span class="comment">//118 -&gt; 64（剪去了header的高度）</span></div><div class="line">            <span class="keyword">self</span>.scrollView.mj_insetT += <span class="keyword">self</span>.insetTDelta;</div><div class="line">            </div><div class="line">            <span class="comment">// 自动调整透明度</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.isAutomaticallyChangeAlpha) <span class="keyword">self</span>.alpha = <span class="number">0.0</span>;</div><div class="line">            </div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.pullingPercent = <span class="number">0.0</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.endRefreshingCompletionBlock) &#123;</div><div class="line">                <span class="comment">//调用刷新完成的block</span></div><div class="line">                <span class="keyword">self</span>.endRefreshingCompletionBlock();</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">         <span class="comment">//============== 设置状态为正在刷新状态 =============//</span></div><div class="line">         <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            </div><div class="line">             [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">               </div><div class="line">                <span class="built_in">CGFloat</span> top = <span class="keyword">self</span>.scrollViewOriginalInset.top + <span class="keyword">self</span>.mj_h;<span class="comment">//64 + 54 (都是默认的高度)</span></div><div class="line">                <span class="comment">// 重新设置contentInset，top = 118</span></div><div class="line">                <span class="keyword">self</span>.scrollView.mj_insetT = top;</div><div class="line">                <span class="comment">// 设置滚动位置</span></div><div class="line">                [<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, -top) animated:<span class="literal">NO</span>];</div><div class="line">                 </div><div class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                <span class="comment">//调用进行刷新的block</span></div><div class="line">                [<span class="keyword">self</span> executeRefreshingCallback];</div><div class="line">            &#125;];</div><div class="line">         &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意两点：</p>
<ol>
<li>这里状态的切换，主要围绕着两种：默认状态和正在刷新状态。也就是针对<strong>开始刷新</strong>和<strong>结束刷新</strong>这两个切换点。</li>
<li>从正在刷新状态状态切换为默认状态时（结束刷新），需要记录刷新结束的时间。因为header里面有一个默认的label是用来显示上次刷新的时间的。</li>
</ol>
</blockquote>
<h2 id="MJRefreshStateHeader"><a href="#MJRefreshStateHeader" class="headerlink" title="MJRefreshStateHeader"></a>MJRefreshStateHeader</h2><p>这个类是<code>MJRefreshHeader</code>类的子类，它做了两件事：</p>
<h3 id="有哪些职能？-1"><a href="#有哪些职能？-1" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol>
<li>简单布局了<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>。</li>
<li>根据控件状态的切换（默认状态，正在刷新状态），实现了这两个label显示的文字的切换。</li>
</ol>
<p>给一张图，让大家直观感受一下这两个控件：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_3.png" alt="两个Label"></p>
<h3 id="职能如何实现？-2"><a href="#职能如何实现？-2" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>这个类通过覆盖父类三个方法来实现上述两个实现：</p>
<h4 id="方法1：prepare方法"><a href="#方法1：prepare方法" class="headerlink" title="方法1：prepare方法"></a>方法1：prepare方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化间距</span></div><div class="line">    <span class="keyword">self</span>.labelLeftInset = MJRefreshLabelLeftInset;</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化文字</span></div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];</div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];</div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，将每一个状态对应的提示文字放入一个字典里面,key是状态的NSNumber形式</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (title == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">self</span>.stateTitles[@(state)] = title;</div><div class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(<span class="keyword">self</span>.state)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：placeSubviews方法"><a href="#方法2：placeSubviews方法" class="headerlink" title="方法2：placeSubviews方法"></a>方法2：placeSubviews方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> noConstrainsOnStatusLabel = <span class="keyword">self</span>.stateLabel.constraints.count == <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果更新时间label是隐藏的，则让状态label撑满整个header</span></div><div class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) <span class="keyword">self</span>.stateLabel.frame = <span class="keyword">self</span>.bounds;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果更新时间label不是隐藏的，根据约束设置更新时间label和状态label（高度各占一半）</span></div><div class="line">        <span class="built_in">CGFloat</span> stateLabelH = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) &#123;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_x = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_y = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_w = <span class="keyword">self</span>.mj_w;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_h = stateLabelH;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 更新时间label</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_x = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y = stateLabelH;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_w = <span class="keyword">self</span>.mj_w;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_h = <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里主要是对<code>lastUpdatedTimeLabel</code>和<code>stateLabel</code>进行布局。要注意<code>lastUpdatedTimeLabel</code>隐藏的情况。</p>
</blockquote>
<h4 id="方法3-setState-方法"><a href="#方法3-setState-方法" class="headerlink" title="方法3: setState:方法"></a>方法3: setState:方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="comment">// 设置状态文字</span></div><div class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(state)];</div><div class="line">    </div><div class="line">    <span class="comment">// 重新设置key（重新显示时间）</span></div><div class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = <span class="keyword">self</span>.lastUpdatedTimeKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，根据传入的state的不同，在<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>里切换相应的文字。</p>
<ul>
<li><code>stateLabel</code>里的文字直接从<code>stateTitles</code>字典里取出即可。</li>
<li><code>lastUpdatedTimeLabel</code>里的文字需要通过一个方法来取出即可：</li>
</ul>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setLastUpdatedTimeKey:(<span class="built_in">NSString</span> *)lastUpdatedTimeKey</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> setLastUpdatedTimeKey:lastUpdatedTimeKey];</div><div class="line">    </div><div class="line">    <span class="comment">// 如果label隐藏了，就不用再处理</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//根据key，从NSUserDefaults获取对应的NSData型时间</span></div><div class="line">    <span class="built_in">NSDate</span> *lastUpdatedTime = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:lastUpdatedTimeKey];</div><div class="line">    </div><div class="line">    <span class="comment">// 如果有block，从block里拿来时间，这应该是用户自定义显示时间格式的渠道</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeText) &#123;</div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = <span class="keyword">self</span>.lastUpdatedTimeText(lastUpdatedTime);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果没有block，就按照下面的默认方法显示时间格式</span></div><div class="line">    <span class="keyword">if</span> (lastUpdatedTime) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 获得了上次更新时间</span></div><div class="line">        <span class="comment">// 1.获得年月日</span></div><div class="line">        <span class="built_in">NSCalendar</span> *calendar = [<span class="keyword">self</span> currentCalendar];</div><div class="line">        <span class="built_in">NSUInteger</span> unitFlags = <span class="built_in">NSCalendarUnitYear</span>| <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitDay</span> |<span class="built_in">NSCalendarUnitHour</span> |<span class="built_in">NSCalendarUnitMinute</span>;</div><div class="line">        <span class="built_in">NSDateComponents</span> *cmp1 = [calendar components:unitFlags fromDate:lastUpdatedTime];</div><div class="line">        <span class="built_in">NSDateComponents</span> *cmp2 = [calendar components:unitFlags fromDate:[<span class="built_in">NSDate</span> date]];</div><div class="line">        </div><div class="line">        <span class="comment">// 2.格式化日期</span></div><div class="line">        <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">        <span class="built_in">BOOL</span> isToday = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> ([cmp1 day] == [cmp2 day]) &#123;</div><div class="line">            <span class="comment">//今天，省去年月日</span></div><div class="line">            formatter.dateFormat = <span class="string">@" HH:mm"</span>;</div><div class="line">            isToday = <span class="literal">YES</span>;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([cmp1 year] == [cmp2 year]) &#123; <span class="comment">// 今年</span></div><div class="line">            <span class="comment">//今年，省去年，显示月日</span></div><div class="line">            formatter.dateFormat = <span class="string">@"MM-dd HH:mm"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//其他，年月日都显示</span></div><div class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSString</span> *time = [formatter stringFromDate:lastUpdatedTime];</div><div class="line">        </div><div class="line">        <span class="comment">// 3.显示日期</span></div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@%@"</span>,</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</div><div class="line">                                          isToday ? [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderDateTodayText] : <span class="string">@""</span>,</div><div class="line">                                          time];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有获得上次更新时间（应该是第一次更新或者多次更新，之前的更新都失败了）</span></div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>,</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderNoneLastDateText]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里注意两点：</p>
<ol>
<li>作者通过使用block来让用户自己定义日期现实的格式，如果用户没有自定义，就使用作者提供的默认格式。</li>
<li>在默认格式的设置里，判断了是否是今日，是否是今年的情况。在以后设计显示时间的labe的时候可以借鉴一下。</li>
</ol>
</blockquote>
<h2 id="MJRefreshNormalHeader"><a href="#MJRefreshNormalHeader" class="headerlink" title="MJRefreshNormalHeader"></a>MJRefreshNormalHeader</h2><h3 id="有哪些职能？-2"><a href="#有哪些职能？-2" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>MJRefreshNormalHeader 继承于 MJRefreshStateHeader，它主要做了两件事：</p>
<ol>
<li>它在MJRefreshStateHeader上添加了<code>_arrowView</code>和<code>loadingView</code>。</li>
<li>布局了这两个view并在Refresh控件的状态切换的时候改变这两个view的样式。</li>
</ol>
<p>还是给一张图来直观感受一下这两个view：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_4.png" alt="两个view"></p>
<h3 id="职能如何实现？-3"><a href="#职能如何实现？-3" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>同MJRefreshStateHeader一样，也是重写了父类的三个方法：</p>
<h4 id="方法1：prepare"><a href="#方法1：prepare" class="headerlink" title="方法1：prepare"></a>方法1：prepare</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.activityIndicatorViewStyle = <span class="built_in">UIActivityIndicatorViewStyleGray</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：placeSubviews"><a href="#方法2：placeSubviews" class="headerlink" title="方法2：placeSubviews"></a>方法2：placeSubviews</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">// 首先将箭头的中心点x设为header宽度的一半</span></div><div class="line">    <span class="built_in">CGFloat</span> arrowCenterX = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.stateLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</div><div class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//在stateLabel里的文字宽度和更新时间里的文字宽度里取较宽的</span></div><div class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</div><div class="line">        <span class="comment">//根据self.labelLeftInset和textWidth向左移动中心点x</span></div><div class="line">        arrowCenterX -= textWidth / <span class="number">2</span> + <span class="keyword">self</span>.labelLeftInset;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//中心点y永远设置为header的高度的一半</span></div><div class="line">    <span class="built_in">CGFloat</span> arrowCenterY = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//获得了最终的center，而这个center同时适用于arrowView和loadingView，因为二者是不共存的。</span></div><div class="line">    <span class="built_in">CGPoint</span> arrowCenter = <span class="built_in">CGPointMake</span>(arrowCenterX, arrowCenterY);</div><div class="line">    </div><div class="line">    <span class="comment">// 箭头</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.arrowView.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//控件大小等于图片大小</span></div><div class="line">        <span class="keyword">self</span>.arrowView.mj_size = <span class="keyword">self</span>.arrowView.image.size;</div><div class="line">        <span class="keyword">self</span>.arrowView.center = arrowCenter;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">// 菊花</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.loadingView.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.loadingView.center = arrowCenter;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//arrowView的色调与stateLabel的字体颜色一致</span></div><div class="line">    <span class="keyword">self</span>.arrowView.tintColor = <span class="keyword">self</span>.stateLabel.textColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里注意一点：因为<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>是上下并排分布的，而<code>arrowView</code>或<code>loadingView</code>是在这二者的左边，所以为了避免这两组重合，在计算<code>arrowView</code>或<code>loadingView</code>的center的时候，需要获取<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>两个控件的宽度并比较大小，将较大的一个作为两个label的‘最宽距离’，再计算center，这样一来就不会重合了。<br>而对于如何计算宽度，作者给出了一个方案，大家可以在以后的实践中使用：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)mj_textWith &#123;</div><div class="line">    <span class="built_in">CGFloat</span> stringWidth = <span class="number">0</span>;</div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.text.length &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="meta">#if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span></div><div class="line">        stringWidth =[<span class="keyword">self</span>.text</div><div class="line">                      boundingRectWithSize:size</div><div class="line">                      options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></div><div class="line">                      attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:<span class="keyword">self</span>.font&#125;</div><div class="line">                      context:<span class="literal">nil</span>].size.width;</div><div class="line"><span class="meta">#else</span></div><div class="line">        </div><div class="line">        stringWidth = [<span class="keyword">self</span>.text sizeWithFont:<span class="keyword">self</span>.font</div><div class="line">                             constrainedToSize:size</div><div class="line">                                 lineBreakMode:<span class="built_in">NSLineBreakByCharWrapping</span>].width;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stringWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法3-setState"><a href="#方法3-setState" class="headerlink" title="方法3: setState:"></a>方法3: setState:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="comment">// 根据状态更新arrowView和loadingView的显示</span></div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//1. 设置为默认状态</span></div><div class="line">        <span class="keyword">if</span> (oldState == MJRefreshStateRefreshing) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//1.1 从正在刷新状态中切换过来</span></div><div class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            </div><div class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">                <span class="comment">//隐藏菊花</span></div><div class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">0.0</span>;</div><div class="line">                </div><div class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// 如果执行完动画发现不是idle状态，就直接返回，进入其他状态</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateIdle) <span class="keyword">return</span>;</div><div class="line">                <span class="comment">//菊花停止旋转</span></div><div class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>;</div><div class="line">                [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">                <span class="comment">//显示箭头</span></div><div class="line">                <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//1.2 从其他状态中切换过来</span></div><div class="line">            [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">            <span class="comment">//显示箭头并设置为初始状态</span></div><div class="line">            <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">                <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStatePulling) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//2. 设置为可以刷新状态</span></div><div class="line">        [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">            <span class="comment">//箭头倒立</span></div><div class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformMakeRotation</span>(<span class="number">0.000001</span> - M_PI);</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//3. 设置为正在刷新状态</span></div><div class="line">        <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>; <span class="comment">// 防止refreshing -&gt; idle的动画完毕动作没有被执行</span></div><div class="line">        <span class="comment">//菊花旋转</span></div><div class="line">        [<span class="keyword">self</span>.loadingView startAnimating];</div><div class="line">        <span class="comment">//隐藏arrowView</span></div><div class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此为止，我们已经从<code>MJRefreshComponent</code>到<code>MJRefreshNormalHeader</code>的实现过程看了一遍。可以看出，作者将<code>prepare</code>,<code>placeSubviews</code>以及<code>setState：</code>方法作为基类的方法，让下面的子类去一层一层实现。</p>
<p>而每一层的子类，根据自身的职责，分别按照自己的方式来实现这三个方法：</p>
<ul>
<li><code>MJRefreshHeader</code>: 负责header的高度和调整header自身在外部的位置。</li>
<li><code>MJRefreshStateHeader</code>:负责header内部的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>的布局和不同状态下内部文字的显示。</li>
<li><code>MJRefreshNormalHeader</code>:负责header内部的<code>loadingView</code>以及<code>arrowView</code>的布局和不同状态下的显示。</li>
</ul>
<p>这样做的好处是，如果想要增加某种类型的header，只要在某一层上做文章即可。例如该框架里的<code>MJRefreshGifHeader</code>,它和<code>MJRefreshNormalHeader</code>属于同一级，都是继承于<code>MJRefreshStateHeader</code>。因为二者都具有相同形式的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>，唯一不同的就是左侧的部分：</p>
<ul>
<li><code>MJRefreshNormalHeader</code>的左侧是箭头。</li>
<li><code>MJRefreshGifHeader</code>的左侧则是一个gif动画。</li>
</ul>
<p>还是提供一张图来直观感受一下：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_5.png" alt="normalHeader 与 gifHeader"></p>
<p>下面我们来看一下的实现：</p>
<h2 id="MJRefreshGifHeader"><a href="#MJRefreshGifHeader" class="headerlink" title="MJRefreshGifHeader"></a>MJRefreshGifHeader</h2><p>它提供了两个接口，是用来设置不同状态下使用的图片数组的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images duration:(<span class="built_in">NSTimeInterval</span>)duration forState:(MJRefreshState)state </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span> (images == <span class="literal">nil</span>) <span class="keyword">return</span>; </div><div class="line">    </div><div class="line">    <span class="comment">//设置不同状态下的图片组和持续时间</span></div><div class="line">    <span class="keyword">self</span>.stateImages[@(state)] = images; </div><div class="line">    <span class="keyword">self</span>.stateDurations[@(state)] = @(duration); </div><div class="line">    </div><div class="line">    <span class="comment">/* 根据图片设置控件的高度 */</span> </div><div class="line">    <span class="built_in">UIImage</span> *image = [images firstObject]; </div><div class="line">    <span class="keyword">if</span> (image.size.height &gt; <span class="keyword">self</span>.mj_h) &#123; </div><div class="line">        <span class="keyword">self</span>.mj_h = image.size.height; </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images forState:(MJRefreshState)state </div><div class="line">&#123; </div><div class="line">   <span class="comment">//如果没有传入duration，则根据图片的多少来计算</span></div><div class="line">    [<span class="keyword">self</span> setImages:images duration:images.count * <span class="number">0.1</span> forState:state]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="有哪些职能？-3"><a href="#有哪些职能？-3" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>然后，和<code>MJRefreshNormalHeader</code>一样，它也重写了基类提供的三个方法来实现显示gif图片的职能。</p>
<h3 id="职能如何实现？-4"><a href="#职能如何实现？-4" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化和label的间距<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化间距</span></div><div class="line">    <span class="keyword">self</span>.labelLeftInset = <span class="number">20</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####2. 根据label的宽度和存在与否设置gif的位置<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">//如果约束存在，就立即返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.gifView.constraints.count) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.gifView.frame = <span class="keyword">self</span>.bounds;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden &amp;&amp; <span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel都在隐藏状态，将gif剧中显示</span></div><div class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeCenter</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel中至少一个存在，则根据label的宽度设置gif的位置</span></div><div class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeRight</span>;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</div><div class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</div><div class="line">        <span class="keyword">self</span>.gifView.mj_w = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span> - textWidth * <span class="number">0.5</span> - <span class="keyword">self</span>.labelLeftInset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-根据传入状态的不同来设置动画"><a href="#3-根据传入状态的不同来设置动画" class="headerlink" title="3. 根据传入状态的不同来设置动画"></a>3. 根据传入状态的不同来设置动画</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//1. 如果传进来的状态是可以刷新和正在刷新</span></div><div class="line">        <span class="built_in">NSArray</span> *images = <span class="keyword">self</span>.stateImages[@(state)];</div><div class="line">        <span class="keyword">if</span> (images.count == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (images.count == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">//1.1 单张图片</span></div><div class="line">            <span class="keyword">self</span>.gifView.image = [images lastObject];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//1.2 多张图片</span></div><div class="line">            <span class="keyword">self</span>.gifView.animationImages = images;</div><div class="line">            <span class="keyword">self</span>.gifView.animationDuration = [<span class="keyword">self</span>.stateDurations[@(state)] doubleValue];</div><div class="line">            [<span class="keyword">self</span>.gifView startAnimating];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">        <span class="comment">//2.如果传进来的状态是默认状态</span></div><div class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>Footer类是用来处理上拉加载的，实现原理和下拉刷新很类似，在这里先不介绍了～</p>
<p>总的来说，该框架设计得非常工整：通过一个基类来定义一些状态和一些需要子类实现的接口。通过一层一层地继承，让每一层的子类各司其职，只完成真正属于自己的任务，提高了框架的可定制性，而且对于功能的扩展和bug的追踪也很有帮助，非常值得我们参考与借鉴。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot;&gt;MJRefresh&lt;/a&gt;是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。&lt;/p&gt;
&lt;p&gt;该框架的结构设计得很清晰，使用一个基类&lt;code&gt;MJRefreshComponent&lt;/code&gt;来做一些基本的设定，然后通过继承的方式，让&lt;code&gt;MJRefreshHeader&lt;/code&gt;和&lt;code&gt;MJRefreshFooter&lt;/code&gt;分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png&quot; alt=&quot;框架组织结构图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MBProgressHUD源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/MBProgressHUD源码解析/</id>
    <published>2018-02-02T16:17:34.000Z</published>
    <updated>2018-05-15T13:14:38.448Z</updated>
    
    <content type="html"><![CDATA[<p>听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的<strong>读好源码Project</strong>。</p>
<p>从哪个框架开始呢？我想到了<code>SDWebImage</code>，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～</p>
<a id="more"></a>
<p>找着找着就找到了<code>MBProgressHUD</code>，这个框架只有两个文件，一个头文件和一个实现文件，很适合我现在的水平（对于一个没怎么读过源码的选手），于是就撸起了袖子开始了。</p>
<p>连查知识点带记笔记一共花了大概3个小时（虽然文件很少，但是里面好多东西都不知道[捂脸]）。整体说来，收获还是比较大的，除了一些零碎的语法之外，框架作者对于代码结构的设计和各种情况的考虑还是很出色的，很值得学习，而且我在下文也有介绍。</p>
<p>这篇总结主要分三个部分来介绍这个框架：</p>
<ol>
<li>核心Public API</li>
<li>方法调用流程图</li>
<li>方法内部实现</li>
</ol>
<p>不多说了，开始吧～</p>
<h2 id="1-核心Public-API"><a href="#1-核心Public-API" class="headerlink" title="1. 核心Public API"></a>1. 核心Public API</h2><h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDMode mode;<span class="comment">//HUD的类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDAnimation animationType <span class="built_in">UI_APPEARANCE_SELECTOR</span>;<span class="comment">//动画类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> graceTime;<span class="comment">//show函数触发到显示HUD的时间段</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> minShowTime;<span class="comment">//HUD显示的最短时间</span></div></pre></td></tr></table></figure>
<h3 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在某个view上添加HUD并显示</div><div class="line"> *</div><div class="line"> * 注意：显示之前，先去掉在当前view上显示的HUD。这个做法很严谨，我们将这个方案抽象出来：如果一个模型是这样的：我们需要将A加入到B中，但是需求上B里面只允许只有一个A。那么每次将A添加到B之前，都要先判断当前的b里面是否有A，如果有，则移除。</div><div class="line"> */</div><div class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 找到某个view上最上层的HUD并隐藏它。</div><div class="line"> * 如果返回值是YES的话，就表明HUD被找到而且被移除了。</div><div class="line"> */</div><div class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 在某个view上找到最上层的HUD并返回它。</div><div class="line"> * 返回值可以是空，所以返回值的关键字为：nullable</div><div class="line"> */</div><div class="line">+ (<span class="keyword">nullable</span> MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view;</div></pre></td></tr></table></figure>
<h3 id="对象方法："><a href="#对象方法：" class="headerlink" title="对象方法："></a>对象方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个HUD的便利构造函数，用某个view来初始化HUD：这个view的bounds就是HUD的bounds</div><div class="line"> */</div><div class="line">- (<span class="keyword">instancetype</span>)initWithView:(<span class="built_in">UIView</span> *)view;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 显示HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 隐藏HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 在delay的时间过后隐藏HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</div></pre></td></tr></table></figure>
<p>看完了这些比较主要的API，我们看一下方法调用的流程图：</p>
<h2 id="2-方法调用流程图："><a href="#2-方法调用流程图：" class="headerlink" title="2. 方法调用流程图："></a>2. 方法调用流程图：</h2><p>总体来说，这个第三方框架的接口还是比较整齐的，可以大致上分为两类：显示（show）和隐藏（hide）。而且无论是调用显示方法还是隐藏方法，最终都会走到私有方法<code>animateIn:withType: completion:</code>里（前提是附加动画效果）。可以看一下方法调用的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-fe3f0f393bcc3b9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法调用流程图"></p>
<p>看完方法调用的结构之后，我们来具体看一下方法内部是如何实现的：</p>
<h2 id="3-方法内部实现："><a href="#3-方法内部实现：" class="headerlink" title="3. 方法内部实现："></a>3. 方法内部实现：</h2><p>在讲解API之前，有必要先介绍一下HUD使用的三个Timer。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *graceTimer; <span class="comment">//执行一次：在show方法触发后到HUD真正显示之前,前提是设定了graceTime，默认为0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *minShowTimer;<span class="comment">//执行一次：在HUD显示后到HUD被隐藏之前</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *hideDelayTimer;<span class="comment">//执行一次：在HUD被隐藏的方法触发后到真正隐藏之前</span></div></pre></td></tr></table></figure>
<ul>
<li>graceTimer：用来推迟HUD的显示。如果设定了graceTime，那么HUD会在<code>show</code>方法触发后的graceTime时间后显示。它的意义是：如果任务完成所消耗的时间非常短并且短于graceTime，则HUD就不会出现了，避免HUD一闪而过的差体验。</li>
<li>minShowTimer：如果设定了minShowTime，就会在<code>hide</code>方法触发后判断任务执行的时间是否短于minShowTime。因此即使任务在minShowTime之前完成了，HUD也不会立即消失，它会在走完minShowTime之后才消失，这应该也是避免HUD一闪而过的情况。</li>
<li>hideDelayTimer：用来推迟HUD的隐藏。如果设定了delayTime，那么在触发<code>hide</code>方法后HUD也不会立即隐藏，它会在走完delayTime之后才隐藏。</li>
</ul>
<p>这三者的关系可以由下面这张图来体现（并没有包含所有的情况）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c9f49bfcec64dd0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三种timer"></p>
<p>下面开始分别讲解<code>show</code>系列的方法和<code>hide</code>系列的方法。</p>
<h3 id="show系列方法"><a href="#show系列方法" class="headerlink" title="show系列方法"></a>show系列方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBProgressHUD *hud = [[<span class="keyword">self</span> alloc] initWithView:view];<span class="comment">// 接着调用 [self initWithFrame:view.bounds]：根据传进来的view的frame来设定自己的frame</span></div><div class="line">    hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;<span class="comment">//removeFromSuperViewOnHide 应该是一个标记，表明HUD自己处于“应该被移除的状态”</span></div><div class="line">    [view addSubview:hud];<span class="comment">//在view上将自己的实例添加上去</span></div><div class="line">    [hud showAnimated:animated];</div><div class="line">    <span class="keyword">return</span> hud;</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用showAnimated：</span></div><div class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBMainThreadAssert();</div><div class="line">    [<span class="keyword">self</span>.minShowTimer invalidate];<span class="comment">//取消当前的minShowTimer</span></div><div class="line">     <span class="keyword">self</span>.useAnimation = animated;<span class="comment">//设置animated状态</span></div><div class="line">     <span class="keyword">self</span>.finished = <span class="literal">NO</span>;<span class="comment">//添加标记：表明当前任务仍在进行</span></div><div class="line">    <span class="comment">// 如果设定了graceTime，就要推迟HUD的显示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.graceTime &gt; <span class="number">0.0</span>) &#123;</div><div class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.graceTime target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleGraceTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line">        <span class="keyword">self</span>.graceTimer = timer;</div><div class="line">    &#125; </div><div class="line">    <span class="comment">// ... otherwise show the HUD immediately</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//self.graceTimer触发的方法</span></div><div class="line">- (<span class="keyword">void</span>)handleGraceTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</div><div class="line">    <span class="comment">// Show the HUD only if the task is still running</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.hasFinished) &#123;</div><div class="line">        [<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//所有的show方法最终都会走到这个方法</span></div><div class="line">- (<span class="keyword">void</span>)showUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    <span class="comment">// Cancel any previous animations : 移走所有的动画</span></div><div class="line">    [<span class="keyword">self</span>.bezelView.layer removeAllAnimations];</div><div class="line">    [<span class="keyword">self</span>.backgroundView.layer removeAllAnimations];</div><div class="line">    <span class="comment">// Cancel any scheduled hideDelayed: calls :取消delay的timer</span></div><div class="line">    [<span class="keyword">self</span>.hideDelayTimer invalidate];</div><div class="line">    <span class="comment">//记忆开始的时间</span></div><div class="line">    <span class="keyword">self</span>.showStarted = [<span class="built_in">NSDate</span> date];</div><div class="line">    <span class="keyword">self</span>.alpha = <span class="number">1.</span>f;</div><div class="line">    <span class="comment">// Needed in case we hide and re-show with the same NSProgress object attached.</span></div><div class="line">    [<span class="keyword">self</span> setNSProgressDisplayLinkEnabled:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">if</span> (animated) &#123;        </div><div class="line">        [<span class="keyword">self</span> animateIn:<span class="literal">YES</span> withType:<span class="keyword">self</span>.animationType completion:<span class="literal">NULL</span>];   </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//方法弃用警告</span></div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">        <span class="keyword">self</span>.bezelView.alpha = <span class="keyword">self</span>.opacity;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，无论是类方法的show方法，还是对象方法的show方法，而且无论是触发了<code>graceTimer</code>还是没有触发，最后都会走到<code>showUsingAnimation:</code>方法来让HUD显示出来。</p>
</blockquote>
<p>这里补充讲解一下NSProgress的监听方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setNSProgressDisplayLinkEnabled:(<span class="built_in">BOOL</span>)enabled &#123;</div><div class="line">    <span class="comment">// 这里使用 CADisplayLink 来刷新progress的变化。因为如果使用kvo机制来监听的话可能会非常消耗主线程（因为频率可能非常快）。</span></div><div class="line">    <span class="keyword">if</span> (enabled &amp;&amp; <span class="keyword">self</span>.progressObject) &#123;</div><div class="line">        <span class="comment">// Only create if not already active.</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.progressObjectDisplayLink) &#123;</div><div class="line">            <span class="keyword">self</span>.progressObjectDisplayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateProgressFromProgressObject)];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//不刷新</span></div><div class="line">        <span class="keyword">self</span>.progressObjectDisplayLink = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。 CADisplayLink以特定模式注册到runloop后， 每当屏幕显示内容刷新结束的时候，runloop就会向 CADisplayLink指定的target发送一次指定的selector消息，  CADisplayLink类对应的selector就会被调用一次。<br>参考文章：<a href="http://www.tuicool.com/articles/meMVR3" target="_blank" rel="external">Core Animation系列之CADisplayLink</a></p>
</blockquote>
<h3 id="hide系列方法"><a href="#hide系列方法" class="headerlink" title="hide系列方法"></a>hide系列方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBProgressHUD *hud = [<span class="keyword">self</span> HUDForView:view];<span class="comment">//获取当前view的最前为止的HUD</span></div><div class="line">    <span class="keyword">if</span> (hud != <span class="literal">nil</span>) &#123;</div><div class="line">        hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;</div><div class="line">        [hud hideAnimated:animated];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line">+ (MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view &#123;   </div><div class="line">    <span class="built_in">NSEnumerator</span> *subviewsEnum = [view.subviews reverseObjectEnumerator]; <span class="comment">//倒叙排序</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> subviewsEnum) &#123;</div><div class="line">        <span class="keyword">if</span> ([subview isKindOfClass:<span class="keyword">self</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> (MBProgressHUD *)subview;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBMainThreadAssert();</div><div class="line">    [<span class="keyword">self</span>.graceTimer invalidate];</div><div class="line">     <span class="keyword">self</span>.useAnimation = animated;</div><div class="line">     <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">     <span class="comment">//如果设定了HUD最小显示时间，那就需要判断最小显示时间和已经经过的时间的大小</span></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</div><div class="line">        <span class="built_in">NSTimeInterval</span> interv = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:<span class="keyword">self</span>.showStarted];</div><div class="line">        </div><div class="line">        <span class="comment">//如果最小显示时间比较大，则暂时不触发HUD的隐藏，而是启动一个timer，再经过二者的时间差的时间之后再触发隐藏</span></div><div class="line">        <span class="keyword">if</span> (interv &lt; <span class="keyword">self</span>.minShowTime) &#123;</div><div class="line">            <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:(<span class="keyword">self</span>.minShowTime - interv) target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleMinShowTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line">            <span class="keyword">self</span>.minShowTimer = timer;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; </div><div class="line">     &#125;</div><div class="line">    <span class="comment">//如果最小显示时间比较小，则立即将HUD隐藏</span></div><div class="line">    [<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">&#125;</div><div class="line"><span class="comment">//self.minShowTimer触发的方法</span></div><div class="line">- (<span class="keyword">void</span>)handleMinShowTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</div><div class="line">    [<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)hideUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    <span class="keyword">if</span> (animated &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</div><div class="line">        <span class="comment">//隐藏时，将showStarted设为nil</span></div><div class="line">        <span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</div><div class="line">        [<span class="keyword">self</span> animateIn:<span class="literal">NO</span> withType:<span class="keyword">self</span>.animationType completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            [<span class="keyword">self</span> done];</div><div class="line">        &#125;];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">self</span>.bezelView.alpha = <span class="number">0.</span>f;</div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，无论是类方法的<code>hide</code>方法，还是对象方法的<code>hide</code>方法，而且无论是触发还是没有触发<code>minShowTimer</code>,最终都会走到<code>hideUsingAnimation</code>这个方法里。</p>
</blockquote>
<p>而无论是<code>show</code>方法，还是<code>hide</code>方法，在设定animated属性为YES的前提下，最终都会走到<code>animateIn: withType: completion:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)animateIn:(<span class="built_in">BOOL</span>)animatingIn withType:(MBProgressHUDAnimation)type completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completion &#123;</div><div class="line">    <span class="comment">// Automatically determine the correct zoom animation type</span></div><div class="line">    <span class="keyword">if</span> (type == MBProgressHUDAnimationZoom) &#123;</div><div class="line">        type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//()内代表x和y方向缩放倍数</span></div><div class="line">    <span class="built_in">CGAffineTransform</span> small = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</div><div class="line">    <span class="built_in">CGAffineTransform</span> large = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.5</span>f, <span class="number">1.5</span>f);</div><div class="line">    <span class="comment">// 设定初始状态</span></div><div class="line">    <span class="built_in">UIView</span> *bezelView = <span class="keyword">self</span>.bezelView;</div><div class="line">    <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</div><div class="line">        bezelView.transform = small;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</div><div class="line">        bezelView.transform = large;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建动画任务</span></div><div class="line">    dispatch_block_t animations = ^&#123;</div><div class="line">        <span class="keyword">if</span> (animatingIn) &#123;</div><div class="line">            bezelView.transform = <span class="built_in">CGAffineTransformIdentity</span>;<span class="comment">//重置</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</div><div class="line">            bezelView.transform = large;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</div><div class="line">            bezelView.transform = small;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">        bezelView.alpha = animatingIn ? <span class="keyword">self</span>.opacity : <span class="number">0.</span>f;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">       <span class="comment">//如果animatingIn是true，就是show方法，否则是hide方法</span></div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = animatingIn ? <span class="number">1.</span>f : <span class="number">0.</span>f;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// Spring animations are nicer, but only available on iOS 7+</span></div><div class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV</span></div><div class="line">    <span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;</div><div class="line">        <span class="comment">//执行动画 &gt;= iOS7</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> usingSpringWithDamping:<span class="number">1.</span>f initialSpringVelocity:<span class="number">0.</span>f options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>除了一些细节上的语法之外，我觉得该框架有几个地方值得我们借鉴：</p>
<ol>
<li>暴露出来的API最终都会走到同一个私有方法里。</li>
<li>将真正显示的时间的前后加上缓冲的时间（graceTimer 和 hideDelayTimer），可以提高可定制性和稳定性。</li>
<li>如果有两个方法是矛盾的，并且可以同时调用，就需要在全局设置一个属性来判断当前的状态（removeFromSuperViewOnHide属性，finished属性）</li>
<li>使用CADisplayLink来刷新更新频率可能很高的view。</li>
<li>使用NSAssert来捕获各种异常。</li>
</ol>
<p>就这样大致写完了，没有怎么读过第三方框架的源码，所以第一次可能显得稍许不足。有不好的地方还希望多多指点哈～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的&lt;strong&gt;读好源码Project&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从哪个框架开始呢？我想到了&lt;code&gt;SDWebImage&lt;/code&gt;，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JSONModel源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/JSONModel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/JSONModel源码解析/</id>
    <published>2018-02-02T16:17:27.000Z</published>
    <updated>2018-02-02T16:17:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列的<a href="http://www.jianshu.com/nb/9137726" target="_blank" rel="external">源码解析</a>分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。</p>
<p>想来想去，还是从<a href="https://github.com/jsonmodel/jsonmodel">JSONModel</a>开始吧～</p>
<p>首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。</p>
<p>该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。</p>
<a id="more"></a>
<p>在讲解源码之前，有必要先给不会使用JSONModel的同学们通过实际的例子来介绍一下它的使用方法（而且后面的源码解析部分也是结合这些例子给出的，因为结合例子有助于加快理解）：</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="1-最基本的使用"><a href="#1-最基本的使用" class="headerlink" title="1. 最基本的使用"></a>1. 最基本的使用</h2><p>第一种就是单纯地传入一个字典，并转换成模型：<br>首先我们需要定义我们自己的模型类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sex;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>然后再使用字典来转换为模型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                        <span class="string">@"gender"</span>:<span class="string">@"male"</span>,</div><div class="line">                      &#125;;</div><div class="line"> <span class="built_in">NSError</span> *error;</div><div class="line"> Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;Person&gt; </div><div class="line">   [name]: Jack</div><div class="line">   [sex]: male</div><div class="line">   [gender]: 23</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure></p>
<p>可以看出来，该框架的使用非常方便，一行代码就将模型转换好了。<br>但是该框架的功能远不止这些：</p>
<h2 id="2-转换属性名称"><a href="#2-转换属性名称" class="headerlink" title="2. 转换属性名称"></a>2. 转换属性名称</h2><p>有的时候，传入的字典里的key发生了变化（比如接口重构之类的原因），但是我们前端这边已经写好的模型属性可能不容易被修改（因为业务逻辑很复杂什么的），所以这个时候，最好有一个转化的功能。</p>
<p>在这里举个例子：原来字典里的<code>gender</code>这个key变成了<code>sex</code>，这就需要我们定义一个转换的mapper（<code>JSONKeyMapper</code>）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">+ (JSONKeyMapper *)keyMapper</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[JSONKeyMapper alloc] initWithModelToJSONDictionary:@&#123;</div><div class="line">                                                                  <span class="string">@"gender"</span>: <span class="string">@"sex"</span>,                                                             &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一来，<code>JSONKeyMapper</code>就会自动帮我们做转换。<br>为了验证效果，我们修改一下传入的字典里的<code>gender</code>字段为<code>sex</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                        <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</div><div class="line">                      &#125;;</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>再看一下输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Person&gt; </div><div class="line">   [name]: Jack</div><div class="line">   [age]: 23</div><div class="line">   [gender]: male</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure>
<p>没有受到传入字典里key值的变化的影响，是吧？</p>
<h2 id="3-自定义错误"><a href="#3-自定义错误" class="headerlink" title="3. 自定义错误"></a>3. 自定义错误</h2><p>除了一些框架里自己处理的错误（比如传入的对象不是字典等），框架的作者也允许我们自己定义属于我们自己的错误。</p>
<p>比如，当<code>age</code>对应的数值小于25的时候，打印出<code>Too young!</code>,并阻止模型的转换：</p>
<p>首先，我们在模型的实现文件里添加：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validate:(<span class="built_in">NSError</span> **)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">super</span> validate:error])</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.age &lt; <span class="number">25</span>)</div><div class="line">    &#123;</div><div class="line">        *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Too young!"</span> code:<span class="number">10</span> userInfo:<span class="literal">nil</span>];</div><div class="line">        <span class="built_in">NSError</span> *errorLog = *error;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,errorLog.domain);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] Too young!</div><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] (null)</div></pre></td></tr></table></figure></p>
<p>打印了错误，而且模型也没有被转换。</p>
<h2 id="4-模型嵌套"><a href="#4-模型嵌套" class="headerlink" title="4. 模型嵌套"></a>4. 模型嵌套</h2><p>有的时候，我们需要在模型里加一个数组，而这个数组里面的元素是另一个对象：这就涉及到了模型的嵌套。</p>
<p>举个例子，我们让上面的<code>Person</code>对象含有一个数组<code>Friends</code>，它里面的元素是对象<code>Friend</code>，也就是好友信息。若要实现模型的嵌套，我们只需在原来的模型类里增加一个协议<code>Friend</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"JSONModel.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Friend</span>;</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Friend</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;Friend&gt; *friends;<span class="comment">//数组，嵌套模型</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>而且要在<code>Person</code>的实现文件里加上这一段代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Friend</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意！如果不添加，则会令程序崩溃。</p>
<p>最后，在使用的时候，我们只需将持有一个数组的字典里传入即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[</div><div class="line">                      @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Peter"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">35</span>,</div><div class="line">                        &#125;,</div><div class="line">                   ];</div><div class="line">    </div><div class="line"> <span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                           <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                           <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                           <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</div><div class="line">                           <span class="string">@"friends"</span>:array,<span class="comment">//朋友列表（模型嵌套）</span></div><div class="line">                         &#125;;</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person);</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Person&gt; </div><div class="line">   [age]: 23</div><div class="line">   [gender]: male</div><div class="line">   [friends]: (</div><div class="line">       "&lt;Friend&gt; \n   [name]: Peter\n   [age]: 35\n&lt;/Friend&gt;"</div><div class="line">   )</div><div class="line">   [name]: Jack</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，person对象里含有一个数组，这个数组只有一个元素，对应着上面字典里的array里的信息。</p>
<p>OK，这样一来，大家已经可以掌握该框架的主要用法了，现在开始详细讲解代码：</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>本篇源码解析主要围绕着<code>initWithDictionary:error:</code>来展开，在这一个方法里作者做到了所有的容错和模型的转化。</p>
<p>按照老规矩，先上流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-94b356eeb7b560e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字典-&gt;模型"></p>
<p>该流程图对应的方法实现是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//方法1. 参数为nil</span></div><div class="line">    <span class="keyword">if</span> (!dict) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法2. 参数不是nil，但也不是字典</span></div><div class="line">    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法3. 初始化</span></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//初始化失败</span></div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO）</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span>.__keyMapper error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法5. 核心方法：字典的key与模型的属性的映射</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span>.__keyMapper validation:<span class="literal">YES</span> error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法7. 终于通过了！成功返回model</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>方法1-4:都是对错误的发现与处理。</li>
<li>方法5:是真正的mapping。</li>
<li>方法6:是作者给用户自己定义错误的方法，如果复合了用户自己定义的错误，那么即使mapping成功了，也要返回nil。<br>-方法7:成功返回模型对象。</li>
</ul>
<p>在讲解代码之前，有必要先了解一下JSONModel所持有的一些数据：</p>
<ul>
<li><p><strong>关联对象kClassPropertiesKey</strong>:(用来保存所有属性信息的NSDictionary)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       age = <span class="string">"@property primitive age (Setters = [])"</span>;</div><div class="line">      name = <span class="string">"@property NSString* name (Standard JSON type, Setters = [])"</span>;</div><div class="line">    gender = <span class="string">"@property NSString* gender (Standard JSON type, Setters = [])"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>关联对象kClassRequiredPropertyNamesKey</strong>：(用来保存所有属性的名称NSSet)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;(</div><div class="line">    name,</div><div class="line">    age,</div><div class="line">    gender</div><div class="line">)&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>关联对象kMapperObjectKey</strong>：(用来保存JSONKeyMapper)：自定义的mapper，具体的使用方法在上面的例子中可以看到。</p>
</li>
</ul>
<ul>
<li><strong>JSONModelClassProperty</strong>：封装的jsonmodel的一个属性，它包含了对应属性的名字（name：gender），类型（type：NSString），是否是JSONModel支持的类型（isStandardJSONType：YES/NO），是否是可变对象（isMutable:YES/NO）等属性。</li>
</ul>
<p>再大致讲解一下整个的流程：<br>首先，在这个模型类的对象被初始化的时候，遍历自身到所有的父类（直到JSONModel为止），获取所有的属性，并将其保存在一个字典里。获取传入字典的所有key，将这些key与保存的所有属性进行匹配。如果匹配成功，则进行kvc赋值。</p>
<p>OK，现在从上到下逐步讲解上段代码：</p>
<p>首先，在<code>load</code>方法里，定义了该框架支持的类型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;           </div><div class="line">            <span class="comment">//兼容的对象属性</span></div><div class="line">            allowedJSONTypes = @[</div><div class="line">                [<span class="built_in">NSString</span> <span class="keyword">class</span>], [<span class="built_in">NSNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSDecimalNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>], [<span class="built_in">NSDictionary</span> <span class="keyword">class</span>], [<span class="built_in">NSNull</span> <span class="keyword">class</span>], <span class="comment">//immutable JSON classes</span></div><div class="line">                [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>] <span class="comment">//mutable JSON classes</span></div><div class="line">            ];</div><div class="line">            <span class="comment">//兼容的基本类型属性</span></div><div class="line">            allowedPrimitiveTypes = @[</div><div class="line">                <span class="string">@"BOOL"</span>, <span class="string">@"float"</span>, <span class="string">@"int"</span>, <span class="string">@"long"</span>, <span class="string">@"double"</span>, <span class="string">@"short"</span>,</div><div class="line">                <span class="comment">//and some famous aliases</span></div><div class="line">                <span class="string">@"NSInteger"</span>, <span class="string">@"NSUInteger"</span>,</div><div class="line">                <span class="string">@"Block"</span></div><div class="line">            ];</div><div class="line">            <span class="comment">//转换器</span></div><div class="line">            valueTransformer = [[JSONValueTransformer alloc] init];</div><div class="line">            </div><div class="line">            <span class="comment">//自己的类型</span></div><div class="line">            JSONModelClass = <span class="built_in">NSClassFromString</span>(<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们看一下从方法3的init方法开始，作者都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> __setup__];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)__setup__</div><div class="line">&#123;</div><div class="line">    <span class="comment">//只有第一次实例化时，才执行</span></div><div class="line">    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kClassPropertiesKey)) &#123;</div><div class="line">        [<span class="keyword">self</span> __inspectProperties];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果存在自定义的mapper，则将它保存在关联对象里面，key是kMapperObjectKey</span></div><div class="line">    <span class="keyword">id</span> mapper = [[<span class="keyword">self</span> <span class="keyword">class</span>] keyMapper];</div><div class="line">    <span class="keyword">if</span> ( mapper &amp;&amp; !objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kMapperObjectKey) ) &#123;</div><div class="line">        objc_setAssociatedObject(</div><div class="line">                                 <span class="keyword">self</span>.class,</div><div class="line">                                 &amp;kMapperObjectKey,</div><div class="line">                                 mapper,</div><div class="line">                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></div><div class="line">                                 );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得注意的是，这里的<code>__inspectProperties:</code>方法是该框架的核心方法之一：它的任务是保存了所有需要赋值的属性。用作在将来与传进来字典进行映射：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)__inspectProperties</div><div class="line">&#123;</div><div class="line"><span class="comment">//    最终保存所有属性的字典，形式为：</span></div><div class="line"><span class="comment">//    &#123;</span></div><div class="line"><span class="comment">//        age = "@property primitive age (Setters = [])";</span></div><div class="line"><span class="comment">//        friends = "@property NSArray*&lt;Friend&gt; friends (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//        gender = "@property NSString* gender (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//        name = "@property NSString* name (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span>* propertyIndex = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    <span class="comment">//获取当前的类名</span></div><div class="line">    Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];    </div><div class="line">    <span class="built_in">NSScanner</span>* scanner = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSString</span>* propertyType = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 循环条件：当class 是 JSONModel自己的时候终止</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">class</span> != [JSONModel <span class="keyword">class</span>]) &#123;        </div><div class="line">        <span class="comment">//属性的个数</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</div><div class="line">        <span class="comment">//获得属性列表（所有@property声明的属性）</span></div><div class="line">        objc_property_t *properties = class_copyPropertyList(<span class="keyword">class</span>, &amp;propertyCount);</div><div class="line">        <span class="comment">//遍历所有的属性</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</div><div class="line">            <span class="comment">//获得属性名称</span></div><div class="line">            objc_property_t property = properties[i];<span class="comment">//获得当前的属性</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);<span class="comment">//name（C字符串）            </span></div><div class="line">            <span class="comment">//JSONModel里的每一个属性，都被封装成一个JSONModelClassProperty对象</span></div><div class="line">            JSONModelClassProperty* p = [[JSONModelClassProperty alloc] init];</div><div class="line">            p.name = @(propertyName);<span class="comment">//propertyName:属性名称，例如：name，age，gender</span></div><div class="line">            <span class="comment">//获得属性类型</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *attrs = property_getAttributes(property);</div><div class="line">            <span class="built_in">NSString</span>* propertyAttributes = @(attrs);</div><div class="line">            <span class="comment">// T@\"NSString\",C,N,V_name</span></div><div class="line">            <span class="comment">// Tq,N,V_age</span></div><div class="line">            <span class="comment">// T@\"NSString\",C,N,V_gender</span></div><div class="line">            <span class="comment">// T@"NSArray&lt;Friend&gt;",&amp;,N,V_friends            </span></div><div class="line">            <span class="built_in">NSArray</span>* attributeItems = [propertyAttributes componentsSeparatedByString:<span class="string">@","</span>];</div><div class="line">            <span class="comment">//说明是只读属性，不做任何操作</span></div><div class="line">            <span class="keyword">if</span> ([attributeItems containsObject:<span class="string">@"R"</span>]) &#123;</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">//to next property</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//检查出是布尔值</span></div><div class="line">            <span class="keyword">if</span> ([propertyAttributes hasPrefix:<span class="string">@"Tc,"</span>]) &#123;</div><div class="line">                p.structName = <span class="string">@"BOOL"</span>;<span class="comment">//使其变为结构体</span></div><div class="line">            &#125;            </div><div class="line">            <span class="comment">//实例化一个scanner</span></div><div class="line">            scanner = [<span class="built_in">NSScanner</span> scannerWithString: propertyAttributes];</div><div class="line">            [scanner scanUpToString:<span class="string">@"T"</span> intoString: <span class="literal">nil</span>];</div><div class="line">            [scanner scanString:<span class="string">@"T"</span> intoString:<span class="literal">nil</span>];</div><div class="line">            <span class="comment">//http://blog.csdn.net/kmyhy/article/details/8258858           </span></div><div class="line">            <span class="keyword">if</span> ([scanner scanString:<span class="string">@"@\""</span> intoString: &amp;propertyType]) &#123;                </div><div class="line">                 <span class="comment">//属性是一个对象</span></div><div class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@"\"&lt;"</span>]</div><div class="line">                                        intoString:&amp;propertyType];<span class="comment">//propertyType -&gt; NSString                </span></div><div class="line">                p.type = <span class="built_in">NSClassFromString</span>(propertyType);<span class="comment">// p.type = @"NSString"</span></div><div class="line">                p.isMutable = ([propertyType rangeOfString:<span class="string">@"Mutable"</span>].location != <span class="built_in">NSNotFound</span>); <span class="comment">//判断是否是可变的对象</span></div><div class="line">                p.isStandardJSONType = [allowedJSONTypes containsObject:p.type];<span class="comment">//是否是该框架兼容的类型</span></div><div class="line">                <span class="comment">//存在协议(数组，也就是嵌套模型)</span></div><div class="line">                <span class="keyword">while</span> ([scanner scanString:<span class="string">@"&lt;"</span> intoString:<span class="literal">NULL</span>]) &#123;</div><div class="line">                    <span class="built_in">NSString</span>* protocolName = <span class="literal">nil</span>;</div><div class="line">                    [scanner scanUpToString:<span class="string">@"&gt;"</span> intoString: &amp;protocolName];</div><div class="line">                    <span class="keyword">if</span> ([protocolName isEqualToString:<span class="string">@"Optional"</span>]) &#123;</div><div class="line">                        p.isOptional = <span class="literal">YES</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Index"</span>]) &#123;</div><div class="line"><span class="meta">#pragma GCC diagnostic push</span></div><div class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">                        p.isIndex = <span class="literal">YES</span>;</div><div class="line"><span class="meta">#pragma GCC diagnostic pop</span></div><div class="line">                        objc_setAssociatedObject(</div><div class="line">                                                 <span class="keyword">self</span>.class,</div><div class="line">                                                 &amp;kIndexPropertyNameKey,</div><div class="line">                                                 p.name,</div><div class="line">                                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></div><div class="line">                                                 );</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Ignore"</span>]) &#123;</div><div class="line">                        p = <span class="literal">nil</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        p.protocol = protocolName;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//到最接近的&gt;为止</span></div><div class="line">                    [scanner scanString:<span class="string">@"&gt;"</span> intoString:<span class="literal">NULL</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;            </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ([scanner scanString:<span class="string">@"&#123;"</span> intoString: &amp;propertyType])                </div><div class="line">                <span class="comment">//属性是结构体</span></div><div class="line">                [scanner scanCharactersFromSet:[<span class="built_in">NSCharacterSet</span> alphanumericCharacterSet]</div><div class="line">                                    intoString:&amp;propertyType];</div><div class="line">                p.isStandardJSONType = <span class="literal">NO</span>;</div><div class="line">                p.structName = propertyType;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//属性是基本类型：Tq,N,V_age</span></div><div class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@","</span>]</div><div class="line">                                        intoString:&amp;propertyType];</div><div class="line">                <span class="comment">//propertyType:q</span></div><div class="line">                propertyType = valueTransformer.primitivesNames[propertyType];              </div><div class="line">                <span class="comment">//propertyType:long</span></div><div class="line">                <span class="comment">//基本类型数组</span></div><div class="line">                <span class="keyword">if</span> (![allowedPrimitiveTypes containsObject:propertyType]) &#123;</div><div class="line">                    <span class="comment">//类型不支持</span></div><div class="line">                    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"JSONModelProperty type not allowed"</span></div><div class="line">                                                   reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Property type of %@.%@ is not supported by JSONModel."</span>, <span class="keyword">self</span>.class, p.name]</div><div class="line">                                                 userInfo:<span class="literal">nil</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSString</span> *nsPropertyName = @(propertyName);            </div><div class="line">            <span class="comment">//可选的</span></div><div class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsOptional:nsPropertyName])&#123;</div><div class="line">                p.isOptional = <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//可忽略的</span></div><div class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsIgnored:nsPropertyName])&#123;</div><div class="line">                p = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//集合类</span></div><div class="line">            Class customClass = [[<span class="keyword">self</span> <span class="keyword">class</span>] classForCollectionProperty:nsPropertyName];            </div><div class="line">            <span class="keyword">if</span> (customClass) &#123;</div><div class="line">                p.protocol = <span class="built_in">NSStringFromClass</span>(customClass);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//忽略block</span></div><div class="line">            <span class="keyword">if</span> ([propertyType isEqualToString:<span class="string">@"Block"</span>]) &#123;</div><div class="line">                p = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果字典里不存在，则添加到属性字典里（终于添加上去了。。。）</span></div><div class="line">            <span class="keyword">if</span> (p &amp;&amp; ![propertyIndex objectForKey:p.name]) &#123;</div><div class="line">                [propertyIndex setValue:p forKey:p.name];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//setter 和 getter</span></div><div class="line">            <span class="keyword">if</span> (p)</div><div class="line">            &#123;   <span class="comment">//name -&gt;Name</span></div><div class="line">                <span class="built_in">NSString</span> *name = [p.name stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:[p.name substringToIndex:<span class="number">1</span>].uppercaseString];</div><div class="line">                <span class="comment">// getter</span></div><div class="line">                SEL <span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"JSONObjectFor%@"</span>, name]);</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>])</div><div class="line">                    p.customGetter = <span class="keyword">getter</span>;</div><div class="line">                <span class="comment">// setters</span></div><div class="line">                p.customSetters = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">                SEL genericSetter = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@WithJSONObject:"</span>, name]);</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:genericSetter])</div><div class="line">                    p.customSetters[<span class="string">@"generic"</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;genericSetter objCType:<span class="keyword">@encode</span>(SEL)];</div><div class="line">                <span class="keyword">for</span> (Class type <span class="keyword">in</span> allowedJSONTypes)</div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">NSString</span> *<span class="keyword">class</span> = <span class="built_in">NSStringFromClass</span>([JSONValueTransformer classByResolvingClusterClasses:type]);</div><div class="line">                    <span class="keyword">if</span> (p.customSetters[<span class="keyword">class</span>])</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    SEL <span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@With%@:"</span>, name, <span class="keyword">class</span>]);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">setter</span>])</div><div class="line">                        p.customSetters[<span class="keyword">class</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;<span class="keyword">setter</span> objCType:<span class="keyword">@encode</span>(SEL)];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        free(properties);</div><div class="line">        <span class="comment">//再指向自己的父类，知道等于JSONModel才停止</span></div><div class="line">        <span class="keyword">class</span> = [<span class="keyword">class</span> superclass];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//最后保存所有当前类，JSONModel的所有的父类的属性</span></div><div class="line">    objc_setAssociatedObject(</div><div class="line">                             <span class="keyword">self</span>.class,</div><div class="line">                             &amp;kClassPropertiesKey,</div><div class="line">                             [propertyIndex <span class="keyword">copy</span>],</div><div class="line">                             OBJC_ASSOCIATION_RETAIN</div><div class="line">                             );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意几点：</p>
<ol>
<li>作者利用一个<code>while</code>函数，获取当前类和当前类的除JSONModel的所有父类的属性保存在一个字典中。在将来用于和传入的字典进行映射。</li>
<li>作者用<code>JSONModelClassProperty</code>类封装了JSONModel的每一个属性。这个类有两个重要的属性：一个是<code>name</code>，它是属性的名称(例如gender)。另一个是<code>type</code>，它是属性的类型（例如NSString）。</li>
<li>作者将属性分为了如下几个类型：<ol>
<li>对象（不含有协议）。</li>
<li>对象（含有协议，属于模型嵌套）。</li>
<li>基本数据类型。</li>
<li>结构体。</li>
</ol>
</li>
</ol>
</blockquote>
<p>我们来看一下方法4的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)__doesDictionary:(<span class="built_in">NSDictionary</span>*)dict matchModelWithKeyMapper:(JSONKeyMapper*)keyMapper error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//拿到字典里所有的key</span></div><div class="line">    <span class="built_in">NSArray</span>* incomingKeysArray = [dict allKeys];    </div><div class="line">    <span class="comment">//返回保存所有属性名称的数组(name,age,gender...)</span></div><div class="line">    <span class="built_in">NSMutableSet</span>* requiredProperties = [<span class="keyword">self</span> __requiredPropertyNames].mutableCopy;    </div><div class="line">    <span class="comment">//从array拿到set</span></div><div class="line">    <span class="built_in">NSSet</span>* incomingKeys = [<span class="built_in">NSSet</span> setWithArray: incomingKeysArray];</div><div class="line">    <span class="comment">//如果用户自定义了mapper，则进行转换</span></div><div class="line">    <span class="keyword">if</span> (keyMapper || globalKeyMapper) &#123;</div><div class="line">        <span class="built_in">NSMutableSet</span>* transformedIncomingKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity: requiredProperties.count];</div><div class="line">        <span class="built_in">NSString</span>* transformedName = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//便利需要转换的属性列表</span></div><div class="line">        <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</div><div class="line">            <span class="comment">//被转换成的属性名称 gender（模型内） -&gt; sex（字典内）</span></div><div class="line">            transformedName = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</div><div class="line">            <span class="comment">//拿到sex以后，查看传入的字典里是否有sex对应的值</span></div><div class="line">            <span class="keyword">id</span> value;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                value = [dict valueForKeyPath:transformedName];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                value = dict[transformedName];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果值存在，则将sex添加到传入的keys数组中</span></div><div class="line">            <span class="keyword">if</span> (value) &#123;</div><div class="line">                [transformedIncomingKeys addObject: property.name];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        incomingKeys = transformedIncomingKeys;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//查看当前的model的属性的集合是否大于传入的属性集合，如果是，则返回错误。</span></div><div class="line">    <span class="comment">//也就是说模型类里的属性是不能多于传入字典里的key的，例如：</span></div><div class="line">    <span class="keyword">if</span> (![requiredProperties isSubsetOfSet:incomingKeys]) &#123;</div><div class="line">        <span class="comment">//获取多出来的属性</span></div><div class="line">        [requiredProperties minusSet:incomingKeys];</div><div class="line">        <span class="comment">//not all required properties are in - invalid input</span></div><div class="line">        JMLog(<span class="string">@"Incoming data was invalid [%@ initWithDictionary:]. Keys missing: %@"</span>, <span class="keyword">self</span>.class, requiredProperties);</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMissingKeys:requiredProperties];</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不需要了，释放掉</span></div><div class="line">    incomingKeys= <span class="literal">nil</span>;</div><div class="line">    requiredProperties= <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里需要需要注意的：</p>
<ol>
<li>model类里面定义的属性集合是不能大于传入的字典里的key集合的。</li>
<li>如果存在了用户自定义的mapper，则需要按照用户的定义来进行转换。<br>（在这里是奖gender转换为了sex）。</li>
</ol>
</blockquote>
<p>最后来看一下本框架第二个核心代码(上面的方法5)，也就是真正从字典里获取值并赋给当前模型对象的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)__importDictionary:(<span class="built_in">NSDictionary</span>*)dict withKeyMapper:(JSONKeyMapper*)keyMapper validation:(<span class="built_in">BOOL</span>)validation error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//遍历保存的所有属性的字典</span></div><div class="line">    <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</div><div class="line">        <span class="comment">//将属性的名称拿过来，作为key，用这个key来查找传进来的字典里对应的值</span></div><div class="line">        <span class="built_in">NSString</span>* jsonKeyPath = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</div><div class="line">        <span class="comment">//用来保存从字典里获取的值</span></div><div class="line">        <span class="keyword">id</span> jsonValue;        </div><div class="line">        <span class="keyword">@try</span> &#123;</div><div class="line">            jsonValue = [dict valueForKeyPath: jsonKeyPath];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">            jsonValue = dict[jsonKeyPath];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//字典不存在对应的key</span></div><div class="line">        <span class="keyword">if</span> (isNull(jsonValue)) &#123;</div><div class="line">            <span class="comment">//如果这个key是可以不存在的</span></div><div class="line">            <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;            </div><div class="line">            <span class="comment">//如果这个key是必须有的，则返回错误</span></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Value of required model key %@ is null"</span>, property.name];</div><div class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//获取 取到的值的类型</span></div><div class="line">        Class jsonValueClass = [jsonValue <span class="keyword">class</span>];</div><div class="line">        <span class="built_in">BOOL</span> isValueOfAllowedType = <span class="literal">NO</span>;</div><div class="line">        <span class="comment">//查看是否是本框架兼容的属性类型</span></div><div class="line">        <span class="keyword">for</span> (Class allowedType <span class="keyword">in</span> allowedJSONTypes) &#123;</div><div class="line">            <span class="keyword">if</span> ( [jsonValueClass isSubclassOfClass: allowedType] ) &#123;</div><div class="line">                isValueOfAllowedType = <span class="literal">YES</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//如果不兼容，则返回NO，mapping失败</span></div><div class="line">        <span class="keyword">if</span> (isValueOfAllowedType==<span class="literal">NO</span>) &#123;</div><div class="line">            <span class="comment">//type not allowed</span></div><div class="line">            JMLog(<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass));</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass)];</div><div class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是兼容的类型：</span></div><div class="line">        <span class="keyword">if</span> (property) &#123;</div><div class="line">            <span class="comment">// 查看是否有自定义setter，并设置</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __customSetValue:jsonValue forProperty:property]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 基本类型</span></div><div class="line">            <span class="keyword">if</span> (property.type == <span class="literal">nil</span> &amp;&amp; property.structName==<span class="literal">nil</span>) &#123;</div><div class="line">                <span class="comment">//kvc赋值</span></div><div class="line">                <span class="keyword">if</span> (jsonValue != [<span class="keyword">self</span> valueForKey:property.name]) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果传来的值是空，即使当前的属性对应的值不是空，也要将空值赋给它</span></div><div class="line">            <span class="keyword">if</span> (isNull(jsonValue)) &#123;</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> valueForKey:property.name] != <span class="literal">nil</span>) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:<span class="literal">nil</span> forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 1. 属性本身是否是jsonmodel类型</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __isJSONModelSubClass:property.type]) &#123;</div><div class="line">                <span class="comment">//通过自身的转模型方法，获取对应的值</span></div><div class="line">                JSONModelError* initErr = <span class="literal">nil</span>;</div><div class="line">                <span class="keyword">id</span> value = [[property.type alloc] initWithDictionary: jsonValue error:&amp;initErr];</div><div class="line">                <span class="keyword">if</span> (!value) &#123;               </div><div class="line">                    <span class="comment">//如果该属性不是必须的，则略过</span></div><div class="line">                    <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;</div><div class="line">                    <span class="comment">//如果该属性是必须的，则返回错误</span></div><div class="line">                    <span class="keyword">if</span>((err != <span class="literal">nil</span>) &amp;&amp; (initErr != <span class="literal">nil</span>))</div><div class="line">                    &#123;</div><div class="line">                        *err = [initErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;            </div><div class="line">                <span class="comment">//当前的属性值为空，则赋值</span></div><div class="line">                <span class="keyword">if</span> (![value isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:value forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果不是jsonmodel的类型，则可能是一些普通的类型：NSArray，NSString。。。</span></div><div class="line">                <span class="comment">// 是否是模型嵌套（带有协议）</span></div><div class="line">                <span class="keyword">if</span> (property.protocol) &#123;</div><div class="line">                    <span class="comment">//转化为数组，这个数组就是例子中的friends属性。</span></div><div class="line">                    jsonValue = [<span class="keyword">self</span> __transform:jsonValue forProperty:property error:err];</div><div class="line">                   </div><div class="line">                    <span class="keyword">if</span> (!jsonValue) &#123;</div><div class="line">                        <span class="keyword">if</span> ((err != <span class="literal">nil</span>) &amp;&amp; (*err == <span class="literal">nil</span>)) &#123;</div><div class="line">                            <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Failed to transform value, but no error was set during transformation. (%@)"</span>, property];</div><div class="line">                            JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                            *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 对象类型</span></div><div class="line">                <span class="keyword">if</span> (property.isStandardJSONType &amp;&amp; [jsonValue isKindOfClass: property.type]) &#123;</div><div class="line">                    <span class="comment">//可变类型</span></div><div class="line">                    <span class="keyword">if</span> (property.isMutable) &#123;</div><div class="line">                        jsonValue = [jsonValue mutableCopy];</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//赋值</span></div><div class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</div><div class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 当前的值的类型与对应的属性的类型不一样的时候，需要查看用户是否自定义了转换器（例如从NSSet到NSArray转换：- (NSSet *)NSSetFromNSArray:(NSArray *)array）</span></div><div class="line">                <span class="keyword">if</span> (</div><div class="line">                    (![jsonValue isKindOfClass:property.type] &amp;&amp; !isNull(jsonValue))</div><div class="line">                    ||</div><div class="line">                    <span class="comment">//the property is mutable</span></div><div class="line">                    property.isMutable</div><div class="line">                    ||</div><div class="line">                    <span class="comment">//custom struct property</span></div><div class="line">                    property.structName</div><div class="line">                    ) &#123;</div><div class="line">                    <span class="comment">// searched around the web how to do this better</span></div><div class="line">                    <span class="comment">// but did not find any solution, maybe that's the best idea? (hardly)</span></div><div class="line">                    Class sourceClass = [JSONValueTransformer classByResolvingClusterClasses:[jsonValue <span class="keyword">class</span>]];</div><div class="line">                    <span class="comment">//JMLog(@"to type: [%@] from type: [%@] transformer: [%@]", p.type, sourceClass, selectorName);</span></div><div class="line"></div><div class="line">                    <span class="comment">//build a method selector for the property and json object classes</span></div><div class="line">                    <span class="built_in">NSString</span>* selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@From%@:"</span>,</div><div class="line">                                              (property.structName? property.structName : property.type), <span class="comment">//target name</span></div><div class="line">                                              sourceClass]; <span class="comment">//source name</span></div><div class="line">                    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line">                    <span class="comment">//查看自定义的转换器是否存在</span></div><div class="line">                    <span class="built_in">BOOL</span> foundCustomTransformer = <span class="literal">NO</span>;</div><div class="line">                    <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</div><div class="line">                        foundCustomTransformer = <span class="literal">YES</span>;                        </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//try for hidden custom transformer</span></div><div class="line">                        selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"__%@"</span>,selectorName];</div><div class="line">                        selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line">                        <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</div><div class="line">                            foundCustomTransformer = <span class="literal">YES</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//如果存在自定义转换器，则进行转换</span></div><div class="line">                    <span class="keyword">if</span> (foundCustomTransformer) &#123;                        </div><div class="line">                        IMP imp = [valueTransformer methodForSelector:selector];</div><div class="line">                        <span class="keyword">id</span> (*func)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)imp;</div><div class="line">                        jsonValue = func(valueTransformer, selector, jsonValue);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">                            [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];                        </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;                       </div><div class="line">                        <span class="comment">//没有自定义转换器，返回错误</span></div><div class="line">                        <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ type not supported for %@.%@"</span>, property.type, [<span class="keyword">self</span> <span class="keyword">class</span>], property.name];</div><div class="line">                        JSONModelError* dataErr = [JSONModelError errorInvalidDataWithTypeMismatch:msg];</div><div class="line">                        *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;                        </div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 3.4) handle "all other" cases (if any)</span></div><div class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是：</p>
<ul>
<li>作者在最后给属性赋值的时候使用的是kvc的<code>setValue:ForKey:</code>的方法。</li>
<li>作者判断了模型里的属性的类型是否是JSONModel的子类，可见作者的考虑是非常周全的。</li>
<li>整个框架看下来，有很多的地方涉及到了错误判断，作者将将错误类型单独抽出一个类（<code>JSONModelError</code>），里面支持的错误类型很多，可以侧面反应作者思维之缜密。而且这个做法也可以在我们写自己的框架或者项目中使用。</li>
</ul>
</blockquote>
<p>错误判断的一个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JSONModelError.m</span></div><div class="line">+(<span class="keyword">id</span>)errorInvalidDataWithMessage:(<span class="built_in">NSString</span>*)message</div><div class="line">&#123;</div><div class="line">    message = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Invalid JSON data: %@"</span>, message];</div><div class="line">    <span class="keyword">return</span> [JSONModelError errorWithDomain:JSONModelErrorDomain</div><div class="line">                                      code:kJSONModelErrorInvalidData</div><div class="line">                                  userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:message&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>夸了作者这么多，唯一我个人不太喜欢的地方就是if语句下只有一行的时候，作者不喜欢加上大括号：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">    [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div></pre></td></tr></table></figure></p>
<p>但是我觉得应该加的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])&#123;</div><div class="line">  [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ul>
<li>作者用NSScanner来扫描字符串，将从类结构体里拿过来的属性的描述字符串<code>T@\&quot;NSString\&quot;,C,N,V_name</code>中扫描出了类型：<code>NSString</code>。</li>
<li>作者两次用到了NSSet：当集合里的元素顺序不重要的时候，优先考虑用NSSet。</li>
</ul>
<p>总的来说这个框架的难度还是不大的，但可能因为是第一次阅读不涉及UIVIiew的框架，感觉有些枯燥，不过慢慢习惯就好啦～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列的&lt;a href=&quot;http://www.jianshu.com/nb/9137726&quot;&gt;源码解析&lt;/a&gt;分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。&lt;/p&gt;
&lt;p&gt;想来想去，还是从&lt;a href=&quot;https://github.com/jsonmodel/jsonmodel&quot;&gt;JSONModel&lt;/a&gt;开始吧～&lt;/p&gt;
&lt;p&gt;首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。&lt;/p&gt;
&lt;p&gt;该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>详解iOS多图下载的缓存机制</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E8%AF%A6%E8%A7%A3iOS%E5%A4%9A%E5%9B%BE%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/详解iOS多图下载的缓存机制/</id>
    <published>2018-02-02T16:17:12.000Z</published>
    <updated>2018-02-02T16:17:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>做iOS开发也有半年多了，想想自己对一些第三方库还只是停留在简单运用的阶段，感觉心慌慌的。于是决定用一个月的时间深入了解一些好的第三方库。</p>
<p>第一个想到了SDWebImage，这个库很不错，几乎每个iOS项目都会有它的影子，因为它很完美地解决了下载图片并显示的处理逻辑。那么深究它之前，笔者准备先了解一下多图下载的缓存机制，因为它和SDWebImage的方案类似。</p>
<p>有一个多图缓存机制的教程是来自李明杰小码哥的，笔者觉得讲得挺不错的，于是就花了2个小时好好学习了一下。</p>
<a id="more"></a>
<h1 id="1-需求点是什么？"><a href="#1-需求点是什么？" class="headerlink" title="1.需求点是什么？"></a>1.需求点是什么？</h1><hr>
<p>这里所说的<strong>多图下载</strong>，就是要在tableview的每一个cell里显示一张图片,而且这些图片都需要从网上下载。</p>
<h1 id="2-容易遇到的问题"><a href="#2-容易遇到的问题" class="headerlink" title="2.容易遇到的问题"></a>2.容易遇到的问题</h1><hr>
<p>如果不知道或不使用<strong>异步操作</strong>和<strong>缓存机制</strong>，那么写出来的代码很可能会是这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cell.textLabel.text = app.name;</div><div class="line">cell.detailTextLabel.text = app.download;</div><div class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:app.url];</div><div class="line">cell.imageView.image = [<span class="built_in">UIImage</span> imageWithData:imageData];</div></pre></td></tr></table></figure>
<p>这样写有什么后果呢？</p>
<h4 id="后果1：不可避免的卡顿（因为没有异步下载操作）"><a href="#后果1：不可避免的卡顿（因为没有异步下载操作）" class="headerlink" title="后果1：不可避免的卡顿（因为没有异步下载操作）"></a>后果1：不可避免的卡顿（因为没有异步下载操作）</h4><blockquote>
<p>dataWithContentsOfURL：是耗时操作，将其放在主线程会造成卡顿。如果图片很多，图片很大，而且网络情况不好的话肯定会卡出翔！</p>
</blockquote>
<h4 id="后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）"><a href="#后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）" class="headerlink" title="后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）"></a>后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）</h4><blockquote>
<p>由于没有缓存机制，即使下载完成并显示了当前cell的图片，但是当该cell再一次需要显示的时候还是会下载它所对应的图片：耗费了下载流量，而且还导致重复操作。</p>
</blockquote>
<p>很显然，要达到Tableview滚动的<strong>如丝滑般的享受</strong>必须二者兼得才可以，具体怎么做呢？</p>
<h1 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h1><hr>
<h4 id="1-先看一下解决方案的流程图"><a href="#1-先看一下解决方案的流程图" class="headerlink" title="1.先看一下解决方案的流程图"></a>1.先看一下解决方案的流程图</h4><p>小码哥将他的解决方案在PPT里用流程图画了出来，笔者觉得很不错，但是颜值略低（毕竟人家是一心搞技术，没时间在意这些外在的东西），笔者理了理思路，自己重新画了一张（好看么？）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-addf3137097c3912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多图下载解决方案流程图"></p>
<p>要想快速看懂此图，需要先了解该流程所需的所有数据源：</p>
<p><strong>1. 图片的URL</strong>：因为每张图片对应的URL都是唯一的，所以我们可以通过它来建立<strong>图片缓存</strong>和<strong>下载操作的缓存</strong>的键，以及拼接<strong>沙盒缓存</strong>的路径字符串。<br><strong>2. 图片缓存（字典）</strong>：存放于内存中；键为图片的URL，值为UIImage对象。作用：读取速度快，直接使用UIImage对象。<br><strong>3. 下载操作缓存（字典）</strong>：存放与内存中，键为图片的URL，值为NSBlockOperation对象。作用：用来避免对于同一张图片还要开启多个下载线程。<br><strong>4. 沙盒缓存(文件路径对应NSData)</strong>：存放于磁盘中，位于Cache文件夹内，路径为“Cache/图片URL的最后的部分”，值为NSData对象（将UIImage转化为NSData才能写入磁盘里）。作用：程序断网，再次启动也可以直接在磁盘中拿到图片。</p>
<h4 id="2-再看一下解决方案的代码"><a href="#2-再看一下解决方案的代码" class="headerlink" title="2.再看一下解决方案的代码"></a>2.再看一下解决方案的代码</h4><p><strong>2.1图片缓存，下载操作缓存，沙盒缓存路径</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  存放所有下载完的图片</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *images;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  存放所有的下载操作（key是url，value是operation对象）</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *operations;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  拼接Cache文件夹的路径与url最后的部分，合并成唯一约定好的缓存路径</div><div class="line"> */</div><div class="line"><span class="meta">#define CachedImageFile(url) [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:[url lastPathComponent]]</span></div></pre></td></tr></table></figure></p>
<p><strong>2.2 图片下载之前的查询缓存部分</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先从images缓存中取出图片url对应的UIImage</span></div><div class="line">    <span class="built_in">UIImage</span> *image = <span class="keyword">self</span>.images[app.icon];</div><div class="line">    <span class="keyword">if</span> (image) &#123; </div><div class="line"></div><div class="line">    <span class="comment">// 存在：说明图片已经下载成功，并缓存成功）</span></div><div class="line">        cell.imageView.image = image;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123; </div><div class="line"></div><div class="line">     <span class="comment">// 不存在：说明图片并未下载成功过，或者成功下载但是在images里缓存失败，需要在沙盒里寻找对于的图片</span></div><div class="line"></div><div class="line">         <span class="comment">// 获得url对于的沙盒缓存路径</span></div><div class="line">        <span class="built_in">NSString</span> *file = CachedImageFile(app.icon);</div><div class="line">        </div><div class="line">        <span class="comment">// 先从沙盒中取出图片</span></div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:file];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (data) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//data不为空，说明沙盒中存在这个文件</span></div><div class="line">            cell.imageView.image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">         <span class="comment">// 反之沙盒中不存在这个文件</span></div><div class="line">             <span class="comment">// 在下载之前显示占位图片</span></div><div class="line">            cell.imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// 下载图片</span></div><div class="line">            [<span class="keyword">self</span> download:app.icon indexPath:indexPath];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>2.3 图片的下载部分</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  下载图片</div><div class="line"> *</div><div class="line"> *  @param imageUrl 图片的url</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)download:(<span class="built_in">NSString</span> *)imageUrl indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 取出当前图片url对应的下载操作（operation对象）</span></div><div class="line">    <span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span>.operations[imageUrl];</div><div class="line">    <span class="keyword">if</span> (operation) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建操作，下载图片</span></div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) appsVc = <span class="keyword">self</span>;</div><div class="line">    operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:imageUrl];</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url]; <span class="comment">// 下载</span></div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data]; <span class="comment">// NSData -&gt; UIImage</span></div><div class="line">        </div><div class="line">        <span class="comment">// 回到主线程</span></div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">                     </div><div class="line">            <span class="keyword">if</span> (image) &#123;</div><div class="line">                <span class="comment">// 如果存在图片（下载完成），存放图片到图片缓存字典中</span></div><div class="line">                appsVc.images[imageUrl] = image;</div><div class="line">                </div><div class="line">                <span class="comment">//将图片存入沙盒中</span></div><div class="line">                <span class="comment">//1. 先将图片转化为NSData</span></div><div class="line">                <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</div><div class="line">                </div><div class="line">                <span class="comment">//2.  再生成缓存路径            </span></div><div class="line">                [data writeToFile:CachedImageFile(imageUrl) atomically:<span class="literal">YES</span>];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 从字典中移除下载操作 (保证下载失败后，能重新下载)</span></div><div class="line">            [appsVc.operations removeObjectForKey:imageUrl];</div><div class="line">            </div><div class="line">            <span class="comment">// 刷新当前表格，减少系统开销</span></div><div class="line">            [appsVc.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationNone</span>];</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加下载操作到队列中</span></div><div class="line">    [<span class="keyword">self</span>.queue addOperation:operation];</div><div class="line">    </div><div class="line">    <span class="comment">// 将当前下载操作添加到下载操作缓存中 (为了解决重复下载)</span></div><div class="line">    <span class="keyword">self</span>.operations[imageUrl] = operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-有哪些点是值得注意的？"><a href="#3-有哪些点是值得注意的？" class="headerlink" title="3. 有哪些点是值得注意的？"></a>3. 有哪些点是值得注意的？</h4><p>要说值得注意的地方，还是离不开对于缓存内容的添加和删除操作。</p>
<p><strong>3.1 关于图片缓存</strong>：<br>很简单，成功下载，拿到了图片，就将图片添加到图片缓存中；下载失败，什么都不做，反正没有图。在这种机制下，就没有删除缓存里某个图片项的情况，因为图片缓存永远不会出现重复添加多个相同图片的情况，缓存中只要有一张对应的图，就直接拿去用了，不会去再下载了。</p>
<p><strong>3.2 关于沙盒缓存</strong>：<br>同样地，对于沙盒缓存也是一个道理：有图就将其转化为NSData，写入磁盘，并对应唯一的路径，没有图就不写。所以即使是要下载相同的图片，因为当前url对应的沙盒路径已经存在文件了，所以直接拿就可以了，不会再下载。</p>
<p>但是！<br>下载操作缓存是不同的！</p>
<p><strong>3.3 关于下载操作缓存</strong><br>我们需要在下载回调完成后，立即将当前的下载操作从下载操作缓存中删去！<br>因为要避免下载失败后，无法再次下载的情况的发生！</p>
<p>为什么呢？<br>注意一下将下载操作加入到下载操作缓存的时机：<br>是在<strong>下载开始的那一刻</strong>而不是<strong>下载成功的那一刻</strong>！</p>
<p>如果在下载开始的那一刻加入到缓存中的话，这个缓存信息就包括两个情况：下载成功和下载失败：</p>
<ul>
<li><p>如果未来下载成功了，那么我们就不会来到判断当前下载操作是否在下载操作缓存这一步，在这之前直接就可以拿图去用了，下载操作是否存在下载操作缓存里并没有什么影响。</p>
</li>
<li><p>但是！如果未来下载失败了，那就肯定不会有对应的图片缓存和沙盒缓存，也就肯定会来到判断当前的下载操作是否在下载操作缓存里这一步。不幸的是，因为没有被删去，它是存在的。存在的话就不做任何其他操作，放任自流，导致曾经下载失败的图片永远不会再次下载。</p>
</li>
</ul>
<p>忘了那段代码了么？回看一下代码（看我多好）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span>.operations[imageUrl];</div><div class="line"> <span class="keyword">if</span> (operation) <span class="keyword">return</span>;<span class="comment">//转身就走，毫不留情</span></div></pre></td></tr></table></figure></p>
<p>因此，无论下载成功或是失败，在图片下载的回调里都要将当前的下载操作从下载操作队列中移走：用来保证如果下载失败了，就可以重新开启对应的下载操作进行下载，逻辑上更加严谨。</p>
<h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4.最后的话"></a>4.最后的话</h1><hr>
<p>异步+缓存这两个机制双剑合璧的话会对程序新能带来很大的改观。这应该app开发进阶的必经之路。</p>
<p>小码哥讲述的这套流程还算比较完整的了，更重要的还是学习其中的思想：</p>
<blockquote>
<ol>
<li><p>将缓存分级：内存缓存，沙盒缓存，下载操作缓存。</p>
</li>
<li><p>而且还要经常使用二分法，将我们的逻辑考虑得滴水不漏。<br>如果我们没有认识到将下载操作添加到下载操作缓存的时机是包含下载成功和下载失败两个情况，那么就不会考虑到即时要将下载操作从下载操作缓存中删去的操作，很容易引起bug。所以在以后的开发中，成功和失败两个情况都要考虑进去，也就是说有if一定要有else！</p>
</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做iOS开发也有半年多了，想想自己对一些第三方库还只是停留在简单运用的阶段，感觉心慌慌的。于是决定用一个月的时间深入了解一些好的第三方库。&lt;/p&gt;
&lt;p&gt;第一个想到了SDWebImage，这个库很不错，几乎每个iOS项目都会有它的影子，因为它很完美地解决了下载图片并显示的处理逻辑。那么深究它之前，笔者准备先了解一下多图下载的缓存机制，因为它和SDWebImage的方案类似。&lt;/p&gt;
&lt;p&gt;有一个多图缓存机制的教程是来自李明杰小码哥的，笔者觉得讲得挺不错的，于是就花了2个小时好好学习了一下。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（一）：iOS的MVC框架</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AiOS%E7%9A%84MVC%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（一）：iOS的MVC框架/</id>
    <published>2018-02-02T16:17:05.000Z</published>
    <updated>2018-02-02T16:17:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><hr>
<p>入职iOS开发也有半年了，一直没有积极更新技术博客，感到甚是惭愧。虽然这期斯坦福公开课内容相对基础一些，但是笔者还是想把每一课的内容都总结一下然后分享出去，也算是对自己的锻炼以及对这一经典的课程致敬吧。</p>
<p>课程地址：<a href="http://open.163.com/special/opencourse/ios7.html" target="_blank" rel="external">斯坦福大学公开课：iOS 7应用开发</a></p>
<p>废话少说，开始！</p>
<a id="more"></a>
<h2 id="MVC架构介绍"><a href="#MVC架构介绍" class="headerlink" title="MVC架构介绍"></a>MVC架构介绍</h2><hr>
<h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ul>
<li><strong>视图</strong>(View)：构建UI的类；例如：按钮，标签，进度条等。</li>
<li><strong>模型</strong>(Model)：视图类所需要的数据；例如：表格需要显示的文字。</li>
<li><strong>控制器</strong>(Controller)：连接视图类和模型类，任务是使数据显示在屏幕上。例如：控制器将表格需要使用的数据“填入”表格视图中，将表格视图显示出来。</li>
</ul>
<h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul>
<li><strong>控制器可以直接访问模型</strong>：将模型直接作为控制器的属性。</li>
<li><strong>控制器可以直接访问视图</strong>：将视图直接作为控制器的属性。</li>
<li><p><strong>模型与视图无法直接访问对方</strong>：二者完全解耦，不能引用对方，把对方设置为属性。</p>
</li>
<li><p><strong>视图到控制器的通信</strong>：</p>
<ol>
<li><p><strong>目标动作机制</strong>(target - action)：用户与视图交互触发控制器的方法。例如：点击按钮后实现视界面跳转，网络请求，刷新UI等。</p>
</li>
<li><p><strong>委托机制</strong>(delegate)：视图向控制器询问某些自己无法决定的事情，或是让控制器帮助自己做一些自己独立无法完成的事情。 因为控制器才是掌握全局的角色，很多时候视图是无法自己做决定的。例如：表格问控制器：我可以滚动么？然后控制器给予回答告知是否可以继续滚动。 如果表格的高度很小，那么就可以不让它滚动。但是如果表格的高度已经超过了屏幕的高度，这时候如果让它自作主张无法滚动久不好了。                                             </p>
</li>
<li><strong>数据源机制</strong>(dataSource):视图让控制器给它将要显示的数据。例如：音乐的数据存在于模型里，控制器访问模型，从模型里拿到数据后告诉视图如何显示出歌曲。</li>
</ol>
</li>
<li><p><strong>模型到控制器的通信</strong></p>
<ol>
<li><strong>广播机制</strong>(Notification)：控制器注册监听某模型数据变化的广播频道，当此模型数据变化后向该控制器发送广播，告知模型变化情况。</li>
<li><strong>KVO机制</strong>(Key-Value Observing)：模型作为控制器的属性，当模型属性被修改后，持有此模型属性的控制器就会收到通知。</li>
</ol>
</li>
</ul>
<p>下面一张图可以直观看出上述的通信方式。图片来自本课程配套的<a href="https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewPodcast?id=480479762" target="_blank" rel="external">课件</a><br><img src="http://upload-images.jianshu.io/upload_images/859001-492c53ebbb43ad76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS MVC架构"></p>
<h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><hr>
<h3 id="类文件类型："><a href="#类文件类型：" class="headerlink" title="类文件类型："></a>类文件类型：</h3><ul>
<li><strong>.h文件</strong>(头文件):公开API，其他类可以调用的方法，告诉其他类“我能做些什么：<strong>what I can do</strong>。</li>
<li><strong>.m文件</strong>(实现文件):非公开API，如何实现.h文件的方法，查看实现文件可以知道该类具体是如何实现公开API的方法的:<strong>how to do</strong>。</li>
</ul>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><strong>strong</strong>：在堆中保持这个所指的东西，至少有一个强指针指向它，否则就会释放。</li>
<li><strong>weak</strong>：如果没有强指针指向它，清理指向的内存后，会被设置成nil指针。</li>
<li><strong>nonatomic</strong>：不能有两个线程同时设置该属性。</li>
</ul>
<h3 id="零散知识"><a href="#零散知识" class="headerlink" title="零散知识"></a>零散知识</h3><ul>
<li>所有对象都在堆里，OC会为我们管理这些内存。</li>
<li>访问实例变量，就是访问对象的实例数据。</li>
<li>OC里，可以先实现方法再声明。</li>
</ul>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><hr>
<p>第一讲里的内容比较基础，重点是介绍了MVC模型的通信机制，需要反复推敲并且在实际操作中<strong>严格遵守</strong>。因为只有这样做才能降低类之间的耦合性，写出易于维护和扩展的代码。</p>
<p>比如在模型类里是不能调用控制器的方法的，模型类只能被控制器调用并且当所拥有的数据改变后通知使用自己的控制器数据的改变。更不能直接给视图通知让视图自己更新UI。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;入职iOS开发也有半年了，一直没有积极更新技术博客，感到甚是惭愧。虽然这期斯坦福公开课内容相对基础一些，但是笔者还是想把每一课的内容都总结一下然后分享出去，也算是对自己的锻炼以及对这一经典的课程致敬吧。&lt;/p&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;http://open.163.com/special/opencourse/ios7.html&quot;&gt;斯坦福大学公开课：iOS 7应用开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;废话少说，开始！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（四 五）：属性字符串Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%20%E4%BA%94%EF%BC%89%EF%BC%9A%E5%B1%9E%E6%80%A7%E5%AD%97%E7%AC%A6%E4%B8%B2Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（四 五）：属性字符串Demo/</id>
    <published>2018-02-02T16:16:23.000Z</published>
    <updated>2018-02-02T16:16:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲解了iOS框架里几个重要的知识点：动态绑定，控制器的生命周期，属性字符串等。最后演示了一个Demo用来讲解属性字符串的几个功能。</p>
<a id="more"></a>
<h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><hr>
<p>在OC的编译期，所有的指针都是id类型，只有在运行时，对象的类型才会被确定。</p>
<p>举个🌰 ：<br>在编译期，<code>NSString*</code> 实际上与id相同，但是加上去的好处是让编译器知道你至少是<strong>意图让该指针指向一个字符串</strong>。所以如果尝试发送非字符串消息给该指针，它会发出警告，但是不会提示错误，仍可以通过编译。但是如果在运行时就会“露馅”，因为此时如果向该对象发送非字符串消息时，就会引起崩溃。</p>
<p>再举个具体的🌰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSString *hellow = @&quot;hello&quot;;</div><div class="line">Ship *hellowShip = (Ship *)hello;</div><div class="line">[helloShip shoot];</div></pre></td></tr></table></figure>
<blockquote>
<p>编译器会认为<code>hellowShip</code>是<code>ship</code>类型，因此向<code>hellowShip</code>发送<code>shoot</code>消息时，在编译器期是可以通过的。<br>但是，<code>hellowShip</code>实际上指向的是字符串，所以会导致在运行时崩溃。</p>
</blockquote>
<p>所以就引出了<strong>类型保护机制</strong>用来确定对象的类型：</p>
<h1 id="类型保护机制"><a href="#类型保护机制" class="headerlink" title="类型保护机制"></a>类型保护机制</h1><hr>
<h3 id="没有添加类型保护机制："><a href="#没有添加类型保护机制：" class="headerlink" title="没有添加类型保护机制："></a>没有添加类型保护机制：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PlayingCard *otherCard = [otherCards firstObject];</div><div class="line">[otherCard play];</div></pre></td></tr></table></figure>
<blockquote>
<p>firstObject 方法返回的是id类型，这里需要保护机制确保取出的对象是<code>PlayingCard</code>的实例，以防止向其发送消息时导致程序崩溃。</p>
</blockquote>
<h3 id="添加了类型保护机制："><a href="#添加了类型保护机制：" class="headerlink" title="添加了类型保护机制："></a>添加了类型保护机制：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">PlayingCard *otherCard = [otherCards firstObject];</div><div class="line"></div><div class="line">id card = [otherCards firstObjct];</div><div class="line">if ([card isKindOfClass:[PlayingCard class]])</div><div class="line">&#123;</div><div class="line">   PlayingCard *otherCard = (PlaytingCard *)card;</div><div class="line">   [otherCard play];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到<code>card</code>指针通过<code>isKindOfClass:</code>方法被确认了是<code>PlayingCard</code>类的实例，那么如果我们给<code>card</code>实例发送其消息时，就不会发生崩溃。反之，若<code>card</code>是其他类的实例，如果向其发送<code>card</code>类的消息就会非常危险！</p>
</blockquote>
<h1 id="NSRange"><a href="#NSRange" class="headerlink" title="NSRange"></a>NSRange</h1><hr>
<p>NSRange是一个表示“范围”的结构体，包括起点和长度,主要用于字符串。</p>
<p>常用方法：</p>
<h4 id="字符串所有的字符："><a href="#字符串所有的字符：" class="headerlink" title="字符串所有的字符："></a>字符串所有的字符：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *title = @&quot;好好学习天天向上&quot;;</div><div class="line">NSMakeRange(0, [title length])</div></pre></td></tr></table></figure>
<h4 id="判断某个字符串里包含某个字符："><a href="#判断某个字符串里包含某个字符：" class="headerlink" title="判断某个字符串里包含某个字符："></a>判断某个字符串里包含某个字符：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSString *greeting = @&quot;hellow world&quot;;</div><div class="line">Nsstring *hi = @&quot;hi&quot;;</div><div class="line">NSRange r = [greeting rangeOfString:hi];</div><div class="line">if(r.location != NSNotFound)</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;Found&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="控制器生命周期"><a href="#控制器生命周期" class="headerlink" title="控制器生命周期"></a>控制器生命周期</h1><hr>
<p>在控制器(ViewController)的生命周期里，处于某个特定的时间点会执行某个特定的方法。通过在这些方法里之行某些特定的任务，可以正确地实现其应实现的功能。</p>
<h3 id="viewDidLoad"><a href="#viewDidLoad" class="headerlink" title="viewDidLoad"></a>viewDidLoad</h3><p>控制器的<code>viewDidLoad</code>方法在控制器的view为nil的时候被调用，在控制器的生命周期中只调用一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- （voidviewDidLoad</div><div class="line">&#123;</div><div class="line">   [super viewDidLoad];    </div><div class="line">   </div><div class="line">   //可执行：</div><div class="line">   //1. 控制器的初始化数据</div><div class="line">   //2. 网络请求</div><div class="line">   </div><div class="line">   </div><div class="line">   //不可执行：</div><div class="line">   //1. 视图形状的初始化信息</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="viewWillAppear"><a href="#viewWillAppear" class="headerlink" title="viewWillAppear:"></a>viewWillAppear:</h3><p>控制器的<code>viewWillAppear:</code>在UIViewController对象的视图即将加入窗口时调用。只要该控制器的view即将要出现，都会调用，在控制器的生命周期中可以调用多次。<br>而且，如果该方法被调用，就说明视图<strong>一定</strong>会出现在屏幕上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillAppear:animated];</div><div class="line">    </div><div class="line">    //可执行：</div><div class="line">    //1. 更新view离开界面后可能会改变的数据。</div><div class="line">    //2. view的几何变化。</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="viewWillDisappear"><a href="#viewWillDisappear" class="headerlink" title="viewWillDisappear:"></a>viewWillDisappear:</h3><p>控制器的<code>viewWillDisappear:</code>在UIViewController的view即将不显示的时候调用，在控制器的生命周期中可以调用多次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)viewWillDisappear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">    </div><div class="line">    //可执行：</div><div class="line">    //1. 记录滚动视图的偏移量(因为要记住滚动位置，便于下次查看)</div><div class="line">    //2. 存储数据，便于再次显示该控制器时使用。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="属性字符串Demo"><a href="#属性字符串Demo" class="headerlink" title="属性字符串Demo"></a>属性字符串Demo</h1><hr>
<h2 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h2><ul>
<li>布局为TextView下方有四个颜色按钮，再下方有添加轮廓按钮和去除轮廓按钮。</li>
<li>选中TextView的文本后，点击色彩按钮，选中的文本的颜色变成点击的色彩按钮的背景色。</li>
<li>选中TextView的文本后，点击添加轮廓，选中的文本增加了轮廓，再点击色彩按钮，轮廓变成了相应的颜色。</li>
<li>文本有轮廓的状态下，点击去除轮廓按钮，轮廓消失。</li>
<li>在设置选项来改变系统字体，再回到本Demo界面，字体会做相应改变。</li>
</ul>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-4660010abbea2854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="属性字符串效果图"></p>
<h2 id="知识点详解"><a href="#知识点详解" class="headerlink" title="知识点详解"></a>知识点详解</h2><h4 id="属性字符串的设置"><a href="#属性字符串的设置" class="headerlink" title="属性字符串的设置"></a>属性字符串的设置</h4><p>属性字符串分为不可变属性字符串<code>NSAttributedString</code>和<code>NSMutableAttributedString</code>。</p>
<p>设置属性字符串的一般步骤为：</p>
<ol>
<li>初始化可变属性字符串。</li>
<li>向其添加属性字典和制定属性字典被应用的范围。</li>
</ol>
<p>举个🌰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">//1. 由现有字符串初始化可变属性字符串</div><div class="line">NSMutableAttributedString *title = [[NSMutableAttributedString alloc] initWithString:self.outLineButton.currentTitle];</div><div class="line"></div><div class="line">//2. 添加属性字典和范围</div><div class="line">[title setAttributes:@&#123;NSStrokeWidthAttributeName : @3,</div><div class="line">                      NSStrokeColorAttributeName  : self.outLineButton.tintColor&#125;</div><div class="line">                                             range: NSMakeRange(0, [title length])];</div><div class="line"></div><div class="line">//3. 将属性字符串赋给按钮的属性字符串属性</div><div class="line">[self.outLineButton setAttributedTitle:title forState:UIControlStateNormal];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//设定选中的字都被设置为和点击的按钮一样的背景颜色</div><div class="line">[self.textView.textStorage  addAttribute:NSForegroundColorAttributeName value:sender.backgroundColor range:self.body.selectedRange];</div></pre></td></tr></table></figure>
<h4 id="关于按钮的操作"><a href="#关于按钮的操作" class="headerlink" title="关于按钮的操作"></a>关于按钮的操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取按钮的背景色</div><div class="line">self.button.backgroundColor</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//获取按钮当前的标题</div><div class="line">self.button.currentTitle</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//设定按钮当前的属性字符串标题</div><div class="line">[self.button setAttributedTitle:title forState:UIControlStateNormal];</div></pre></td></tr></table></figure>
<h4 id="属性字典里的key："><a href="#属性字典里的key：" class="headerlink" title="属性字典里的key："></a>属性字典里的key：</h4><ul>
<li><code>NSForegroundColorAttributeName</code>:属性字符串字符的颜色</li>
<li><code>NSStrokeColorAttributeName</code>:属性字符串字符轮廓的颜色</li>
<li><code>NSStrokeWidthAttributeName</code>:属性字符串字符轮廓的宽度</li>
</ul>
<h4 id="获取TextView被选中的范围"><a href="#获取TextView被选中的范围" class="headerlink" title="获取TextView被选中的范围"></a>获取TextView被选中的范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.textView.selectedRange</div></pre></td></tr></table></figure>
<h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>为了实现本Demo最后一个需求，我们需要监听系统字体何时被改变了。所以需要注册一个能收听“系统改变”广播的频道：</p>
<p>注册通知：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(prefredFontsChaged:) name:UIContentSizeCategoryDidChangeNotification object:nil];</div></pre></td></tr></table></figure>
<p>这样一来，当系统字体发生变化时，注册该频道的对象会收到通知并执行自定义的方法。<br>当改变系统字体的大小后，该类会收到通知，并调用<code>prefredFontsChaged:</code>方法，此时Demo上的字体也要做相应的改变：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)prefredFontsChaged: (NSNotification *)notification</div><div class="line">&#123;</div><div class="line">    //收到通知后，调用本地自定义的方法</div><div class="line">    [self userPreferredFonts];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)userPreferredFonts</div><div class="line">&#123;</div><div class="line">    //使用被改变后的系统字体</div><div class="line">    self.body.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];</div><div class="line">    self.headLine.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里，显然又是一个MVC的流程：系统字体(模型)被改变了，通过广播(通知)的机制来告诉控制器，然后控制器再调用更改View的方法。还记得在第一篇（详情请见：<a href="http://www.jianshu.com/p/eb58ab21080a" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（一） ：iOS的MVC框架</a>）里强调的，从模型到控制器的通信是通过广播或KVO机制完成的么？</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到此Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲解了iOS框架里几个重要的知识点：动态绑定，控制器的生命周期，属性字符串等。最后演示了一个Demo用来讲解属性字符串的几个功能。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E8%A1%A8%E6%A0%BC%E8%A7%86%E5%9B%BE%EF%BC%8CFlickr-%E7%85%A7%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo/</id>
    <published>2018-02-02T16:16:18.000Z</published>
    <updated>2018-02-02T16:16:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UITableview"><a href="#UITableview" class="headerlink" title="UITableview"></a>UITableview</h1><hr>
<p>UITableview是iOS软件中最常见的视图，用来以表格的形式显示数据。</p>
<h2 id="数据源方法"><a href="#数据源方法" class="headerlink" title="数据源方法"></a>数据源方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section;//表格的总section数，默认为返回1，可以不实现</div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; //返回当前section的行数，必须实现</div><div class="line">- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; //返回某section某row的cell，必须实现</div></pre></td></tr></table></figure>
<h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//cell被点击是调用的方法</div></pre></td></tr></table></figure>
<h2 id="根据cell获得对应的indexPath"><a href="#根据cell获得对应的indexPath" class="headerlink" title="根据cell获得对应的indexPath"></a>根据cell获得对应的indexPath</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"> NSIndexPath *indexPath = [self.tableView  indexPathForCell :sender];</div></pre></td></tr></table></figure>
<h2 id="UITableView-Spinner"><a href="#UITableView-Spinner" class="headerlink" title="UITableView Spinner"></a>UITableView Spinner</h2><p>顶部加载时显示的小圆圈动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl;</div><div class="line"></div><div class="line">- (void)beginRefreshing;</div><div class="line">- (void)endRefreshing;</div></pre></td></tr></table></figure></p>
<h2 id="模型改变，刷新表格"><a href="#模型改变，刷新表格" class="headerlink" title="模型改变，刷新表格"></a>模型改变，刷新表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)reloadData; //刷新全部表格：一般在模型大部分变化的时候才调用，在某个数据变化时不推荐使用</div><div class="line"></div><div class="line">- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//只刷新某一个cell，在某行货少数行数据变化时推荐使用</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="Universal-Application"><a href="#Universal-Application" class="headerlink" title="Universal Application"></a>Universal Application</h1><hr>
<p>Universal Application通用应用是指既可以在iPhone上运行，也可以在iPad上运行的应用，它有两个故事版文件，一个是针对iphone的，另一个是针对ipad的。</p>
<p>iPad有两种独有的视图：</p>
<ol>
<li>Split View：拆分视图</li>
<li>Popover:弹窗</li>
</ol>
<p>识别是否是ipad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BOOL iPad  = ([&#123;UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad)</div></pre></td></tr></table></figure></p>
<h1 id="UISplitViewController"><a href="#UISplitViewController" class="headerlink" title="UISplitViewController"></a>UISplitViewController</h1><hr>
<h2 id="UISplitViewController包括"><a href="#UISplitViewController包括" class="headerlink" title="UISplitViewController包括"></a>UISplitViewController包括</h2><ul>
<li>Master View Controller</li>
<li>Detail View Controller</li>
</ul>
<p>UISplitViewController是storyboard的最顶层，不能被加入到UIViewController里面</p>
<h2 id="获得SplitViewController："><a href="#获得SplitViewController：" class="headerlink" title="获得SplitViewController："></a>获得SplitViewController：</h2><p>返回当前UIViewcontroller所在的SplitViewController:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UIViewController.h</div><div class="line"></div><div class="line">@property (strong) UISplitViewController  *splitViewController;</div></pre></td></tr></table></figure></p>
<h2 id="获得SplitViewController的master和detail："><a href="#获得SplitViewController的master和detail：" class="headerlink" title="获得SplitViewController的master和detail："></a>获得SplitViewController的master和detail：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (copy) NSArray *viewControllers;//0：master;1: detail</div></pre></td></tr></table></figure>
<h2 id="UISplitViewControllerDelegate"><a href="#UISplitViewControllerDelegate" class="headerlink" title="UISplitViewControllerDelegate"></a>UISplitViewControllerDelegate</h2><p>在awakeFromNib设置此代理,代理负责 控制master和detail何时出现</p>
<p>代理的几个方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)splitViewController:(UISplitViewController *)svc shouldHideViewController:(UIViewController *)vc inOrientation:(UIInterfaceOrientation)orientation&#123;</div><div class="line">           return NO; //永远不隐藏master，master和detail将一直在屏幕上显示，无论是横屏或竖屏 </div><div class="line">           return UIInterfaceOrientationIsPortrait(orientation);//竖屏不显示master 但是竖屏时左上角有按键可以显示master，但是</div><div class="line">不实现这个代理就不能出现按钮了。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在横屏或竖屏是否该隐藏master</p>
<h1 id="Popovers"><a href="#Popovers" class="headerlink" title="Popovers"></a>Popovers</h1><hr>
<p>Popover是弹窗控件，它的作用是控制另一个视图控制器弹出到屏幕上，也是ipad独有的控件。<br>因为ipad的面积比较大，所以有时可以只以弹窗的形式提供信息而不用跳转到下一页面。</p>
<p>注意：这个控件并没有继承UIViewController，是一个NSObject</p>
<h2 id="Popover的Segue是UIStroyboardPopoverSegue。"><a href="#Popover的Segue是UIStroyboardPopoverSegue。" class="headerlink" title="Popover的Segue是UIStroyboardPopoverSegue。"></a>Popover的Segue是<code>UIStroyboardPopoverSegue</code>。</h2><p>在Popover出现之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)prepareForSegue: (UIStoryboardSegue *)segue sender: (id)sender</div><div class="line">&#123;</div><div class="line">    if([segue isKindOfClass:[UIStroyboardPopoverSegue class]])&#123;</div><div class="line">        </div><div class="line">         UIPopoverController *popoverController = ((UIStroyboardPopoverSegue *)segue.)popoverController;</div><div class="line"></div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="使Popover消失："><a href="#使Popover消失：" class="headerlink" title="使Popover消失："></a>使Popover消失：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)dismissPopoverAnimated:(BOOL)animated;</div></pre></td></tr></table></figure>
<p>默认情况下，点击外部任何的地方都能使它消失，除非我们给它指定即使点击也不会消失的<code>UIVIew</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (copy) NSArray *passthroughViews;</div></pre></td></tr></table></figure>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<p>该Demo是同时适用iPad 和iPhone的，可惜笔者没有iPad，无法调试，于是只适配了iPhone，以后有机会会补上适配iPad的代码的。</p>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>第一个页面用表格显示从Flickr抓取的图片数据，只显示图片名和图片详情。</li>
<li>点击第一个页面的cell，跳转到图片详情页。</li>
<li>图片详情页显示具体的大图，可以伸缩，可以移动。</li>
</ul>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-b0a8e98131ae59b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-获取Flickr上的数据"><a href="#1-获取Flickr上的数据" class="headerlink" title="1. 获取Flickr上的数据"></a>1. 获取Flickr上的数据</h4><p>Flickr提供了公共的接口提供了自家的照片，接口文件在本Demo里的<code>Flickr Fetcher</code>文件里，唯一注意的是需要申请<code>APIKEY</code>,<a href="[http://www.flickr.com/services/api/misc.api_keys.html](http://www.flickr.com/services/api/misc.api_keys.html">申请网址</a>)。</p>
<p>解析照片数据的过程是比较耗时的，所以需要分配到子线程来进行。获得数组后，在主线程将数组赋予当前类的属性里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)fetchPhotos</div><div class="line">&#123;</div><div class="line">    self.photos = nil;</div><div class="line">    NSURL *url = [FlickrFetcher URLforRecentGeoreferencedPhotos];</div><div class="line"></div><div class="line">    //手动创建一个子线程</div><div class="line">    dispatch_queue_t fetchQ = dispatch_queue_create(&quot;flickr fetcher&quot;, NULL);</div><div class="line"></div><div class="line">    dispatch_async(fetchQ, ^&#123;</div><div class="line"></div><div class="line">        //获得json数据，比较耗时</div><div class="line">        NSData *jsonResults = [NSData dataWithContentsOfURL:url];</div><div class="line"></div><div class="line">        //获得字典</div><div class="line">        NSDictionary *propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:NULL];</div><div class="line">        NSArray *photos = [propertyListResults valueForKeyPath:FLICKR_RESULTS_PHOTOS];</div><div class="line">   </div><div class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">           //回到主线程     </div><div class="line">            self.photos = photos;</div><div class="line"></div><div class="line">        &#125;);    </div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>NULL是C指针，代表指向OC指针的指针没有指向任何对象</p>
</blockquote>
<p>什么是指向OC指针的指针？：&amp;error是指向error的指针<br>如果我们这样写，就可以获得error：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> NSError *error = nil;</div><div class="line"> NSDictionary *propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>如果我们不关心error，就可以传NULL。</p>
<p>好了，现在我们获得了数据，需要刷新表格：</p>
<h4 id="2-刷新表格"><a href="#2-刷新表格" class="headerlink" title="2. 刷新表格"></a>2. 刷新表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (void)setPhotos:(NSArray *)photos</div><div class="line">&#123;</div><div class="line">    _photos = photos;</div><div class="line">    [self.tableView reloadData];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只是刷新表格是不够的，还要实现<code>UITableView</code>的数据源方法来告诉<code>TableView</code>如何显示数据。（调用<code>reload</code>方法后会调用这些数据源方法）</p>
<h4 id="3-实现数据源方法"><a href="#3-实现数据源方法" class="headerlink" title="3. 实现数据源方法"></a>3. 实现数据源方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">#pragma mark - Table view data source</div><div class="line"></div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</div><div class="line">    //只有一组</div><div class="line">     return 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</div><div class="line">   //行数为图片的个数</div><div class="line">    return self.photos.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</div><div class="line"></div><div class="line">    //从重用池中拿到cell</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Flickr Photo Cell&quot; forIndexPath:indexPath];</div><div class="line"></div><div class="line">    //通过indexPath来获得在数据里对应的图片数据</div><div class="line">    NSDictionary *photoDict = self.photos[indexPath.row];</div><div class="line">    //设置主标题和副标题</div><div class="line"></div><div class="line">    cell.textLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_TITLE];</div><div class="line"></div><div class="line">    cell.detailTextLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_DESCRIPTION];    </div><div class="line"></div><div class="line">    return cell;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-点击cell，实现跳转"><a href="#4-点击cell，实现跳转" class="headerlink" title="4. 点击cell，实现跳转"></a>4. 点击cell，实现跳转</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">#pragma mark - Navigation</div><div class="line"></div><div class="line">// In a storyboard-based application, you will often want to do a little preparation before navigation</div><div class="line"></div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</div><div class="line"></div><div class="line">    if ([sender isKindOfClass:[UITableViewCell class]]) &#123;</div><div class="line"></div><div class="line">        NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];    </div><div class="line"></div><div class="line">        if (indexPath) &#123;</div><div class="line">         </div><div class="line">            if ([segue.destinationViewController isKindOfClass:[ImageViewController class]]) &#123;</div><div class="line"></div><div class="line">                [self prepareImageViewController:segue.destinationViewController toDisplayPhoto:self.photos[indexPath.row]];                </div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)prepareImageViewController:(ImageViewController *)ivc toDisplayPhoto:(NSDictionary*)photo</div><div class="line">&#123;</div><div class="line"></div><div class="line">   //获得图像的URL传给ImageViewController</div><div class="line">    ivc.imageURL = [FlickrFetcher URLforPhoto:photo format:FlickrPhotoFormatLarge];</div><div class="line">   //导航栏的标题为图片的名字</div><div class="line">    ivc.title = [photo valueForKey:FLICKR_PHOTO_TITLE];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里的<code>ImageViewController</code>复用了<a href="http://www.jianshu.com/p/ddb4f528b334" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（十） ：多线程，UIScrollView，图片浏览器Demo</a>里第二个页面。</p>
</blockquote>
<h4 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h4><p>每次跳转到图片详情页，将图片的原点设置在最左上端，并且大小恢复到该图片的原始大小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)setImage:(UIImage *)image</div><div class="line">&#123;</div><div class="line"></div><div class="line">    //重置缩放大小为1</div><div class="line">    self.scrollView.zoomScale = 1.0;</div><div class="line">    self.imageView.image = image;</div><div class="line">    [self.imageView sizeToFit];</div><div class="line"></div><div class="line">    //将视图框的原点设在左上角</div><div class="line">    self.imageView.frame = CGRectMake(0, 0, self.image.size.width, self.image.size.height);</div><div class="line"></div><div class="line">    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;</div><div class="line"></div><div class="line">    [self.spinner stopAnimating];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UITableview&quot;&gt;&lt;a href=&quot;#UITableview&quot; class=&quot;headerlink&quot; title=&quot;UITableview&quot;&gt;&lt;/a&gt;UITableview&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;UITableview是iOS软件中最常见的视图，用来以表格的形式显示数据。&lt;/p&gt;
&lt;h2 id=&quot;数据源方法&quot;&gt;&lt;a href=&quot;#数据源方法&quot; class=&quot;headerlink&quot; title=&quot;数据源方法&quot;&gt;&lt;/a&gt;数据源方法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (NSInteger)numberOfRowsInSection:(NSInteger)section;//表格的总section数，默认为返回1，可以不实现&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; //返回当前section的行数，必须实现&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; //返回某section某row的cell，必须实现&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;代理方法&quot;&gt;&lt;a href=&quot;#代理方法&quot; class=&quot;headerlink&quot; title=&quot;代理方法&quot;&gt;&lt;/a&gt;代理方法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//cell被点击是调用的方法&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;根据cell获得对应的indexPath&quot;&gt;&lt;a href=&quot;#根据cell获得对应的indexPath&quot; class=&quot;headerlink&quot; title=&quot;根据cell获得对应的indexPath&quot;&gt;&lt;/a&gt;根据cell获得对应的indexPath&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt; NSIndexPath *indexPath = [self.tableView  indexPathForCell :sender];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;UITableView-Spinner&quot;&gt;&lt;a href=&quot;#UITableView-Spinner&quot; class=&quot;headerlink&quot; title=&quot;UITableView Spinner&quot;&gt;&lt;/a&gt;UITableView Spinner&lt;/h2&gt;&lt;p&gt;顶部加载时显示的小圆圈动画&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (void)beginRefreshing;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (void)endRefreshing;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;模型改变，刷新表格&quot;&gt;&lt;a href=&quot;#模型改变，刷新表格&quot; class=&quot;headerlink&quot; title=&quot;模型改变，刷新表格&quot;&gt;&lt;/a&gt;模型改变，刷新表格&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (void)reloadData; //刷新全部表格：一般在模型大部分变化的时候才调用，在某个数据变化时不推荐使用&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (void)reloadRowsAtIndexPaths:(NSArray&amp;lt;NSIndexPath *&amp;gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//只刷新某一个cell，在某行货少数行数据变化时推荐使用&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E5%9B%9B%20%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9ACoreLocation%EF%BC%8CMapKit%EF%BC%8C%E5%9C%A8%E5%9C%B0%E5%9B%BE%E4%B8%8A%E6%A0%87%E8%AF%86Flickr%E6%91%84%E5%BD%B1%E5%B8%88%E7%9A%84%E4%BD%9C%E5%93%81/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品/</id>
    <published>2018-02-02T16:16:13.000Z</published>
    <updated>2018-02-02T16:16:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>本总结将第十四和十五课放在了一起，原因有二：第一是略去了ipad开发Demo的部分（因为笔者木有ipad，无法进行调试）。第二是两节课都讲解了关于地图框架的相关知识，故将二者放在一起总结。</p>
<p>在本篇总结的最后，会给大家讲解在地图上显示Flickr上摄影师的照片作品。</p>
<h1 id="Network-Activity-Indicator"><a href="#Network-Activity-Indicator" class="headerlink" title="Network Activity Indicator"></a>Network Activity Indicator</h1><hr>
<p>顾名思义，该控件叫做网络活动指示器。当app有网络活动时，可以让状态栏左边的小圆圈滚动用来提示用户当前的网络状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible;</div></pre></td></tr></table></figure>
<p>如果设定为YES，状态栏上的小转轮就会转，反之亦然。</p>
<blockquote>
<p>注意：应用中的所有线程都可使用这个转轮，我们需要通过各种方法来向用户准确显示转轮的状态。</p>
</blockquote>
<a id="more"></a>
<h1 id="Core-Location"><a href="#Core-Location" class="headerlink" title="Core Location"></a>Core Location</h1><hr>
<p>通过该框架的基本类：<code>CLLocation</code>，我们能获得设备处于地球上的位置信息。</p>
<h2 id="Core-Location几个重要的属性："><a href="#Core-Location几个重要的属性：" class="headerlink" title="Core Location几个重要的属性："></a>Core Location几个重要的属性：</h2><h4 id="1-坐标属性"><a href="#1-坐标属性" class="headerlink" title="1. 坐标属性"></a>1. 坐标属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">typedef struct &#123;</div><div class="line">CLLocationDegrees latitude;    //double value</div><div class="line">CLLocationDegrees longitude;   //double value</div><div class="line">&#125; CLLocationCoordinate2D;</div></pre></td></tr></table></figure>
<h4 id="2-高度"><a href="#2-高度" class="headerlink" title="2. 高度"></a>2. 高度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property(readonly, nonatomic) CLLocationDistance altitude; //单位是米</div></pre></td></tr></table></figure>
<h4 id="3-变化精度："><a href="#3-变化精度：" class="headerlink" title="3. 变化精度："></a>3. 变化精度：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy;//水平精度</div><div class="line">@property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy;//高度精度</div></pre></td></tr></table></figure>
<p>如何获得CLLocation？<br>通过实例化<code>CLLocationManager</code>类，让其告诉它的代理当前设备所处的位置。<br>下面来介绍一下<code>CLLocationManager</code>:</p>
<h1 id="CLLocationManager"><a href="#CLLocationManager" class="headerlink" title="CLLocationManager"></a>CLLocationManager</h1><hr>
<h2 id="CLLocationManager的工作步骤："><a href="#CLLocationManager的工作步骤：" class="headerlink" title="CLLocationManager的工作步骤："></a>CLLocationManager的工作步骤：</h2><p>1.查看硬件是否支持位置更新。<br>2.实例化<code>CLLocationManager</code>让其告诉它的代理当前的位置。<br>3.设置位置更新的类型(精度)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property(assign, nonatomic) CLLocationAccuracy desiredAccuracy; //期望的经度</div><div class="line">@property(assign, nonatomic) CLLocationDistance distanceFilter;  //更新到该距离之内不要告诉我更新了多少</div></pre></td></tr></table></figure>
<p>4.开始位置监控。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)startUpdatingLocation;//开始更新位置</div><div class="line">- (void)stopUpdatingLocation;//停止位置更新</div><div class="line">- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations;//位置更新的代理方法</div><div class="line">- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error;//更新失败</div></pre></td></tr></table></figure>
<h2 id="位置监控的类型："><a href="#位置监控的类型：" class="headerlink" title="位置监控的类型："></a>位置监控的类型：</h2><h4 id="1-基于精度的监控"><a href="#1-基于精度的监控" class="headerlink" title="1. 基于精度的监控"></a>1. 基于精度的监控</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">extern const CLLocationAccuracy kCLLocationAccuracyBestForNavigation; //最精确，但是非常耗能</div><div class="line">extern const CLLocationAccuracy kCLLocationAccuracyBest;</div><div class="line">extern const CLLocationAccuracy kCLLocationAccuracyNearestTenMeters;</div><div class="line">extern const CLLocationAccuracy kCLLocationAccuracyHundredMeters;</div><div class="line">extern const CLLocationAccuracy kCLLocationAccuracyKilometer;</div><div class="line">extern const CLLocationAccuracy kCLLocationAccuracyThreeKilometers;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：精度越高，耗电量越大</p>
</blockquote>
<h4 id="2-位置发生重大变化时更新。"><a href="#2-位置发生重大变化时更新。" class="headerlink" title="2. 位置发生重大变化时更新。"></a>2. 位置发生重大变化时更新。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)startMonitoringSignificantLocationChanges;</div><div class="line">- (void)stopMonitoringSignificantLocationChanges ;</div></pre></td></tr></table></figure>
<p>该方法在前台和后台都能监控位置的变化，甚至关掉app后，也可以启动应用告诉用户位置更新:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">    //如果``launchOptions``存在``UIApplicationLaunchOptionsLocationKey``，说明程序启动的原因是因为位置发生了重大变化</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-进入某个区域更新。"><a href="#3-进入某个区域更新。" class="headerlink" title="3. 进入某个区域更新。"></a>3. 进入某个区域更新。</h4><p>3.1设定一个圆形的区域，经过该区域的时候会更新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)startMonitoringForRegion:(CLRegion *)region;</div><div class="line">- (void)requestStateForRegion:(CLRegion *)region;</div></pre></td></tr></table></figure>
<p>3.2 通过一个信标来监控</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property (readonly, nonatomic) CLLocationDistance maximumRegionMonitoringDistance;//设置最大监控距离</div><div class="line"></div><div class="line">- (void)startRangingBeaconsInRegion:(CLBeaconRegion *)region;//设置信标</div></pre></td></tr></table></figure>
<h4 id="4-监控前进的方向"><a href="#4-监控前进的方向" class="headerlink" title="4. 监控前进的方向"></a>4. 监控前进的方向</h4><h1 id="MapKit"><a href="#MapKit" class="headerlink" title="MapKit"></a>MapKit</h1><hr>
<p>MapKit是用于显示地图的框架，它通过<code>MKMapView</code>来显示地图。<br>我们来看一下该框架中几个比较重要的元素：</p>
<h2 id="1-MKMapView"><a href="#1-MKMapView" class="headerlink" title="1. MKMapView"></a>1. MKMapView</h2><p>MKMapView就是用来显示地图的View。</p>
<p>MKMapView的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic) MKMapType mapType;// MKMapTypeStandard : 标准；MKMapTypeSatellite:卫星；MKMapTypeHybrid：叠加</div><div class="line">@property (nonatomic) BOOL showsUserLocation; //显示用户的地点</div><div class="line">@property (nonatomic, readonly, getter=isUserLocationVisible) BOOL userLocationVisible;</div><div class="line">//用户坐标是否可见</div><div class="line">@property (nonatomic, getter=isZoomEnabled) BOOL zoomEnabled; //是否可放大缩小</div><div class="line">@property (nonatomic, getter=isRotateEnabled) BOOL rotateEnabled; //是否可旋转</div><div class="line">@property (nonatomic, getter=isPitchEnabled) BOOL pitchEnabled; //3D效果</div></pre></td></tr></table></figure></p>
<h2 id="2-MKAnnotationView"><a href="#2-MKAnnotationView" class="headerlink" title="2. MKAnnotationView"></a>2. MKAnnotationView</h2><p>在<code>MKMapView</code>视图里，可以显示用于标注具体位置的“大头针” ，它是MapKit框架里的<code>AnnotationView</code>。</p>
<p>MKAnnotationView的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong, nullable) id &lt;MKAnnotation&gt; annotation;</div><div class="line">@property (nonatomic, strong, nullable) UIImage *image;//大头针的图像</div><div class="line">@property (strong, nonatomic, nullable) UIView *leftCalloutAccessoryView;//左附属对话框</div><div class="line">@property (strong, nonatomic, nullable) UIView *rightCalloutAccessoryView;//右附属对话框</div><div class="line">@property (nonatomic, getter=isDraggable) BOOL draggable //是否可拖动</div></pre></td></tr></table></figure></p>
<p>大头针被点击时调用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view</div></pre></td></tr></table></figure></p>
<h2 id="3-id"><a href="#3-id" class="headerlink" title="3. id"></a>3. id<mkannotation></mkannotation></h2><p>AnnotationView的数据源就是：id<mkannotation>，任何遵从该协议的对象都可以成为AnnotationView的数据源，也就是说，任何遵守    <code>MKAnootation</code>协议的对象你都可以将其放入地图中。</mkannotation></p>
<p>我们先看一下在MKMapView里的关于MKAnnotation的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, readonly) NSArray&lt;id&lt;MKAnnotation&gt;&gt; *annotations;//包含MapView所显示的所有Annotaion</div></pre></td></tr></table></figure></p>
<p>注意：annotations是只读的数组，只能添加或者删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)addAnnotation:(id &lt;MKAnnotation&gt;)annotation;</div><div class="line">- (void)addAnnotations:(NSArray&lt;id&lt;MKAnnotation&gt;&gt; *)annotations;</div><div class="line">- (void)removeAnnotation:(id &lt;MKAnnotation&gt;)annotation;</div><div class="line">- (void)removeAnnotations:(NSArray&lt;id&lt;MKAnnotation&gt;&gt; *)annotations;</div></pre></td></tr></table></figure>
<p>MKAnnotation协议的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">@protocol MKAnnotation &lt;NSObject&gt;</div><div class="line">@property (nonatomic, readonly) CLLocationCoordinate2D coordinate; //坐标</div><div class="line"></div><div class="line">@optional</div><div class="line">@property (nonatomic, readonly, copy, nullable) NSString *title;//标题</div><div class="line">@property (nonatomic, readonly, copy, nullable) NSString *subtitle;//副标题</div><div class="line"></div><div class="line">- (void)setCoordinate:(CLLocationCoordinate2D)newCoordinate ;//设置坐标</div></pre></td></tr></table></figure>
<p>那么二者是如何关联的呢？<br>通过MKMapView的代理方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation</div><div class="line">&#123;</div><div class="line">    //提供一个 annotation，返回一个 MKAnnotationView</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="4-Callout-对话框"><a href="#4-Callout-对话框" class="headerlink" title="4. Callout(对话框)"></a>4. Callout(对话框)</h2><p>点击大头针（MKAnnotationView），会出现一个白底的对话框，它被叫做<code>callout</code>,可以设置它的主标题和副标题。另外还有左右附属实图，它们可以显示图片或者箭头，也可被点击。
﻿</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求："><a href="#Demo需求：" class="headerlink" title="Demo需求："></a>Demo需求：</h2><ul>
<li>显示从flickr抓取的摄影师列表。</li>
<li>点击列表中的一项，打开地图，在当前摄影师所照照片的地点显示大头针。</li>
<li>点击其中的一个大头针，显示照片详情：缩略图和名称。</li>
<li>点击箭头按钮，滑入显示照片的页面，显示原始照片。</li>
</ul>
<h2 id="Demo效果图："><a href="#Demo效果图：" class="headerlink" title="Demo效果图："></a>Demo效果图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-269dd622430d4972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在地图显示照片拍摄位置"></p>
<h2 id="重要代码段和知识点："><a href="#重要代码段和知识点：" class="headerlink" title="重要代码段和知识点："></a>重要代码段和知识点：</h2><h4 id="1-更改Core-Data模型"><a href="#1-更改Core-Data模型" class="headerlink" title="1. 更改Core Data模型"></a>1. 更改Core Data模型</h4><p>在上一节课的基础上，我们需要在模型里的<code>Photo</code>实体添加经度和纬度的属性，还有大头针缩略图的URL属性。<br>在更新属性后，一定要重新生成对应该实体的类文件，并且要将原app删除，因为数据库前后是不兼容的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0bf538fa1a08fe3d.gif?imageMogr2/auto-orient/strip" alt="更新模型"></p>
<h4 id="2-新建PhotosByPhotographerMapViewController-h，用来显示MKMapView"><a href="#2-新建PhotosByPhotographerMapViewController-h，用来显示MKMapView" class="headerlink" title="2. 新建PhotosByPhotographerMapViewController.h，用来显示MKMapView"></a>2. 新建PhotosByPhotographerMapViewController.h，用来显示<code>MKMapView</code></h4><p>因为要在地图上显示摄影师所照照片的位置，因此，该类的数据源来自摄影师模型：<code>Photographer</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;Photographer.h&quot;</div><div class="line">@interface PhotosByPhotographerMapViewController : UIViewController</div><div class="line">@property (nonatomic, strong) Photographer *photographer;//公共API：摄影师</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>``</p>
<p>#import “PhotosByPhotographerMapViewController.h”</p>
<p>#import <mapkit mapkit.h=""></mapkit></p>
<p>@interface PhotosByPhotographerMapViewController ()<mkmapviewdelegate><br>@property (strong, nonatomic) IBOutlet MKMapView <em>mapView;//地图view<br>@property (nonatomic,strong) NSArray </em>photosByPhotographer;//装入摄影师拥有的照片的数组<br>@end</mkmapviewdelegate></p>
<p>@implementation PhotosByPhotographerMapViewController<br>@end<br>``</p>
<h4 id="3-导入Mapkit的framework"><a href="#3-导入Mapkit的framework" class="headerlink" title="3. 导入Mapkit的framework"></a>3. 导入Mapkit的framework</h4><p>需要注意的是，除了要在类文件引用<code>&lt;MapKit/MapKit.h&gt;</code>框架以外，还要手动向项目中添加该框架：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-8fb04dfbac7bbdd7.gif?imageMogr2/auto-orient/strip" alt="手动添加MapKit框架.gif"></p>
<h4 id="4-更新photographer和mapView后更新annotation："><a href="#4-更新photographer和mapView后更新annotation：" class="headerlink" title="4. 更新photographer和mapView后更新annotation："></a>4. 更新photographer和mapView后更新annotation：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">- (void)setMapView:(MKMapView *)mapView</div><div class="line">&#123;</div><div class="line">    _mapView = mapView;</div><div class="line"></div><div class="line">    //设置代理</div><div class="line">    self.mapView.delegate = self;</div><div class="line"></div><div class="line">    //更新</div><div class="line">    [self updateMapViewAnnotations];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setPhotographer:(Photographer *)photographer</div><div class="line">&#123;</div><div class="line">    _photographer = photographer;</div><div class="line">    //导航栏标题</div><div class="line">    self.title = photographer.name;</div><div class="line">    //准备更新数组，要事先设置其为nil，否则不会生成新的</div><div class="line">    self.photosByPhotographer = nil;</div><div class="line">    [self updateMapViewAnnotations];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateMapViewAnnotations</div><div class="line">&#123;</div><div class="line">    [self.mapView removeAnnotations:self.mapView.annotations];</div><div class="line">    [self.mapView addAnnotations:self.photosByPhotographer];</div><div class="line">    [self.mapView showAnnotations:self.photosByPhotographer animated:YES];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="5-自定义点击大头针后显示的view"><a href="#5-自定义点击大头针后显示的view" class="headerlink" title="5. 自定义点击大头针后显示的view"></a>5. 自定义点击大头针后显示的view</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation</div><div class="line">&#123;</div><div class="line"></div><div class="line">    //类似UITableviewCell的复用</div><div class="line">    static NSString *reuseId = @&quot;PhotosByPhotographerMapViewController&quot;;    </div><div class="line"></div><div class="line">    MKPinAnnotationView *view = (MKPinAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:reuseId];    </div><div class="line"></div><div class="line">    if (!view) &#123;</div><div class="line">        view = [[MKPinAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:reuseId];</div><div class="line">       //是否显示callout</div><div class="line">        view.canShowCallout = YES;</div><div class="line">        //设置左部分的callout：UIImageView</div><div class="line">        UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 46, 46)];</div><div class="line">        view.leftCalloutAccessoryView = imageView;</div><div class="line">        //设置右部分的callout：UIButton</div><div class="line">        UIButton *disclosurebutton = [[UIButton alloc] init];</div><div class="line">        [disclosurebutton setBackgroundImage:[UIImage imageNamed:@&quot;disclosure&quot;] forState:UIControlStateNormal];</div><div class="line">        [disclosurebutton sizeToFit];</div><div class="line">        view.rightCalloutAccessoryView = disclosurebutton;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    view.annotation = annotation;</div><div class="line">    return view;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-点击大头针，更新callout左侧显示的缩略图"><a href="#6-点击大头针，更新callout左侧显示的缩略图" class="headerlink" title="6. 点击大头针，更新callout左侧显示的缩略图"></a>6. 点击大头针，更新callout左侧显示的缩略图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> *  点击大头针view</div><div class="line"> *</div><div class="line"> *  @param mapView 大头针所属的mapView</div><div class="line"> *  @param view    大头针view</div><div class="line"> */</div><div class="line">- (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view</div><div class="line">&#123;</div><div class="line">    [self updateLeftCalloutAccessoryViewInAnnotationView:view];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  更新callout里的图片（在左侧）</div><div class="line"> *</div><div class="line"> *  @param annotationView 当前被点击的大头针view</div><div class="line"> */</div><div class="line">- (void)updateLeftCalloutAccessoryViewInAnnotationView:(MKAnnotationView *)annotationView</div><div class="line">&#123;</div><div class="line">    UIImageView *imageView = nil;</div><div class="line">    if ([annotationView.leftCalloutAccessoryView isKindOfClass:[UIImageView class]]) &#123;</div><div class="line">        imageView = (UIImageView *)annotationView.leftCalloutAccessoryView;</div><div class="line">    &#125;</div><div class="line">    if (imageView) &#123;</div><div class="line">        Photo *photo = nil;</div><div class="line">        if ([annotationView.annotation isKindOfClass:[Photo class]]) &#123;</div><div class="line">            photo = (Photo *)annotationView.annotation;</div><div class="line">        &#125;</div><div class="line">        if (photo) &#123;</div><div class="line">            NSString *urlString = photo.thumbnailURL;</div><div class="line">            imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：显示图片的代码：<code>imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]]];</code>方法会阻塞主线程，实际操作中应该放在子线程中执行。详情请参考笔者另一篇讲解关于多线程的博客：<a href="http://www.jianshu.com/p/6e74f5438f2c" target="_blank" rel="external">最浅显易懂的iOS多线程技术 - GCD的教程</a>。</p>
</blockquote>
<h4 id="7-点击callout，在下一页面显示原图"><a href="#7-点击callout，在下一页面显示原图" class="headerlink" title="7. 点击callout，在下一页面显示原图"></a>7. 点击callout，在下一页面显示原图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  点击callout实行跳转</div><div class="line"> *</div><div class="line"> *  @param mapView 当前的mapView</div><div class="line"> *  @param view    当前callout所属的AnnotationView</div><div class="line"> *  @param control callout内部被点击的控件</div><div class="line"> */</div><div class="line">- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view calloutAccessoryControlTapped:(UIControl *)control</div><div class="line">&#123;</div><div class="line">    [self performSegueWithIdentifier:@&quot;Show Photo&quot; sender:view];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  调转执行前的代码</div><div class="line"> *</div><div class="line"> *  @param segue  连接前后两个控制器的segue</div><div class="line"> *  @param sender 被点击的AnnotaionView</div><div class="line"> */</div><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</div><div class="line">&#123;</div><div class="line"> </div><div class="line">    if ([sender isKindOfClass:[MKAnnotationView class]]) &#123;</div><div class="line">        [self prepareViewController:segue.destinationViewController</div><div class="line">                           forSegue:segue.identifier</div><div class="line">                   toShowAnnotation:((MKAnnotationView *)sender).annotation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  为目标控制器准备数据（图片的URL）</div><div class="line"> *</div><div class="line"> *  @param vc              目标控制器</div><div class="line"> *  @param segueIdentifier segue.identifier</div><div class="line"> *  @param annotation      被点击的AnnotaionView</div><div class="line"> */</div><div class="line">- (void)prepareViewController:(id)vc</div><div class="line">                     forSegue:(NSString *)segueIdentifier</div><div class="line">             toShowAnnotation:(id &lt;MKAnnotation&gt;)annotation</div><div class="line">&#123;</div><div class="line">    Photo *photo = nil;</div><div class="line">    if ([annotation isKindOfClass:[Photo class]]) &#123;</div><div class="line">        photo = (Photo *)annotation;</div><div class="line">    &#125;</div><div class="line">    if (photo) &#123;</div><div class="line">        if (![segueIdentifier length] || [segueIdentifier isEqualToString:@&quot;Show Photo&quot;]) &#123;</div><div class="line">            if ([vc isKindOfClass:[ImageViewController class]]) &#123;</div><div class="line">                ImageViewController *ivc = (ImageViewController *)vc;</div><div class="line">                ivc.imageURL = [NSURL URLWithString:photo.imageURL];</div><div class="line">                ivc.title = photo.title;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里的<code>ivc.imageURL = [NSURL URLWithString:photo.imageURL];</code>代码同样会阻塞主线程，实际操作中应该放在子线程来做！</p>
<p>而且,本demo的图片地址应该都是在墙外的，所以最好先让电脑翻墙，然后在模拟器上运行比较好。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本总结将第十四和十五课放在了一起，原因有二：第一是略去了ipad开发Demo的部分（因为笔者木有ipad，无法进行调试）。第二是两节课都讲解了关于地图框架的相关知识，故将二者放在一起总结。&lt;/p&gt;
&lt;p&gt;在本篇总结的最后，会给大家讲解在地图上显示Flickr上摄影师的照片作品。&lt;/p&gt;
&lt;h1 id=&quot;Network-Activity-Indicator&quot;&gt;&lt;a href=&quot;#Network-Activity-Indicator&quot; class=&quot;headerlink&quot; title=&quot;Network Activity Indicator&quot;&gt;&lt;/a&gt;Network Activity Indicator&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;顾名思义，该控件叫做网络活动指示器。当app有网络活动时，可以让状态栏左边的小圆圈滚动用来提示用户当前的网络状态。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;@property(nonatomic,getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果设定为YES，状态栏上的小转轮就会转，反之亦然。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：应用中的所有线程都可使用这个转轮，我们需要通过各种方法来向用户准确显示转轮的状态。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十七）：CoreMotion，app的生命周期，方块碰撞游戏Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9ACoreMotion%EF%BC%8Capp%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E6%96%B9%E5%9D%97%E7%A2%B0%E6%92%9E%E6%B8%B8%E6%88%8FDemo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（十七）：CoreMotion，app的生命周期，方块碰撞游戏Demo/</id>
    <published>2018-02-02T16:16:07.000Z</published>
    <updated>2018-02-02T16:16:07.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲解了Core Motion框架的知识，简单介绍了app的生命周期，最后用一个方块碰撞游戏来对本节课的知识作总结。</p>
<h1 id="Core-Motion"><a href="#Core-Motion" class="headerlink" title="Core Motion"></a>Core Motion</h1><hr>
<p>CoreMotion是一个专门处理设备“动作”的框架，其中包含了加速度计，陀螺仪和磁力针。加速计由三个坐标轴决定，用户最常见的操作设备的动作移动，晃动手机(摇一摇)，倾斜手机都可以被设备检测到，加速计可以检测到线性的变化。陀螺仪可以更好的检测到偏转的动作，可以根据用户的动作做出相应的动作；磁力针可以判断设备的方向。</p>
<p>CoreMotion的工作是基于<code>CMMotionManager</code>类来执行的。我们看一下该类的API：</p>
<h2 id="CMMotionManager"><a href="#CMMotionManager" class="headerlink" title="CMMotionManager"></a>CMMotionManager</h2><h3 id="检测硬件设备："><a href="#检测硬件设备：" class="headerlink" title="检测硬件设备："></a>检测硬件设备：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property(readonly, nonatomic, getter=isAccelerometerAvailable) BOOL accelerometerAvailable __TVOS_PROHIBITED;</div><div class="line">@property(readonly, nonatomic, getter=isGyroAvailable) BOOL gyroAvailable __TVOS_PROHIBITED;</div><div class="line">@property(readonly, nonatomic, getter=isMagnetometerAvailable) BOOL magnetometerAvailable NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</div><div class="line">@property(readonly, nonatomic, getter=isDeviceMotionAvailable) BOOL deviceMotionAvailable __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="开启相应的模块："><a href="#开启相应的模块：" class="headerlink" title="开启相应的模块："></a>开启相应的模块：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)startAccelerometerUpdates __TVOS_PROHIBITED;</div><div class="line">- (void)startGyroUpdates __TVOS_PROHIBITED;</div><div class="line">- (void)startMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</div><div class="line">- (void)startDeviceMotionUpdates __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<h3 id="检测相应的模块是否正在收集数据："><a href="#检测相应的模块是否正在收集数据：" class="headerlink" title="检测相应的模块是否正在收集数据："></a>检测相应的模块是否正在收集数据：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@property(readonly, nonatomic, getter=isAccelerometerActive) BOOL accelerometerActive __TVOS_PROHIBITED;</div><div class="line">@property(readonly, nonatomic, getter=isGyroActive) BOOL gyroActive __TVOS_PROHIBITED;</div><div class="line">@property(readonly, nonatomic, getter=isMagnetometerActive) BOOL magnetometerActive NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</div><div class="line">@property(readonly, nonatomic, getter=isDeviceMotionActive) BOOL deviceMotionActive __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<h3 id="关闭相应的模块："><a href="#关闭相应的模块：" class="headerlink" title="关闭相应的模块："></a>关闭相应的模块：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)stopAccelerometerUpdates __TVOS_PROHIBITED;</div><div class="line">- (void)stopGyroUpdates __TVOS_PROHIBITED;</div><div class="line">- (void)stopMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</div><div class="line">- (void)stopDeviceMotionUpdates __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<h3 id="使用block监听"><a href="#使用block监听" class="headerlink" title="使用block监听"></a>使用block监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler __TVOS_PROHIBITED;</div><div class="line">- (void)startGyroUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMGyroHandler)handler __TVOS_PROHIBITED;</div><div class="line">- (void)startMagnetometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMMagnetometerHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</div><div class="line">- (void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame toQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<h3 id="CMMotionManager的工作步骤"><a href="#CMMotionManager的工作步骤" class="headerlink" title="CMMotionManager的工作步骤"></a>CMMotionManager的工作步骤</h3><ol>
<li>首先初始化<code>CMMotionManager</code>类。</li>
<li>判断硬件设备的可使用性。</li>
<li>调用API<br>详细的使用方法请看Demo部分的讲解部分。</li>
</ol>
<h1 id="app的生命周期"><a href="#app的生命周期" class="headerlink" title="app的生命周期"></a>app的生命周期</h1><hr>
<p>程序在运行过程中，是由各种不同的状态的，在这些状态之间切换时可以执行一些代码用于满足一定的业务需求。</p>
<h2 id="应用程序的几种状态："><a href="#应用程序的几种状态：" class="headerlink" title="应用程序的几种状态："></a>应用程序的几种状态：</h2><ul>
<li>Not running:未运行  程序没启动</li>
<li>Inactive:未激活, 程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。</li>
<li>Active:激活,  程序在前台运行而且接收到了事件。这是程序在前台运行的正常状态。</li>
<li>Backgroud:后台, 程序在后台而且能执行代码。大多数程序进入这个状态后会在在这个状态上停留一会， 时间到之后会进入挂起状态(Suspended)。</li>
<li>Suspended:挂起 ,程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为当前处于前台程序提供更多的内存。</li>
</ul>
<h2 id="应用程序的状态之间切换时调用的代理方法（AppDelegate）："><a href="#应用程序的状态之间切换时调用的代理方法（AppDelegate）：" class="headerlink" title="应用程序的状态之间切换时调用的代理方法（AppDelegate）："></a>应用程序的状态之间切换时调用的代理方法（AppDelegate）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions   //启动基本完成，程序准备开始运行时调用。</div><div class="line">- (void)applicationWillResignActive:(UIApplication *)application          //当应用程序将要入非活动状态执行。在此期间，应用程序不接收消息或事件，比如来电话时。</div><div class="line">- (void)applicationDidBecomeActive:(UIApplication *)application           //当应用程序入活动状态执行。</div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application        //当程序被推到后台的时候调用。</div><div class="line">- (void)applicationWillEnterForeground:(UIApplication *)application       //当程序从后台将要重新回到前台时候调用。</div><div class="line">- (void)applicationWillTerminate:(UIApplication *)application             // 当程序将要退出时调用，通常是用来保存数据和一些退出前的清理工作。</div></pre></td></tr></table></figure>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求:"></a>Demo需求:</h2><ul>
<li>显示两个小方块，一黑一红，二者可以随着屏幕的转动而移动。</li>
<li>由红色方块碰撞黑色方块来得分。</li>
</ul>
<h2 id="Demo效果图："><a href="#Demo效果图：" class="headerlink" title="Demo效果图："></a>Demo效果图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-baa2c6607140ad2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：游戏进行中 | 右：游戏暂停"></p>
<h2 id="重要知识点和代码段："><a href="#重要知识点和代码段：" class="headerlink" title="重要知识点和代码段："></a>重要知识点和代码段：</h2><h4 id="1-添加animator和重力行为和碰撞行为"><a href="#1-添加animator和重力行为和碰撞行为" class="headerlink" title="1. 添加animator和重力行为和碰撞行为"></a>1. 添加animator和重力行为和碰撞行为</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">- (UIDynamicAnimator *)animator</div><div class="line">&#123;</div><div class="line">    if (!_animator) _animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];</div><div class="line">    return _animator;</div><div class="line">&#125;</div><div class="line">- (UICollisionBehavior *)collider</div><div class="line">&#123;</div><div class="line">    if (!_collider) &#123;</div><div class="line">        UICollisionBehavior *collider = [[UICollisionBehavior alloc] init];</div><div class="line">        collider.translatesReferenceBoundsIntoBoundary = YES;</div><div class="line">        [self.animator addBehavior:collider];</div><div class="line">        self.collider = collider;</div><div class="line">    &#125;</div><div class="line">    return _collider;</div><div class="line">&#125;</div><div class="line">- (UIGravityBehavior *)gravity</div><div class="line">&#123;</div><div class="line">    if (!_gravity) &#123;</div><div class="line">        UIGravityBehavior *gravity = [[UIGravityBehavior alloc] init];</div><div class="line">        [self.animator addBehavior:gravity];</div><div class="line">        self.gravity = gravity;</div><div class="line">    &#125;</div><div class="line">    return _gravity;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>老规矩，还是要将animtor添加到view里面再向其添加各种动作行为。有关动画的讲解请参考笔者之前一篇总结：<a href="http://www.jianshu.com/p/5f1f40f963ac" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（八） ：协议，block，动画，俄罗斯方块Demo</a>。</p>
</blockquote>
<h4 id="2-根据偏移量来设置方块的位置"><a href="#2-根据偏移量来设置方块的位置" class="headerlink" title="2. 根据偏移量来设置方块的位置"></a>2. 根据偏移量来设置方块的位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (UIView *)addBlockOffsetFromCenterBy:(UIOffset)offset</div><div class="line">&#123;</div><div class="line">    CGPoint blockCenter = CGPointMake(CGRectGetMidX(self.view.bounds)+offset.horizontal,</div><div class="line">                                      CGRectGetMidY(self.view.bounds)+offset.vertical);</div><div class="line"></div><div class="line">    CGRect blockFrame = CGRectMake(blockCenter.x-blockSize.width/2,</div><div class="line">                                   blockCenter.y-blockSize.height/2,</div><div class="line">                                   blockSize.width,</div><div class="line">                                   blockSize.height);</div><div class="line"></div><div class="line">    UIView *block = [[UIView alloc] initWithFrame:blockFrame];</div><div class="line">    [self.view addSubview:block];</div><div class="line">    return block;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，使用了<code>CGRectGetMidX</code>函数来获得view的横向中心点。</p>
</blockquote>
<h4 id="3-初始化红色和黑色方块"><a href="#3-初始化红色和黑色方块" class="headerlink" title="3. 初始化红色和黑色方块"></a>3. 初始化红色和黑色方块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">        self.redBlock = [self addBlockOffsetFromCenterBy:UIOffsetMake(-100, 0)];</div><div class="line">        self.redBlock.backgroundColor = [UIColor redColor];</div><div class="line">        [self.collider addItem:self.redBlock];</div><div class="line">        [self.gravity addItem:self.redBlock];</div><div class="line">        </div><div class="line">        self.blackBlock = [self addBlockOffsetFromCenterBy:UIOffsetMake(+100, 0)];</div><div class="line">        self.blackBlock.backgroundColor = [UIColor blackColor];</div><div class="line">        [self.collider addItem:self.blackBlock];</div><div class="line"></div><div class="line">        //将开始的重力设为0：方块将不感受重力，只能通过人为手段施加</div><div class="line">        self.gravity.gravityDirection = CGVectorMake(0, 0);</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，红色方块具有碰撞和重力行为，但是黑色方块却只有碰撞行为。因为黑色是不受重力控制的，它的运动的触发只来自红色方块的碰撞。</p>
</blockquote>
<h4 id="4-在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作："><a href="#4-在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作：" class="headerlink" title="4. 在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作："></a>4. 在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationWillResignActiveNotification</div><div class="line">                                                      object:nil</div><div class="line">                                                       queue:nil</div><div class="line">                                                  usingBlock:^(NSNotification *note) &#123;</div><div class="line">                                                      [self pauseGame];</div><div class="line">                                                  &#125;];</div><div class="line"></div><div class="line">    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidBecomeActiveNotification</div><div class="line">                                                     object:nil</div><div class="line">                                                       queue:nil</div><div class="line">                                                  usingBlock:^(NSNotification *note) &#123;</div><div class="line">                                                      if (self.view.window) [self resumeGame];</div><div class="line">                                                  &#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>我们也可以在appdelegate里面来实现这些方法，不过个人认为将方法写在一起看起来比较直观</p>
</blockquote>
<h4 id="5-CMMotionManager的初始化和使用"><a href="#5-CMMotionManager的初始化和使用" class="headerlink" title="5. CMMotionManager的初始化和使用"></a>5. CMMotionManager的初始化和使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">//初始化</div><div class="line">- (CMMotionManager *)motionManager</div><div class="line">&#123;</div><div class="line">    if (!_motionManager) &#123;</div><div class="line">        _motionManager = [[CMMotionManager alloc] init];</div><div class="line">        _motionManager.accelerometerUpdateInterval = 0.1;</div><div class="line">    &#125;</div><div class="line">    return _motionManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//将方法放在主线程的代码块中</div><div class="line"> if (!self.motionManager.isAccelerometerActive) &#123;</div><div class="line"></div><div class="line">        [self.motionManager startAccelerometerUpdatesToQueue:[NSOperationQueue mainQueue]</div><div class="line"></div><div class="line">                                                 withHandler:^(CMAccelerometerData *accelerometerData, NSError *error) &#123;</div><div class="line">    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿//获取加速器的方向</div><div class="line">                                                     CGFloat x = accelerometerData.acceleration.x;</div><div class="line">                                                     CGFloat y = accelerometerData.acceleration.y;</div><div class="line">    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿</div><div class="line">    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿//根据设备的方向来给方块施加不同方向的重力</div><div class="line">                                                     switch (self.interfaceOrientation) &#123;</div><div class="line">                                                         case UIInterfaceOrientationLandscapeRight:</div><div class="line">                                                            self.gravity.gravityDirection = CGVectorMake(- y, - x); break;</div><div class="line">  </div><div class="line">                                                       case UIInterfaceOrientationLandscapeLeft:</div><div class="line">                                                             self.gravity.gravityDirection = CGVectorMake(y, x); break;</div><div class="line"></div><div class="line">                                                         case UIInterfaceOrientationPortrait:</div><div class="line">                                                             self.gravity.gravityDirection = CGVectorMake(x, - y); break;</div><div class="line"></div><div class="line">                                                         case UIInterfaceOrientationPortraitUpsideDown:</div><div class="line">                                                            self.gravity.gravityDirection = CGVectorMake(- x, y); break;</div><div class="line">                                                     &#125;</div><div class="line"></div><div class="line">                                                     [self updateScore];</div><div class="line">                                                 &#125;];</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>如果嫌麻烦的童鞋可以在留言留下邮箱，笔者会将Demo包发给你~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲解了Core Motion框架的知识，简单介绍了app的生命周期，最后用一个方块碰撞游戏来对本节课的知识作总结。&lt;/p&gt;
&lt;h1 id=&quot;Core-Motion&quot;&gt;&lt;a href=&quot;#Core-Motion&quot; class=&quot;headerlink&quot; title=&quot;Core Motion&quot;&gt;&lt;/a&gt;Core Motion&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;CoreMotion是一个专门处理设备“动作”的框架，其中包含了加速度计，陀螺仪和磁力针。加速计由三个坐标轴决定，用户最常见的操作设备的动作移动，晃动手机(摇一摇)，倾斜手机都可以被设备检测到，加速计可以检测到线性的变化。陀螺仪可以更好的检测到偏转的动作，可以根据用户的动作做出相应的动作；磁力针可以判断设备的方向。&lt;/p&gt;
&lt;p&gt;CoreMotion的工作是基于&lt;code&gt;CMMotionManager&lt;/code&gt;类来执行的。我们看一下该类的API：&lt;/p&gt;
&lt;h2 id=&quot;CMMotionManager&quot;&gt;&lt;a href=&quot;#CMMotionManager&quot; class=&quot;headerlink&quot; title=&quot;CMMotionManager&quot;&gt;&lt;/a&gt;CMMotionManager&lt;/h2&gt;&lt;h3 id=&quot;检测硬件设备：&quot;&gt;&lt;a href=&quot;#检测硬件设备：&quot; class=&quot;headerlink&quot; title=&quot;检测硬件设备：&quot;&gt;&lt;/a&gt;检测硬件设备：&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;@property(readonly, nonatomic, getter=isAccelerometerAvailable) BOOL accelerometerAvailable __TVOS_PROHIBITED;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@property(readonly, nonatomic, getter=isGyroAvailable) BOOL gyroAvailable __TVOS_PROHIBITED;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@property(readonly, nonatomic, getter=isMagnetometerAvailable) BOOL magnetometerAvailable NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;@property(readonly, nonatomic, getter=isDeviceMotionAvailable) BOOL deviceMotionAvailable __TVOS_PROHIBITED;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十六）：模态视图，UITextField，UImagePickerController，在Flickr添加摄影师照片Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%80%81%E8%A7%86%E5%9B%BE%EF%BC%8CUITextField,UImagePickerController%EF%BC%8C%E5%9C%A8Flickr%E6%B7%BB%E5%8A%A0%E6%91%84%E5%BD%B1%E5%B8%88%E7%85%A7%E7%89%87Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（十六）：模态视图，UITextField,UImagePickerController，在Flickr添加摄影师照片Demo/</id>
    <published>2018-02-02T16:16:01.000Z</published>
    <updated>2018-02-02T16:16:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲解了模态视图，文本框，UImagePickerController的相关知识，并延续了上一节课的Demo，添加了照相并存储照片的功能。</p>
<h1 id="模态视图"><a href="#模态视图" class="headerlink" title="模态视图"></a>模态视图</h1><hr>
<p>模态视图不同于左右滑入的视图，它是从下往上，覆盖整个屏幕的视图。每次滑入都会重新新建一个控制器。通常用于修改信息等操作。</p>
<p>显示模态视图：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">  [self presentViewController:(nonnull UIViewController *) animated:(BOOL) completion:^&#123;&#125;];</div></pre></td></tr></table></figure>
<p>让模态视图消失：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)dissmissViewControllerAnimated:(BOOL)animated completion:(void(^))block;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意:该消息是发送给present该模态视图的控制器，而不是该模态视图本身。因此，调用方法应该是：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self.presentingViewController dissmissViewControllerAnimated:YES ...];</div></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="UITextField"><a href="#UITextField" class="headerlink" title="UITextField"></a>UITextField</h1><hr>
<p>UITextField是文本框，可以用来输入文字，类似于UILabel。</p>
<h3 id="让键盘出现和消失："><a href="#让键盘出现和消失：" class="headerlink" title="让键盘出现和消失："></a>让键盘出现和消失：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[textField becomeFirstResponder];</div><div class="line">[textField resignFirstResponder];</div></pre></td></tr></table></figure>
<h2 id="代理方法："><a href="#代理方法：" class="headerlink" title="代理方法："></a>代理方法：</h2><h4 id="1-当点击了确定按键-让键盘消失"><a href="#1-当点击了确定按键-让键盘消失" class="headerlink" title="1. 当点击了确定按键,让键盘消失"></a>1. 当点击了确定按键,让键盘消失</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (BOOL)textFieldShouldReturn:(UITextField *)textField</div><div class="line">&#123;</div><div class="line">    [textField resignFirstResponder];</div><div class="line">    return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-当resignFirstResponder完成后执行："><a href="#2-当resignFirstResponder完成后执行：" class="headerlink" title="2. 当resignFirstResponder完成后执行："></a>2. 当resignFirstResponder完成后执行：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)textFieldDidEndEditing:(UITextField *)textField;</div></pre></td></tr></table></figure>
<h4 id="3-内容发生变化时收到通知："><a href="#3-内容发生变化时收到通知：" class="headerlink" title="3. 内容发生变化时收到通知："></a>3. 内容发生变化时收到通知：</h4><p>注册这个广播，就可以收到该通知：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;</div></pre></td></tr></table></figure></p>
<h4 id="4-键盘"><a href="#4-键盘" class="headerlink" title="4. 键盘"></a>4. 键盘</h4><p>设置键盘的类型需要通过给实现<code>UITextInputTraits</code>的协议方法，通常是<code>UITextField</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@protocol UITextInputTraits &lt;NSObject&gt;</div><div class="line"></div><div class="line">@optional</div><div class="line">@property(nonatomic) UITextAutocapitalizationType autocapitalizationType; // 自动大写</div><div class="line">@property(nonatomic) UIKeyboardType keyboardType;                         // default is UIKeyboardTypeDefault</div><div class="line">@property(nonatomic) UIReturnKeyType returnKeyType;                       // 回车键，返回键，搜索键盘</div><div class="line">@property(nonatomic,getter=isSecureTextEntry) BOOL secureTextEntry;       // 密码</div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="5-监听键盘的高度："><a href="#5-监听键盘的高度：" class="headerlink" title="5. 监听键盘的高度："></a>5. 监听键盘的高度：</h4><p>通过注册<code>UIKeyboard{will,did} {show hide}</code>广播来计算键盘弹出后的高度。</p>
<h1 id="Alert"><a href="#Alert" class="headerlink" title="Alert"></a>Alert</h1><p>Alert是用来提醒用户某些消息的控件，它会出现在屏幕的正中央。我们可以自定义它的显示消息和按钮。也可以设定点击某个按钮执行的操作。</p>
<h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithTitle:(nullable NSString *)title delegate:(nullable id&lt;UIActionSheetDelegate&gt;)delegate cancelButtonTitle:(nullable NSString *)cancelButtonTitle destructiveButtonTitle:(nullable NSString *)destructiveButtonTitle otherButtonTitles:(nullable NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION NS_EXTENSION_UNAVAILABLE_IOS(&quot;Use UIAlertController instead.&quot;);</div></pre></td></tr></table></figure>
<h2 id="增加按钮"><a href="#增加按钮" class="headerlink" title="增加按钮"></a>增加按钮</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)addButtonWithTitle:(nullable NSString *)title;</div></pre></td></tr></table></figure>
<h2 id="显示在屏幕上"><a href="#显示在屏幕上" class="headerlink" title="显示在屏幕上:"></a>显示在屏幕上:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated NS_AVAILABLE_IOS(3_2);</div><div class="line">- (void)showInView:(UIView *)view;</div></pre></td></tr></table></figure>
<h2 id="处理点击事件："><a href="#处理点击事件：" class="headerlink" title="处理点击事件："></a>处理点击事件：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 8_3) __TVOS_PROHIBITED;  // after animation</div></pre></td></tr></table></figure>
<h2 id="手动让其消失"><a href="#手动让其消失" class="headerlink" title="手动让其消失"></a>手动让其消失</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;</div></pre></td></tr></table></figure>
<h1 id="UImagePickerController"><a href="#UImagePickerController" class="headerlink" title="UImagePickerController"></a>UImagePickerController</h1><hr>
<p>UImagePickerController是用来选取图片，视频资源的控制器，也可以进行拍照。</p>
<h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><ol>
<li>alloc/init, set delegate</li>
<li>配置摄像头，照片库，用户是否可以编辑相片</li>
<li>显示</li>
<li>实现代理方法，获取媒体</li>
</ol>
<h2 id="检查硬件设备："><a href="#检查硬件设备：" class="headerlink" title="检查硬件设备："></a>检查硬件设备：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (BOOL)isSourceTypeAvailable:(UIImagePickerControllerSourceType)sourceType;  </div><div class="line"></div><div class="line">typedef NS_ENUM(NSInteger, UIImagePickerControllerSourceType) &#123;</div><div class="line">    UIImagePickerControllerSourceTypePhotoLibrary,</div><div class="line">    UIImagePickerControllerSourceTypeCamera,</div><div class="line">    UIImagePickerControllerSourceTypeSavedPhotosAlbum</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="检查是否可以摄像："><a href="#检查是否可以摄像：" class="headerlink" title="检查是否可以摄像："></a>检查是否可以摄像：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (nullable NSArray&lt;NSString *&gt; *)availableMediaTypesForSourceType:(UIImagePickerControllerSourceType)sourceType;</div></pre></td></tr></table></figure>
<p>返回的数组是否有相应的字段：<br>kUTTypeImage<br>kUTTypeMovie</p>
<h2 id="允许用户编辑（裁剪）："><a href="#允许用户编辑（裁剪）：" class="headerlink" title="允许用户编辑（裁剪）："></a>允许用户编辑（裁剪）：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property BOOL allowEditing;</div></pre></td></tr></table></figure>
<h2 id="获取了媒体（照片）后的代理方法"><a href="#获取了媒体（照片）后的代理方法" class="headerlink" title="获取了媒体（照片）后的代理方法"></a>获取了媒体（照片）后的代理方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info;</div></pre></td></tr></table></figure>
<h2 id="点击了取消后的代理方法："><a href="#点击了取消后的代理方法：" class="headerlink" title="点击了取消后的代理方法："></a>点击了取消后的代理方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker</div><div class="line">&#123;</div><div class="line">    [self dismissViewControllerAnimated:YES completion:NULL];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求："><a href="#Demo需求：" class="headerlink" title="Demo需求："></a>Demo需求：</h2><ul>
<li>在原摄影师列表的第一行添加“我的照片”。</li>
<li>点击“我的照片”后，显示地图上“我”所照照片的地点。</li>
<li>点击大头针，显示相应照片详情。</li>
<li>在导航栏右上角显示照相机按钮。</li>
<li>点击照相机按钮，从底部弹出添加照片的页面。</li>
<li>点击“Take Photo”,启动相机，照相并可以裁剪。</li>
<li>裁剪后，回到添加剂照片的页面。设置标题和副标题后，保存照片。</li>
<li>回到地图页面，自动添加刚才所增加照片的大头针。</li>
</ul>
<h2 id="Demo效果图"><a href="#Demo效果图" class="headerlink" title="Demo效果图"></a>Demo效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-b1f9ecf0f562f5c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：添加照片 | 中：在地图上标注位置 | 右：点击查看大图"></p>
<h2 id="重要知识点和代码段"><a href="#重要知识点和代码段" class="headerlink" title="重要知识点和代码段"></a>重要知识点和代码段</h2><h4 id="1-在添加照片页面显示后判断是否可以拍照"><a href="#1-在添加照片页面显示后判断是否可以拍照" class="headerlink" title="1. 在添加照片页面显示后判断是否可以拍照"></a>1. 在添加照片页面显示后判断是否可以拍照</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">    </div><div class="line">    if (![[self class] canAddPhoto]) &#123;</div><div class="line">        [self fatalAlert:@&quot;Sorry, this device cannot add a photo.&quot;];</div><div class="line">    &#125; else &#123;</div><div class="line">        [self.locationManager startUpdatingLocation];//开始更新位置</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewWillDisappear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewWillDisappear:animated];</div><div class="line">    //页面消失前，停止更新位置，避免耗能    </div><div class="line">    [self.locationManager stopUpdatingLocation];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  判断当前设备是否可以添加照片</div><div class="line"> *</div><div class="line"> *  @return 是否</div><div class="line"> */</div><div class="line"></div><div class="line">+ (BOOL)canAddPhoto</div><div class="line">&#123;</div><div class="line">    //判断相机是否可用</div><div class="line">    if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) &#123;</div><div class="line">        //返回支持媒体类型的数组</div><div class="line">        NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];</div><div class="line"></div><div class="line">        //判断数组里有无照片类型</div><div class="line">        if ([availableMediaTypes containsObject:(NSString *)kUTTypeImage]) &#123;</div><div class="line"></div><div class="line">            //判断可以支持照片类型后，判断当前设备是否可以获取位置信息</div><div class="line">            if ([CLLocationManager authorizationStatus] != kCLAuthorizationStatusRestricted) &#123;</div><div class="line"></div><div class="line">                return YES;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return NO;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)fatalAlert:(NSString *)msg</div><div class="line">&#123;</div><div class="line">    [[[UIAlertView alloc] initWithTitle:@&quot;Add Photo&quot;</div><div class="line">                                message:msg</div><div class="line">                               delegate:self</div><div class="line">                      cancelButtonTitle:nil</div><div class="line">                      otherButtonTitles:@&quot;Cancel&quot;, nil] show];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-CLLocationManager的初始化和使用"><a href="#2-CLLocationManager的初始化和使用" class="headerlink" title="2. CLLocationManager的初始化和使用"></a>2. CLLocationManager的初始化和使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">- (CLLocationManager *)locationManager</div><div class="line">&#123;</div><div class="line">    if (!_locationManager) &#123;</div><div class="line"></div><div class="line">        //1. 初始化</div><div class="line">        CLLocationManager *locationManager = [[CLLocationManager alloc] init];</div><div class="line"></div><div class="line">        //2. 设置代理</div><div class="line">        locationManager.delegate = self;</div><div class="line"></div><div class="line">        //3. 设置精度</div><div class="line">        locationManager.desiredAccuracy = kCLLocationAccuracyBest;</div><div class="line">        _locationManager = locationManager;</div><div class="line">        //4. iOS8以上要调用，否则无法监听位置！</div><div class="line">        [_locationManager requestAlwaysAuthorization];</div><div class="line">        [_locationManager requestWhenInUseAuthorization];</div><div class="line">    &#125;</div><div class="line">    return _locationManager;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations</div><div class="line">&#123;</div><div class="line">    //获取最后得到的位置信息（最准确）</div><div class="line">    self.location = [locations lastObject];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error</div><div class="line">&#123;</div><div class="line">    //获取错误码</div><div class="line">    self.locationErrorCode = error.code;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-UIImagePickerController的初始化和使用"><a href="#3-UIImagePickerController的初始化和使用" class="headerlink" title="3. UIImagePickerController的初始化和使用"></a>3. UIImagePickerController的初始化和使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/**</div><div class="line"> *  点击了“Take Photo 添加照片”</div><div class="line"> */</div><div class="line">- (IBAction)takePhoto</div><div class="line">&#123;</div><div class="line">    //1. 初始化</div><div class="line">    UIImagePickerController *uiipc = [[UIImagePickerController alloc] init];</div><div class="line"></div><div class="line">    //2. 设置代理</div><div class="line">    uiipc.delegate = self;</div><div class="line"></div><div class="line">    //3. 获取图片媒体</div><div class="line">    uiipc.mediaTypes = @[(NSString *)kUTTypeImage];</div><div class="line">    uiipc.sourceType = UIImagePickerControllerSourceTypeCamera | UIImagePickerControllerSourceTypePhotoLibrary;</div><div class="line"></div><div class="line">    //4. 允许裁剪</div><div class="line">    uiipc.allowsEditing = YES;</div><div class="line"></div><div class="line">    //5. 弹出UIImagePickerController</div><div class="line">    [self presentViewController:uiipc animated:YES completion:NULL];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  拍照成功</div><div class="line"> *</div><div class="line"> *  @param picker 当前的UIImagePickerController</div><div class="line"> *  @param info   获取的照片信息</div><div class="line"> */</div><div class="line"></div><div class="line">- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info</div><div class="line">&#123;</div><div class="line">    //获取裁剪后的图片</div><div class="line">    UIImage *image = info[UIImagePickerControllerEditedImage];</div><div class="line"></div><div class="line">    //如果无法获取裁剪后的图片，获取原图</div><div class="line">    if (!image) image = info[UIImagePickerControllerOriginalImage];</div><div class="line"></div><div class="line">    //更新当前的image属性</div><div class="line">    self.image = image;</div><div class="line"></div><div class="line">    [self dismissViewControllerAnimated:YES completion:NULL];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  点击了取消</div><div class="line"> *</div><div class="line"> *  @param picker 当前的UIImagePickerController</div><div class="line"> */</div><div class="line">- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker</div><div class="line">&#123;</div><div class="line">    [self dismissViewControllerAnimated:YES completion:NULL];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-判断是否执行某个Segue的Identifier"><a href="#4-判断是否执行某个Segue的Identifier" class="headerlink" title="4. 判断是否执行某个Segue的Identifier"></a>4. 判断是否执行某个Segue的Identifier</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(id)sender</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if ([identifier isEqualToString:@&quot;Do Add Photo&quot;]) &#123;</div><div class="line">        if (!self.image) &#123;</div><div class="line">            //无照片</div><div class="line">            [self alert:@&quot;No photo taken!&quot;];</div><div class="line">            return NO;</div><div class="line">            </div><div class="line">        &#125; else if (![self.titleTextField.text length]) &#123;</div><div class="line"></div><div class="line">            //无标题</div><div class="line">            [self alert:@&quot;Title required!&quot;];</div><div class="line">            return NO;</div><div class="line">       </div><div class="line">        &#125; else if (!self.location) &#123;</div><div class="line">            </div><div class="line">            //没有获取到位置信息</div><div class="line">            switch (self.locationErrorCode) &#123;</div><div class="line"></div><div class="line">                case kCLErrorLocationUnknown:</div><div class="line">                    [self alert:@&quot;Couldn&apos;t figure out where this photo was taken (yet).&quot;]; break;</div><div class="line"></div><div class="line">                case kCLErrorDenied:</div><div class="line">                    [self alert:@&quot;Location Services disabled under Privacy in Settings application.&quot;]; break;</div><div class="line"></div><div class="line">                case kCLErrorNetwork:</div><div class="line">                    [self alert:@&quot;Can&apos;t figure out where this photo is being taken.  Verify your connection to the network.&quot;]; break;</div><div class="line"></div><div class="line">                default:</div><div class="line">                    [self alert:@&quot;Cant figure out where this photo is being taken, sorry.&quot;]; break;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            return NO;</div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; else &#123;</div><div class="line"></div><div class="line">        return [super shouldPerformSegueWithIdentifier:identifier sender:sender];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)alert:(NSString *)msg</div><div class="line">&#123;</div><div class="line"></div><div class="line">    [[[UIAlertView alloc] initWithTitle:@&quot;Add Photo&quot;</div><div class="line">                                message:msg</div><div class="line">                               delegate:nil</div><div class="line">                      cancelButtonTitle:nil</div><div class="line">                      otherButtonTitles:@&quot;Cancel&quot;, nil] show];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在添加照片后，我们需要将该页面取消并储存相应的数据。但由于业务需求，如果想要储存数据的前提下取消页面的话，那么就需要在取消页面之前来判断当前的数据是否满足储存的条件：是否有照片；是否设置了标题；是否获取了位置信息等。</p>
</blockquote>
<h4 id="5-确定页面可以被取消后，在页面被取消前储存数据："><a href="#5-确定页面可以被取消后，在页面被取消前储存数据：" class="headerlink" title="5. 确定页面可以被取消后，在页面被取消前储存数据："></a>5. 确定页面可以被取消后，在页面被取消前储存数据：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</div><div class="line">&#123;</div><div class="line"></div><div class="line">    if ([segue.identifier isEqualToString:@&quot;Do Add Photo&quot;]) &#123;</div><div class="line"></div><div class="line">        NSManagedObjectContext *context = self.photographerTakingPhoto.managedObjectContext;</div><div class="line"></div><div class="line">        if (context) &#123;</div><div class="line"></div><div class="line">            Photo *photo = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Photo&quot;  inManagedObjectContext:context];</div><div class="line"></div><div class="line">            photo.title = self.titleTextField.text;</div><div class="line">            photo.subtittle = self.subtitleTextField.text;</div><div class="line">            photo.whoTook = self.photographerTakingPhoto;</div><div class="line">            photo.latitude = @(self.location.coordinate.latitude);</div><div class="line">            photo.longitude = @(self.location.coordinate.longitude);</div><div class="line">            photo.imageURL = [self.imageURL absoluteString];</div><div class="line">            photo.thumbnailURL = [self.thumbnailURL absoluteString];            </div><div class="line"></div><div class="line">            self.addedPhoto = photo;         </div><div class="line">            self.imageURL = nil;</div><div class="line">            self.thumbnailURL = nil;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="6-获取新增图片的本地路径"><a href="#6-获取新增图片的本地路径" class="headerlink" title="6. 获取新增图片的本地路径"></a>6. 获取新增图片的本地路径</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> *  获取图片的本地URL</div><div class="line"> *</div><div class="line"> *  @return 图片的本地URL</div><div class="line"> */</div><div class="line"></div><div class="line">- (NSURL *)imageURL</div><div class="line">&#123;</div><div class="line">    if (!_imageURL &amp;&amp; self.image) &#123;</div><div class="line">        NSURL *url = [self uniqueDocumentURL];</div><div class="line">        if (url) &#123;</div><div class="line">            //UIImage -&gt; NSData</div><div class="line">            NSData *imageData = UIImageJPEGRepresentation(self.image, 1.0);</div><div class="line">            //将data写入url</div><div class="line">            if ([imageData writeToURL:url atomically:YES]) &#123;</div><div class="line">                //如果写入成功，更新imageURL属性</div><div class="line">                _imageURL = url;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return _imageURL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  获取图片缩略图的本地URL</div><div class="line"> *</div><div class="line"> *  @return 缩略图的本地URL</div><div class="line"> */</div><div class="line"></div><div class="line">- (NSURL *)thumbnailURL</div><div class="line">&#123;</div><div class="line"></div><div class="line">    NSURL *url = [self.imageURL URLByAppendingPathExtension:@&quot;thumbnail&quot;];</div><div class="line">    if (![_thumbnailURL isEqual:url]) &#123;</div><div class="line"></div><div class="line">        _thumbnailURL = nil;</div><div class="line">        if (url) &#123;</div><div class="line">            //以某Size压缩图片（详情请看本Demo添加的image分类）</div><div class="line">            UIImage *thumbnail = [self.image imageByScalingToSize:CGSizeMake(75, 75)];</div><div class="line"></div><div class="line">            //0.5倍压缩</div><div class="line">            NSData *imageData = UIImageJPEGRepresentation(thumbnail, 0.5);</div><div class="line"></div><div class="line">            if ([imageData writeToURL:url atomically:YES]) &#123;</div><div class="line">                _thumbnailURL = url;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return _thumbnailURL;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/**</div><div class="line"> *  以时间来生成唯一本地路径</div><div class="line"> *</div><div class="line"> *  @return 本地路径</div><div class="line"> */</div><div class="line"></div><div class="line">- (NSURL *)uniqueDocumentURL</div><div class="line">&#123;</div><div class="line"></div><div class="line">    NSArray *documentDirectories = [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask];</div><div class="line"></div><div class="line">    NSString *unique = [NSString stringWithFormat:@&quot;%.0f&quot;, floor([NSDate timeIntervalSinceReferenceDate])];</div><div class="line">    return [[documentDirectories firstObject] URLByAppendingPathComponent:unique];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，我们用当前的时间来拼接Document路径，获得了图片的唯一地址。</p>
</blockquote>
<p>笔者今天在公司附近拍了一张照片来验证效果：一张南京东路苹果旗舰店的照片，不过定位比较不准。可能是由于周围高楼比较多，而且定位时间不够长的关系。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>如果嫌麻烦的童鞋可以在留言留下邮箱，笔者会将Demo包发给你~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲解了模态视图，文本框，UImagePickerController的相关知识，并延续了上一节课的Demo，添加了照相并存储照片的功能。&lt;/p&gt;
&lt;h1 id=&quot;模态视图&quot;&gt;&lt;a href=&quot;#模态视图&quot; class=&quot;headerlink&quot; title=&quot;模态视图&quot;&gt;&lt;/a&gt;模态视图&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;模态视图不同于左右滑入的视图，它是从下往上，覆盖整个屏幕的视图。每次滑入都会重新新建一个控制器。通常用于修改信息等操作。&lt;/p&gt;
&lt;p&gt;显示模态视图：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;  [self presentViewController:(nonnull UIViewController *) animated:(BOOL) completion:^&amp;#123;&amp;#125;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;让模态视图消失：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;- (void)dissmissViewControllerAnimated:(BOOL)animated completion:(void(^))block;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意:该消息是发送给present该模态视图的控制器，而不是该模态视图本身。因此，调用方法应该是：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[self.presentingViewController dissmissViewControllerAnimated:YES ...];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十二 十三）：CoreData,表格视图，Flickr摄影师资料列表Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%BA%8C%20%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9ACoreData%EF%BC%8C%E8%A1%A8%E6%A0%BC%E8%A7%86%E5%9B%BE%EF%BC%8CFlickr%E6%91%84%E5%BD%B1%E5%B8%88%E8%B5%84%E6%96%99%E5%88%97%E8%A1%A8/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（十二 十三）：CoreData，表格视图，Flickr摄影师资料列表/</id>
    <published>2018-02-02T16:15:56.000Z</published>
    <updated>2018-02-02T16:15:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>第十二课和第十三课都介绍了CoreData的知识，并在十三课的中段通过一个Demo来具体实现了CoreData的操作。</p>
<p>笔者之前从未接触过Core Data的相关知识，因此学期这两节课比较吃力，这一篇总结还是有很多需要改进的地方，以后随着对Core Data认识的深入和对这两节课的反复咀嚼，会不断更新该总结。</p>
<p>开始吧！</p>
<a id="more"></a>
<h1 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h1><hr>
<p>Core Data是一种持久化技术，它能将模型对象的状态持久化到磁盘，但它最重要的特点是：Core Data不仅是一个加载、保存数据的框架，它还能和内存中的数据很好的共事。</p>
<p>排除错误认识：Core Data<strong>并不是数据库!</strong> 它只是连接类（Class）和数据库（SQL）的桥梁。通过Core Data的相关功能，我们可以对数据库进行增删改查的操作。</p>
<h2 id="CoreData是如何工作的呢？"><a href="#CoreData是如何工作的呢？" class="headerlink" title="CoreData是如何工作的呢？"></a>CoreData是如何工作的呢？</h2><h3 id="1-创建对象的可视化映射"><a href="#1-创建对象的可视化映射" class="headerlink" title="1. 创建对象的可视化映射"></a>1. 创建对象的可视化映射</h3><p>在看到可视化映射之前，需要了解<strong>实体</strong>的概念：</p>
<blockquote>
<p><strong>实体的概念</strong>：每个实体是一个表，每个表对应一个对象。<br>简单粗暴的理解：实体在数据库领域叫做表，在面向对象领域叫做对象。</p>
<p><strong>实体之间的关系</strong>=表之间创建关系，对象之间的关系。</p>
</blockquote>
<p><strong>注意</strong>：两个对象之间的关系在两个对象端具有不同的名称。而且关系的对应数量也是不同的：<code>to one</code>,<code>to many</code>。</p>
<blockquote>
<p>举个🌰 ：摄影者和照片的关系：<br>摄影者对应多个照片，但是照片只对应一个摄影者。</p>
</blockquote>
<p>那么言归正传，如何创建对象的可视化映射呢？</p>
<ol>
<li>创建模型文件，用来装入各种需要映射的实体。</li>
<li>在模型内部添加实体（Entity），创建实体之间的关系（必要时）。</li>
</ol>
<p>下面笔者录制了创建实体，增加实体属性，连接实体的操作：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-ca646fa9e1e18f5a.gif?imageMogr2/auto-orient/strip" alt="创建实体，增加属性"></p>
<h3 id="2-为实体创建NSManagedObjectd子类"><a href="#2-为实体创建NSManagedObjectd子类" class="headerlink" title="2. 为实体创建NSManagedObjectd子类"></a>2. 为实体创建NSManagedObjectd子类</h3><p>我们需要将刚得到的可视化的实体“转变为”具体的类。在Core Data中，这些类都是NSManagedObjectd子类。</p>
<p>下面演示一下其创建过程：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-2eab784599ea6776.gif?imageMogr2/auto-orient/strip" alt="创建NSManagedObjectd子类"></p>
<p>以实体<code>Photo</code>为例，系统为我们生成了<code>Photo.h</code>和<code>Photo.m</code>。</p>
<p>我们先看一下<code>Photo.h</code>:</p>
<p>``</p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>#import <coredata coredata.h=""></coredata></p>
<p>NS_ASSUME_NONNULL_BEGIN<br>@interface Photo : NSManagedObject<br>// Insert code here to declare functionality of your managed object subclass<br>@end<br>NS_ASSUME_NONNULL_END</p>
<p>#import “Photo+CoreDataProperties.h”<br>``</p>
<blockquote>
<p>我们可以看到，<code>Photo</code>类继承了<code>NSManagedObject</code>。</p>
</blockquote>
<p>但是，有意思的是，系统还为我们自动生成了<code>Photo+CoreDataProperties.h</code>和<code>Photo+CoreDataProperties.m</code>，详情见动图左侧，创建实体类之后。</p>
<p><strong>思考</strong>：<br>生成这两个文件的目的是什么呢？<br>首先，我们首先要知道这两个文件是什么：<br>他们构成了<code>Photo</code>类的分类(Category)。</p>
<p>那么什么是分类呢？<br>通过分类，我们可以向原有的类添加方法，而不需要通过继承的方式。分类的局限是：在分类里不能再添加属性。</p>
<p>那么显然，通过<code>Photo+CoreDataProperties</code>，我们就可以不用继承<code>Photo</code>类来给其添加方法。因为原有的<code>Photo</code>类只具有属性，除了获取属性之外，并不能为我们做其他的事情。这时，如果可以在其他的地方给其无限地添加方法还是很具有诱惑力的。令人欣慰的是，系统可以自动为我们生成。</p>
<h3 id="3-通过创建NSManagedObjectContext访问，操作数据库"><a href="#3-通过创建NSManagedObjectContext访问，操作数据库" class="headerlink" title="3. 通过创建NSManagedObjectContext访问，操作数据库"></a>3. 通过创建NSManagedObjectContext访问，操作数据库</h3><p>数据库创建对象，设置对象属性，查询对象都需要<code>NSManagedObjectContext</code>。</p>
<p>创建<code>NSManagedObjectContext</code>的两个不同的方法：</p>
<p>1.通过其自身的初始化：</p>
<p><code>[NSManagedObjectContext alloc] init];</code></p>
<p>2.通过UIManagedDocument创建：</p>
<p>UIManagedDocument 用于管理存储的机制，将Core Data数据库放入某存储空间。<br><code>UIManagedDocument *document = [[UIManagedDocument alloc] initWithFileURL:url];
//url:这个core data 数据库存储的地方</code></p>
<h2 id="数据库的操作："><a href="#数据库的操作：" class="headerlink" title="数据库的操作："></a>数据库的操作：</h2><h4 id="1-向数据库添加对象（实体）："><a href="#1-向数据库添加对象（实体）：" class="headerlink" title="1. 向数据库添加对象（实体）："></a>1. 向数据库添加对象（实体）：</h4><p><code>[NSEntityDescription insertNewObjectForEntityForName:@&quot;Photo&quot; inManagedObjectContext:context];</code></p>
<h4 id="2-从数据库删除对象（实体）："><a href="#2-从数据库删除对象（实体）：" class="headerlink" title="2. 从数据库删除对象（实体）："></a>2. 从数据库删除对象（实体）：</h4><p><code>[aDocument.managedObjectContext deleteObject:photo];</code></p>
<p>删除对象后，系统会向所有对象发送这个消息</p>
<p>``</p>
<ul>
<li>(void)prepareForDeletion{<br> //在这里保持数据同步，比如删掉这个对象的时候会影响到其他对象的数据<br>  //应该在这个对象被删除前及时更新那个数据<br> }</li>
</ul>
<p>``</p>
<h4 id="3-在数据库查询对象（实体）："><a href="#3-在数据库查询对象（实体）：" class="headerlink" title="3. 在数据库查询对象（实体）："></a>3. 在数据库查询对象（实体）：</h4><p>我们使用<code>NSFetchRequest</code>类查询数据库的对象，通过设置其不同属性来查找符合不同标准的数据：</p>
<p>举个🌰 ：查找出100个photo的实体：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Photo&quot;];</div><div class="line">request.fetchLimit = 100;</div></pre></td></tr></table></figure>
<h2 id="关于Core-data的线程安全"><a href="#关于Core-data的线程安全" class="headerlink" title="关于Core data的线程安全"></a>关于Core data的线程安全</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//让context在安全队列中执行的方法</div><div class="line">[context performBlock:^&#123;</div><div class="line">    [A doSomething];</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h1 id="NSFetchedResultsController"><a href="#NSFetchedResultsController" class="headerlink" title="NSFetchedResultsController"></a>NSFetchedResultsController</h1><hr>
<p>NSFetchedResultsController的作用是将NSFetchRequest 和 UITalbleView联系到一起。<br>和TableView的数据源方法类似：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section&#123;</div><div class="line">  return [[self.fetchedResultsController sections] count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView&#123;</div><div class="line">   return [[self.fetchedResultsController sections] count] objectAtIndex:section] numberOfObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详细的使用方法会在Demo讲解部分中告诉大家。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>每隔20分钟，从flickr拿回最新的摄影者数据。</li>
<li>用一个TableView显示当前拿回的摄影者的名字和所照的照片数。</li>
</ul>
<h2 id="Demo效果图"><a href="#Demo效果图" class="headerlink" title="Demo效果图"></a>Demo效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-72dc6873f1c13917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="摄影师的信息列表"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-在启动接口获取flickr的数组"><a href="#1-在启动接口获取flickr的数组" class="headerlink" title="1. 在启动接口获取flickr的数组"></a>1. 在启动接口获取flickr的数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">     self.photoDatabaseContext = [self createMainQueueManagedObjectContext];    </div><div class="line">     [self startFlickrFetch];   </div><div class="line">     return YES;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)startFlickrFetch</div><div class="line">&#123;</div><div class="line">    [self.flickrDownloadSession getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</div><div class="line">        if (![downloadTasks count]) &#123;</div><div class="line">            NSURLSessionDownloadTask *task = [self.flickrDownloadSession downloadTaskWithURL:[FlickrFetcher URLforRecentGeoreferencedPhotos]];</div><div class="line">            task.taskDescription = FLICKR_FETCH;</div><div class="line">            [task resume];</div><div class="line">        &#125; else &#123;</div><div class="line">            for (NSURLSessionDownloadTask *task in downloadTasks) [task resume];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-每隔20分钟获取新的内容"><a href="#2-每隔20分钟获取新的内容" class="headerlink" title="2. 每隔20分钟获取新的内容"></a>2. 每隔20分钟获取新的内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (void)setPhotoDatabaseContext:(NSManagedObjectContext *)photoDatabaseContext</div><div class="line">&#123;</div><div class="line">    _photoDatabaseContext = photoDatabaseContext;</div><div class="line">    </div><div class="line">    //photoDatabaseContext设定成功后，每隔20分钟重新获取信息</div><div class="line">    if (self.photoDatabaseContext)</div><div class="line">    &#123;</div><div class="line">        self.flickrForegroundFetchTimer = [NSTimer scheduledTimerWithTimeInterval:FOREGROUND_FLICKR_FETCH_INTERVAL</div><div class="line">                                                                           target:self</div><div class="line">                                                                         selector:@selector(startFlickrFetch:)</div><div class="line">                                                                         userInfo:nil</div><div class="line">                                                                          repeats:YES];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //photoDatabaseContext设定成功后 向控制器发送消息</div><div class="line">    NSDictionary *userInfo = self.photoDatabaseContext ? @&#123; PhotoDatabaseAvailabilityContext : self.photoDatabaseContext &#125; : nil;</div><div class="line">    [[NSNotificationCenter defaultCenter] postNotificationName:PhotoDatabaseAvailabilityNotification</div><div class="line">                                                        object:self</div><div class="line">                                                      userInfo:userInfo];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-在表格视图查询所有摄影师的名字"><a href="#3-在表格视图查询所有摄影师的名字" class="headerlink" title="3. 在表格视图查询所有摄影师的名字"></a>3. 在表格视图查询所有摄影师的名字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)setManagedObjectContext:(NSManagedObjectContext *)managedObjectContext</div><div class="line">&#123;</div><div class="line">    //哪个数据库</div><div class="line">    _managedObjectContext = managedObjectContext;</div><div class="line">    </div><div class="line">    NSFetchRequest *requet = [NSFetchRequest fetchRequestWithEntityName:@&quot;Photographer&quot;];</div><div class="line">    requet.predicate = nil;//所有的,无过滤</div><div class="line">    requet.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES selector:@selector(localizedStandardCompare:)]];</div><div class="line"></div><div class="line">    self.fetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:requet managedObjectContext:managedObjectContext sectionNameKeyPath:nil cacheName:nil];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-重写tablelViwe-cellForRowAtIndex-方法，显示摄影师数据"><a href="#4-重写tablelViwe-cellForRowAtIndex-方法，显示摄影师数据" class="headerlink" title="4. 重写tablelViwe:cellForRowAtIndex:方法，显示摄影师数据"></a>4. 重写<code>tablelViwe:cellForRowAtIndex:</code>方法，显示摄影师数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Photographer cell&quot;];</div><div class="line">    </div><div class="line">    //拿到摄影师的名字和摄影数量</div><div class="line">    Photographer *photographer = [self.fetchedResultsController objectAtIndexPath:indexPath];</div><div class="line">    cell.textLabel.text = photographer.name;</div><div class="line">    cell.detailTextLabel.text = [NSString stringWithFormat:@&quot;%lu photos&quot;, [photographer.photos count]];    </div><div class="line">    return cell;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本Demo显然是一个未完成品，它只显示了摄影师的相关信息，并且只有一个页面。在接下来的课程中应该会对该Demo进行更多过的扩展。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第十二课和第十三课都介绍了CoreData的知识，并在十三课的中段通过一个Demo来具体实现了CoreData的操作。&lt;/p&gt;
&lt;p&gt;笔者之前从未接触过Core Data的相关知识，因此学期这两节课比较吃力，这一篇总结还是有很多需要改进的地方，以后随着对Core Data认识的深入和对这两节课的反复咀嚼，会不断更新该总结。&lt;/p&gt;
&lt;p&gt;开始吧！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AEUI/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI/</id>
    <published>2018-02-02T16:15:47.000Z</published>
    <updated>2018-02-02T16:15:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是斯坦福大学iOS7系列课程（CS193P）的最后一节课的总结，终于把18节课的内容都总结完了，而且这个文集也画上了句号，有点不舍的赶脚。。</p>
<p>好了，不煽情了，开始！<br><a id="more"></a></p>
<h1 id="国际化-Internationalization"><a href="#国际化-Internationalization" class="headerlink" title="国际化 Internationalization"></a>国际化 Internationalization</h1><hr>
<p>如果我们想要将app推广到国际市场，那么就免不了将我们的app翻译成其他国家的语言以便于当地人去使用。</p>
<p>而翻译的内容主要集中于“非内容”部分：例如标题类文字，按钮上的文字，提示框的文字等等。</p>
<p>所谓“翻译”app的过程主要分为<strong>国际化</strong>和<strong>本地化</strong>两个步骤：</p>
<ol>
<li>国际化：是让app能够本地化的过程。</li>
<li>本地化：将程序翻译另外一种语言。<ul>
<li>故事版字符串的本地化：改变故事版中出现的字符串。</li>
<li>类文件字符串的本地化：改变文件中出现的字符串，包括字符串面量和非字符串面量。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>好的UI设计：给用户呈现出的内容大多数都需要显示的（内容），而不是自己添加的（提示）。这样一来，也会减少我们本地化的工作量。</li>
<li>所有的地方都要设置好自动布局，否则本地化将无从谈起，因为将文字翻译成其他语言后，长度很可能是不一样的。</li>
</ol>
</blockquote>
<p>下面来来具体看一下本地化的方法，分为<strong>故事版中字符串</strong>的本地化和<strong>类文件中字符串</strong>的本地化。</p>
<h2 id="1-故事版中的本地化"><a href="#1-故事版中的本地化" class="headerlink" title="1. 故事版中的本地化"></a>1. 故事版中的本地化</h2><p>在故事版中本地化的过程是：</p>
<ol>
<li>在项目里添加其他语言。</li>
<li>在被添加语言的故事版文件中找到相应的.string文件，加以更改。</li>
</ol>
<p>具体过程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-917657136741d815.gif?imageMogr2/auto-orient/strip" alt="故事版的本地化.gif"></p>
<h2 id="2-类文件中字符串的本地化"><a href="#2-类文件中字符串的本地化" class="headerlink" title="2. 类文件中字符串的本地化"></a>2. 类文件中字符串的本地化</h2><p>除了需要本地化故事版中的字符串，类文件中的字符串也需要本地化，因为故事版并不能显示所有需要翻译的字符串。</p>
<p>而且，类文件中的字符串分为两种形式：</p>
<ol>
<li>字符串面量。</li>
<li>非字符串面量。</li>
</ol>
<p>字符串面量:</p>
<p><code>NSString *myName = @“Jack”;</code></p>
<p>类似这样的字符串是比较好找的，只需要搜索<code>@</code>即可很容易找到。<br>但是，我们仍然会通过该方法搜索到不应该本地化的字符串：<br>也就是不出现在UI中的字符串面量。</p>
<p>例如：</p>
<ul>
<li>文件扩展名</li>
<li>segure的identifier</li>
<li>stiringWithFormat:</li>
</ul>
<h4 id="2-1字符串面量的本地化步骤："><a href="#2-1字符串面量的本地化步骤：" class="headerlink" title="2.1字符串面量的本地化步骤："></a>2.1字符串面量的本地化步骤：</h4><ol>
<li>找到需要本地化的字符串面量。</li>
<li>通过宏，将字符串面量添加到表中。</li>
<li>创建表的.string文件。</li>
<li>本地化.string文件</li>
</ol>
<p>1.找到 <code>@&quot;Sorry, this device cannot add a photo.&quot;</code> 字符串面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">    if (![[self class] canAddPhoto]) &#123;</div><div class="line">        [self fatalAlert:@&quot;Sorry, this device cannot add a photo.&quot;]; //</div><div class="line">    &#125; else &#123;</div><div class="line">        [self.locationManager startUpdatingLocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.通过宏，将字符串面量添加到表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">   [super viewDidAppear: animated];</div><div class="line">   </div><div class="line">   if (![[self class] canAddPhoto]) &#123;</div><div class="line">       [self fatalAlert:ALERT_CANT_ADD_PHOTO]; // @&quot;Sorry, this device cannot add a photo.&quot;</div><div class="line">   &#125; else &#123;</div><div class="line">       [self.locationManager startUpdatingLocation];</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ALERT_CANT_ADD_PHOTO NSLocalizedStringFromTable(@&quot;ALERT_CANT_ADD_PHOTO&quot;, @&quot;AddPhotoViewController&quot;, @&quot;Alert message delivered when there is something that prevents the user from adding a new photo to the database that the user can do nothing about.&quot;)</div></pre></td></tr></table></figure>
<p>3.创建表的.string文件</p>
<p>我们已经在AddPhotoViewController.m文件里将需要本地化的字符串添加到了叫做AddPhotoViewController的表里，下面就需要用命令行工具找到该.m文件：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-a043fa2da855615c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="找到.m文件所在目录"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b3adf539663b1269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入genstrigns ^*m命令"></p>
<p>4.本地化.string文件</p>
<p>在第三步中，我们需要手动创建<code>AddPhotoViewController</code>表的.string文件，然后在文件内部将对应的key进行翻译。因为过程略繁琐，所以以动图的形式呈献给大家：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-100dfbddbe7399bb.gif?imageMogr2/auto-orient/strip" alt="本地化string.gif"></p>
<blockquote>
<p>失误了，右侧的字符串应该是没有“@”的，大家注意。因为到最后才发现的，不好改了 额。。 理解万岁。。</p>
</blockquote>
<h2 id="2-2-非字面量字符串的本地化："><a href="#2-2-非字面量字符串的本地化：" class="headerlink" title="2.2 非字面量字符串的本地化："></a>2.2 非字面量字符串的本地化：</h2><p>在类文件里，有些显示出来的字符串并不都是通过字符串面量赋值的，比如下面这个例子：</p>
<p><code>self.title = newfrc.fetchRequest.entity.name;</code></p>
<p>在这里，title取的是模型里的字段，并没有用字面量语法来表示。<br>对于这种情况，我们需要用NSBundle的<code>localizedStringForKey:value:table:</code>方法来进行本地化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.title = [[NSBundle mainBundle] localizedStringForKey:newfrc.fetchRequest.entity.name</div><div class="line">                         value:newfrc.fetchRequest.entity.name     </div><div class="line">                         table:@&quot;Entities&quot;];</div></pre></td></tr></table></figure>
<p>这样一来，我们就生成了对应名字叫<strong>Entities</strong>的表的映射。但是这张表对应的.string文件还没有生成，需要我们手动去生成，并设置对应的key和value。生成方法如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-965d85e9b008d0c8.gif?imageMogr2/auto-orient/strip" alt="手动生成.string文件"></p>
<h1 id="设置页的UI"><a href="#设置页的UI" class="headerlink" title="设置页的UI"></a>设置页的UI</h1><hr>
<p>在苹果系统的设置里，会有我们装入的app的信息和设置。有时，我们需要将一些设置选项放在这里面供用户使用。</p>
<p>而这里的UI是通过通过Settings bundle来设定的。我们首先要新建一个Settings Bundle:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d49a21d343306156.gif?imageMogr2/auto-orient/strip" alt="创建Settings Bundle"></p>
<p>创建成功后，分别有一个slider，switch，和textfield来对应设置页里的UI。</p>
<p>在设置页里的样子是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6dc1b24f8d070871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建的Settings Bundle 后的设置页效果"></p>
<p>那么如何使用呢？我们设置一下上一节课的Bouncer Demo的弹性系数：让用户通过调节设置里的slider来调整app里的弹性系数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)resetElasticity</div><div class="line">&#123;</div><div class="line">    //连接代码与Setting Bundle</div><div class="line">    NSNumber *elasticity = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;Setting_Elasticity&quot;];//连接setting bundle</div><div class="line">    if (elasticity) &#123;</div><div class="line">        //如果有，就取当前设定的</div><div class="line">        self.elastic.elasticity = [elasticity floatValue];</div><div class="line">    &#125; else &#123;</div><div class="line">        //如果没有，就设置为1</div><div class="line">        self.elastic.elasticity = 1.0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，通过<code>valueForKey</code>的键值对应了Setting Bundle plist 文件里的<code>identifier</code>，我们将plist文件里的<code>identifier</code>修改成了<code>Setting_Elasticity</code>而且更改了<code>Title</code>，而且将按钮和文本框删除掉，只保留了slider：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f195429739d8262b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Setting Bundle plist"></p>
<p>所对应的设置页的UI：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-1d15dcab18d5df94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新的设置页UI"></p>
<p>现在我们可以通过identifier连接了代码和plist文件，获取到了键对应的值。</p>
<p>而且，我们还需考虑在程序运行过程中，用户跳转到了设置页面来设置弹性系数的情况。因此，我们需要监听用户是否更改了设置里的选项：</p>
<p>监听用户在设置中的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserverForName:NSUserDefaultsDidChangeNotification</div><div class="line">                                                  object:nil</div><div class="line">                                                   queue:nil</div><div class="line">                                              usingBlock:^(NSNotification *note) &#123;</div><div class="line">                                                  [self resetElasticity];</div><div class="line">                                              &#125;];</div></pre></td></tr></table></figure>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>当~当~当~当~！<br>笔者终于利用了2个月的部分业余时间总结了所有斯坦福iOS7的课程和相关Demo。通过以博客的形式总结，更加加深了对知识的理解和认识，也对基础知识进行了一次查缺补漏，或许也在一定程度上给其他看到这些博客的同仁们一些帮助吧~</p>
<p>最后附上这一系列笔者总结的所有Demo在GitHub上的地址：<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">Stanford_iOS_Lecture_DemoBundle</a>。</p>
<p>笔者下一阶段应该是总结下面两本书的内容：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0eeac0652f909c84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Effective Objective- C 2.0"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c1046257878a01d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Swift 基础教程"></p>
<p>这两本书笔者都已经看了3分之一，因为要总结归纳，所以应该进度不是很快，不过还是会坚持写博客的！</p>
<p>加油~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是斯坦福大学iOS7系列课程（CS193P）的最后一节课的总结，终于把18节课的内容都总结完了，而且这个文集也画上了句号，有点不舍的赶脚。。&lt;/p&gt;
&lt;p&gt;好了，不煽情了，开始！&lt;br&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>

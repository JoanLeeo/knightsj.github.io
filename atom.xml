<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J_Knight</title>
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/knightsj/knightsj.github.io/"/>
  <updated>2017-10-10T05:21:58.308Z</updated>
  <id>https://github.com/knightsj/knightsj.github.io/</id>
  
  <author>
    <name>J_Knight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>结合一个开源的底部菜单组件来讲一下如何封装一个React Native组件</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/10/10/%E7%BB%93%E5%90%88%E4%B8%80%E4%B8%AA%E5%BC%80%E6%BA%90%E7%9A%84%E5%BA%95%E9%83%A8%E8%8F%9C%E5%8D%95%E7%BB%84%E4%BB%B6%E6%9D%A5%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%A6%82%E4%BD%95%E5%B0%81%E8%A3%85%E4%B8%80%E4%B8%AAReact%20Native%E7%BB%84%E4%BB%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/10/10/结合一个开源的底部菜单组件来讲一下如何封装一个React Native组件/</id>
    <published>2017-10-10T05:15:54.520Z</published>
    <updated>2017-10-10T05:21:58.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>前几天写了一个React Native组件：一个可定制性比较高的底部弹出菜单（ActionSheet）。该组件符合React Native的特性：同时支持iOS和Android双平台，一份相同的代码会在两个平台上展示几乎完全相同的样式。</p>
<p>先看一下效果(上图为iOS模拟器，下图为Android模拟器)：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_3.png" alt=""></p>
<p>上图展示的是该组件的默认样式。由于该组件具有较高的定制性，所以只需要通过设置一些属性就可以得到更多不同的样式。</p>
<p>开源项目地址：<a href="https://github.com/knightsj/react-naive-highly-customizable-action-sheet">GitHub:react-naive-highly-customizable-action-sheet</a></p>
<a id="more"></a>
<h2 id="定制性介绍"><a href="#定制性介绍" class="headerlink" title="定制性介绍"></a>定制性介绍</h2><p>在该组件里：最顶部的标题，中间的选择项，最底部的取消项都是可有可无的，而且每一部分的字体，颜色，高度，距离，分割线颜色，圆角等也都是可以定制的。</p>
<p>先来看几个默认的样式：</p>
<h3 id="默认的样式："><a href="#默认的样式：" class="headerlink" title="默认的样式："></a>默认的样式：</h3><p>默认的样式是指使用者在不设置样式相关属性，只设置数据（文字）相关属性时展现的样式。该样式是微信，微博里使用的样式，也是我个人非常喜欢的样式。</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_1.gif" alt=""></p>
<h3 id="类似iOS原生-ActionSheet的样式"><a href="#类似iOS原生-ActionSheet的样式" class="headerlink" title="类似iOS原生 ActionSheet的样式"></a>类似iOS原生 ActionSheet的样式</h3><p>用户可以通过设置某些属性可以实现iOS默认的ActionSheet的样式：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_2.gif" alt=""></p>
<p>除此之外，用户还可以通过设置某些属性来实现各种其他的样式：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_3.gif" alt=""></p>
<p>下面结合使用方法来看一下如何通过代码来定制这些样式：</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h3><p><code>npm install react-naive-highly-customizable-action-sheet</code></p>
<p>引用组件：</p>
<p><code>import ActionSheet from &#39;react-naive-highly-customizable-action-sheet&#39;</code></p>
<p>然后给该组件传入标题，选项文字数组，回调方法数组等实现一个ActionSheet的组件。</p>
<p>下面结合一下代码和demo截图讲解一下：</p>
<p>一个默认样式的例子:</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_11.png" alt=""></p>
<p>该样式的实现代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&lt;ActionSheet</div><div class="line">   mainTitle=<span class="string">"There are three ways to contact. Please choose one to contact."</span></div><div class="line">   itemTitles = &#123;[<span class="string">"By phone"</span>,<span class="string">"By message"</span>,<span class="string">"By email"</span>]&#125;</div><div class="line">   selectionCallbacks = &#123;[<span class="keyword">this</span>.clickedByPhone,<span class="keyword">this</span>.clickedByMessage,<span class="keyword">this</span>.clickedByEmail]&#125;</div><div class="line">   mainTitleTextAlign = <span class="string">'center'</span></div><div class="line">   ref=&#123;(actionsheet)=&gt;&#123;<span class="keyword">this</span>.actionsheet = actionsheet&#125;&#125;</div><div class="line">/&gt;</div><div class="line">  </div><div class="line"><span class="comment">//弹出底部菜单</span></div><div class="line">showActionSheet()&#123;</div><div class="line">	<span class="keyword">this</span>.actionsheet.show();  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByPhone()&#123;</div><div class="line">   alert(<span class="string">'By Phone'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByMessage()&#123;</div><div class="line">    alert(<span class="string">'By Message'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByEmail()&#123;</div><div class="line">    alert(<span class="string">'By Email'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，</p>
<ul>
<li><code>mainTitle</code>：是最上方的标题。</li>
<li><code>itemTitles</code>：选项文字的数组。</li>
<li><code>selectionCallbacks</code>：点击选项后的回调函数数组。</li>
</ul>
<p>需要注意的是，选项文字的数组和回调函数数组里的元素应该是一一对应的。不过即使回调函数数组里的元素个数少于选项文字数组里的元素个数也不会引起崩溃。</p>
<p>一个iOS ActionSheet样式的例子：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_12.png" alt=""></p>
<p>该样式的实现代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> &lt;ActionSheet</div><div class="line">    mainTitle=<span class="string">"There are three ways to contact. Please choose one to contact."</span></div><div class="line">    itemTitles = &#123;[<span class="string">"By phone"</span>,<span class="string">"By message"</span>,<span class="string">"By email"</span>]&#125;</div><div class="line">    selectionCallbacks = &#123;[<span class="keyword">this</span>.clickedByPhone,<span class="keyword">this</span>.clickedByMessage,<span class="keyword">this</span>.clickedByEmail]&#125;</div><div class="line">    mainTitleTextAlign = <span class="string">'center'</span></div><div class="line">    contentBackgroundColor = <span class="string">'#EFF0F1'</span></div><div class="line">    bottomSpace = &#123;<span class="number">10</span>&#125;</div><div class="line">    cancelVerticalSpace = &#123;<span class="number">10</span>&#125;</div><div class="line">    borderRadius = &#123;<span class="number">5</span>&#125;</div><div class="line">    sideSpace = &#123;<span class="number">6</span>&#125;</div><div class="line">    itemTitleColor = <span class="string">'#006FFF'</span></div><div class="line">    cancelTitleColor = <span class="string">'#006FFF'</span></div><div class="line">    ref=&#123;(actionsheet)=&gt;&#123;<span class="keyword">this</span>.actionsheet = actionsheet&#125;&#125;</div><div class="line">/&gt;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//弹出底部菜单</span></div><div class="line">showActionSheet()&#123;</div><div class="line">	<span class="keyword">this</span>.actionsheet.show();  </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByPhone()&#123;</div><div class="line">   alert(<span class="string">'By Phone'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByMessage()&#123;</div><div class="line">    alert(<span class="string">'By Message'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//回调函数</span></div><div class="line">clickedByEmail()&#123;</div><div class="line">    alert(<span class="string">'By Email'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更多其他的样式设定可以参考<a href="https://github.com/knightsj/react-naive-highly-customizable-action-sheet">demo</a>里的<code>Example</code>。</p>
<p>大致介绍完这个组件的功能和使用方法，下面来看一下该组件是如何封装的。</p>
<h2 id="React-Native组件的封装"><a href="#React-Native组件的封装" class="headerlink" title="React Native组件的封装"></a>React Native组件的封装</h2><h3 id="封装些什么"><a href="#封装些什么" class="headerlink" title="封装些什么"></a>封装些什么</h3><p>对于GUI编程里视图组件来说，无外乎是以下三个内容：</p>
<ol>
<li>数据</li>
<li>样式</li>
<li>交互</li>
</ol>
<p>而对于视图组件的封装，我个人的理解是：封装接收数据的形式，数据与样式之间的转化规则以及交互的逻辑。而这些都是从数据的接收开始的。没有数据的接收就没有UI的展示，更谈不上交互了。</p>
<p>所以在最开始从React Native视图组件的数据接收来说起是比较妥当的。</p>
<h3 id="数据接收"><a href="#数据接收" class="headerlink" title="数据接收"></a>数据接收</h3><p>在iOS开发中，给view提供数据的方式是通过设置属性或者实现数据源方法来做的。但是在React Native开发中，通常<strong>只能</strong>通过设置属性来传入该组件为了实现某个样式所需要的一些数据。比如在上面的两个例子里，标题，以及选项文字都是通过设置特定的属性来传入的。</p>
<p>而且，为了保证设置属性的类型正确，最好对属性做一个类型检查：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123;Component, PropTypes&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">static</span> propTypes = &#123;</div><div class="line"> </div><div class="line">    <span class="attr">mainTitle</span>:PropTypes.string.isRequired,<span class="comment">//类型为字符串，且必须传入</span></div><div class="line">    mainTitleFont:PropTypes.number,<span class="comment">//类型为数字</span></div><div class="line">    mainTitleColor:PropTypes.string,<span class="comment">//类型为字符串</span></div><div class="line">    mainTitleTextAlign:PropTypes.oneOf([<span class="string">'center'</span>, <span class="string">'left'</span>]),<span class="comment">//二者选其一</span></div><div class="line">    hideCancel:PropTypes.bool,<span class="comment">//类型为布尔值</span></div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下第一行的<code>mainTitle</code>属性，在上面将它设置为必须传入的属性。所以如果在这种情况下没有传入该属性，就会出现警告。</p>
<p>上面的只是我举的例子，在我封装的这个组件里没有任何属性是必须传入的。因为要提高定制性，所以所有属性都是可传可不传。</p>
<p>现在我们知道了如何将数据传入到组件里。但是这仅仅是第一步。因为组件所需要的数据可能不仅仅包括用户传入的这些数据，还包括一些通过用户传入的这些数据计算后得到的另一些数据，比如弹窗的总高度。不难理解，弹窗的总高度取决于标题的高度，选项的高度和选项的个数，以及取消项的高度总和。而这个数据显然是通过传入的标题，选项等数据后经过计算得到的。</p>
<p>而且，对于一些可以不一定需要用户传入的数据，可能组件自己也许要提供一下对应属性的默认值。</p>
<p>综上所述，对于数据处理部分，可以分为两类的处理：</p>
<ol>
<li>计算额外的数据。</li>
<li>提供对应属性的默认值。</li>
</ol>
<p>分别举两个在该组件中的代码（之间省略了部分内容）讲解一下。</p>
<h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><h4 id="1-额外需要计算的数据"><a href="#1-额外需要计算的数据" class="headerlink" title="1. 额外需要计算的数据"></a>1. 额外需要计算的数据</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">componentWillMount()&#123;</div><div class="line">    </div><div class="line">     ...</div><div class="line">    <span class="comment">//Calculate Title Height</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.props.mainTitle)&#123;</div><div class="line">        <span class="keyword">this</span>.real_titleHeight = <span class="number">0</span></div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.real_titleHeight = <span class="keyword">this</span>.state.mainTitleHeight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate Items height</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.props.itemTitles)&#123;</div><div class="line">        <span class="keyword">this</span>.real_itemsPartHeight = <span class="number">0</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.real_itemsPartHeight = (<span class="keyword">this</span>.state.itemHeight + <span class="keyword">this</span>.state.itemVerticalSpace) * <span class="keyword">this</span>.props.itemTitles.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//Calculate Cancel part height</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.props.hideCancel)&#123;</div><div class="line">        <span class="keyword">this</span>.real_cancelPartHeight = <span class="number">0</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">this</span>.real_cancelPartHeight = <span class="keyword">this</span>.state.cancelVerticalSpace + <span class="keyword">this</span>.state.cancelHeight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// total content height</span></div><div class="line">    <span class="keyword">this</span>.totalHeight = <span class="keyword">this</span>.real_titleHeight +  <span class="keyword">this</span>.real_itemsPartHeight + <span class="keyword">this</span>.real_cancelPartHeight + <span class="keyword">this</span>.state.bottomSpace;</div><div class="line">     ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，<code>this.real_titleHeight</code>,<code>this.real_itemsPartHeight</code>,<code>this.real_cancelPartHeigh</code>,<code>this.totalHeight</code>都是在拿到属性以后，需要额外计算的数据。我把这些工作放在了<code>componentWillMount()</code>方法里面。</p>
<h4 id="2-提供对应属性的默认值"><a href="#2-提供对应属性的默认值" class="headerlink" title="2. 提供对应属性的默认值"></a>2. 提供对应属性的默认值</h4><p>如果用户没有传入标题文字的颜色，则提供一个默认的标题颜色：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">constructor</span>(props) &#123;</div><div class="line"><span class="keyword">super</span>(props);</div><div class="line">   <span class="keyword">this</span>.state = &#123;</div><div class="line">     ...</div><div class="line">     mainTitleColor:<span class="keyword">this</span>.props.mainTitleColor?<span class="keyword">this</span>.props.mainTitleColor:<span class="string">'gray'</span>,<span class="comment">//主标题颜色</span></div><div class="line">     cancelTitle:<span class="keyword">this</span>.props.cancelTitle?<span class="keyword">this</span>.props.cancelTitle:<span class="string">'Cancel'</span>,<span class="comment">//取消的文字</span></div><div class="line">     ...</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，如果用户没有设置<code>mainTitleColor</code>和<code>cancelTitle</code>这两个属性值，组件内部会提供相应的默认值。</p>
<h3 id="数据展示"><a href="#数据展示" class="headerlink" title="数据展示"></a>数据展示</h3><p>在React Native里，组件的<code>render()</code>函数负责渲染组件。因此这个函数里会使用之前计算好的数据来渲染组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">   retrun(  </div><div class="line">     &lt;View&gt;</div><div class="line">        &#123;this._renderTitleItem()&#125;</div><div class="line">        &#123;this._renderItemsPart()&#125;</div><div class="line">        &#123;this._renderCancelItem()&#125;</div><div class="line">    &lt;/View&gt;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//render title part</span></div><div class="line">_renderTitleItem()&#123;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.props.mainTitle)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;<span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;TouchableWithoutFeedback&gt;</div><div class="line">                &lt;View style=&#123;[styles.contentViewStyle]&#125;&gt;</div><div class="line">                    &lt;Text&gt;&#123;this.props.mainTitle&#125;&lt;/Text&gt;</div><div class="line">                &lt;/View&gt;</div><div class="line">            &lt;/TouchableWithoutFeedback&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//render selection items part</span></div><div class="line">_renderItemsPart()&#123;</div><div class="line">    <span class="keyword">var</span> itemsArr = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    <span class="keyword">let</span> title = <span class="keyword">this</span>.state.itemTitles[i];</div><div class="line">    <span class="keyword">let</span> itemView =</div><div class="line">        &lt;View key=&#123;i&#125;&gt;</div><div class="line">            &#123;/* Seperate Line */&#125;</div><div class="line">            &#123;this._renderItemSeperateLine(showItemSeperateLine)&#125;</div><div class="line">            &#123;/* item for selection*/&#125;</div><div class="line">            &lt;TouchableOpacity onPress=&#123;this._didSelect.bind(this, i)&#125;&gt;</div><div class="line">                &lt;View style=&#123;[styles.contentViewStyle]&#125; key=&#123;i&#125;&gt;</div><div class="line">                    &lt;Text style=&#123;[styles.textStyle]&#125;&gt;&#123;title&#125;&lt;/Text&gt;</div><div class="line">                &lt;/View&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;</div><div class="line">        &lt;/View&gt;</div><div class="line">        itemsArr.push(itemView);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> itemsArr;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//render cancel part</span></div><div class="line">_renderCancelItem()&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;View style=&#123;&#123;width:this.contentWidth,height: this.real_cancelPartHeight&#125;&#125;&gt;</div><div class="line">          &#123;/* Seperate Line */&#125;</div><div class="line">          &#123;this._renderCancelSeperateLine(showCancelSeperateLine)&#125;</div><div class="line">          &#123;/* Cancel Item */&#125;</div><div class="line">            &lt;TouchableOpacity onPress=&#123;this._dismiss.bind(this)&#125;&gt;</div><div class="line">                &lt;View style=&#123;[styles.contentViewStyle]&#125;&gt;</div><div class="line">                    &lt;Text style=&#123;[styles.textStyle]&#125;&gt;&#123;this.state.cancelTitle&#125;&lt;/Text&gt;</div><div class="line">                &lt;/View&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;</div><div class="line">      &lt;/View&gt;</div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>组件的交互可以分为两种：有外部回调的交互以及没有外部回调的交互。这个外部回调是指在组件外部所需要执行的函数。比如底部菜单组件：如果用户点击了某一项，菜单会回落，并调用该组件外部的函数（例如退出登录，清除缓存等等）。类比在iOS开发中，可以使用代理或者block的方式进行回调，而在React Native中实现回调的方式与iOS中block的方式类似。</p>
<h4 id="有回调的交互"><a href="#有回调的交互" class="headerlink" title="有回调的交互"></a>有回调的交互</h4><p>在React Native中，如果需要调用外部的函数，就需要在一开始的时候将该函数作为属性传入组件中。然后拦截用户的点击，调用相应的回调函数。这里面分为三个步骤：</p>
<ol>
<li>传入回调函数</li>
<li>拦截用户操作</li>
<li>调用回调函数</li>
</ol>
<p><strong>1. 传入回调函数：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> propTypes = &#123;</div><div class="line">  </div><div class="line">    <span class="comment">//selection items callback</span></div><div class="line">    selectionCallbacks:PropTypes.array,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>selectionCallbacks</code>是对应选择项的回调函数数组属性。这里因为选择项数量不确定，所以用数组来保存回调函数。</p>
</blockquote>
<p><strong>2. 拦截用户操作(点击)：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;TouchableOpacity onPress=&#123;<span class="keyword">this</span>._didSelect.bind(<span class="keyword">this</span>, i)&#125;  activeOpacity = &#123;<span class="number">0.9</span>&#125;&gt;</div><div class="line">    &lt;View style=&#123;styles.contentViewStyle&#125; key=&#123;i&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.textStyle&#125;&gt;&#123;title&#125;&lt;/Text&gt;</div><div class="line">    &lt;/View&gt;</div><div class="line">&lt;<span class="regexp">/TouchableOpacity&gt;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，使用了<code>TouchableOpacity</code>组件让<code>View</code>组件获得可以被点击的能力，并且绑定了函数<code>_select(index)</code>。</p>
</blockquote>
<p><strong>3. 调用回调函数：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取出相应的回调函数并调用</span></div><div class="line">_select(i) &#123;</div><div class="line">    <span class="keyword">let</span> callback = <span class="keyword">this</span>.state.selectionCallbacks[i];</div><div class="line">    <span class="keyword">if</span>(callback)&#123;</div><div class="line">        &#123;callback()&#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，_didSelect(index)函数是某个选项被点击后调用的函数。该函数拿到传入的index值，从callback数组里面获取对应index的回调函数并调用。而且为了避免崩溃，还判断了callback是否为空。</p>
</blockquote>
<h4 id="没有回调的交互"><a href="#没有回调的交互" class="headerlink" title="没有回调的交互"></a>没有回调的交互</h4><p>如果这个交互没有回调就比较简单了，在组件内部做就可以了。比如点击取消后的回落事件：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;TouchableOpacity onPress=&#123;this._dismiss.bind(this)&#125; activeOpacity = &#123;0.9&#125;&gt;</div><div class="line">    &lt;View style=&#123;styles.contentViewStyle&#125;&gt;</div><div class="line">        &lt;Text style=&#123;styles.textStyle&#125;&gt;&#123;this.state.cancelTitle&#125;&lt;/Text&gt;</div><div class="line">    &lt;/View&gt;</div><div class="line">&lt;/TouchableOpacity&gt;</div><div class="line"></div><div class="line">//dismiss ActionSheet</div><div class="line">_dismiss() &#123;</div><div class="line">    if (!this.state.hide) &#123;</div><div class="line">        this._fade();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里除了使菜单回落以外，再点击取消的时候还给了用户反馈：点击时背景色的透明度改变。实现方法是利用的<code>TouchableOpacity</code>的<code>activeOpacity = {0.9}</code></p>
<p>OK，现在讲完了数据和交互，再来看一下React Native是如何支持动画效果的（因为用到了所以就顺带讲一下了）。</p>
<h3 id="动画效果"><a href="#动画效果" class="headerlink" title="动画效果"></a>动画效果</h3><p>一般来说，底部菜单在弹出和回落的时候是有动画效果的，React Native的动画效果可以用其内置的<code>Animated</code>库来实现。</p>
<p>结合菜单弹出的例子来说明一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//animation of showing</span></div><div class="line">_appear() &#123;</div><div class="line">    Animated.parallel([</div><div class="line">        Animated.timing(</div><div class="line">            <span class="keyword">this</span>.state.opacity, <span class="comment">//动画改编的变量</span></div><div class="line">            &#123;</div><div class="line">                <span class="attr">easing</span>: Easing.linear,</div><div class="line">                <span class="attr">duration</span>: <span class="number">200</span>,  <span class="comment">//动画时长，单位是毫秒</span></div><div class="line">                toValue: <span class="number">0.7</span>,   <span class="comment">//终点值</span></div><div class="line">            &#125;</div><div class="line">        ),</div><div class="line">        Animated.timing(</div><div class="line">            <span class="keyword">this</span>.state.offset,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">easing</span>: Easing.linear,</div><div class="line">                <span class="attr">duration</span>: <span class="number">200</span>,</div><div class="line">                <span class="attr">toValue</span>: <span class="number">1</span>,</div><div class="line">            &#125;</div><div class="line">        )</div><div class="line">    ]).start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在这里，</p>
<ul>
<li><p><code>Animated.parallel</code>函数负责执行<strong>同时执行的组合动画</strong>。既然是组合动画，那么传入的就应该是一个动画的数组。仔细看一下就会发现这里有两个<code>Animated.timing</code>函数。</p>
</li>
<li><p><code>Animated.timing</code>函数负责执行以时间为单位的动画。从注释上不难看出，在这里同时执行的两个动画是：</p>
<ul>
<li><code>this.state.opacity</code>值在200毫秒内，从0到0.7渐变的动画。</li>
<li><code>this.state.offset</code>值在200毫秒内，从0到1渐变的动画。</li>
</ul>
</li>
<li><p>最底部的<code>start()</code>函数触发了这个组合动画。</p>
<p>​</p>
</li>
</ul>
<blockquote>
<p>这里没有提供起点值，因为在这里直接获取的是传入变量的当前值。</p>
</blockquote>
<p>相对底部菜单的弹出动画，来看一下底部菜单的回落动画：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//animation of fading</span></div><div class="line">_fade() &#123;</div><div class="line">    Animated.parallel([</div><div class="line">        Animated.timing(</div><div class="line">            <span class="keyword">this</span>.state.opacity,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">easing</span>: Easing.linear,</div><div class="line">                <span class="attr">duration</span>: <span class="number">200</span>,</div><div class="line">                <span class="attr">toValue</span>: <span class="number">0</span>,</div><div class="line">            &#125;</div><div class="line">        ),</div><div class="line">        Animated.timing(</div><div class="line">            <span class="keyword">this</span>.state.offset,</div><div class="line">            &#123;</div><div class="line">                <span class="attr">easing</span>: Easing.linear,</div><div class="line">                <span class="attr">duration</span>: <span class="number">200</span>,</div><div class="line">                <span class="attr">toValue</span>: <span class="number">0</span>,</div><div class="line">            &#125;</div><div class="line">        )</div><div class="line">    ]).start(<span class="function">(<span class="params">finished</span>) =&gt;</span> <span class="keyword">this</span>.setState(&#123;<span class="attr">hide</span>: <span class="literal">true</span>&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有关动画的知识可以查看官方文档[React Native :动画](<a href="http://reactnative.cn/docs/0.48/animations.html#conte" target="_blank" rel="external">http://reactnative.cn/docs/0.48/animations.html#conte</a></p>
<p>其实到这里，对于组件的封装就基本讲完了，讲解的内容还是集中在数据这一块，组件是怎么画出来的就不讲解了。因为毕竟每个组件将数据转化为样式的代码是不一样的，学会一个弹出菜单的画法对于画其他的组件没有太大的借鉴意义。但是对于一个通用组件来说，其定制性必须达到一定标准才可以。所以相对于讲解“组件是如何画出来的”，我认为讲一下“提高组件定制性”应该更实际一些。</p>
<h3 id="为提高定制性所做的工作："><a href="#为提高定制性所做的工作：" class="headerlink" title="为提高定制性所做的工作："></a>为提高定制性所做的工作：</h3><p>最开始做这个控件也仅仅只能设置标题，选项以及回调函数，样式也只有这一种：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/as_11.png" alt=""></p>
<p>但是为了提高定制性，支持更多的样式，也为了自己能更好地了解React Native，就决定挑战一下，看定制性能提高到什么程度。</p>
<p>如上文所说，在React Native里，组件的数据传递是通过设置其属性来实现的。所以如果想要提高组件的定制性就需要增加该组件的属性。</p>
<p>看一下该组件的所有属性：</p>
<ul>
<li><code>itemTitles</code><em>(Array)</em>:选择项的标题数组</li>
<li><code>selectionCallbacks</code><em>(Array)</em>：点击选项的回调数组</li>
</ul>
<ul>
<li><code>mainTitle</code><em>(String)</em>:标题文字</li>
<li><code>mainTitleFont</code><em>(Number)</em>:标题字体</li>
<li><code>mainTitleColor</code><em>(String)</em>:标题颜色</li>
<li><code>mainTitleHeight</code><em>(Number)</em>:标题栏高度</li>
<li><code>mainTitleTextAlign</code><em>(String)</em>:标题对齐方式</li>
<li><code>mainTitlePadding</code><em>(Number)</em>:标题内边距</li>
<li><code>itemTitleFont</code><em>(Number)</em>:选择项字体</li>
<li><code>itemTitleColor</code><em>(String)</em>:选择项颜色</li>
<li><code>itemHeight</code><em>(Number)</em>:选择栏高度</li>
</ul>
<ul>
<li><code>cancelTitle</code><em>(String)</em>:取消项标题，默认为’Cancel’</li>
<li><code>cancelTitleFont</code><em>(Number)</em>:取消标题字体</li>
<li><code>cancelTitleColor</code><em>(String)</em>:取消标题颜色</li>
<li><code>cancelHeight</code><em>(Number)</em>:取消栏高度</li>
<li><code>hideCancel</code><em>(Bool)</em>:是否隐藏取消项（默认不隐藏）</li>
</ul>
<ul>
<li><code>fontWeight</code><em>(String)</em>:所有文字的字体粗细（同时设置标题，选择项，取消项的字体粗细）</li>
<li><code>titleFontWeight</code><em>(String)</em>:标题的字体粗细，默认为’normal’</li>
<li><code>itemFontWeight</code><em>(String)</em>:选择项的字体粗细，默认为’normal’</li>
<li><code>cancelFontWeight</code><em>(String)</em>:取消项的字体粗细，默认为’bold’</li>
</ul>
<ul>
<li><code>contentBackgroundColor</code><em>(String)</em>:所有项目的背景色（同时设置标题，选择项，取消项的背景色）</li>
<li><code>titleBackgroundColor</code><em>(String)</em>:标题的背景色（默认是白色）</li>
<li><code>itemBackgroundColor</code><em>(String)</em>:选择项的背景色（默认是白色）</li>
<li><code>cancelBackgroundColor</code><em>(String)</em>:取消项的背景色（默认是白色）</li>
<li><code>itemSpaceColor</code><em>(String)</em>:选择项之间的分割线颜色（默认是浅灰色）</li>
<li><code>cancelSpaceColor</code><em>(String)</em>:取消项和最后一个选择项之间的分割线颜色（默认是浅灰色）</li>
</ul>
<ul>
<li><code>itemVerticalSpace</code><em>(Number)</em>:选择项之间分割线的高度</li>
</ul>
<ul>
<li><code>cancelVerticalSpace</code><em>(Number)</em>:取消项和最后一个选择项之间的分割线的高度</li>
<li><code>bottomSpace</code><em>(Number)</em>:屏幕底部距离取消项底部的距离</li>
<li><code>sideSpace</code><em>(Number)</em>:弹出框左右侧边距离屏幕左右侧边的距离</li>
</ul>
<ul>
<li><code>borderRadius</code><em>(Number)</em>:弹出框的圆角</li>
</ul>
<ul>
<li><code>maskOpacity</code><em>(Number)</em>:mask的透明度（默认为0.3）</li>
</ul>
<p>不难看出，该组件的三个部分（标题，选项，取消）里，每个部分都有各自对应的属性可以设置。因为在设计这个组件的时候就将这三个部分高度解耦了：每个部分都互不影响，有各自的数据（除了少数可以共同使用的数据），并分别进行绘制。</p>
<p>比如，我们可以设置：</p>
<h4 id="每个部分文字内容，字体大小，高度"><a href="#每个部分文字内容，字体大小，高度" class="headerlink" title="每个部分文字内容，字体大小，高度"></a>每个部分文字内容，字体大小，高度</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_4.png" alt=""></p>
<h4 id="背景颜色（可以统一设置，也可以单独设置）"><a href="#背景颜色（可以统一设置，也可以单独设置）" class="headerlink" title="背景颜色（可以统一设置，也可以单独设置）"></a>背景颜色（可以统一设置，也可以单独设置）</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_5.png" alt=""></p>
<h4 id="分割线高度，距离底部的高度，距离屏幕侧边的距离"><a href="#分割线高度，距离底部的高度，距离屏幕侧边的距离" class="headerlink" title="分割线高度，距离底部的高度，距离屏幕侧边的距离"></a>分割线高度，距离底部的高度，距离屏幕侧边的距离</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_6.png" alt=""></p>
<h4 id="分割线的颜色"><a href="#分割线的颜色" class="headerlink" title="分割线的颜色"></a>分割线的颜色</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_7.png" alt=""></p>
<p>上面这些图片的效果对应的代码在<a href="https://github.com/knightsj/react-naive-highly-customizable-action-sheet">demo</a>中都有提供(具体查看Example文件夹)。</p>
<p>另外该组件也支持一些比较极端的情况，虽然可能需求上极少遇到，但还是提供了支持。</p>
<h4 id="极端情况："><a href="#极端情况：" class="headerlink" title="极端情况："></a>极端情况：</h4><p><img src="http://oih3a9o4n.bkt.clouddn.com/as_13.png" alt=""></p>
<p>高度解耦的程度可以通过这最后一张图看出来：主标题，选择项，取消项都可以根据传入属性的情况来展示，互不影响。而且在都不设置的情况下，只展示了灰色的底部mask。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>写这个组件一共花了3天的时间，其实第一天就已经完成了默认样式的开发。而后2天主要做的是提高定制性的工作。因为定制性的工作是与数据处理和应用分不开的，而自己对JavaScript语法了解得不是很好，所以期间写了不少的bug。值得庆幸的是，由于React Native本身搭建UI的能力很强，效率很高，所以数据处理好了之后工作量就不大了。</p>
<p>毕竟是自己封装的第一个React Native组件，我相信它还是有很多提升空间的，比如数据处理这一块可能有不妥的地方，还需要各位能给出宝贵的意见和建议。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;前几天写了一个React Native组件：一个可定制性比较高的底部弹出菜单（ActionSheet）。该组件符合React Native的特性：同时支持iOS和Android双平台，一份相同的代码会在两个平台上展示几乎完全相同的样式。&lt;/p&gt;
&lt;p&gt;先看一下效果(上图为iOS模拟器，下图为Android模拟器)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/as_3.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;上图展示的是该组件的默认样式。由于该组件具有较高的定制性，所以只需要通过设置一些属性就可以得到更多不同的样式。&lt;/p&gt;
&lt;p&gt;开源项目地址：&lt;a href=&quot;https://github.com/knightsj/react-naive-highly-customizable-action-sheet&quot;&gt;GitHub:react-naive-highly-customizable-action-sheet&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="React Native" scheme="https://github.com/knightsj/knightsj.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>从一个实战项目来看一下React Native开发的几个关键技术点</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/08/30/%E4%BB%8E%E4%B8%80%E4%B8%AA%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E6%9D%A5%E7%9C%8B%E4%B8%80%E4%B8%8BReact%20Native%E5%BC%80%E5%8F%91%E7%9A%84%E5%87%A0%E4%B8%AA%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF%E7%82%B9/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/08/30/从一个实战项目来看一下React Native开发的几个关键技术点/</id>
    <published>2017-08-30T05:32:14.000Z</published>
    <updated>2017-08-30T05:33:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行了2个星期的基础学习（Flexbox, React.js, JSX, JavaScript）之后，想通过一个实战项目来提高React Native的开发水平，于是找到了下面这个项目：</p>
<h1 id="一-项目介绍"><a href="#一-项目介绍" class="headerlink" title="一. 项目介绍"></a>一. 项目介绍</h1><p>这是我在学习<a href="http://www.devio.org/" target="_blank" rel="external">贾鹏辉</a>老师在慕课网上的一个很火的<a href="http://coding.imooc.com/class/89.html" target="_blank" rel="external">React Native实战的教程</a>后，写出的课程Demo。该课程是慕课网里很火的一个React Native课程，当初在看了课程介绍和课程安排觉得讲解的点还是很全的，所以毫不犹豫地买了下来。</p>
<p>从看视频，敲代码到重构，改bug，大概花了2个多星期的时间，除了调用友盟的SDK以及CodePush集成之外，其他的部分都基本完成了，而且同时可以在iOS和Android设备上运行：<br><img src="http://oih3a9o4n.bkt.clouddn.com/rn_13.png" alt="上排是iOS模拟器 | 下排是Android模拟器"></p>
<p>而且比较吸引人的是该项目可以实现多个主题的切换：<br><img src="http://oih3a9o4n.bkt.clouddn.com/rn_15.png" alt="多主题切换"></p>
<blockquote>
<p>切换的技术实现会在下文给出。</p>
</blockquote>
<p>用一个动图来过一遍大致的需求：<br><img src="http://oih3a9o4n.bkt.clouddn.com/github%E5%AE%A2%E6%88%B7%E7%AB%AF_4.gif" alt=""></p>
<p>Demo GitHub地址：<a href="https://github.com/knightsj/GitHubPopular-SJ">GitHubPopular-SJ</a><br>可以按照README文件里的方法运行该项目。</p>
<blockquote>
<p>已经贾老师允许上传到GitHub</p>
</blockquote>
<p>值得一提的是：这确实是一门物有所值的课程，可以让想入门React Native的开发者少走很多弯路。虽然我上传的Demo可以实现视频里大部分功能，但是经过调试，修改后的代码信息量还是很有限的，而且老师在视频中讲解的很多关于实际开发的知识点在代码中并没有体现出来，所以还是建议各位报名参加课程来提高自己的开发水平。</p>
<a id="more"></a>
<h1 id="二-React-Native开发的几个关键技术点"><a href="#二-React-Native开发的几个关键技术点" class="headerlink" title="二. React Native开发的几个关键技术点"></a>二. React Native开发的几个关键技术点</h1><p>首先用一张思维导图来看一下第二节讲的内容：<br><img src="http://oih3a9o4n.bkt.clouddn.com/rn_16_1.png" alt=""></p>
<h2 id="2-1-组件化的思想"><a href="#2-1-组件化的思想" class="headerlink" title="2.1 组件化的思想"></a>2.1 组件化的思想</h2><p>React Native是React在移动端的跨平台方案。如果想更快地理解和掌握React Native开发，就必须先了解React。</p>
<p>React是FaceBook开源的一个前端框架，它起源于 Facebook 的内部项目，并于 2013 年 5 月开源。因为React 拥有较高的性能，代码逻辑非常简单，所以越来越多的人已开始关注和使用它，目前该框架在Github上已经有7万+star。</p>
<p>React采用组件化的方式开发，通过将view构建成组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。有一句话说的很形象：在React中，构建应用就像搭积木一样。</p>
<p>因此，如果想掌握React Native，就必须先了解React中的组件。</p>
<p>那么问题来了，什么是组件呢？</p>
<p>在React中，在UI上每一个功能相对独立的模块就会被定义为组件。  相对小的组件可以通过组合或者嵌套的方式构成大的组件，最终完成整体UI的构建。</p>
<p>因此，整个UI是一个通过小组件构成的大组件，而且每个组件只关心自己部分的逻辑，彼此独立。</p>
<p>React认为一个组件应该具有如下特征：</p>
<ul>
<li>可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件；</li>
<li>可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景；</li>
<li>可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护；</li>
</ul>
<p>举个🌰，我们看一下这个Demo使用的导航栏：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_1_1_1.png" alt=""></p>
<p>封装好的导航栏就可以被称之为一个组件，它符合上述三个特点：</p>
<ol>
<li>可组合：可以将导航栏组件放在页面组件中作为页面组件的子组件。而且在导航栏组件的内部，也有按钮组件等子组件。</li>
<li>可重用：如果封装好了该组件，就可以放在任意需要导航栏的页面（组件）使用，也可以放在其他项目中使用。</li>
<li>可维护：因为具有独立的功能和展示逻辑，所以便于定位和修改。</li>
</ol>
<p>在了解了组件的基本概念以后，我们来看一下组件其他的一些相关知识。</p>
<h2 id="2-2-组件的属性与状态"><a href="#2-2-组件的属性与状态" class="headerlink" title="2.2 组件的属性与状态"></a>2.2 组件的属性与状态</h2><p>在React Native（React.js）里，组件所持有的数据分为两种：</p>
<ol>
<li>属性（props）：组件的props是不可变的，它只能从其他的组件（例如父组件）传递过来。</li>
<li>状态（state）：组件的state是可变的，它负责处理与用户的交互。在通过用户点击事件等操作以后，如果使得当前组件的某个state发生了改变，那么当前组件就会触发<code>render()</code>方法刷新自己。</li>
</ol>
<p>举一个这个项目的收藏页面来说：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_2_1_1.png" alt=""></p>
<p>我们可以看到这个页面有两个子页面，一个是‘最热’页面（组件），另一个是‘趋势‘页面（组件）。那么这两个组件都有什么props和state呢？</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p>首先看一下props：<br>由于props是从其父组件传递过来的，那么可想而知，props的声明应该是在当前组件的父组件里来做。在React Native中，通常props的声明是和当前组件的声明放在一起的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最热子页面</span></div><div class="line">&lt;FavoriteTabPage  &#123;...this.props&#125; tabLabel=<span class="string">'最热'</span> flag=&#123;FlAG_STORAGE.flag_popular&#125;/&gt;</div><div class="line"></div><div class="line"><span class="comment">//趋势子页面</span></div><div class="line">&lt;FavoriteTabPage  &#123;...this.props&#125; tabLabel=<span class="string">'趋势'</span> flag=&#123;FlAG_STORAGE.flag_trending&#125;/&gt;</div></pre></td></tr></table></figure>
<p>在这里，收藏页面是父组件，而最热页面和趋势页面是其子组件。在收藏页面组件里声明了最热页面和趋势页面的组件。</p>
<p>而且我们也可以看到，最热页面和趋势页面组件都用的是同一个组件：<code>FavoriteTabPage</code>，而这两个页面的不同点只在于传入的两个props的不同：<code>tabLabel</code>和<code>flag</code>。</p>
<p>而在<code>FavoriteTabPage</code>组件内部，如果想调用flag这个props，可以使用<code>this.props.flag</code>来调用。</p>
<p>再来看一下state：</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>下面是最热和趋势页面的组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FavoriteTabPage</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//组件的构造方法</span></div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line"></div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state=&#123;</div><div class="line">            <span class="attr">dataSource</span>:<span class="keyword">new</span> ListView.DataSource(&#123;<span class="attr">rowHasChanged</span>:<span class="function">(<span class="params">r1,r2</span>)=&gt;</span>r1!==r2&#125;),</div><div class="line">            <span class="attr">isLoading</span>:<span class="literal">false</span>,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面定义了两个state:</p>
<ol>
<li>dataSource:列表的数据源</li>
<li>isLoading:是否正在刷新</li>
</ol>
<p>这两个state都是将来可能经常变化的。比如在网络请求以后，列表的数据源会被替换掉，这个时候就要调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.setState(&#123;</div><div class="line">     <span class="comment">//把新的值newDataArr对象传给dataSource</span></div><div class="line">      dataSource:newDataArr</div><div class="line"> &#125;)</div></pre></td></tr></table></figure></p>
<p>来触发<code>render()</code>方法来刷新列表组件。</p>
<h2 id="2-3-组件的生命周期"><a href="#2-3-组件的生命周期" class="headerlink" title="2.3 组件的生命周期"></a>2.3 组件的生命周期</h2><p>和iOS开发里<code>ViewController</code>的生命周期类似，组件也有生命周期，大致分为三大阶段：</p>
<ul>
<li>Mounting：已插入真实 DOM</li>
<li>Updating：正在被重新渲染</li>
<li>Unmounting：已移出真实 DOM</li>
</ul>
<blockquote>
<p>DOM是前端的一个概念，暂时可以粗略理解为一个页面的树形结构。</p>
</blockquote>
<p>在每个阶段都有相应的状态和与之对应的回调函数，具体可以看下图：</p>
<p><img src="https://raw.githubusercontent.com/crazycodeboy/RNStudyNotes/master/React%20Native%E4%B9%8BReact%E9%80%9F%E5%AD%A6%E6%95%99%E7%A8%8B/images/component-lifecycle.jpg" alt="组件的生命周期"></p>
<blockquote>
<p>上图来自：<a href="http://www.devio.org/2016/08/10/React-Native%E4%B9%8BReact%E9%80%9F%E5%AD%A6%E6%95%99%E7%A8%8B-(%E4%B8%AD" target="_blank" rel="external">贾鹏辉的技术博客：React Native之React速学教程(中)</a>/)</p>
</blockquote>
<p>从上图中我们可以看到，React 为每个状态都提供了两种回调函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用。</p>
<p>在这里讲一下这其中几个重要的回调函数：</p>
<h4 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h4><p>该函数是组件的渲染回调函数，该函数是必须实现的，并且必须返回一个组件或一个包含多个子组件的组件。</p>
<blockquote>
<p>注意：该函数可以被调用多次：初始化时的渲染以及state改变以后的渲染都会调用这个函数。</p>
</blockquote>
<h4 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h4><p>在初始化渲染执行之后立刻调用一次，也就是说，在这个函数调用时，当前组件已经渲染完毕了，相当于iOS开发中<code>ViewController</code>里的<code>viewDidLoad</code>方法。</p>
<blockquote>
<p>我们通常在这个方法里执行网络请求操作。</p>
</blockquote>
<h4 id="componentWillReceiveProps-object-nextProps"><a href="#componentWillReceiveProps-object-nextProps" class="headerlink" title="componentWillReceiveProps(object nextProps)"></a>componentWillReceiveProps(object nextProps)</h4><p>在当前组件接收到新的 props 的时候调用。此函数可以作为 react 在 prop 传入之后， render() 渲染之前更新 state 的机会。新的props可以从参数里取到，老的 props 可以通过 this.props 获取到。</p>
<blockquote>
<p>注意：在初始化渲染的时候，该方法不会调用。</p>
</blockquote>
<h4 id="shouldComponentUpdate-object-nextProps-object-nextState"><a href="#shouldComponentUpdate-object-nextProps-object-nextState" class="headerlink" title="shouldComponentUpdate(object nextProps, object nextState):"></a>shouldComponentUpdate(object nextProps, object nextState):</h4><p>在接收到新的 props 或者 state，将要渲染之前调用。如果确定新的 props 和 state 不会导致组件更新，则此处应该 返回 false，这样组件就不会更新，减少了性能上不必要的损耗。</p>
<blockquote>
<p>注意：该方法在初始化渲染的时候不会调用。</p>
</blockquote>
<h4 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h4><p>在组件从 DOM 中移除的时候立刻被调用。例如当前页面点击返回键跳转到上一页面的时候就会调用。</p>
<blockquote>
<p>我们通常在这个方法里移除通知。具体做法在后文会提到。</p>
</blockquote>
<p>到此，已经讲解了一些组件相关的知识，下面来看一下我们如何使用组件来搭建界面。</p>
<h2 id="2-4-使用组件来搭建界面"><a href="#2-4-使用组件来搭建界面" class="headerlink" title="2.4 使用组件来搭建界面"></a>2.4 使用组件来搭建界面</h2><p>在这里我们举几个例子来看一下在React Native里搭建View的方式。</p>
<p>首先我们来看一下最热页面的cell是如何布局的：</p>
<h3 id="2-41-搭建cell组件"><a href="#2-41-搭建cell组件" class="headerlink" title="2.41 搭建cell组件"></a>2.41 搭建cell组件</h3><p>首先举一个在最热标签页面列表里的一个cell为例，讲解一下一个简单的UI组件是如何实现的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_4_1_1.png" alt="最热标签页面的cell"></p>
<p>我们把该组件定名为：<code>RespositoryCell</code>，结合代码来看一下具体的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">RespositoryCell</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</div><div class="line"> </div><div class="line">    ...</div><div class="line">    </div><div class="line">    render()&#123;</div><div class="line"></div><div class="line">        <span class="comment">//获取当前cell的数据赋值给item</span></div><div class="line">        <span class="keyword">let</span> item = <span class="keyword">this</span>.props.projectModel.item?<span class="keyword">this</span>.props.projectModel.item:<span class="keyword">this</span>.props.projectModel;</div><div class="line"></div><div class="line">        <span class="comment">//收藏按钮</span></div><div class="line">        <span class="keyword">let</span> favoriteButton = &lt;TouchableOpacity</div><div class="line">            onPress=&#123;()=&gt;this.onPressFavorite()&#125;</div><div class="line">        &gt;</div><div class="line">            &lt;Image</div><div class="line">                style=&#123;[styles.favoriteImageStyle,this.props.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                source=&#123;this.state.favoriteIcon&#125;</div><div class="line">            /&gt;</div><div class="line">        &lt;/TouchableOpacity&gt;</div><div class="line"></div><div class="line">        return(</div><div class="line">            &lt;TouchableOpacity</div><div class="line">                 onPress=&#123;this.props.onSelect&#125;</div><div class="line">                 style=&#123;styles.container&#125;</div><div class="line">            &gt;</div><div class="line">                //整个cell的view</div><div class="line">                &lt;View style=&#123;styles.cellContainerViewStyle&#125;&gt;</div><div class="line"></div><div class="line">                    //1. 项目名称</div><div class="line">                    &lt;Text style=&#123;styles.repositoryTitleStyle&#125;&gt;&#123;item.full_name&#125;&lt;/Text&gt;</div><div class="line"></div><div class="line">                    //2. 项目介绍</div><div class="line">                    &lt;Text style=&#123;styles.repositoryDescriptionStyle&#125;&gt;&#123;item.description&#125;&lt;/Text&gt;</div><div class="line"></div><div class="line">                    //3. 底部 container</div><div class="line">                    &lt;View style=&#123;styles.bottomContainerViewStyle&#125;&gt;</div><div class="line"></div><div class="line">                        //3.1 作者container</div><div class="line">                        &lt;View style=&#123;styles.authorContainerViewStyle&#125;&gt;</div><div class="line"></div><div class="line">                            //3.11 作者名称</div><div class="line">                            &lt;Text style=&#123;styles.bottomTextStyle&#125;&gt;Author:&lt;/Text&gt;</div><div class="line"></div><div class="line">                            //3.12 作者头像</div><div class="line">                            &lt;Image</div><div class="line">                                style=&#123;styles.authorAvatarImageStyle&#125;</div><div class="line">                                source=&#123;&#123;uri:item.owner.avatar_url&#125;&#125;</div><div class="line">                             /&gt;</div><div class="line">                        &lt;/View&gt;</div><div class="line"></div><div class="line">                        //3.2 star container</div><div class="line">                        &lt;View style=&#123;styles.starContainerViewStyle&#125;&gt;</div><div class="line">                //3.21 star标题</div><div class="line">                            &lt;Text style=&#123;styles.bottomTextStyle&#125;&gt;Starts:&lt;/Text&gt;</div><div class="line">                       //3.21 star数量</div><div class="line">                            &lt;Text style=&#123;styles.bottomTextStyle&#125;&gt;&#123;item.stargazers_count&#125;&lt;/Text&gt;</div><div class="line">                        &lt;/View&gt;</div><div class="line"></div><div class="line">                        //3.3 收藏按钮</div><div class="line">                        &#123;favoriteButton&#125;</div><div class="line">                     &lt;/View&gt;</div><div class="line">                 &lt;/View&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里省略了处理交互事件等的函数，为了让大家集中在cell的布局和样式上。</p>
</blockquote>
<ul>
<li>这里声明了<code>RespositoryCell</code>组件，它继承于<code>Component</code>，也就是组件类，即是说，声明组件的时候必须都要继承与这个类。</li>
<li>集中看一下该组件的render方法，它返回的是该组件的实际布局：在语法上使用JSX，类似于HTML的标签式语法，很清楚地将cell的层级展现了出来：<ul>
<li>最外层被一个<code>View</code>组件包裹着，里面第一层有三个子组件：两个<code>Text</code>组件和一个作为底部背景的<code>View</code>组件。</li>
<li>底部背景的<code>View</code>组件又有三个子组件：<code>View</code>组件（显示作者信息），<code>View</code>组件（显示star信息）,收藏按钮。</li>
</ul>
</li>
</ul>
<p>试着结合代码来看一下下面的图片，可以看出组件的实际布局与代码的布局是高度一致的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_5_2.png" alt="Cell 布局 "></p>
<p>然而仅仅定义组件的层级关系是不够的，我们还需要定义组件的样式（例如图片组件的大小样式等等），这时候就通过定义一个样式的对象（通常使用常量对象）来定义一些需要使用的样式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//样式常量</span></div><div class="line"><span class="keyword">const</span> styles =StyleSheet.create(&#123;</div><div class="line"></div><div class="line">    <span class="comment">//项目cell的背景view的style       </span></div><div class="line">    cellContainerViewStyle:&#123;</div><div class="line">          </div><div class="line">        <span class="comment">//背景色</span></div><div class="line">        backgroundColor:<span class="string">'white'</span>,</div><div class="line">          </div><div class="line">        <span class="comment">//内边距</span></div><div class="line">        padding:<span class="number">10</span>,</div><div class="line">          </div><div class="line">        <span class="comment">//外边距</span></div><div class="line">        marginTop:<span class="number">4</span>,</div><div class="line">        <span class="attr">marginLeft</span>:<span class="number">6</span>,</div><div class="line">        <span class="attr">marginRight</span>:<span class="number">6</span>,</div><div class="line">        <span class="attr">marginVertical</span>:<span class="number">2</span>,</div><div class="line">          </div><div class="line">        <span class="comment">//边框</span></div><div class="line">        borderWidth:<span class="number">0.3</span>,</div><div class="line">        <span class="attr">borderColor</span>:<span class="string">'#dddddd'</span>,</div><div class="line">        <span class="attr">borderRadius</span>:<span class="number">1</span>,</div><div class="line">          </div><div class="line">        <span class="comment">//iOS的阴影</span></div><div class="line">        shadowColor:<span class="string">'#b5b5b5'</span>,</div><div class="line">        <span class="attr">shadowOffset</span>:&#123;<span class="attr">width</span>:<span class="number">3</span>,<span class="attr">height</span>:<span class="number">2</span>&#125;,</div><div class="line">        <span class="attr">shadowOpacity</span>:<span class="number">0.4</span>,</div><div class="line">        <span class="attr">shadowRadius</span>:<span class="number">1</span>,</div><div class="line">      </div><div class="line">        <span class="comment">//Android的阴影</span></div><div class="line">        elevation:<span class="number">2</span></div><div class="line">    &#125;,</div><div class="line">  </div><div class="line">    <span class="comment">//项目标题的style</span></div><div class="line">    repositoryTitleStyle:&#123;</div><div class="line">        <span class="attr">fontSize</span>:<span class="number">15</span>,</div><div class="line">        <span class="attr">marginBottom</span>:<span class="number">2</span>,</div><div class="line">        <span class="attr">color</span>:<span class="string">'#212121'</span>,</div><div class="line">    &#125;,</div><div class="line">  </div><div class="line">    <span class="comment">//项目介绍的style  </span></div><div class="line">    repositoryDescriptionStyle:&#123;</div><div class="line">        <span class="attr">fontSize</span>:<span class="number">12</span>,</div><div class="line">        <span class="attr">marginBottom</span>:<span class="number">2</span>,</div><div class="line">        <span class="attr">color</span>:<span class="string">'#757575'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//底部container的style</span></div><div class="line">    bottomContainerViewStyle:&#123;</div><div class="line">        <span class="attr">flexDirection</span>:<span class="string">'row'</span>,</div><div class="line">        <span class="attr">justifyContent</span>:<span class="string">'space-between'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//作者container的style</span></div><div class="line">    authorContainerViewStyle:&#123;</div><div class="line">        <span class="attr">flexDirection</span>:<span class="string">'row'</span>,</div><div class="line">        <span class="attr">alignItems</span>:<span class="string">'center'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//作者头像图片的style</span></div><div class="line">    authorAvatarImageStyle:&#123;</div><div class="line">        <span class="attr">width</span>:<span class="number">16</span>,</div><div class="line">        <span class="attr">height</span>:<span class="number">16</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//星星container的style</span></div><div class="line">    starContainerViewStyle: &#123;</div><div class="line">        <span class="attr">flexDirection</span>:<span class="string">'row'</span>,</div><div class="line">        <span class="attr">alignItems</span>:<span class="string">'center'</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//底部文字的style</span></div><div class="line">    bottomTextStyle:&#123;</div><div class="line">       <span class="attr">fontSize</span>:<span class="number">11</span>,</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//收藏按钮的图片的style</span></div><div class="line">    favoriteImageStyle:&#123;</div><div class="line">        <span class="attr">width</span>:<span class="number">18</span>,</div><div class="line">        <span class="attr">height</span>:<span class="number">18</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在上面这段代码里定义了<code>RespositoryCell</code>组件所使用的所有样式，通过将其赋值给对应子组件的style属性来实现对组件样式的修改，例如我们看一下项目标题的组件和其样式的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;styles.repositoryTitleStyle&#125;&gt;&#123;item.full_name&#125;&lt;<span class="regexp">/Text&gt;</span></div></pre></td></tr></table></figure>
<p>在这里，我们首先定义了一个Text组件用来显示项目的标题。然后将<code>styles.repositoryTitleStyle</code>赋给了当前Text组件的style,而标题的具体内容，则通过<code>item.full_name</code>来获取。</p>
<p>需要注意的是，在JSX的语法中，对象需要被{}来包裹住，否则会被认为是常量。比如，如果这里写成：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;styles.repositoryTitleStyle&#125;&gt;item.full_name&lt;<span class="regexp">/Text&gt;</span></div></pre></td></tr></table></figure>
<p>那么所有项目cell的标题则都会显示为’’item.full_name’’，有图有真相：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_5_1_1.png" alt=""></p>
<p>这是初学者比较常犯的错误，所以要注意：在搭建页面的时候，一定要区分是对象还是常量。如果是对象就必须要用大括号括起来！如果是对象就必须要用大括号括起来！如果是对象就必须要用大括号括起来！</p>
<blockquote>
<p>这里每个样式里面的长，宽，内外边距，以及<code>flexDirection</code>等flexBox相关的布局属性就不介绍了。可以通过查找本文最后的相关链接来学习。</p>
</blockquote>
<h3 id="2-42-搭建静态表格页"><a href="#2-42-搭建静态表格页" class="headerlink" title="2.42 搭建静态表格页"></a>2.42 搭建静态表格页</h3><p>在React Native中搭建个人页，设置页这种静态表格页面的时候，可以用<code>ScrollView</code>组件包裹各种封装好的cell组件的形式实现。看一下这个Demo的个人页的效果图和代码实现：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_6_1_1.png" alt="个人页"></p>
<p>我们在项目中新建一个JavaScript文件，取名为取名为<code>MinePage.js</code> 。该文件就是个人页面的实现。结合代码来看一下它的实现（删除了处理点击cell的逻辑处理代码）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//区域一：引用区：</span></div><div class="line"><span class="comment">//引用React，Component(组件类)以及React Native中自带的组件</span></div><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    StyleSheet,</div><div class="line">    Text,</div><div class="line">    View,</div><div class="line">    Image,</div><div class="line">    ScrollView,</div><div class="line">    TouchableHighlight,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="comment">//引入项目中定义的其他组件(页面组件)和常量，路径为相对路径</span></div><div class="line"><span class="keyword">import</span> NavigationBar <span class="keyword">from</span> <span class="string">'../../common/NavigationBar'</span></div><div class="line"><span class="keyword">import</span> &#123;MORE_MENU&#125; <span class="keyword">from</span> <span class="string">'../../common/MoreMenu'</span></div><div class="line"><span class="keyword">import</span> GlobalStyles <span class="keyword">from</span> <span class="string">'../../../res/styles/GlobalStyles'</span></div><div class="line"><span class="keyword">import</span> ViewUtil <span class="keyword">from</span> <span class="string">'../../util/ViewUtils'</span></div><div class="line"><span class="keyword">import</span> &#123;FLAG_LANGUAGE&#125;<span class="keyword">from</span> <span class="string">'../../dao/LanguageDao'</span></div><div class="line"><span class="keyword">import</span> AboutPage <span class="keyword">from</span> <span class="string">'./AboutPage'</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> CustomKeyPage <span class="keyword">from</span> <span class="string">'./CustomKeyPage'</span></div><div class="line"><span class="keyword">import</span> SortPage <span class="keyword">from</span> <span class="string">'./SortKeyPage'</span></div><div class="line"><span class="keyword">import</span> AboutMePage <span class="keyword">from</span> <span class="string">'./AboutMePage'</span></div><div class="line"><span class="keyword">import</span> CustomThemePage <span class="keyword">from</span> <span class="string">'./CustomThemePage'</span></div><div class="line"><span class="keyword">import</span> BaseComponent <span class="keyword">from</span> <span class="string">'../../base/BaseCommon'</span></div><div class="line"></div><div class="line"><span class="comment">//区域二：页面组件定义区域：</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MinePage</span> <span class="keyword">extends</span> <span class="title">BaseComponent</span> </span>&#123;</div><div class="line"></div><div class="line"> ...</div><div class="line">    </div><div class="line">    <span class="comment">//渲染页面中List中每个cell的统一函数</span></div><div class="line">    createSettingItem(tag,icon,text)&#123;</div><div class="line">        <span class="keyword">return</span> ViewUtil.createSettingItem(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.onClick(tag),icon,text,<span class="keyword">this</span>.state.theme.styles.tabBarSelectedIcon,<span class="literal">null</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render()&#123;</div><div class="line">        <span class="keyword">return</span> &lt;View style=&#123;GlobalStyles.listViewContainerStyle&#125;&gt;</div><div class="line">            &lt;NavigationBar</div><div class="line">                title=&#123;'我的'&#125;</div><div class="line">                style=&#123;this.state.theme.styles.navBar&#125;</div><div class="line">            /&gt;</div><div class="line">            &lt;ScrollView&gt;</div><div class="line"></div><div class="line">                &#123;/*=============项目信息Section=============*/&#125;</div><div class="line">                &lt;TouchableHighlight</div><div class="line">                    underlayColor= 'transparent'</div><div class="line">                    onPress=&#123;()=&gt;this.onClick(MORE_MENU.About)&#125;</div><div class="line">                &gt;</div><div class="line">                    &lt;View style=&#123;styles.itemInfoItemStyle&#125;&gt;</div><div class="line">                        &lt;View style=&#123;&#123;flexDirection:'row',alignItems:'center'&#125;&#125;&gt;</div><div class="line">                            &lt;Image source=&#123;require('../../../res/images/ic_trending.png')&#125;</div><div class="line">                                   style=&#123;[&#123;width:40,height:40,marginRight:10&#125;,this.state.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                            /&gt;</div><div class="line">                            &lt;Text&gt;GitHub Popular 项目信息&lt;/Text&gt;</div><div class="line">                        &lt;/View&gt;</div><div class="line">                        &lt;Image source=&#123;require('../../../res/images/ic_tiaozhuan.png')&#125;</div><div class="line">                            style=&#123;[&#123;height:22,width:22&#125;,this.state.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                        /&gt;</div><div class="line">                    &lt;/View&gt;</div><div class="line">                &lt;/TouchableHighlight&gt;</div><div class="line">                &#123;/*分割线*/&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*=============趋势管理Section=============*/&#125;</div><div class="line">                &lt;Text style=&#123;styles.groupTitleStyle&#125;&gt;趋势管理&lt;/Text&gt;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;/*自定义语言*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Custom_Language,require('../../../res/images/ic_custom_language.png'),'自定义语言')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*语言排序*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Sort_Language,require('../../../res/images/ic_swap_vert.png'),'语言排序')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*=============标签管理Section=============*/&#125;</div><div class="line">                &lt;Text style=&#123;styles.groupTitleStyle&#125;&gt;标签管理&lt;/Text&gt;</div><div class="line"></div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;/*自定义标签*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Custom_Key,require('../../../res/images/ic_custom_language.png'),'自定义标签')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;/*标签排序*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Sort_Key,require('../../../res/images/ic_swap_vert.png'),'标签排序')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;/*标签移除*/&#125;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Remove_Key,require('../../../res/images/ic_remove.png'),'标签移除')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*=============设置Section=============*/&#125;</div><div class="line">                &lt;Text style=&#123;styles.groupTitleStyle&#125;&gt;设置&lt;/Text&gt;</div><div class="line">                &#123;/*自定义主题*/&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line">                &#123;this.createSettingItem(MORE_MENU.Custom_Theme,require('../../../res/images/ic_view_quilt.png'),'自定义主题')&#125;</div><div class="line">                &lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div><div class="line"></div><div class="line">                &#123;/*展示自定义主题页面*/&#125;</div><div class="line">                &#123;this.renderCustomTheme()&#125;</div><div class="line">            &lt;/ScrollView&gt;</div><div class="line">        &lt;/View&gt;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//区域三：定义页面组件样式区：</div><div class="line">const styles = StyleSheet.create(&#123;</div><div class="line"></div><div class="line">    itemInfoItemStyle:&#123;</div><div class="line">        flexDirection:'row',</div><div class="line">        justifyContent:'space-between',</div><div class="line">        alignItems:'center',</div><div class="line">        padding:10,</div><div class="line">        height:76,</div><div class="line">        backgroundColor:'white'</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    groupTitleStyle:&#123;</div><div class="line">        marginLeft:10,</div><div class="line">        marginTop:15,</div><div class="line">        marginBottom:6,</div><div class="line">        color:'gray'</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在上面的代码中，我们可以看到一个页面组件的全貌，它大致分为三个区域：</p>
<ol>
<li>引用区域</li>
<li>定义组件区域</li>
<li>定义样式区域</li>
</ol>
<p>下面两个区域在上一节已经介绍过。第一个区域，引用区域一般写在组件文件的开头，在这里一般是需要引入该组件需要的其他组件或者常量。</p>
<p>现在看一下该组件的<code>render()</code>函数，它返回了用来包裹整个页面的<code>View</code>组件，该组件有两个子组件</p>
<ul>
<li>NavigationBar组件（导航栏），传入了两个props：title和style。</li>
<li>ScrollView组件，包裹了项目信息Cell的View组件，分割线，项目Cell的View组件。需要注意的是，每个cell的组件都比较类似，所以在这里将生成它的代码封装起来做一个函数来调用：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">createSettingItem(tag,icon,text)&#123;</div><div class="line">        <span class="keyword">return</span>  ViewUtil.createSettingItem(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.onClick(tag),icon,text,<span class="keyword">this</span>.state.theme.styles.tabBarSelectedIcon,<span class="literal">null</span>);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>可以看到这个函数传入的参数有三个：用来作标记的tag，图片 和标题文字。它的返回值通过调用ViewUtil组件的<code>createSettingItem</code>方法来实现。这个方法用于统一生成类似布局的cell。</p>
<p>看一下这个函数的实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"><span class="comment">//ViewUtils.js</span></div><div class="line"><span class="keyword">static</span> createSettingItem(callBack,icon,text,tintColor,expandableIcon)&#123;</div><div class="line"></div><div class="line">        <span class="comment">//如果不传入icon，则不显示</span></div><div class="line">        <span class="keyword">let</span> image = <span class="literal">null</span>;</div><div class="line">        <span class="keyword">if</span> (icon)&#123;</div><div class="line">            image = &lt;Image</div><div class="line">                source=&#123;icon&#125;</div><div class="line">                resizeMode='stretch'</div><div class="line">                style=&#123;[&#123;width:18,height:18,marginRight:10&#125;,tintColor]&#125;</div><div class="line">            /&gt;</div><div class="line">        &#125;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;&#123;backgroundColor:'white'&#125;&#125;&gt;</div><div class="line">                &lt;TouchableHighlight</div><div class="line">                    onPress=&#123;callBack&#125;</div><div class="line">                    underlayColor= 'transparent'</div><div class="line">                &gt;</div><div class="line">                    &lt;View style=&#123;styles.settingItemContainerStyle&#125;&gt;</div><div class="line">                        &lt;View style=&#123;&#123;flexDirection:'row',alignItems:'center'&#125;&#125;&gt;</div><div class="line">                            &#123;image&#125;</div><div class="line">                            &lt;Text&gt;&#123;text&#125;&lt;/Text&gt;</div><div class="line">                        &lt;/View&gt;</div><div class="line">                        &lt;Image source=&#123;expandableIcon?expandableIcon:require('../../res/images/ic_tiaozhuan.png')&#125;</div><div class="line">                               style=&#123;[&#123;marginRight:0,height:22,width:22&#125;,tintColor]&#125;//要用括号</div><div class="line">                        /&gt;</div><div class="line">                    &lt;/View&gt;</div><div class="line">                &lt;/TouchableHighlight&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个函数有5个参数：</p>
<ul>
<li>callback：点击cell时调用的方法，需要父组件传入</li>
<li>icon：cell左侧的图片</li>
<li>text：cell标题</li>
<li>tintColor：cell的主题颜色</li>
<li>expandableIcon:cell右侧的图片（三角箭头）</li>
</ul>
<p>因为在React Native中没有特定的<code>Button</code>组件，所以实现组件的点击都是通过被<code>TouchableHighlight</code>等可点击组件包裹来实现的。</p>
<p>常用的可以实现点击效果的是<code>View</code>组件和<code>Text</code>组件。</p>
<p>注意一下<code>TouchableHighlight</code>里面传入的两个props：</p>
<ol>
<li>如果需要在点击时颜色不变，可以将它的<code>underlayColor</code>设为<code>transparent</code>。</li>
<li>可以把点击时触发的函数传给它的<code>onPress</code>属性。所以，如果该cell被点击了，就会触发传入的callback。这个callback就等于当初传过来的箭头函数：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ViewUtil.createSettingItem(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">this</span>.onClick(tag),icon,text,<span class="keyword">this</span>.state.theme.styles.tabBarSelectedIcon,<span class="literal">null</span>);</div></pre></td></tr></table></figure>
<p>该函数是在个人页被调用的，用来实现点击cell时的跳转等操作。</p>
<blockquote>
<p>注意，在这个ViewUtils类中，我们可以定义很多常用的View组件，例如这种设置页面的cell，导航栏上的返回按钮等等。</p>
</blockquote>
<p>现在cell的实现讲完了，下面讲一下分割线和session的title。</p>
<p>先来看一下分割线：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;View style=&#123;GlobalStyles.cellBottomLineStyle&#125;&gt;&lt;/View&gt;</div></pre></td></tr></table></figure>
<p>它的样式调用了<code>GlobalStyles</code>的<code>cellBottomLineStyle</code>。因为<code>GlobalStyles</code>是全局的样式文件（单独写在了一个js文件中），可以使用它来专门管理一些常用的样式。这样一来，我们就不需要在不同页面的组件页面里面重复声明样式常量了。</p>
<p>我们看一下如何定义全局的样式文件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GlobalStyles.js</span></div><div class="line"><span class="built_in">module</span>.exports =&#123;</div><div class="line"></div><div class="line">    <span class="comment">//cell分割线样式</span></div><div class="line">    cellBottomLineStyle: &#123;</div><div class="line">        <span class="attr">height</span>: <span class="number">0.4</span>,</div><div class="line">        <span class="attr">opacity</span>:<span class="number">0.5</span>,</div><div class="line">        <span class="attr">backgroundColor</span>: <span class="string">'darkgray'</span>,</div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//cell背景色样式</span></div><div class="line">    cell_container: &#123;</div><div class="line">        <span class="attr">flex</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">backgroundColor</span>: <span class="string">'white'</span>,</div><div class="line">        <span class="attr">padding</span>: <span class="number">10</span>,</div><div class="line">        <span class="attr">marginLeft</span>: <span class="number">5</span>,</div><div class="line">        <span class="attr">marginRight</span>: <span class="number">5</span>,</div><div class="line">        <span class="attr">marginVertical</span>: <span class="number">3</span>,</div><div class="line">        <span class="attr">borderColor</span>: <span class="string">'#dddddd'</span>,</div><div class="line">        <span class="attr">borderStyle</span>: <span class="literal">null</span>,</div><div class="line">        <span class="attr">borderWidth</span>: <span class="number">0.5</span>,</div><div class="line">        <span class="attr">borderRadius</span>: <span class="number">2</span>,</div><div class="line">        <span class="attr">shadowColor</span>: <span class="string">'gray'</span>,</div><div class="line">        <span class="attr">shadowOffset</span>: &#123;<span class="attr">width</span>:<span class="number">0.5</span>, <span class="attr">height</span>: <span class="number">0.5</span>&#125;,</div><div class="line">        <span class="attr">shadowOpacity</span>: <span class="number">0.4</span>,</div><div class="line">        <span class="attr">shadowRadius</span>: <span class="number">1</span>,</div><div class="line">        <span class="attr">elevation</span>:<span class="number">2</span></div><div class="line">    &#125;,</div><div class="line"></div><div class="line">    <span class="comment">//当前屏幕高度</span></div><div class="line">    window_height:height,</div><div class="line">    <span class="comment">//当前屏幕宽度</span></div><div class="line">    window_width:width,</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>因为使用了<code>module.exports</code>方法，在这里定义的全局样式可以在外部随意使用。</p>
<p>最后，Section Title的View就比较简单了，就是一个带有灰色文字的<code>View</code>组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Text style=&#123;styles.groupTitleStyle&#125;&gt;趋势管理&lt;/Text&gt;</div></pre></td></tr></table></figure>
<h3 id="2-43-搭建app基本骨架：TabBar-NavigationBar"><a href="#2-43-搭建app基本骨架：TabBar-NavigationBar" class="headerlink" title="2.43 搭建app基本骨架：TabBar + NavigationBar"></a>2.43 搭建app基本骨架：TabBar + NavigationBar</h3><p>做移动开发的朋友们应该比较了解，底部TabBar，顶部NavigationBar是移动app很主流的一个全局界面方案。然而在原生的React Native组件里面，没有将二者整合在一起的组件。幸运的是，有一个第三方组件比较好的将二者整合到了一起：<a href="https://github.com/happypancake/react-native-tab-navigator">react-native-tab-navigator</a>.</p>
<p>在它的主页告诉我们其导入方式是在项目主目录下执行：<code>npm install react-native-tab-navigator —save</code>命令。但是我建议使用<code>yarn</code>来引入所有第三方的组件：<code>yarn add react-native-tab-navigator</code>。因为使用npm命令安装第三方组件的时候有时会出现问题。而且建议引入第三方组件的时候都是用<code>yarn</code>来操作，比较保险一点。</p>
<p>在确认<code>react-native-tab-navigator</code>组件下载到了npm文件夹以后，就可以在项目中导入使用了。下面来看一下使用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//导入 react-native-tab-navigator 组件，取名为 TabNavigator(随意取名)</span></div><div class="line"><span class="keyword">import</span> TabNavigator <span class="keyword">from</span> <span class="string">'react-native-tab-navigator'</span>;</div><div class="line"></div><div class="line"><span class="comment">//每个tab对应的唯一标识，可以在外部获取</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">const</span> FLAG_TAB = &#123;</div><div class="line">    <span class="attr">flag_popularTab</span>: <span class="string">'flag_popularTab'</span>,</div><div class="line">    <span class="attr">flag_trendingTab</span>: <span class="string">'flag_trendingTab'</span>,</div><div class="line">    <span class="attr">flag_favoriteTab</span>: <span class="string">'flag_favoriteTab'</span>,</div><div class="line">    <span class="attr">flag_myTab</span>: <span class="string">'flag_myTab'</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">BaseComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">      </div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        </div><div class="line">        <span class="keyword">let</span> selectedTab = <span class="keyword">this</span>.props.selectedTab?<span class="keyword">this</span>.props.selectedTab:FLAG_TAB.flag_popularTab</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.state = &#123;</div><div class="line">            <span class="attr">selectedTab</span>:selectedTab,</div><div class="line">            <span class="attr">theme</span>:<span class="keyword">this</span>.props.theme</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    _renderTab(Component, selectedTab, title, renderIcon) &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;TabNavigator.Item</div><div class="line">                selected=&#123;this.state.selectedTab === selectedTab&#125;</div><div class="line">                title=&#123;title&#125;</div><div class="line">                selectedTitleStyle=&#123;this.state.theme.styles.selectedTitleStyle&#125;</div><div class="line">                renderIcon=&#123;() =&gt; &lt;Image style=&#123;styles.tabItemImageStyle&#125;</div><div class="line">                                         source=&#123;renderIcon&#125;/&gt;&#125;</div><div class="line">                renderSelectedIcon=&#123;() =&gt; &lt;Image</div><div class="line">                    style=&#123;[styles.tabItemImageStyle,this.state.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                    source=&#123;renderIcon&#125;/&gt;&#125;</div><div class="line">                    onPress=&#123;() =&gt; this.onSelected(selectedTab)&#125;&gt;</div><div class="line">                &lt;Component &#123;...this.props&#125; theme=&#123;this.state.theme&#125; homeComponent=&#123;this&#125;/&gt;</div><div class="line">            &lt;/TabNavigator.Item&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        return (</div><div class="line">            &lt;View style=&#123;styles.container&#125;&gt;</div><div class="line">                &lt;TabNavigator</div><div class="line">                    tabBarStyle=&#123;&#123;opacity: 0.9,&#125;&#125;</div><div class="line">                    sceneStyle=&#123;&#123;paddingBottom: 0&#125;&#125;</div><div class="line">                &gt;</div><div class="line">                    &#123;this._renderTab(PopularPage, FLAG_TAB.flag_popularTab, '最热', require('../../../res/images/ic_polular.png'))&#125;</div><div class="line">                    &#123;this._renderTab(TrendingPage, FLAG_TAB.flag_trendingTab, '趋势', require('../../../res/images/ic_trending.png'))&#125;</div><div class="line">                    &#123;this._renderTab(FavoritePage, FLAG_TAB.flag_favoriteTab, '收藏', require('../../../res/images/ic_favorite.png'))&#125;</div><div class="line">                    &#123;this._renderTab(MinePage, FLAG_TAB.flag_myTab, '我的', require('../../../res/images/ic_my.png'))&#125;</div><div class="line">                &lt;/TabNavigator&gt;</div><div class="line">            &lt;/View&gt;</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我省略了其他的代码，只保留了关于搭建<code>TabBar &amp;&amp; NavigationBar</code>的代码。</p>
<p>这里定义的是<code>HomePage</code>组件，是这个Demo用来管理这些tab的组件。</p>
<p>因为这个Demo一共有四个tab，所以将渲染的tab的代码抽取出来作为单独的一个函数：<code>_renderTab</code>。该函数有四个参数：</p>
<ul>
<li>Component：当前tab被点击后显示的组件。</li>
<li>selectedTab：当前tab的唯一标识。</li>
<li>title：当前tab的标题。</li>
<li>renderIcon：当前tab的图标。</li>
</ul>
<p>在<code>_renderTab</code>方法里，我们返回一个<code>TabNavigator.Item</code>组件，除了一些关于tab的props的定义以外，我们将属于该tab的组件填充了进去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Component &#123;...this.props&#125; theme=&#123;this.state.theme&#125; homeComponent=&#123;this&#125;/&gt;</div></pre></td></tr></table></figure>
<p>在这里，{…this.props}是将当前<code>HomePage</code>的所有props赋给这个<code>Component</code>。还有另外两个props也定义了进去：<code>theme</code>和<code>homeComponent</code>。</p>
<p>这里用一个常量定义了四个tab的唯一标识，需要注意的是，这个常量是可以被其他组件获得的，以为它被<code>export</code>字段修饰了。</p>
<p>另外，还需要注意一下<code>HomePage</code>有一个属性是<code>selectedTab</code>，它用来标记当前选择的tab是哪一个。在<code>constructor</code>方法里做了一个判断，如果没有从外部组件传进来<code>selectedTab</code>，则需要初始化为<code>FLAG_TAB.flag_popularTab</code>。</p>
<h2 id="2-5-组件间通信"><a href="#2-5-组件间通信" class="headerlink" title="2.5 组件间通信"></a>2.5 组件间通信</h2><p>既然React项目是以组件为单位搭建的，那么一定少不了组件之间的数据和事件的传递，也就是组件之间的通信。</p>
<p>组件间通信分为两大类：</p>
<ol>
<li><p>有直接关系或间接关系的组件之间通信</p>
</li>
<li><p>无直接关系或间接关系的组件之间通信</p>
</li>
</ol>
<p>   ​</p>
<h3 id="2-51-有直接关系或间接关系的组件之间通信"><a href="#2-51-有直接关系或间接关系的组件之间通信" class="headerlink" title="2.51 有直接关系或间接关系的组件之间通信"></a>2.51 有直接关系或间接关系的组件之间通信</h3><p>我个人是这么理解父组件和子组件的关系的：</p>
<p>如果A组件包含了B组件，或者说在A组件里创建了B组件，那么A组件就是B组件的父组件；反过来B组件就是A组件的子组件，是有直接关系的组件。</p>
<p>比如：</p>
<ul>
<li><p>一个界面的导航栏组件是整个页面组件的子组件，因为这个导航栏组件被包含在了当前的页面组件当中。</p>
</li>
<li><p>从这个页面跳转到的下一个页面是当前页面的子组件：因为被包含在了当前页面组件的<code>Navigator</code>里。</p>
<p>​</p>
</li>
</ul>
<p>再加上子组件和子组件的通信，直接或间接关系组件之间的通信就分为下面这三种情况：</p>
<ol>
<li><p>父组件向子组件传递数据和事件。</p>
</li>
<li><p>子组件向父组件传递消息和事件。</p>
</li>
<li><p>子组件向子组件传递消息和事件。</p>
<p>​</p>
</li>
</ol>
<h4 id="父组件向子组件传递数据和事件：通过对子组件的属性赋值来实现。"><a href="#父组件向子组件传递数据和事件：通过对子组件的属性赋值来实现。" class="headerlink" title="父组件向子组件传递数据和事件：通过对子组件的属性赋值来实现。"></a>父组件向子组件传递数据和事件：通过对子组件的属性赋值来实现。</h4><p>在上面我们看到，在给页面布局的时候我们使用了导航栏组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;NavigationBar</div><div class="line">      title=&#123;<span class="string">'我的'</span>&#125;</div><div class="line">      style=&#123;<span class="keyword">this</span>.state.theme.styles.navBar&#125;</div><div class="line"> /&gt;</div></pre></td></tr></table></figure>
<p>在这里，当前页面组件将<code>&#39;我的&#39;</code>对象，以及<code>this.state.theme.styles.navBar</code>对象分别赋值给了导航栏组件。而导航栏接收到这两个值以后，在其内部可以通过<code>this.props.title</code>和<code>this.props.style</code>来获取到这两个值。这样一来，就实现了父组件向子组件传递数据的功能。</p>
<h4 id="子组件向父组件传递消息、数据：通过父组件给子组件一个闭包（回调函数）来实现"><a href="#子组件向父组件传递消息、数据：通过父组件给子组件一个闭包（回调函数）来实现" class="headerlink" title="子组件向父组件传递消息、数据：通过父组件给子组件一个闭包（回调函数）来实现"></a>子组件向父组件传递消息、数据：通过父组件给子组件一个闭包（回调函数）来实现</h4><p>举一个点击最热标签页面的一个cell进行回调后实现界面跳转的例子：</p>
<p>既然这个cell组件是在最热标签页面组件中生成的，那么cell组件就是其子组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ListView组件生成每个cell的函数</span></div><div class="line">renderRow(projectModel)&#123;</div><div class="line">  <span class="keyword">return</span> &lt;RespositoryCell</div><div class="line">            key = &#123;projectModel.item.id&#125;</div><div class="line">            theme=&#123;this.state.theme&#125;</div><div class="line">            projectModel=&#123;projectModel&#125;</div><div class="line">            onSelect = &#123;()=&gt;this.onSelectRepository(projectModel)&#125;</div><div class="line">            onFavorite=&#123;(item,isFavorite)=&gt;this.onFavorite(item,isFavorite)&#125;/&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>renderRow()</code>函数是<code>ListView</code>组件用来渲染每一行Cell的函数，必须返回一个Cell组件才可以。在这里我们自定义了一个<code>RespositoryCell</code>组件作为其Cell组件。</p>
<p>我们可以看到，这里面有5个props被赋值了，其中，<code>onSelect</code>和<code>onFavorite</code>被赋予了函数：</p>
<ul>
<li><code>onSelect</code>回调的是点击cell之后在最热标签页面里跳转页面的函数<code>onSelectRepository()</code>。</li>
<li><code>onFavorite</code>则回调的是更改最热标签页面对应收藏按钮状态的函数<code>onFavorite</code>（未被收藏时是空心的星；被收藏的话是实心的星）。</li>
</ul>
<p>下面在<code>RespositoryCell</code>组件内部看一下这两个函数是如何回调的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">render()&#123;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> item = <span class="keyword">this</span>.props.projectModel.item?<span class="keyword">this</span>.props.projectModel.item:<span class="keyword">this</span>.props.projectModel;</div><div class="line"></div><div class="line">        <span class="keyword">let</span> favoriteButton = &lt;TouchableOpacity</div><div class="line">            &#123;/*调用点击收藏的回调函数*/&#125;</div><div class="line">            onPress=&#123;()=&gt;this.onPressFavorite()&#125;</div><div class="line">        &gt;</div><div class="line">            &lt;Image</div><div class="line">                style=&#123;[styles.favoriteImageStyle,this.props.theme.styles.tabBarSelectedIcon]&#125;</div><div class="line">                source=&#123;this.state.favoriteIcon&#125;</div><div class="line">            /&gt;</div><div class="line">        &lt;/TouchableOpacity&gt;</div><div class="line"></div><div class="line">        return(</div><div class="line">            &lt;TouchableOpacity</div><div class="line">                 &#123;/*点击cell的回调函数*/&#125;</div><div class="line">                 onPress=&#123;this.props.onSelect&#125;</div><div class="line">                 style=&#123;styles.container&#125;</div><div class="line">            &gt;</div><div class="line">               &lt;View style=&#123;styles.cellContainerViewStyle&#125;&gt;</div><div class="line">                   ...</div><div class="line">                   &#123;favoriteButton&#125;</div><div class="line">               &lt;/View&gt;</div><div class="line">            &lt;/TouchableOpacity&gt;)</div><div class="line"></div><div class="line">    &#125;</div><div class="line">          </div><div class="line">   onPressFavorite()&#123;</div><div class="line">        this.setFavoriteState(!this.state.isFavorite);</div><div class="line">        //点击收藏的回调函数</div><div class="line">        this.props.onFavorite(this.props.projectModel.item,!this.state.isFavorite)</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>由上一节我们知道，父组件给子组件的props传值后，子组件里面对应的props就被赋值了。在这<code>RespositoryCell</code>组件里面就是<code>this.props.onSelect</code>和<code>this.props.onFavorite</code>。这两个函数被赋给了两个<code>TouchableOpacity</code>组件的<code>onPress</code>里面。这里的<code>()=&gt;</code>可以理解为为传递事件，表示当该控件被点击后的事件。</p>
<p>不同的是，<code>this.props.onFavorite()</code>是可以将两个值回传给其父组件。细心的同学会发现，在给<code>RespositoryCell</code>传值的时候，是有两个返回值存在的。</p>
<blockquote>
<p>注意，在这里的<code>TouchableOpacity</code>和上文提到的<code>TouchableHighlight</code>类似，都可以让非可点击组件变成可点击组件。区别在于配合<code>TouchableOpacity</code>使用时，点击后无高亮效果。而<code>TouchableHighlight</code>默认是有高亮效果的。</p>
</blockquote>
<p>OK，现在我们知道了父组件和子组件是如何传递数据和事件了：</p>
<ul>
<li>父组件到子组件：通过直接给属性赋值</li>
<li>子组件到父组件：通过父组件给子组件传递回调函数</li>
</ul>
<p>需要注意的是，上面讲的都是直接关系的父子组件，其实还有间接关系的组件，也就是两个组件之间有一个或多个组件连接着，比如父组件的子组件的子组件。这些组件之间的通信都可以通过上述的方法来实现，只不过是中间跨过多少层的区别而已。</p>
<blockquote>
<p>需要注意的是，这里说的父组件和子组件的通信，不仅仅包括这种直接关系，还包括间接关系，而间接关系的组件就是该组件与其子组件的子组件的关系。</p>
</blockquote>
<p>所以无论中间隔了多少组件，只要是存在于这种关系链上的组件，都可以用上述两种方式来传递数据和事件。</p>
<h4 id="兄弟组件之间的通信"><a href="#兄弟组件之间的通信" class="headerlink" title="兄弟组件之间的通信"></a>兄弟组件之间的通信</h4><p>虽然不是包含于被包含，由谁创建了谁的关系，但是同一父组件下的几个子组件（兄弟组件）也算得上是有间接关系了（中间夹着共同的父组件）。</p>
<p>那么在同一父组件下的两个子组件是如何传递数据呢？</p>
<p>答案是通过二者所共享的父组件的state来传递数据的</p>
<p>因为我们知道触发组件的渲染是通过<code>setState</code>方法的。因此，如果两个子组件都使用了他们的父组件的同一个state来渲染自己。</p>
<p>那么当其中一个子组件触发了<code>setState</code>,更新了这个共享的父组件的state，继而触发了父组件的<code>render()</code>方法，那么这两个子组件都会依据这个更新后的<code>state</code>来刷新自己，这样一来，就实现了子组件的数据传递。</p>
<p>到现在就讲完了有直接或间接关系的组件之间的通信，下面来讲一下无直接关系或间接关系的组件之间的通信：</p>
<h3 id="2-52-无直接关系和间接关系的组件之间通信"><a href="#2-52-无直接关系和间接关系的组件之间通信" class="headerlink" title="2.52 无直接关系和间接关系的组件之间通信"></a>2.52 无直接关系和间接关系的组件之间通信</h3><p>如果两个组件从属于不同的关系链既没有直接关系，也没有间接关系（例如不同模块下的两个页面组件），那么想实现通信的话，就需要通过通知机制，或者本地持久化方案来实现。在这里先介绍一下通知机制，而本地持久化会在下面单拿出一节来专门讲解。</p>
<p>通知机制可以通过这个Demo的收藏功能来讲解：</p>
<p>先大致介绍一下收藏的需求：</p>
<ol>
<li>在最热标签页或者语言趋势页面如果点击了收藏按钮，那么在收藏页面就会增加被收藏的项目（注意，点击收藏按钮后不进行网络请求，也就是说，收藏页面是没有网络请求的）。</li>
<li>而如果在收藏页面中取消了收藏，就需要在最热标签页面或语言趋势页面中对应的项目里面更新取消收藏的效果（同样没有网络请求）。</li>
</ol>
<p>因为这三个页面从属于不同模块， 而且又不是以网络请求的方式刷新列表，所以如果要满足上述需求，就需要使用通知或者本地存储的方式来实现。</p>
<p>在这个Demo中，第一个需求采用的是本地持久化方案，第二个需求采用的是通知机制。本地持久化方案我会在下一节单独介绍，在本节先讲一下在React Native里如何使用通知机制：</p>
<p>在React Native里面有专门的组件专门负责通知这一功能，它的名字是：<code>DeviceEventEmitter</code>，它是React Native内置的组件，我们可以直接将它导入到工程里。导入的方式和其他内置的组件一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    StyleSheet,</div><div class="line">    Text,</div><div class="line">    View,</div><div class="line">    Image,</div><div class="line">    DeviceEventEmitter,</div><div class="line">    TouchableOpacity</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div></pre></td></tr></table></figure>
<p>既然是通知，那么自然有接收的一方，也有发送的一方，这两个组件都需要引入该通知组件。</p>
<p>在接收的一方需要注册某个通知：</p>
<p>比如在该Demo里面，如果在收藏页面修改了收藏的状态，就要给最热标签页面发送一个通知。所以首先就需要在最热标签页面注册一个通知，注册通知后才能确保将来可以收到某个频道上的通知</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">componentDidMount() &#123;</div><div class="line">    ...</div><div class="line">    this.listener = DeviceEventEmitter.addListener(<span class="string">'favoriteChanged_popular'</span>,()=&gt; &#123;</div><div class="line">            <span class="keyword">this</span>.isFavoriteChanged = <span class="literal">true</span>;</div><div class="line">     &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里通过给<code>DeviceEventEmitter</code>的<code>addListener</code>方法传入两个参数来进行通知的注册：</p>
<ul>
<li>第一个参数是通知的频道，用来区别其他的通知。</li>
<li>第二个参数是需要调用的函数：在这里只是将<code>this.isFavoriteChanged</code>赋值为YES。它的目的是在于将来如果该值等于YES，就进行界面的再渲染，更新收藏状态。</li>
</ul>
<p>需要注意的是，有注册，就要有注销，在组件被卸载之前，需要将监听解除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">componentWillUnmount() &#123;</div><div class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>.listener)&#123;</div><div class="line">         <span class="keyword">this</span>.listener.remove();</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，我们搞定了通知的注册，就可以在程序的任意地方发送通知了。在该需求中，我们需要拦截住在收藏页面里对项目的收藏按钮的点击，只要点击了，就发送通知：告知最热标签页面收藏的状态改变了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">onFavorite(item,isFavorite)&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    DeviceEventEmitter.emit(&apos;favoriteChanged_popular&apos;);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，拦截了收藏按钮的点击。还记得么？这里<code>onFavorite()</code>函数就是上面说的点击收藏按钮的回调。</p>
<p>我们在这里发送了通知，只需传入频道名称即可。</p>
<p>是不是很easy？</p>
<p>OK，到这里我们讲完了组件间的通信这一块，简单回想一下各种关系的组件之间的通信方案。</p>
<p>下面我们来讲一下在React Native里的本地持久化的方案。</p>
<h2 id="2-6-本地持久化"><a href="#2-6-本地持久化" class="headerlink" title="2.6 本地持久化"></a>2.6 本地持久化</h2><p>类似于iOS 中的<code>NSUserDefault</code>， AsyncStorage 是React Native中的 Key-Value 存储系统，可以做本地持久化。</p>
<p>首先看它主要的几个接口：</p>
<h3 id="2-61-AsyncStorage常用接口"><a href="#2-61-AsyncStorage常用接口" class="headerlink" title="2.61 AsyncStorage常用接口"></a>2.61 AsyncStorage常用接口</h3><h4 id="根据键来获取值，获取的结果会放在回调函数中："><a href="#根据键来获取值，获取的结果会放在回调函数中：" class="headerlink" title="根据键来获取值，获取的结果会放在回调函数中："></a>根据键来获取值，获取的结果会放在回调函数中：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> getItem(key: string, <span class="attr">callback</span>:(error, result))</div></pre></td></tr></table></figure>
<h4 id="根据键来设置值："><a href="#根据键来设置值：" class="headerlink" title="根据键来设置值："></a>根据键来设置值：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> setItem(key: string, <span class="attr">value</span>: string, <span class="attr">callback</span>:(error))</div></pre></td></tr></table></figure>
<h4 id="根据键来移除项："><a href="#根据键来移除项：" class="headerlink" title="根据键来移除项："></a>根据键来移除项：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> removeItem(key: string, <span class="attr">callback</span>:(error))</div></pre></td></tr></table></figure>
<h4 id="获取所有的键："><a href="#获取所有的键：" class="headerlink" title="获取所有的键："></a>获取所有的键：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> getAllKeys(callback:(error, keys))</div></pre></td></tr></table></figure>
<h4 id="设置多项，其中-keyValuePairs-是字符串的二维数组，比如：-‘k1’-‘val1’-‘k2’-‘val2’-："><a href="#设置多项，其中-keyValuePairs-是字符串的二维数组，比如：-‘k1’-‘val1’-‘k2’-‘val2’-：" class="headerlink" title="设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]："></a>设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> multiSet(keyValuePairs, <span class="attr">callback</span>:(errors))</div></pre></td></tr></table></figure>
<h4 id="获取多项，其中-keys-是字符串数组，比如：-‘k1’-‘k2’-："><a href="#获取多项，其中-keys-是字符串数组，比如：-‘k1’-‘k2’-：" class="headerlink" title="获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]："></a>获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> multiGet(keys, <span class="attr">callback</span>:(errors, result))</div></pre></td></tr></table></figure>
<h4 id="删除多项，其中-keys-是字符串数组，比如：-‘k1’-‘k2’-："><a href="#删除多项，其中-keys-是字符串数组，比如：-‘k1’-‘k2’-：" class="headerlink" title="删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]："></a>删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> multiRemove(keys, <span class="attr">callback</span>:(errors))</div></pre></td></tr></table></figure>
<h4 id="清除所有的项目："><a href="#清除所有的项目：" class="headerlink" title="清除所有的项目："></a>清除所有的项目：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> clear(callback:(error))</div></pre></td></tr></table></figure>
<h3 id="2-62-AsyncStorage使用注意事项"><a href="#2-62-AsyncStorage使用注意事项" class="headerlink" title="2.62 AsyncStorage使用注意事项"></a>2.62 AsyncStorage使用注意事项</h3><p>需要注意的是，在使用AsyncStorage的时候，setItem里面传入的数组或字典等对象需要使用<code>JSON.stringtify()</code>方法把他们解析成JSON字符串：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AsyncStorage.setItem(<span class="keyword">this</span>.favoriteKey,<span class="built_in">JSON</span>.stringify(favoriteKeys));</div></pre></td></tr></table></figure>
<blockquote>
<p>这里,favoriteKeys是一个数组。</p>
</blockquote>
<p>反过来，在getItem方法里获取数组或字典等对象的时候需要使用<code>JSON.parse</code>方法将他们解析成对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">AsyncStorage.getItem(<span class="keyword">this</span>.favoriteKey,(error,result)=&gt;&#123;</div><div class="line">     <span class="keyword">if</span> (!error) &#123;</div><div class="line">          <span class="keyword">var</span> favoriteKeys=[];</div><div class="line">          <span class="keyword">if</span> (result) &#123;</div><div class="line">                favoriteKeys=<span class="built_in">JSON</span>.parse(result);</div><div class="line">          &#125;</div><div class="line">     ...</div><div class="line">      &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>这里，result被解析出来后是一个数组。</p>
</blockquote>
<h3 id="2-7-网络请求"><a href="#2-7-网络请求" class="headerlink" title="2.7 网络请求"></a>2.7 网络请求</h3><p>在React Native中，经常使用Fetch函数来实现网络请求，它支持GET和POST请求并返回一个Promise对象，这个对象包含一个正确的结果和一个错误的结果。</p>
<p>来看一下用Fetch发起的POST请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">fetch(<span class="string">'http://www.***.cn/v1/friendList'</span>, &#123;</div><div class="line">          <span class="attr">method</span>: <span class="string">'POST'</span>,</div><div class="line">          <span class="attr">headers</span>: &#123; <span class="comment">//header</span></div><div class="line">                <span class="string">'token'</span>: <span class="string">''</span></div><div class="line">            &#125;,</div><div class="line">          <span class="attr">body</span>: <span class="built_in">JSON</span>.stringify(&#123; <span class="comment">//参数</span></div><div class="line">                <span class="string">'start'</span>: <span class="string">'0'</span>,</div><div class="line">                <span class="string">'limit'</span>: <span class="string">'20'</span>,</div><div class="line">            &#125;)</div><div class="line"> &#125;)</div><div class="line">            .then(<span class="function">(<span class="params">response</span>) =&gt;</span> response.json()) <span class="comment">//把response转为json</span></div><div class="line">            .then(<span class="function">(<span class="params">responseData</span>) =&gt;</span> &#123; <span class="comment">// 上面的转好的json</span></div><div class="line">                 <span class="comment">//using responseData</span></div><div class="line">            &#125;)</div><div class="line">            .catch(<span class="function">(<span class="params">error</span>)=&gt;</span> &#123;</div><div class="line">                alert(<span class="string">'返回错误'</span>);</div><div class="line">            &#125;)</div></pre></td></tr></table></figure>
<p>从上面的代码中，我们可以大致看到：Fetch函数中，第一个参数是请求url，第二个参数是一个字典，包括方法，请求头，请求体等信息。</p>
<p>随后的<code>then</code>和<code>catch</code>分别捕捉了fetch函数的返回值：一个Promise对象的<code>正确结果</code>和<code>错误结果</code>。注意，这里面有两个<code>then</code>，其中第二个<code>then</code>把第一个<code>then</code>的结果拿了过来。而第一个<code>then</code>做的事情是把网络请求的结果转化为JSON对象。</p>
<p>那么什么是Promise对象呢？</p>
<p>Promise 是异步编程的一种解决方案，Promise对象可以获取某个异步操作的消息。它里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>
<p>它分为三种状态：</p>
<p><code>Pending</code>（进行中）、<code>Resolved</code>（已成功）和<code>Rejected</code>（已失败）</p>
<p>它的构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>：</p>
<p><code>resolve</code>函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；。<br><code>reject</code>函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>举个例子来看一下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  <span class="comment">// ... some code</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这里resolve和reject的结果会分别被配套使用的Fetch函数的.then和.catch捕捉。</p>
<p>我个人的理解是：如果某个异步操作的返回值是一个Promise对象，那么我们就可以分别使用<code>.then</code>和<code>.catch</code>来捕捉正确和错误的结果。</p>
<p>再看一下GET请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">fetch(url)</div><div class="line">    .then(<span class="function"><span class="params">response</span>=&gt;</span>response.json())</div><div class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</div><div class="line">         resolve(result);</div><div class="line">     &#125;)</div><div class="line"></div><div class="line">     .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</div><div class="line">         reject(error)</div><div class="line">     &#125;)</div></pre></td></tr></table></figure>
<p>因为只是GET请求，所以不需要配置请求体，而且因为这个fetch函数返回值是一个Promise对象， 所以我们可以用<code>.then</code>和<code>.catch</code>来捕捉正确和错误的结果。</p>
<p>在项目中，我们可以创建一个抓们负责网络请求的工具HttpUtils类，封装GET和POST请求。看一下一个简单的封装：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpUtls</span></span>&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> get(url)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">            fetch(url)</div><div class="line">                .then(<span class="function"><span class="params">response</span>=&gt;</span>response.json())</div><div class="line">                .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</div><div class="line">                    resolve(result);</div><div class="line">                &#125;)</div><div class="line"></div><div class="line">                .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</div><div class="line">                    reject(error)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> post(url, data) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</div><div class="line">            fetch(url,&#123;</div><div class="line">                <span class="attr">method</span>:<span class="string">'POST'</span>,</div><div class="line">                <span class="attr">header</span>:&#123;</div><div class="line">                    <span class="string">'Accept'</span>:<span class="string">'application/json'</span>,</div><div class="line">                    <span class="string">'Content-Type'</span>:<span class="string">'application/json'</span>,</div><div class="line">                &#125;,</div><div class="line">                <span class="attr">body</span>:<span class="built_in">JSON</span>.stringify(data)</div><div class="line">            &#125;)</div><div class="line"></div><div class="line">                .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</div><div class="line">                    resolve(result);</div><div class="line">                &#125;)</div><div class="line"></div><div class="line">                .catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</div><div class="line">                    reject(error)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-8-离线缓存"><a href="#2-8-离线缓存" class="headerlink" title="2.8 离线缓存"></a>2.8 离线缓存</h3><p>离线缓存技术可以利用上文提到的<code>Fetch</code>和<code>AsyncStorage</code>实现，将请求url作为key，将返回的结果作为值存入本地数据里。</p>
<p>在下一次请求之前查询是否有缓存，缓存是否过期，如果有缓存并且没有过期，则拿到缓存之后，立即返回进行处理。否则继续进行网络请求。</p>
<p>而且即使没有网络，最终返回错误，也可以拿到缓存数据，立即返回。</p>
<p>来看一下在该项目里面是如何实现离线缓存的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取数据</span></div><div class="line">    fetchRespository(url) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">//首先获取本地缓存</span></div><div class="line">            <span class="keyword">this</span>.fetchLocalRespository(url)</div><div class="line">                .then(<span class="function">(<span class="params">wrapData</span>)=&gt;</span> &#123;</div><div class="line">                    <span class="comment">//本地缓存获取成功</span></div><div class="line">                <span class="keyword">if</span> (wrapData) &#123;</div><div class="line">                    <span class="comment">//缓存对象存在</span></div><div class="line">                    resolve(wrapData,<span class="literal">true</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//缓存对象不存在，进行网络请求</span></div><div class="line">                    <span class="keyword">this</span>.fetchNetRepository(url)</div><div class="line"></div><div class="line">                        <span class="comment">//网路请求成功</span></div><div class="line">                        .then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</div><div class="line">                            resolve(data);</div><div class="line">                        &#125;)</div><div class="line">                        <span class="comment">//网路请求失败</span></div><div class="line">                        .catch(<span class="function"><span class="params">e</span>=&gt;</span> &#123;</div><div class="line">                            reject(e);</div><div class="line">                        &#125;)</div><div class="line">                &#125;</div><div class="line">            &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span> &#123;</div><div class="line">                    <span class="comment">//本地缓存获取失败，进行网络请求</span></div><div class="line">                    <span class="keyword">this</span>.fetchNetRepository(url)</div><div class="line"></div><div class="line">                        <span class="comment">//网路请求成功</span></div><div class="line">                        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</div><div class="line">                            resolve(result);</div><div class="line">                        &#125;)</div><div class="line">                        <span class="comment">//网路请求失败</span></div><div class="line">                        .catch(<span class="function"><span class="params">e</span>=&gt;</span> &#123;</div><div class="line">                            reject(e);</div><div class="line">                        &#125;)</div><div class="line">                &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>在上面的方法中，包含了获取本地缓存和网络请求的两个方法。</p>
<p>首先是尝试获取本地缓存：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    <span class="comment">//获取本地缓存</span></div><div class="line">    fetchLocalRespository(url)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">            <span class="comment">// 获取本地存储</span></div><div class="line">            AsyncStorage.getItem(url, (error, result)=&gt;&#123;</div><div class="line">                <span class="keyword">if</span> (!error)&#123;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        <span class="comment">//必须使用parse解析成对象</span></div><div class="line">                        resolve(<span class="built_in">JSON</span>.parse(result));</div><div class="line">                    &#125;<span class="keyword">catch</span> (e)&#123;</div><div class="line">                        <span class="comment">//解析失败</span></div><div class="line">                        reject(e);</div><div class="line">                    &#125;</div><div class="line">                &#125;<span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">//获取缓存失败</span></div><div class="line">                    reject(error);</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">        &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>AsyncStorage.getItem</code>方法的结果也可以使用Promise对象来包装。因此，<code>this.fetchLocalRespository(url)</code>的结果也就可以被<code>.then</code>和<code>.catch</code>捕捉到了。</p>
</blockquote>
<p>如果获取本地缓存失败，就会调用网络请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">    fetchNetRepository(url)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</div><div class="line">            fetch(url)</div><div class="line">                .then(<span class="function"><span class="params">response</span>=&gt;</span>response.json())</div><div class="line">                .catch(<span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</div><div class="line">                    reject(error);</div><div class="line">                &#125;).then(<span class="function">(<span class="params">responseData</span>)=&gt;</span>&#123;</div><div class="line">                    resolve(responseData);</div><div class="line">                 &#125;)</div><div class="line">             &#125;)</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2-9-主题更换"><a href="#2-9-主题更换" class="headerlink" title="2.9 主题更换"></a>2.9 主题更换</h3><p>这个Demo有一个主题更换的需求，在主题设置页点击某个颜色之后，全app的颜色方案就会改变：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_14.png" alt=""></p>
<p>我们只需要将四个模块的第一个页面的主题修改即可，因为第二个页面的主题都是从第一个页面传进去的，所以只要第一个页面的主题改变了即可。</p>
<p>但是，我们应该不能在选择新主题之后同时向这四个页面都发送通知，命令它们修改自己的页面，而是应该采取一个更加优雅的方法来解决这个问题：使用父类。</p>
<p>新建一个<code>BaseCommon.js</code>页面，作为这四个页面的父类。在这个父类里面接收主题更改的通知，并更新自己的主题。这样一来，继承它的这四个页面就都会刷新自己：</p>
<p>来看一下这个父类的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    DeviceEventEmitter</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123;ACTION_HOME&#125; <span class="keyword">from</span> <span class="string">'../pages/Entry/HomePage'</span></div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.state=&#123;</div><div class="line">            <span class="attr">theme</span>:<span class="keyword">this</span>.props.theme,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    componentDidMount() &#123;</div><div class="line">        <span class="keyword">this</span>.baseListener = DeviceEventEmitter.addListener(<span class="string">'ACTION_BASE'</span>,(action,parmas)=&gt;<span class="keyword">this</span>.changeThemeAction(action,parmas));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//卸载前移除通知</span></div><div class="line">    componentWillUnmount() &#123;</div><div class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.baseListener)&#123;</div><div class="line">            <span class="keyword">this</span>.baseListener.remove();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//接收通知</span></div><div class="line">    changeThemeAction(action,params)&#123;</div><div class="line">        <span class="keyword">if</span> (ACTION_HOME.A_THEME === action)&#123;</div><div class="line">            <span class="keyword">this</span>.onThemeChange(params);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//更新theme</span></div><div class="line">    onThemeChange(theme)&#123;</div><div class="line">        <span class="keyword">if</span>(!theme)<span class="keyword">return</span>;</div><div class="line">        <span class="keyword">this</span>.setState(&#123;</div><div class="line">            <span class="attr">theme</span>:theme</div><div class="line">        &#125;)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在更新主题页面的更新主题事件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">onSelectTheme(themeKey) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">this</span>.themeDao.save(ThemeFlags[themeKey]);</div><div class="line">        <span class="keyword">this</span>.props.onClose();</div><div class="line">        DeviceEventEmitter.emit(<span class="string">'ACTION_BASE'</span>,ACTION_HOME.A_THEME,ThemeFactory.createTheme(</div><div class="line">            ThemeFlags[themeKey]</div><div class="line">        ))</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="2-10-功能调试"><a href="#2-10-功能调试" class="headerlink" title="2.10 功能调试"></a>2.10 功能调试</h3><p>我们可以使用浏览器的开发者工具来调试React Native项目，可以通过打断点的方式来看数据信息以及方法的调用：</p>
<ol>
<li>首先在iOS模拟器中点击<code>command + D</code>，然后再弹出菜单里点击<code>Debug JS Remotely</code>。随后就打开了浏览器进入了调试。</li>
</ol>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_8_1_1.png" alt=""></p>
<ol>
<li>浏览器一般会展示下面的页面，然后点击<code>command + option + J</code>进入真生的调试界面。</li>
</ol>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_9.png" alt=""></p>
<ol>
<li>点击最上方的<code>Sources</code>，然后点击左侧<code>debuggerWorker.js</code>下的<code>localhost:8081</code>，就可以看到目录文件。点击需要调试的文件，在行数栏就可以打断点了。</li>
</ol>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_10_1.png" alt=""></p>
<h3 id="2-11-适配iOS和Android平台"><a href="#2-11-适配iOS和Android平台" class="headerlink" title="2.11 适配iOS和Android平台"></a>2.11 适配iOS和Android平台</h3><p>因为React Native讲求的是一份代码跑在两个平台上，而客观上这两个平台又有一些不一样的地方，所以就需要在别要的时候做一下两个平台的适配。</p>
<p>例如导航栏：在iOS设备中是存在导航栏的，而安卓设备上是没有的。所以在定制导航栏的时候，在不同平台下给导航栏设置不同的高度：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">    StyleSheet,</div><div class="line">    Platform,</div><div class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> NAV_BAR_HEIGHT_IOS = <span class="number">44</span>;</div><div class="line"><span class="keyword">const</span> NAV_BAR_HEIGHT_ANDROID = <span class="number">50</span>;</div><div class="line"></div><div class="line">navBarStyle: &#123;</div><div class="line">        <span class="attr">flexDirection</span>: <span class="string">'row'</span>,</div><div class="line">        <span class="attr">alignItems</span>: <span class="string">'center'</span>,</div><div class="line">        <span class="attr">justifyContent</span>: <span class="string">'space-between'</span>,</div><div class="line">        <span class="attr">height</span>: Platform.OS === <span class="string">'ios'</span> ? NAV_BAR_HEIGHT_IOS : NAV_BAR_HEIGHT_ANDROID,</div><div class="line"> &#125;,</div></pre></td></tr></table></figure>
<p>上面的<code>Platform</code>是React Native内置的用于区分平台的库，可以在引入后直接使用。</p>
<p>建议在调试程序的时候，同时打开iOS和Android的模拟器进行调试，因为有些地方可能在某个平台上是没问题的，但是另一个平台上有问题，这就需要使用<code>Platform</code>来区分平台。</p>
<h3 id="2-12-组织项目结构"><a href="#2-12-组织项目结构" class="headerlink" title="2.12 组织项目结构"></a>2.12 组织项目结构</h3><p>在终端输入<code>react-native demo --version 0.44.0</code>命令以后，就会初始化一个React Native版本为0.44.0的项目。这个最初项目里面直接就包含了iOS和Android的工程文件夹，可以用对应的IDE打开后编译运行。</p>
<p>在新建一个React Native项目之后的根目录结构是这样的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_11.png" alt=""></p>
<p>或者也可以根目录下输入<code>react-native run-ios</code>或者<code>react-native run-android</code>指令， 就会自动打开模拟器运行项目(前提是安装了相应的开发环境)。</p>
<p>但是一个比较完整的项目仅仅有这些类别的文件是不够的，还需要一些工具类，模型类，资源等文件。为了很好地区分它们，使项目结构一目了然，需要组织好项目文件夹以及类的命名，下面是我将教程里的文件夹命名和结构稍加修改后的一个方案，可供大家参考：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/rn_12.png" alt=""></p>
<p>  ​</p>
<h1 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h1><p>从最开始的FlexBox布局的学习到现在这个项目的总结完成有了快两个月的时间了。我在这里说一下这段学习过程中的一些感受：</p>
<h3 id="关于学习成本"><a href="#关于学习成本" class="headerlink" title="关于学习成本"></a>关于学习成本</h3><p>我觉得这一点应该是所有未接触到React Native的人最关心的一点了，所以我将它放到了总结里的第一位。我在这里取两种典型的群体来做比较：</p>
<ol>
<li>只会某种Native开发但是不会JavaScript等前端知识的人群。</li>
<li>只会前端知识但是不会任何一种Native开发的人群。</li>
</ol>
<p>对于这两种人群来说，在React Native的学习过程中成本都不小。但不同的是，这两种人群的学习成本在整个学习过程中的不同阶段是不一样的。怎么说呢？</p>
<p>对于第一种人群，因为缺乏前端相关知识，所以在组建的布局，以及JavaScript的语法上会有点吃力。而这两点恰恰是React Native学习的敲门砖，因此，对于这种群体，在学习React Native的初期会比较吃力，学习成本很大。</p>
<h3 id="关于如何配合视频来学习"><a href="#关于如何配合视频来学习" class="headerlink" title="关于如何配合视频来学习"></a>关于如何配合视频来学习</h3><p>在结合视频学习的时候一定要跟上思路，如果讲师是边写代码边讲解，就一定要弄清楚每一行代码的意义在哪里，为什么要这么写，千万不要怕浪费时间而快速略过。停下脚步来思考实际上是节省时间：因为如果你不试着去理解代码和讲师的思路，在后来你会越来越看不懂，反而浪费大量时间重新回头看。</p>
<p>所以我认为最好是先听一遍讲师讲的内容，理清思路，然后再动手写代码，这样效率会比较高，在将来出现的问题也会更少。</p>
<h1 id="四-学习参考资料"><a href="#四-学习参考资料" class="headerlink" title="四. 学习参考资料"></a>四. 学习参考资料</h1><p>下面是我近1个半月以来收集的比较好的React Native入门资料和博客，分享给大家：</p>
<ul>
<li><a href="http://reactnative.cn/" target="_blank" rel="external">React Native中文网</a></li>
<li><a href="http://www.devio.org/" target="_blank" rel="external">贾鹏辉的技术博客</a></li>
<li><a href="http://www.jianshu.com/p/fa0874be0827" target="_blank" rel="external">Marno:给所有开发者的React Native详细入门指南</a></li>
<li><a href="http://www.w3cplus.com/css3/a-guide-to-flexbox.html" target="_blank" rel="external">大漠:一个完整的Flexbox指南</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">阮一峰:Flex 布局教程：语法篇</a></li>
<li><a href="https://juejin.im/post/597724c26fb9a06bb75260e8" target="_blank" rel="external">八段代码彻底掌握 Promise</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="external">阮一峰：Promise对象</a></li>
<li><a href="http://www.jianshu.com/p/454f2e6f28e9#rd" target="_blank" rel="external">asce1885:React Native 高质量学习资料汇总</a></li>
<li><a href="https://juejin.im/post/591ec246da2f60005d30654c" target="_blank" rel="external">世锋日上:ReactNative 学习资源大汇集</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行了2个星期的基础学习（Flexbox, React.js, JSX, JavaScript）之后，想通过一个实战项目来提高React Native的开发水平，于是找到了下面这个项目：&lt;/p&gt;
&lt;h1 id=&quot;一-项目介绍&quot;&gt;&lt;a href=&quot;#一-项目介绍&quot; class=&quot;headerlink&quot; title=&quot;一. 项目介绍&quot;&gt;&lt;/a&gt;一. 项目介绍&lt;/h1&gt;&lt;p&gt;这是我在学习&lt;a href=&quot;http://www.devio.org/&quot;&gt;贾鹏辉&lt;/a&gt;老师在慕课网上的一个很火的&lt;a href=&quot;http://coding.imooc.com/class/89.html&quot;&gt;React Native实战的教程&lt;/a&gt;后，写出的课程Demo。该课程是慕课网里很火的一个React Native课程，当初在看了课程介绍和课程安排觉得讲解的点还是很全的，所以毫不犹豫地买了下来。&lt;/p&gt;
&lt;p&gt;从看视频，敲代码到重构，改bug，大概花了2个多星期的时间，除了调用友盟的SDK以及CodePush集成之外，其他的部分都基本完成了，而且同时可以在iOS和Android设备上运行：&lt;br&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/rn_13.png&quot; alt=&quot;上排是iOS模拟器 | 下排是Android模拟器&quot;&gt;&lt;/p&gt;
&lt;p&gt;而且比较吸引人的是该项目可以实现多个主题的切换：&lt;br&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/rn_15.png&quot; alt=&quot;多主题切换&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;切换的技术实现会在下文给出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用一个动图来过一遍大致的需求：&lt;br&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/github%E5%AE%A2%E6%88%B7%E7%AB%AF_4.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Demo GitHub地址：&lt;a href=&quot;https://github.com/knightsj/GitHubPopular-SJ&quot;&gt;GitHubPopular-SJ&lt;/a&gt;&lt;br&gt;可以按照README文件里的方法运行该项目。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;已经贾老师允许上传到GitHub&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;值得一提的是：这确实是一门物有所值的课程，可以让想入门React Native的开发者少走很多弯路。虽然我上传的Demo可以实现视频里大部分功能，但是经过调试，修改后的代码信息量还是很有限的，而且老师在视频中讲解的很多关于实际开发的知识点在代码中并没有体现出来，所以还是建议各位报名参加课程来提高自己的开发水平。&lt;/p&gt;
    
    </summary>
    
      <category term="React Native" scheme="https://github.com/knightsj/knightsj.github.io/categories/React-Native/"/>
    
    
      <category term="React Native" scheme="https://github.com/knightsj/knightsj.github.io/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>YTKNetwork源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/07/18/YTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/07/18/YTKNetwork源码解析/</id>
    <published>2017-07-18T05:35:08.000Z</published>
    <updated>2017-07-18T05:35:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS开发来说，就算是没有用过<a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork框架</a>，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。</p>
<p>在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。</p>
<h1 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h1><hr>
<p>先上图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKRequest架构图"></p>
<blockquote>
<p>在这里简单说明一下：</p>
<ol>
<li>YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 </li>
<li>YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。</li>
<li>我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。</li>
<li>YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。</li>
</ol>
</blockquote>
<p>OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。</p>
<a id="more"></a>
<h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h1><hr>
<p>YTKNetwork框架采用的设计模式是<strong>命令模式（Command Pattern）</strong>。</p>
<p>首先看一下命令模式的定义：</p>
<blockquote>
<p>命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。<br>摘自：<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">《Head First 设计模式》</a></p>
</blockquote>
<p>看一下命令模式的类图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c5c7e9ff32b2e647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令模式类图.png"></p>
<p>图中英文的含义：</p>
<table>
<thead>
<tr>
<th>英文</th>
<th>中文</th>
</tr>
</thead>
<tbody>
<tr>
<td>Command</td>
<td>抽象命令类    </td>
</tr>
<tr>
<td>ConcreteCommand</td>
<td>命令类的实现类（子类）</td>
</tr>
<tr>
<td>Invoker</td>
<td>调用者    </td>
</tr>
<tr>
<td>Receiver</td>
<td>命令接收者（执行者)</td>
</tr>
<tr>
<td>Client</td>
<td>客户端</td>
</tr>
</tbody>
</table>
<p>详细介绍一下：</p>
<ol>
<li>命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
</ol>
<p>可能还是觉得有点抽象，在这里举一个<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">《Head First 设计模式》</a>里的例子，一个客人在餐厅点餐的过程：</p>
<ol>
<li>你将点的菜写在订单里，交给了服务员。</li>
<li>服务员将订单交给厨师。</li>
<li>厨师做好菜之后将做好的菜交给服务员。</li>
<li>最后服务员把菜递给你。</li>
</ol>
<p>在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。<br>所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。</p>
<p>结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下YTKNetwork内部的职能</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Command</th>
<th>ConcreteCommand</th>
<th>Invoker</th>
<th>Receiver</th>
<th>Client</th>
</tr>
</thead>
<tbody>
<tr>
<td>餐厅</td>
<td>空白订单</td>
<td>填入菜名的订单</td>
<td>服务员</td>
<td>厨师</td>
<td>客人</td>
</tr>
<tr>
<td>YTKNetwork</td>
<td>YTKBaseRequest</td>
<td>CustomRequest</td>
<td>YTKNetworkAgent</td>
<td>AFNetworking</td>
<td>ViewController/ViewModel</td>
</tr>
</tbody>
</table>
<p>可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。</p>
<p>另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。</p>
<p>相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。</p>
<h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><hr>
<p>在真正讲解源码之前，我先详细说一下各个类的职责:</p>
<h2 id="3-1-责任介绍"><a href="#3-1-责任介绍" class="headerlink" title="3.1 责任介绍"></a>3.1 责任介绍</h2><table>
<thead>
<tr>
<th>类名</th>
<th>职责</th>
</tr>
</thead>
<tbody>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKBaseRequest</td>
<td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td>
</tr>
<tr>
<td>YTKRequest</td>
<td>YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。</td>
</tr>
<tr>
<td>YTKNetworkConfig</td>
<td>被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。</td>
</tr>
<tr>
<td>YTKNetworkPrivate</td>
<td>提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。</td>
</tr>
<tr>
<td>YTKNetworkAgent</td>
<td>真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。</td>
</tr>
<tr>
<td>YTKBatchRequest</td>
<td>可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。</td>
</tr>
<tr>
<td>YTKBatchRequestAgent</td>
<td>负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。</td>
</tr>
<tr>
<td>YTKChainRequest</td>
<td>可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。</td>
</tr>
<tr>
<td>YTKChainRequestAgent</td>
<td>负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。</td>
</tr>
</tbody>
</table>
<p>OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。</p>
<h2 id="3-2-单个请求"><a href="#3-2-单个请求" class="headerlink" title="3.2 单个请求"></a>3.2 单个请求</h2><h3 id="3-21-单个请求的配置"><a href="#3-21-单个请求的配置" class="headerlink" title="3.21 单个请求的配置"></a>3.21 单个请求的配置</h3><p><a href="https://github.com/yuantiku/YTKNetwork/blob/master/Docs/BasicGuide_cn.md">官方的教程</a>建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application </div><div class="line">   didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</div><div class="line">&#123;</div><div class="line">   YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig];</div><div class="line">   config.baseUrl = <span class="string">@"http://yuantiku.com"</span>;</div><div class="line">   config.cdnUrl = <span class="string">@"http://fen.bi"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// RegisterApi.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"YTKRequest.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RegisterApi</span> : <span class="title">YTKRequest</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// RegisterApi.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"RegisterApi.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RegisterApi</span> </span>&#123;</div><div class="line">    <span class="built_in">NSString</span> *_username;</div><div class="line">    <span class="built_in">NSString</span> *_password;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//初始化的时候将两个参数值传入</span></div><div class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _username = username;</div><div class="line">        _password = password;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//需要和baseUrl拼接的地址</span></div><div class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</div><div class="line">    <span class="comment">// “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息</span></div><div class="line">    <span class="keyword">return</span> <span class="string">@"/iphone/register"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//请求方法，某人是GET</span></div><div class="line">- (YTKRequestMethod)requestMethod &#123;</div><div class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//请求体</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"username"</span>: _username,</div><div class="line">        <span class="string">@"password"</span>: _password</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。</p>
<h3 id="3-22-单个请求的发起"><a href="#3-22-单个请求的发起" class="headerlink" title="3.22 单个请求的发起"></a>3.22 单个请求的发起</h3><p>还是刚才的注册API，在实例化以后，直接调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法）就可以发起它：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LoginViewController.m</span></div><div class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</div><div class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</div><div class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</div><div class="line">        [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123;</div><div class="line">            <span class="comment">// 你可以直接在这里使用 self</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</div><div class="line">        &#125; failure:^(YTKBaseRequest *request) &#123;</div><div class="line">            <span class="comment">// 你可以直接在这里使用 self</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是以block的形式回调，YTKNetwork也支持代理的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//LoginViewController.m</span></div><div class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</div><div class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</div><div class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</div><div class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</div><div class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</div><div class="line">        api.delegate = <span class="keyword">self</span>;</div><div class="line">        [api start];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>有两点需要注意的是：</p>
<ol>
<li>必须给自定义请求类（RegisterApi）调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法），才能真正发起请求。</li>
<li>在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。</li>
</ol>
<p>知道了YTKRequest请求是如何在外部发起的，我们现在从<code>startWithCompletionBlockWithSuccess:failure</code>方法开始，来看一下YTKNetwork都做了什么：</p>
<p>首先来到YTKBaseRequest类（因为最早是由它定义的该方法）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line"><span class="comment">//传入成功和失败的block,并保存起来</span></div><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</div><div class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</div><div class="line">    <span class="comment">//保存成功和失败的回调block，便于将来调用</span></div><div class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</div><div class="line">    <span class="comment">//发起请求</span></div><div class="line">    [<span class="keyword">self</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//保存成功和失败的block</span></div><div class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</div><div class="line">                              failure:(YTKRequestCompletionBlock)failure &#123;</div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当保存完成功和失败的block以后，调用<code>start</code>方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了<code>start</code>方法，但是由于YTKRequest类是它的子类并也实现了<code>start</code>方法，所以这里最先走的是YTKRequest类的<code>start</code>方法）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理）</span></div><div class="line">    _dataFromCache = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//5. 回调之前的操作</span></div><div class="line">        <span class="comment">//5.1 缓存处理</span></div><div class="line">        [<span class="keyword">self</span> requestCompletePreprocessor];</div><div class="line">        </div><div class="line">        <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></div><div class="line">        [<span class="keyword">self</span> requestCompleteFilter];</div><div class="line">        </div><div class="line">        YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//6. 执行回调</span></div><div class="line">        <span class="comment">//6.1 请求完成的代理</span></div><div class="line">        [strongSelf.delegate requestFinished:strongSelf];</div><div class="line">        </div><div class="line">        <span class="comment">//6.2 请求成功的block</span></div><div class="line">        <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">            strongSelf.successCompletionBlock(strongSelf);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">        [strongSelf clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个<code>start</code>方法里，它做的是请求之前缓存的查询和检查工作:</p>
<ul>
<li>如果忽略缓存，或者缓存获取失败，调用<code>startWithoutCache</code>方法（参考1-3的情况），发起请求。</li>
<li>如果能成功获取到缓存，则直接回调（参考4-7的情况）。</li>
</ul>
<p>我们来看一下每一步的具体实现：</p>
<ol>
<li><code>ignoreCache</code>属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。</li>
<li><code>resumableDownloadPath</code>是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。</li>
<li><code>loadCacheWithError：</code>方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒）</span></div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache time"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 是否有缓存的元数据，如果没有，返回错误</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheMetadata]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid metadata. Cache may not exist"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有缓存，再验证是否有效</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateCacheWithError:error]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 有缓存，而且有效，再验证是否能取出来</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheData]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache data"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。</p>
<p>我们来看一下上面关于缓存的元数据的获取方法：<code>loadCacheMetadata</code>方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheMetadata &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheMetadataFilePath];</div><div class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</div><div class="line">        <span class="keyword">@try</span> &#123;</div><div class="line">            <span class="comment">//将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata</span></div><div class="line">            _cacheMetadata = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</div><div class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">            YTKLog(<span class="string">@"Load cache metadata failed, reason = %@"</span>, exception.reason);</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。<br>YTKCacheMetadata类被定义在YTKRequest.m文件里面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">long</span> <span class="keyword">long</span> version;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。<br>因此，<code>loadCacheMetadata</code>方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的<code>cacheMetadata</code>属性上。</p>
<p>现在获取了缓存的元数据并赋给了自身的cacheMetadata属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的validateCacheWithError：里面验证：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">// 是否大于过期时间</span></div><div class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</div><div class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</div><div class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache expired"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 缓存的版本号是否符合</span></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</div><div class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache version mismatch"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 敏感信息是否符合</span></div><div class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</div><div class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</div><div class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></div><div class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache sensitive data mismatch"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// app的版本是否符合</span></div><div class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</div><div class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</div><div class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"App version mismatch"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果每项元数据信息都能通过，再在<code>loadCacheData</code>方法里面验证缓存是否能被取出来：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)loadCacheData &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheFilePath];</div><div class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</div><div class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</div><div class="line">        _cacheData = data;</div><div class="line">        _cacheString = [[<span class="built_in">NSString</span> alloc] initWithData:_cacheData encoding:<span class="keyword">self</span>.cacheMetadata.stringEncoding];</div><div class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.responseSerializerType) &#123;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</div><div class="line">                <span class="comment">// Do nothing.</span></div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</div><div class="line">                _cacheJSON = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:_cacheData options:(<span class="built_in">NSJSONReadingOptions</span>)<span class="number">0</span> error:&amp;error];</div><div class="line">                <span class="keyword">return</span> error == <span class="literal">nil</span>;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</div><div class="line">                _cacheXML = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:_cacheData];</div><div class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。</p>
<p>当确认缓存可以成功取出后，手动设置<code>dataFromCache</code>属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。</p>
<p>然后在真正回调之前做了如下处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line"></div><div class="line">    ....</div><div class="line"></div><div class="line">    <span class="comment">//5. 回调之前的操作</span></div><div class="line">    <span class="comment">//5.1 缓存处理</span></div><div class="line">    [<span class="keyword">self</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></div><div class="line">    [<span class="keyword">self</span> requestCompleteFilter];</div><div class="line"></div><div class="line">    ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5.1：<code>requestCompletePreprocessor</code>方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</div><div class="line">            <span class="comment">//保存响应数据到缓存</span></div><div class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//保存响应数据到缓存</span></div><div class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m：</span></div><div class="line"><span class="comment">//保存响应数据到缓存</span></div><div class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</div><div class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                <span class="comment">// New data will always overwrite old data.</span></div><div class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</div><div class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</div><div class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</div><div class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</div><div class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到, <code>requestCompletePreprocessor</code>方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要<code>cacheTimeInSeconds</code>方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是<code>isDataFromCache</code>方法返回NO。<br>但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。</p>
</blockquote>
<p>接着看下5.2：<code>requestCompleteFilter</code>方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestCompleteFilter &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line">   </div><div class="line">    ...</div><div class="line"></div><div class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line">        </div><div class="line">    <span class="comment">//6. 执行回调</span></div><div class="line">    <span class="comment">//6.1 请求完成的代理</span></div><div class="line">    [strongSelf.delegate requestFinished:strongSelf];</div><div class="line">        </div><div class="line">    <span class="comment">//6.2 请求成功的block</span></div><div class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">         strongSelf.successCompletionBlock(strongSelf);</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">    [strongSelf clearCompletionBlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</div><div class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意，在用户同时实现了代理和block的情况下，二者都会被调用。</p>
</blockquote>
<p>到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。</p>
<p>反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么：</p>
<p>仔细看一下上面的<code>start</code>方法，我们会发现，如果缓存不满足条件时，会直接调用<code>startWithoutCache</code>方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start&#123;</div><div class="line"></div><div class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</div><div class="line">        [<span class="keyword">self</span> startWithoutCache];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    ......</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么在<code>startWithoutCache</code>方法里都做了什么呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)startWithoutCache &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 清除缓存</span></div><div class="line">    [<span class="keyword">self</span> clearCacheVariables];</div><div class="line">    </div><div class="line">    <span class="comment">//2. 调用父类的发起请求</span></div><div class="line">    [<span class="keyword">super</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//清除当前请求对应的所有缓存</span></div><div class="line">- (<span class="keyword">void</span>)clearCacheVariables &#123;</div><div class="line">    _cacheData = <span class="literal">nil</span>;</div><div class="line">    _cacheXML = <span class="literal">nil</span>;</div><div class="line">    _cacheJSON = <span class="literal">nil</span>;</div><div class="line">    _cacheString = <span class="literal">nil</span>;</div><div class="line">    _cacheMetadata = <span class="literal">nil</span>;</div><div class="line">    _dataFromCache = <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，首先清除了关于缓存的所有数据，然后调用父类的<code>start</code>方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m:</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 告诉Accessories即将回调了（其实是即将发起请求）</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line"></div><div class="line">    <span class="comment">//2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例</span></div><div class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一步里的Accessories是一些遵从<ytkrequestaccessory>代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里：</ytkrequestaccessory></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用来跟踪请求的状态的代理。</span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YTKRequestAccessory</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request is about to start.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestWillStart:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request is about to stop. This method is called</span></div><div class="line"><span class="comment">///  before executing `requestFinished` and `successCompletionBlock`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestWillStop:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="comment">///  Inform the accessory that the request has already stoped. This method is called</span></div><div class="line"><span class="comment">///  after executing `requestFinished` and `successCompletionBlock`.</span></div><div class="line"><span class="comment">///</span></div><div class="line"><span class="comment">///  @param request The corresponding request.</span></div><div class="line">- (<span class="keyword">void</span>)requestDidStop:(<span class="keyword">id</span>)request;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。</p>
<p>接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获取task</span></div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">//获取用户自定义的requestURL</span></div><div class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</div><div class="line">        </div><div class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></div><div class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">            <span class="comment">//响应的统一处理</span></div><div class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</div><div class="line">        &#125;];</div><div class="line">        request.requestTask = dataTask;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></div><div class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//序列化失败，则认定为请求失败</span></div><div class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSAssert</span>(request.requestTask != <span class="literal">nil</span>, <span class="string">@"requestTask should not be nil"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 优先级的映射</span></div><div class="line">    <span class="comment">// !!Available on iOS 8 +</span></div><div class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</div><div class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</div><div class="line">                <span class="comment">/*!!fall through*/</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Retain request</span></div><div class="line">    YTKLog(<span class="string">@"Add request: %@"</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</div><div class="line">    </div><div class="line">    <span class="comment">//2. 将request放入保存请求的字典中，taskIdentifier为key，request为值</span></div><div class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</div><div class="line">    </div><div class="line">    <span class="comment">//3. 开始task</span></div><div class="line">    [request.requestTask resume];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法挺长的，但是请不要被吓到，它总共分为三个部分：</p>
<ul>
<li>第一部分是获取当前请求对应的task并赋给request的<code>requestTask</code>属性（以后提到的request，都为用户自定义的当前请求类的实例）。</li>
<li>第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。</li>
<li>第三部分是启动task。</li>
</ul>
<p>下面我来依次讲解每个部分：</p>
<p><strong>第一部分：获取当前请求对应的task并赋给request</strong>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (customUrlRequest) &#123;</div><div class="line">        </div><div class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></div><div class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">            <span class="comment">//统一处理请求响应</span></div><div class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</div><div class="line">        &#125;];</div><div class="line">        request.requestTask = dataTask;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></div><div class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line"></div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里判断了用户是否自定义了request：</p>
<ol>
<li>如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。</li>
<li>如果不是，则调用YTKRequest自己的生成task的方法。</li>
</ol>
<p>第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，<code>sessionTaskForRequest: error :</code>方法内部：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//根据不同请求类型，序列化类型，和请求参数来返回NSURLSessionTask</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获得请求类型（GET，POST等）</span></div><div class="line">    YTKRequestMethod method = [request requestMethod];</div><div class="line"></div><div class="line">    <span class="comment">//2. 获得请求url</span></div><div class="line">    <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</div><div class="line"></div><div class="line">    <span class="comment">//3. 获得请求参数</span></div><div class="line">    <span class="keyword">id</span> param = request.requestArgument;</div><div class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</div><div class="line">    </div><div class="line">    <span class="comment">//4. 获得request serializer</span></div><div class="line">    AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</div><div class="line"></div><div class="line">    <span class="comment">//5. 根据不同的请求类型来返回对应的task</span></div><div class="line">    <span class="keyword">switch</span> (method) &#123;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodGET:</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</div><div class="line">                <span class="comment">//下载任务</span></div><div class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath requestSerializer:requestSerializer URLString:url parameters:param progress:request.resumableDownloadProgressBlock error:error];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//普通get请求</span></div><div class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"GET"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPOST:</div><div class="line">            <span class="comment">//POST请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodHEAD:</div><div class="line">            <span class="comment">//HEAD请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"HEAD"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPUT:</div><div class="line">            <span class="comment">//PUT请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PUT"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodDELETE:</div><div class="line">            <span class="comment">//DELETE请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"DELETE"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> YTKRequestMethodPATCH:</div><div class="line">            <span class="comment">//PATCH请求</span></div><div class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PATCH"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法：</p>
<ol>
<li>获得请求类型（GET，POST等）：</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  YTKRequestMethod method = [request requestMethod];</div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>requestMethod</code>方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。</p>
<p>它的枚举类型在YTKBaseRequest.h里面定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.h</span></div><div class="line"><span class="comment">///  HTTP Request method.</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestMethod) &#123;</div><div class="line">    YTKRequestMethodGET = <span class="number">0</span>,</div><div class="line">    YTKRequestMethodPOST,</div><div class="line">    YTKRequestMethodHEAD,</div><div class="line">    YTKRequestMethodPUT,</div><div class="line">    YTKRequestMethodDELETE,</div><div class="line">    YTKRequestMethodPATCH,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>用户可以根据实际的需求在自定义request类里面重写这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RegisterAPI.m</span></div><div class="line">- (YTKRequestMethod)requestMethod &#123;</div><div class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.获得请求url：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">  ...</div><div class="line">  <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</div><div class="line">  ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//返回当前请求url</span></div><div class="line">- (<span class="built_in">NSString</span> *)buildRequestUrl:(YTKBaseRequest *)request &#123;</div><div class="line">   </div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line"></div><div class="line">    <span class="comment">//用户自定义的url（不包括在YTKConfig里面设置的base_url）</span></div><div class="line">    <span class="built_in">NSString</span> *detailUrl = [request requestUrl];</div><div class="line">    <span class="built_in">NSURL</span> *temp = [<span class="built_in">NSURL</span> URLWithString:detailUrl];</div><div class="line">    </div><div class="line">    <span class="comment">// 存在host和scheme的url立即返回正确</span></div><div class="line">    <span class="keyword">if</span> (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123;</div><div class="line">        <span class="keyword">return</span> detailUrl;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果需要过滤url，则过滤</span></div><div class="line">    <span class="built_in">NSArray</span> *filters = [_config urlFilters];</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</div><div class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSString</span> *baseUrl;</div><div class="line">    <span class="keyword">if</span> ([request useCDN]) &#123;</div><div class="line">        <span class="comment">//如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN</span></div><div class="line">        <span class="keyword">if</span> ([request cdnUrl].length &gt; <span class="number">0</span>) &#123;</div><div class="line">            baseUrl = [request cdnUrl];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            baseUrl = [_config cdnUrl];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl</span></div><div class="line">        <span class="keyword">if</span> ([request baseUrl].length &gt; <span class="number">0</span>) &#123;</div><div class="line">            baseUrl = [request baseUrl];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            baseUrl = [_config baseUrl];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果末尾没有/，则在末尾添加一个／</span></div><div class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:baseUrl];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (baseUrl.length &gt; <span class="number">0</span> &amp;&amp; ![baseUrl hasSuffix:<span class="string">@"/"</span>]) &#123;</div><div class="line">        url = [url URLByAppendingPathComponent:<span class="string">@""</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> URLWithString:detailUrl relativeToURL:url].absoluteString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.获得请求参数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">      <span class="comment">//获取用户提供的请求参数</span></div><div class="line">    <span class="keyword">id</span> param = request.requestArgument;</div><div class="line"></div><div class="line">    <span class="comment">//获取用户提供的构造请求体的block（默认是没有的）</span></div><div class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//RegisterApi.m</span></div><div class="line">- (<span class="keyword">id</span>)requestArgument &#123;</div><div class="line">    <span class="keyword">return</span> @&#123;</div><div class="line">        <span class="string">@"username"</span>: _username,</div><div class="line">        <span class="string">@"password"</span>: _password</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.获得request serializer</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">   <span class="comment">//4. 获得request serializer</span></div><div class="line">   AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    AFHTTPRequestSerializer *requestSerializer = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//HTTP or JSON</span></div><div class="line">    <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123;</div><div class="line">        requestSerializer = [AFHTTPRequestSerializer serializer];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123;</div><div class="line">        requestSerializer = [AFJSONRequestSerializer serializer];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//超时时间</span></div><div class="line">    requestSerializer.timeoutInterval = [request requestTimeoutInterval];</div><div class="line">    </div><div class="line">    <span class="comment">//是否允许数据服务</span></div><div class="line">    requestSerializer.allowsCellularAccess = [request allowsCellularAccess];</div><div class="line"></div><div class="line">    <span class="comment">//如果当前请求需要验证</span></div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray];</div><div class="line">    <span class="keyword">if</span> (authorizationHeaderFieldArray != <span class="literal">nil</span>) &#123;</div><div class="line">        [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject</div><div class="line">                                                          password:authorizationHeaderFieldArray.lastObject];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//如果当前请求需要自定义 HTTPHeaderField</span></div><div class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary];</div><div class="line">    <span class="keyword">if</span> (headerFieldValueDictionary != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *httpHeaderField <span class="keyword">in</span> headerFieldValueDictionary.allKeys) &#123;</div><div class="line">            <span class="built_in">NSString</span> *value = headerFieldValueDictionary[httpHeaderField];</div><div class="line">            [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> requestSerializer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。</p>
<p>到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:<span class="literal">nil</span> error:error];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最终返回NSURLSessionDataTask实例</span></div><div class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</div><div class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</div><div class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</div><div class="line">                                      parameters:(<span class="keyword">id</span>)parameters</div><div class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</div><div class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    <span class="comment">//根据有无构造请求体的block的情况来获取request</span></div><div class="line">    <span class="keyword">if</span> (block) &#123;</div><div class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//获得request以后来获取dataTask</span></div><div class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</div><div class="line">    dataTask = [_manager dataTaskWithRequest:request</div><div class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</div><div class="line">                               <span class="comment">//响应的统一处理</span></div><div class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</div><div class="line">                           &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> dataTask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。</p>
<p>OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在<code>addRequest：</code>方法里接下来做的是对序列化失败的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">  <span class="comment">//序列化失败</span></div><div class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。</p>
<p>继续往下走，到了优先级的映射部分：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">    <span class="comment">// 优先级的映射</span></div><div class="line">    <span class="comment">// !!Available on iOS 8 +</span></div><div class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</div><div class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</div><div class="line">                <span class="comment">/*!!fall through*/</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestPriority) &#123;</div><div class="line">    YTKRequestPriorityLow = <span class="number">-4</span>L,</div><div class="line">    YTKRequestPriorityDefault = <span class="number">0</span>,</div><div class="line">    YTKRequestPriorityHigh = <span class="number">4</span>,</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。</p>
<p>到这里，我们拿到了task的实例并设置好了优先级，紧接着就是<code>addRequest:</code>方法里的第二个部分：<br>YTKNetworkAgent将request实例放在了一个字典中，保存起来：</p>
<p><strong>第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">  <span class="comment">//将request实例放入保存请求的字典中，taskIdentifier为key，request为值</span></div><div class="line">  [<span class="keyword">self</span> addRequestToRecord:request];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addRequestToRecord:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    Lock();</div><div class="line">    _requestsRecord[@(request.requestTask.taskIdentifier)] = request;</div><div class="line">    Unlock();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#define Lock() pthread_mutex_lock(&amp;_lock)</span></div><div class="line"><span class="meta">#define Unlock() pthread_mutex_unlock(&amp;_lock)</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。</p>
</blockquote>
<p>在当前的request被保存以后，就到了最后一步，正式发起请求：</p>
<p><strong>第三部分：启动task</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line"></div><div class="line">   ...</div><div class="line">   </div><div class="line">   [request.requestTask resume];</div><div class="line"></div><div class="line">   ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。</p>
<p>那么接下来我们看一下YTKNetwork是如何处理请求的回调的。</p>
<p>眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：<code>handleRequestResult:responseObject:error:</code>。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//统一处理请求结果，包括成功和失败的情况</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 获取task对应的request</span></div><div class="line">    Lock();</div><div class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</div><div class="line">    Unlock();</div><div class="line"></div><div class="line">    <span class="comment">//如果不存在对应的request，则立即返回</span></div><div class="line">    <span class="keyword">if</span> (!request) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    。。。</div><div class="line"></div><div class="line">    <span class="comment">//2. 获取request对应的response</span></div><div class="line">    request.responseObject = responseObject;</div><div class="line">    </div><div class="line">    <span class="comment">//3. 获取responseObject，responseData和responseString</span></div><div class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        </div><div class="line">       <span class="comment">//3.1 获取 responseData</span></div><div class="line">        request.responseData = responseObject;</div><div class="line">        </div><div class="line">        <span class="comment">//3.2 获取responseString</span></div><div class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</div><div class="line"></div><div class="line">         <span class="comment">//3.3 获取responseObject（或responseJSONObject）</span></div><div class="line">        <span class="comment">//根据返回的响应的序列化的类型来得到对应类型的响应</span></div><div class="line">        <span class="keyword">switch</span> (request.responseSerializerType)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</div><div class="line">                <span class="comment">// Default serializer. Do nothing.</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</div><div class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</div><div class="line">                request.responseJSONObject = request.responseObject;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</div><div class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调</span></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="comment">//如果该方法传入的error不为nil</span></div><div class="line">        succeed = <span class="literal">NO</span>;</div><div class="line">        requestError = error;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</div><div class="line">        <span class="comment">//如果序列化失败了</span></div><div class="line">        succeed = <span class="literal">NO</span>;</div><div class="line">        requestError = serializationError;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//即使没有error而且序列化通过，也要验证request是否有效</span></div><div class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</div><div class="line">        requestError = validationError;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></div><div class="line">    <span class="keyword">if</span> (succeed) &#123;</div><div class="line">        <span class="comment">//请求成功的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">     <span class="comment">//6. 回调完成的处理</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//6.1 在字典里移除当前request</span></div><div class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">         <span class="comment">//6.2 清除所有block</span></div><div class="line">        [request clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>简单讲解一下上面的代码：</p>
<ul>
<li>首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。</li>
<li>然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。</li>
<li>再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。</li>
<li>最后根据succeed的值来进行成功和失败的回调。</li>
</ul>
<p>这里先重点介绍一下是如何判断json的有效性的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//判断code是否符合范围和json的有效性</span></div><div class="line">- (<span class="built_in">BOOL</span>)validateResult:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 判断code是否在200~299之间</span></div><div class="line">    <span class="built_in">BOOL</span> result = [request statusCodeValidator];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!result) &#123;</div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid status code"</span>&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//2. result 存在的情况判断json是否有效</span></div><div class="line">    <span class="keyword">id</span> json = [request responseJSONObject];</div><div class="line">    <span class="keyword">id</span> validator = [request jsonValidator];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (json &amp;&amp; validator) &#123;</div><div class="line">        <span class="comment">//通过json和validator来判断json是否有效</span></div><div class="line">        result = [YTKNetworkUtils validateJSON:json withValidator:validator];</div><div class="line">        </div><div class="line">        <span class="comment">//如果json无效</span></div><div class="line">        <span class="keyword">if</span> (!result) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid JSON format"</span>&#125;];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里，首先，用<code>statusCodeValidator</code>方法判断响应的code是否在正确的范围:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseReqiest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)statusCodeValidator &#123;</div><div class="line">    <span class="built_in">NSInteger</span> statusCode = [<span class="keyword">self</span> responseStatusCode];</div><div class="line">    <span class="keyword">return</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt;= <span class="number">299</span>);</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSInteger</span>)responseStatusCode &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.response.statusCode;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再判断json的有效性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkUtils.m</span></div><div class="line"><span class="comment">//判断json的有效性</span></div><div class="line">+ (<span class="built_in">BOOL</span>)validateJSON:(<span class="keyword">id</span>)json withValidator:(<span class="keyword">id</span>)jsonValidator &#123;</div><div class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp;</div><div class="line">        [jsonValidator isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSDictionary</span> * dict = json;</div><div class="line">        <span class="built_in">NSDictionary</span> * validator = jsonValidator;</div><div class="line">        <span class="built_in">BOOL</span> result = <span class="literal">YES</span>;</div><div class="line">        <span class="built_in">NSEnumerator</span> * enumerator = [validator keyEnumerator];</div><div class="line">        <span class="built_in">NSString</span> * key;</div><div class="line">        <span class="keyword">while</span> ((key = [enumerator nextObject]) != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">id</span> value = dict[key];</div><div class="line">            <span class="keyword">id</span> format = validator[key];</div><div class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]</div><div class="line">                || [value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                result = [<span class="keyword">self</span> validateJSON:value withValidator:format];</div><div class="line">                <span class="keyword">if</span> (!result) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> ([value isKindOfClass:format] == <span class="literal">NO</span> &amp;&amp;</div><div class="line">                    [value isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] == <span class="literal">NO</span>) &#123;</div><div class="line">                    result = <span class="literal">NO</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] &amp;&amp;</div><div class="line">               [jsonValidator isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSArray</span> * validatorArray = (<span class="built_in">NSArray</span> *)jsonValidator;</div><div class="line">        <span class="keyword">if</span> (validatorArray.count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="built_in">NSArray</span> * array = json;</div><div class="line">            <span class="built_in">NSDictionary</span> * validator = jsonValidator[<span class="number">0</span>];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> array) &#123;</div><div class="line">                <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> validateJSON:item withValidator:validator];</div><div class="line">                <span class="keyword">if</span> (!result) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:jsonValidator]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。</p>
<p>在验证返回的JSON数据是否有效以后，就可以进行回调了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></div><div class="line">    <span class="keyword">if</span> (succeed) &#123;</div><div class="line">        <span class="comment">//请求成功的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求失败的处理</span></div><div class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//6. 回调完成的处理</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        <span class="comment">//6.1 在字典里移除当前request</span></div><div class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">         <span class="comment">//6.2 清除所有block</span></div><div class="line">        [request clearCompletionBlock];</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们先来分别看一下请求成功的处理和失败的处理：</p>
<p>请求成功的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block</span></div><div class="line">- (<span class="keyword">void</span>)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">//写入缓存 </span></div><div class="line">        [request requestCompletePreprocessor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></div><div class="line">        [request toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//在真正的回调之前做的处理,用户自定义</span></div><div class="line">        [request requestCompleteFilter];</div><div class="line"></div><div class="line">        <span class="comment">//如果有代理，则调用成功的代理</span></div><div class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</div><div class="line">            [request.delegate requestFinished:request];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果传入了成功回调的代码，则调用</span></div><div class="line">        <span class="keyword">if</span> (request.successCompletionBlock) &#123;</div><div class="line">            request.successCompletionBlock(request);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求已经结束了</span></div><div class="line">        [request toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下<code>requestCompletePreprocessor</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</div><div class="line"></div><div class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行）</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</div><div class="line">            <span class="comment">//写入缓存文件</span></div><div class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">         <span class="comment">//写入缓存文件</span></div><div class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//写入缓存文件</span></div><div class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</div><div class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                <span class="comment">// 1. 保存request的responseData到cacheFilePath</span></div><div class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</div><div class="line"></div><div class="line">                <span class="comment">// 2. 保存request的metadata到cacheMetadataFilePath</span></div><div class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</div><div class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</div><div class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</div><div class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</div><div class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</div><div class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</div><div class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</div><div class="line">                </div><div class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先看一下写入缓存操作的执行条件：当<code>cacheTimeInSeconds</code>方法返回大于0并且<code>isDataFromCache</code>为NO的时候会进行写入缓存。</p>
<p><code>cacheTimeInSeconds</code>方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。</p>
<p><code>isDataFromCache</code>属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：<code>isDataFromCache</code>的默认值是NO。在请求发起之前，-<br>查询缓存的时候：</p>
<ul>
<li>如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。</li>
<li>如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。</li>
</ul>
<p>即是说，如果发送了请求，则<code>isDataFromCache</code>一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。</p>
<p>因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。</p>
<p>我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：<br>第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种：</p>
<ol>
<li>缓存的版本，默认返回为0，用户可以自定义。</li>
<li>敏感数据，类型为id，默认返回nil，用户可以自定义。</li>
<li>NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
<li>元数据的创建时间。</li>
<li>app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li>
</ol>
<p>在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过<code>cacheMetadataFilePath</code>方法获取。</p>
<p>现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKRequest.m</span></div><div class="line"><span class="comment">//纯NSData数据缓存的文件名</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</div><div class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</div><div class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</div><div class="line">    <span class="keyword">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</div><div class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Method:%ld Host:%@ Url:%@ Argument:%@"</span>,</div><div class="line">                             (<span class="keyword">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</div><div class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</div><div class="line">    <span class="keyword">return</span> cacheFileName;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//纯NSData数据的缓存位置</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheFilePath &#123;</div><div class="line">    <span class="built_in">NSString</span> *cacheFileName = [<span class="keyword">self</span> cacheFileName];</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</div><div class="line">    path = [path stringByAppendingPathComponent:cacheFileName];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//元数据的缓存位置</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</div><div class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.metadata"</span>, [<span class="keyword">self</span> cacheFileName]];</div><div class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</div><div class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//创建用户保存所有YTKNetwork缓存的文件夹</span></div><div class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//获取全路径</span></div><div class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</div><div class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@"LazyRequestCache"</span>];</div><div class="line"></div><div class="line">    <span class="comment">// YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法</span></div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</div><div class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</div><div class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//创建文件夹</span></div><div class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</div><div class="line">    <span class="keyword">return</span> path;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。</p>
<p>而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。</p>
<p>为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6c5f41fbe2993059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存和缓存元数据的文件"></p>
<p>而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。</p>
<p>OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="comment">//6. 执行回调</span></div><div class="line">    <span class="comment">//6.1 请求完成的代理</span></div><div class="line">    [strongSelf.delegate requestFinished:strongSelf];</div><div class="line"></div><div class="line">    <span class="comment">//6.2 请求成功的block</span></div><div class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</div><div class="line">        strongSelf.successCompletionBlock(strongSelf);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></div><div class="line">    [strongSelf clearCompletionBlock];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用<code>clearCompletionBlock</code>方法将block清空。该方法的实现是在YTKBaseRequest里：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</div><div class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">//请求失败</span></div><div class="line">- (<span class="keyword">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    </div><div class="line">    request.error = error;</div><div class="line">    YTKLog(<span class="string">@"Request %@ failed, status code = %ld, error = %@"</span>,</div><div class="line">           <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]), (<span class="keyword">long</span>)request.responseStatusCode, error.localizedDescription);</div><div class="line"></div><div class="line">    <span class="comment">// 储存未完成的下载数据</span></div><div class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</div><div class="line">    <span class="keyword">if</span> (incompleteDownloadData) &#123;</div><div class="line">        [incompleteDownloadData writeToURL:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Load response from file and clean up if download task failed.</span></div><div class="line">    <span class="comment">//如果下载任务失败，则取出对应的响应文件并清空</span></div><div class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = request.responseObject;</div><div class="line">        </div><div class="line">        <span class="comment">//isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件</span></div><div class="line">        <span class="keyword">if</span> (url.isFileURL &amp;&amp; [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:url.path]) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//将url的data和string赋给request</span></div><div class="line">            request.responseData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</div><div class="line">            request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</div><div class="line"></div><div class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtURL:url error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//清空request</span></div><div class="line">        request.responseObject = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="comment">//请求失败的预处理，YTK没有定义，需要用户定义</span></div><div class="line">        [request requestFailedPreprocessor];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></div><div class="line">        [request toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//在真正的回调之前做的处理</span></div><div class="line">        [request requestFailedFilter];</div><div class="line"></div><div class="line">        <span class="comment">//如果有代理，就调用代理</span></div><div class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</div><div class="line">            [request.delegate requestFailed:request];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//如果传入了失败回调的block代码，就调用block</span></div><div class="line">        <span class="keyword">if</span> (request.failureCompletionBlock) &#123;</div><div class="line">            request.failureCompletionBlock(request);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//告诉Accessories请求已经停止了</span></div><div class="line">        [request toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到<code>resumableDownloadPath</code>里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。</p>
<p>到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-eab27afc98b324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKNetwork流程图"></p>
<p>我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.h</span></div><div class="line"><span class="comment">///  取消某个request</span></div><div class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request;</div><div class="line"></div><div class="line"><span class="comment">///  取消所有添加的request</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllRequests;</div></pre></td></tr></table></figure></p>
<p>首先我们看下取消某个request这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line"><span class="comment">///  取消某个request</span></div><div class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</div><div class="line"></div><div class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</div><div class="line">    <span class="comment">//获取request的task，并取消</span></div><div class="line">    [request.requestTask cancel];</div><div class="line">    <span class="comment">//从字典里移除当前request</span></div><div class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</div><div class="line">    <span class="comment">//清理所有block</span></div><div class="line">    [request clearCompletionBlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//从字典里移除某request</span></div><div class="line">- (<span class="keyword">void</span>)removeRequestFromRecord:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//加锁</span></div><div class="line">    Lock();</div><div class="line">    [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)];</div><div class="line">    YTKLog(<span class="string">@"Request queue size = %zd"</span>, [_requestsRecord count]);</div><div class="line">    Unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>取消所有在字典里添加的request：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKNetworkAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)cancelAllRequests &#123;</div><div class="line">    Lock();</div><div class="line">    <span class="built_in">NSArray</span> *allKeys = [_requestsRecord allKeys];</div><div class="line">    Unlock();</div><div class="line">    <span class="keyword">if</span> (allKeys &amp;&amp; allKeys.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *copiedKeys = [allKeys <span class="keyword">copy</span>];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *key <span class="keyword">in</span> copiedKeys) &#123;</div><div class="line">            Lock();</div><div class="line">            YTKBaseRequest *request = _requestsRecord[key];</div><div class="line">            Unlock();</div><div class="line">            <span class="comment">//stop每个请求</span></div><div class="line">            [request stop];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个stop方法是在YTKBaseRequest里面定义的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBaseRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//告诉Accessories将要回调了</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//清空代理</span></div><div class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//调用agent的取消某个request的方法</span></div><div class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//告诉Accessories回调完成了</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。</p>
<h2 id="3-3-批量请求和链式请求"><a href="#3-3-批量请求和链式请求" class="headerlink" title="3.3 批量请求和链式请求"></a>3.3 批量请求和链式请求</h2><p>YTKNetwork支持的批量请求有两种：</p>
<ol>
<li>批量请求：多个请求几乎同时发起。</li>
<li>链式请求：当前个请求结束后才能发起下一个请求。</li>
</ol>
<p>其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？</p>
<p>我们首先来看一下YTKNetwork是如何实现批量请求的。</p>
<h3 id="3-31批量请求"><a href="#3-31批量请求" class="headerlink" title="3.31批量请求"></a>3.31批量请求</h3><p>YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的<code>_requestArray</code>实例变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithRequestArray:(<span class="built_in">NSArray</span>&lt;YTKRequest *&gt; *)requestArray &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//保存为属性</span></div><div class="line">        _requestArray = [requestArray <span class="keyword">copy</span>];</div><div class="line"></div><div class="line">        <span class="comment">//批量请求完成的数量初始化为0</span></div><div class="line">        _finishedCount = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败</span></div><div class="line">        <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">            <span class="keyword">if</span> (![req isKindOfClass:[YTKRequest <span class="keyword">class</span>]]) &#123;</div><div class="line">                YTKLog(<span class="string">@"Error, request item must be YTKRequest instance."</span>);</div><div class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>初始化以后，我们就可以调用<code>start</code>方法来发起当前YTKBatchRequest实例所管理的所有请求了：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line"><span class="comment">//batch请求开始</span></div><div class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</div><div class="line">                                    failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</div><div class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</div><div class="line">    [<span class="keyword">self</span> start];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置成功和失败的block</span></div><div class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</div><div class="line">                              failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</div><div class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</div><div class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果batch里第一个请求已经成功结束，则不能再start</span></div><div class="line">    <span class="keyword">if</span> (_finishedCount &gt; <span class="number">0</span>) &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Batch request has already started."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//最开始设定失败的request为nil</span></div><div class="line">    _failedRequest = <span class="literal">nil</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//使用YTKBatchRequestAgent来管理当前的批量请求</span></div><div class="line">    [[YTKBatchRequestAgent sharedAgent] addBatchRequest:<span class="keyword">self</span>];</div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//遍历所有request，并开始请求</span></div><div class="line">    <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">        req.delegate = <span class="keyword">self</span>;</div><div class="line">        [req clearCompletionBlock];</div><div class="line">        [req start];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，我们可以看出：<br>1.在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的<code>start</code>方法会立即返回，否则可以无限制start。<br>2.YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequestAgent.m</span></div><div class="line">- (<span class="keyword">void</span>)addBatchRequest:(YTKBatchRequest *)request &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        [_requestArray addObject:request];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3.因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的<code>_requestArray</code>并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。</p>
<p>发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。</p>
<p>YTKRequest子类成功的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line"><span class="meta">#pragma mark - Network Request Delegate</span></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//某个request成功后，首先让_finishedCount + 1</span></div><div class="line">    _finishedCount++;</div><div class="line">    </div><div class="line">    <span class="comment">//如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功</span></div><div class="line">    <span class="keyword">if</span> (_finishedCount == _requestArray.count) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//调用即将结束的代理</span></div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//调用请求成功的代理</span></div><div class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFinished:)]) &#123;</div><div class="line">            [_delegate batchRequestFinished:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//调用批量请求成功的block</span></div><div class="line">        <span class="keyword">if</span> (_successCompletionBlock) &#123;</div><div class="line">            _successCompletionBlock(<span class="keyword">self</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//清空成功和失败的block</span></div><div class="line">        [<span class="keyword">self</span> clearCompletionBlock];</div><div class="line">        </div><div class="line">        <span class="comment">//调用请求结束的代理</span></div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">        </div><div class="line">        <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></div><div class="line">        [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。</p>
<p>接下来我们看一下某个请求失败的处理：</p>
<p>YTKReques子类失败的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKBatchRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKRequest *)request &#123;</div><div class="line">    </div><div class="line">    _failedRequest = request;</div><div class="line">    </div><div class="line">    <span class="comment">//调用即将结束的代理</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//停止batch里所有的请求</span></div><div class="line">    <span class="keyword">for</span> (YTKRequest *req <span class="keyword">in</span> _requestArray) &#123;</div><div class="line">        [req stop];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//调用请求失败的代理</span></div><div class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFailed:)]) &#123;</div><div class="line">        [_delegate batchRequestFailed:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//调用请求失败的block</span></div><div class="line">    <span class="keyword">if</span> (_failureCompletionBlock) &#123;</div><div class="line">        _failureCompletionBlock(<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//清空成功和失败的block</span></div><div class="line">    [<span class="keyword">self</span> clearCompletionBlock];</div><div class="line"></div><div class="line">    <span class="comment">//调用请求结束的代理</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">    </div><div class="line">    <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></div><div class="line">    [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。<br>而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。</p>
<p>总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。</p>
<p>现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。</p>
<h3 id="3-32链式请求"><a href="#3-32链式请求" class="headerlink" title="3.32链式请求"></a>3.32链式请求</h3><p>和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。</p>
<p>但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//下一个请求的index</span></div><div class="line">        _nextRequestIndex = <span class="number">0</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//保存链式请求的数组</span></div><div class="line">        _requestArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        </div><div class="line">        <span class="comment">//保存回调的数组</span></div><div class="line">        _requestCallbackArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">        </div><div class="line">        <span class="comment">//空回调，用来填充用户没有定义的回调block</span></div><div class="line">        _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123;</div><div class="line">            <span class="comment">// do nothing</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是它提供了添加和删除request的接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//在当前chain添加request和callback</span></div><div class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//保存当前请求</span></div><div class="line">    [_requestArray addObject:request];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (callback != <span class="literal">nil</span>) &#123;</div><div class="line">        [_requestCallbackArray addObject:callback];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称</span></div><div class="line">        [_requestCallbackArray addObject:_emptyCallback];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。</p>
<p>我们接着看一下链式请求的发起：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="comment">//如果第1个请求已经结束，就不再重复start了</span></div><div class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Chain request has already started."</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//如果请求队列数组里面还有request，则取出并start</span></div><div class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</div><div class="line">        <span class="comment">//取出当前request并start</span></div><div class="line">        [<span class="keyword">self</span> startNextRequest];</div><div class="line">        <span class="comment">//在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain）</span></div><div class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        YTKLog(<span class="string">@"Error! Chain request array is empty."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，YTKChainRequest用<code>_nextRequestIndex</code>来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。</p>
<p>这里<code>startNextRequest</code>方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="built_in">BOOL</span>)startNextRequest &#123;</div><div class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</div><div class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</div><div class="line">        _nextRequestIndex++;</div><div class="line">        request.delegate = <span class="keyword">self</span>;</div><div class="line">        [request clearCompletionBlock];</div><div class="line">        [request start];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法有两个作用：</p>
<ol>
<li>第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界）</li>
<li>第二个作用是如果可以进行下一个request，则发起该request。并将<code>_nextRequestIndex</code>+1。</li>
</ol>
<p>所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。</p>
<p>现在我们知道了YTKChainRequest的发送，接下来看一下回调部分:</p>
<p>和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//某个request请求成功的代理的实现</span></div><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//1. 取出当前的request和callback，进行回调</span></div><div class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</div><div class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</div><div class="line">    callback(<span class="keyword">self</span>, request);<span class="comment">//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面</span></div><div class="line">    </div><div class="line">    <span class="comment">//2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</div><div class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</div><div class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用<code>startNextRequest</code>方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了：</p>
<ul>
<li>如果没有了，则调用当前YTKChainRequest的最终成功的回调。</li>
<li>如果还有，则发起接下来的request（按顺序）。</li>
</ul>
<p>接下来我们再看一下某个request失败的代理的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//某个reqeust请求失败的代理</span></div><div class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFailed:failedBaseRequest:)]) &#123;</div><div class="line">        [_delegate chainRequestFailed:<span class="keyword">self</span> failedBaseRequest:request];</div><div class="line">        [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。</p>
<p>现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line"><span class="comment">//终止当前的chain</span></div><div class="line">- (<span class="keyword">void</span>)stop &#123;</div><div class="line"></div><div class="line">    <span class="comment">//首先调用即将停止的callback</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</div><div class="line"></div><div class="line">    <span class="comment">//然后stop当前的请求，再清空chain里所有的请求和回掉block</span></div><div class="line">    [<span class="keyword">self</span> clearRequest];</div><div class="line"></div><div class="line">    <span class="comment">//在YTKChainRequestAgent里移除当前的chain</span></div><div class="line">    [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</div><div class="line"></div><div class="line">    <span class="comment">//最后调用已经结束的callback</span></div><div class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个<code>stop</code>方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用<code>clearReuqest</code>方法，将当前request停止，再将请求队列数组和callback数组清空。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//YTKChainRequest.m</span></div><div class="line">- (<span class="keyword">void</span>)clearRequest &#123;</div><div class="line">    <span class="comment">//获取当前请求的index</span></div><div class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (currentRequestIndex &lt; [_requestArray count]) &#123;</div><div class="line">        YTKBaseRequest *request = _requestArray[currentRequestIndex];</div><div class="line">        [request stop];</div><div class="line">    &#125;</div><div class="line">    [_requestArray removeAllObjects];</div><div class="line">    [_requestCallbackArray removeAllObjects];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后在YTKChainRequestAgent单例里面，将自己移除掉。</p>
<h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4. 最后的话"></a>4. 最后的话</h1><hr>
<p>不知不觉写了好多，请原谅我一如既往啰嗦的风格~</p>
<p>阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。</p>
<p>我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。</p>
<p>所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。</p>
<p>希望这篇文章能对读者们有所帮助~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于iOS开发来说，就算是没有用过&lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot;&gt;YTKNetwork框架&lt;/a&gt;，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。&lt;/p&gt;
&lt;p&gt;在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。&lt;/p&gt;
&lt;h1 id=&quot;1-架构&quot;&gt;&lt;a href=&quot;#1-架构&quot; class=&quot;headerlink&quot; title=&quot;1. 架构&quot;&gt;&lt;/a&gt;1. 架构&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;先上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;YTKRequest架构图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这里简单说明一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 &lt;/li&gt;
&lt;li&gt;YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。&lt;/li&gt;
&lt;li&gt;我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。&lt;/li&gt;
&lt;li&gt;YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>iOS 代码规范</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/06/14/iOS%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/06/14/iOS 代码规范/</id>
    <published>2017-06-14T05:11:18.000Z</published>
    <updated>2017-06-14T05:24:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-a9d78ce3d5e7114f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配图来自：nipic.com"></p>
<p>利用上周的业余时间把这篇规范整理了出来，我会将这篇规范作为我们iOS团队的代码规范，并且还会根据读者的反馈，项目的实践和研究的深入做不定时更新，还希望各位朋友看了多多指正和批评。</p>
<p>这篇规范一共分为三个部分：</p>
<ol>
<li>核心原则：介绍了这篇代码规范所遵循的核心原则。</li>
<li>通用规范：不局限于iOS的通用性的代码规范（使用C语言和Swift语言）。</li>
<li>iOS规范：仅适用于iOS的代码规范（使用Objective-C语言）。</li>
</ol>
<a id="more"></a>
<h1 id="一-核心原则"><a href="#一-核心原则" class="headerlink" title="一. 核心原则"></a>一. 核心原则</h1><h2 id="原则一：代码应该简洁易懂，逻辑清晰"><a href="#原则一：代码应该简洁易懂，逻辑清晰" class="headerlink" title="原则一：代码应该简洁易懂，逻辑清晰"></a>原则一：代码应该简洁易懂，逻辑清晰</h2><p>因为软件是需要人来维护的。这个人在未来很可能不是你。所以首先是为人编写程序，其次才是计算机：</p>
<ul>
<li>不要过分追求技巧，降低程序的可读性。</li>
<li>简洁的代码可以让bug无处藏身。要写出明显没有bug的代码，而不是没有明显bug的代码。</li>
</ul>
<h2 id="原则二：面向变化编程，而不是面向需求编程。"><a href="#原则二：面向变化编程，而不是面向需求编程。" class="headerlink" title="原则二：面向变化编程，而不是面向需求编程。"></a>原则二：面向变化编程，而不是面向需求编程。</h2><p>需求是暂时的，只有变化才是永恒的。<br>本次迭代不能仅仅为了当前的需求，写出扩展性强，易修改的程序才是负责任的做法，对自己负责，对公司负责。</p>
<h2 id="原则三：先保证程序的正确性，防止过度工程"><a href="#原则三：先保证程序的正确性，防止过度工程" class="headerlink" title="原则三：先保证程序的正确性，防止过度工程"></a>原则三：先保证程序的正确性，防止过度工程</h2><p>过度工程（over-engineering）：在正确可用的代码写出之前就过度地考虑扩展，重用的问题，使得工程过度复杂。<br>引用《<a href="http://www.jianshu.com/p/7645a5ea7f46" target="_blank" rel="external">王垠：编程的智慧</a>》里的话：</p>
<blockquote>
<ol>
<li>先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。</li>
<li>先写出可用的代码，反复推敲，再考虑是否需要重用的问题。</li>
<li>先写出可用，简单，明显没有bug的代码，再考虑测试的问题。</li>
</ol>
</blockquote>
<h1 id="二-通用规范"><a href="#二-通用规范" class="headerlink" title="二. 通用规范"></a>二. 通用规范</h1><h2 id="关于大括号"><a href="#关于大括号" class="headerlink" title="关于大括号"></a>关于大括号</h2><hr>
<ul>
<li>控制语句(if,for,while,switch)中，大括号开始与行尾</li>
<li>函数中，大括号要开始于行首</li>
</ul>
<p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//控制语句</span></div><div class="line">white(someCondition)&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//函数</span></div><div class="line"><span class="keyword">void</span> function(param1,param2)</div><div class="line">&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><hr>
<h3 id="1-运算符与变量之间的间隔"><a href="#1-运算符与变量之间的间隔" class="headerlink" title="1. 运算符与变量之间的间隔"></a>1. 运算符与变量之间的间隔</h3><h4 id="1-1-一元运算符与变量之间没有空格："><a href="#1-1-一元运算符与变量之间没有空格：" class="headerlink" title="1.1  一元运算符与变量之间没有空格："></a>1.1  一元运算符与变量之间没有空格：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!bValue</div><div class="line">~iValue</div><div class="line">++iCount</div><div class="line">*strSource</div><div class="line">&amp;fSum</div></pre></td></tr></table></figure>
<h4 id="1-2-二元运算符与变量之间必须有空格"><a href="#1-2-二元运算符与变量之间必须有空格" class="headerlink" title="1.2 二元运算符与变量之间必须有空格"></a>1.2 二元运算符与变量之间必须有空格</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fWidth = <span class="number">5</span> + <span class="number">5</span>;</div><div class="line">fLength = fWidth * <span class="number">2</span>;</div><div class="line">fHeight = fWidth + fLength;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</div></pre></td></tr></table></figure>
<h3 id="2-多个不同的运算符同时存在时应该使用括号来明确优先级"><a href="#2-多个不同的运算符同时存在时应该使用括号来明确优先级" class="headerlink" title="2. 多个不同的运算符同时存在时应该使用括号来明确优先级"></a>2. 多个不同的运算符同时存在时应该使用括号来明确优先级</h3><p>在多个不同的运算符同时存在的时候应该合理使用括号，不要盲目依赖操作符优先级。<br>因为有的时候不能保证阅读你代码的人就一定能了解你写的算式里面所有操作符的优先级。</p>
<p>来看一下这个算式：2 &lt;&lt; 2 + 1 * 3 - 4</p>
<p>这里的<code>&lt;&lt;</code>是移位操作直观上却很容易认为它的优先级很高，所以就把这个算式误认为：(2 &lt;&lt; 2) + 1 <em> 3 - 4<br>但事实上，它的优先级是比加减法还要低的，所以该算式应该等同于：2 &lt;&lt; (2 + 1 </em> 3 - 4)。<br>所以在以后写这种复杂一点的算式的时候，尽量多加一点括号，避免让其他人误解（甚至是自己）。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr>
<h3 id="1-一个变量有且只有一个功能，尽量不要把一个变量用作多种用途"><a href="#1-一个变量有且只有一个功能，尽量不要把一个变量用作多种用途" class="headerlink" title="1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途"></a>1. 一个变量有且只有一个功能，尽量不要把一个变量用作多种用途</h3><h3 id="2-变量在使用前应初始化，防止未初始化的变量被引用"><a href="#2-变量在使用前应初始化，防止未初始化的变量被引用" class="headerlink" title="2. 变量在使用前应初始化，防止未初始化的变量被引用"></a>2. 变量在使用前应初始化，防止未初始化的变量被引用</h3><h3 id="3-局部变量应该尽量接近使用它的地方"><a href="#3-局部变量应该尽量接近使用它的地方" class="headerlink" title="3. 局部变量应该尽量接近使用它的地方"></a>3. 局部变量应该尽量接近使用它的地方</h3><p>推荐这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> index = ...;</div><div class="line">  <span class="comment">//Do something With index</span></div><div class="line"></div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = ...;</div><div class="line">  <span class="comment">//Do something With count</span></div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">someFunction</span><span class="params">()</span></span> &#123;</div><div class="line"> </div><div class="line">  <span class="keyword">let</span> index = ...;</div><div class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = ...;</div><div class="line">  <span class="comment">//Do something With index</span></div><div class="line"></div><div class="line">  ...</div><div class="line">  ...</div><div class="line">  </div><div class="line">  <span class="comment">//Do something With count</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><hr>
<h3 id="1-必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。"><a href="#1-必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。" class="headerlink" title="1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。"></a>1. 必须列出所有分支（穷举所有的情况），而且每个分支都必须给出明确的结果。</h3><p>推荐这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hintStr;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">count</span> &lt; <span class="number">3</span>) &#123;</div><div class="line">  hintStr = <span class="string">"Good"</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  hintStr = <span class="string">""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> hintStr;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">count</span> &lt; <span class="number">3</span>) &#123;</div><div class="line"> hintStr = <span class="string">"Good"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-不要使用过多的分支，要善于使用return来提前返回错误的情况"><a href="#2-不要使用过多的分支，要善于使用return来提前返回错误的情况" class="headerlink" title="2. 不要使用过多的分支，要善于使用return来提前返回错误的情况"></a>2. 不要使用过多的分支，要善于使用return来提前返回错误的情况</h3><p>推荐这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)someMethod &#123; </div><div class="line">  <span class="keyword">if</span> (!goodCondition) &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)someMethod &#123; </div><div class="line">  <span class="keyword">if</span> (goodCondition) &#123;</div><div class="line">    <span class="comment">//Do something</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>比较典型的例子我在JSONModel里遇到过：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>)err</div><div class="line">&#123;</div><div class="line">   <span class="comment">//方法1. 参数为nil</span></div><div class="line">   <span class="keyword">if</span> (!dict) &#123;</div><div class="line">     <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];</div><div class="line">     <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法2. 参数不是nil，但也不是字典</span></div><div class="line">    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法3. 初始化</span></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//初始化失败</span></div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO）</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span>.__keyMapper error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法5. 核心方法：字典的key与模型的属性的映射</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span>.__keyMapper validation:<span class="literal">YES</span> error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//方法7. 终于通过了！成功返回model</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以看到，在这里，首先判断出各种错误的情况然后提前返回，把最正确的情况放到最后返回。</p>
</blockquote>
<h3 id="3-条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值"><a href="#3-条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值" class="headerlink" title="3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值"></a>3. 条件表达式如果很长，则需要将他们提取出来赋给一个BOOL值</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let nameContainsSwift = sessionName.hasPrefix(<span class="string">"Swift"</span>)</div><div class="line">let isCurrentYear = sessionDateCompontents.year == <span class="number">2014</span></div><div class="line">let isSwiftSession = nameContainsSwift &amp;&amp; isCurrentYear</div><div class="line"><span class="keyword">if</span> (isSwiftSession) &#123; </div><div class="line">   <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( sessionName.hasPrefix(<span class="string">"Swift"</span>) &amp;&amp; (sessionDateCompontents.year == <span class="number">2014</span>) ) &#123; </div><div class="line">    <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-条件语句的判断应该是变量在左，常量在右"><a href="#4-条件语句的判断应该是变量在左，常量在右" class="headerlink" title="4. 条件语句的判断应该是变量在左，常量在右"></a>4. 条件语句的判断应该是变量在左，常量在右</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( count == <span class="number">6</span>) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( object == <span class="literal">nil</span>) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( !object ) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="number">6</span> == count) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( <span class="literal">nil</span> == object ) &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-每个分支的实现代码都必须被大括号包围"><a href="#5-每个分支的实现代码都必须被大括号包围" class="headerlink" title="5. 每个分支的实现代码都必须被大括号包围"></a>5. 每个分支的实现代码都必须被大括号包围</h3><p>推荐这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error) &#123;</div><div class="line">  <span class="keyword">return</span> success;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error)</div><div class="line">    <span class="keyword">return</span> success;</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (!error) <span class="keyword">return</span> success;</div></pre></td></tr></table></figure>
<h3 id="6-条件过多，过长的时候应该换行"><a href="#6-条件过多，过长的时候应该换行" class="headerlink" title="6. 条件过多，过长的时候应该换行"></a>6. 条件过多，过长的时候应该换行</h3><p>推荐这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition1() &amp;&amp; </div><div class="line">    condition2() &amp;&amp; </div><div class="line">    condition3() &amp;&amp; </div><div class="line">    condition4()) &#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) &#123;</div><div class="line">  <span class="comment">// Do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h2><hr>
<h3 id="1-不可在for循环内修改循环变量，防止for循环失去控制。"><a href="#1-不可在for循环内修改循环变量，防止for循环失去控制。" class="headerlink" title="1. 不可在for循环内修改循环变量，防止for循环失去控制。"></a>1. 不可在for循环内修改循环变量，防止for循环失去控制。</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">10</span>; index++)&#123;</div><div class="line">   ...</div><div class="line">   logicToChange(index)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-避免使用continue和break。"><a href="#2-避免使用continue和break。" class="headerlink" title="2. 避免使用continue和break。"></a>2. 避免使用continue和break。</h3><p>continue和break所描述的是“什么时候不做什么”，所以为了读懂二者所在的代码，我们需要在头脑里将他们取反。</p>
<p>其实最好不要让这两个东西出现，因为我们的代码只要体现出“什么时候做什么”就好了，而且通过适当的方法，是可以将这两个东西消灭掉的：</p>
<h4 id="2-1-如果出现了continue，只需要把continue的条件取反即可"><a href="#2-1-如果出现了continue，只需要把continue的条件取反即可" class="headerlink" title="2.1 如果出现了continue，只需要把continue的条件取反即可"></a>2.1 如果出现了continue，只需要把continue的条件取反即可</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filteredProducts = <span class="type">Array</span>&lt;<span class="type">String</span>&gt;()</div><div class="line"><span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">    <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">        <span class="keyword">continue</span></div><div class="line">    &#125;</div><div class="line">    filteredProducts.append(level)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，通过判断字符串里是否含有“bad”这个prefix来过滤掉一些值。其实我们是可以通过取反，来避免使用continue的：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">    <span class="keyword">if</span> !level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">      filteredProducts.append(level)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-2-消除while里的break：将break的条件取反，并合并到主循环里"><a href="#2-2-消除while里的break：将break的条件取反，并合并到主循环里" class="headerlink" title="2.2  消除while里的break：将break的条件取反，并合并到主循环里"></a>2.2  消除while里的break：将break的条件取反，并合并到主循环里</h4><p>在while里的block其实就相当于“不存在”，既然是不存在的东西就完全可以在最开始的条件语句中将其排除。</p>
<p>while里的break：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition1) &#123;</div><div class="line">  ...</div><div class="line">  <span class="keyword">if</span> (condition2) &#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>取反并合并到主条件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> (condition1 &amp;&amp; !condition2) &#123;</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-在有返回值的方法里消除break：将break转换为return立即返回"><a href="#2-3-在有返回值的方法里消除break：将break转换为return立即返回" class="headerlink" title="2.3 在有返回值的方法里消除break：将break转换为return立即返回"></a>2.3 在有返回值的方法里消除break：将break转换为return立即返回</h4><p>有些朋友喜欢这样做：在有返回值的方法里break之后，再返回某个值。其实完全可以在break的那一行直接返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasBadProductIn</span><span class="params">(products: Array&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> result = <span class="literal">false</span>    </div><div class="line">    <span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">        <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">            result = <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>遇到错误条件直接返回：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">hasBadProductIn</span><span class="params">(products: Array&lt;String&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">for</span> level <span class="keyword">in</span> products &#123;</div><div class="line">        <span class="keyword">if</span> level.hasPrefix(<span class="string">"bad"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">   <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样写的话不用特意声明一个变量来特意保存需要返回的值，看起来非常简洁，可读性高。</p>
<h2 id="Switch语句"><a href="#Switch语句" class="headerlink" title="Switch语句"></a>Switch语句</h2><hr>
<h3 id="1-每个分支都必须用大括号括起来"><a href="#1-每个分支都必须用大括号括起来" class="headerlink" title="1. 每个分支都必须用大括号括起来"></a>1. 每个分支都必须用大括号括起来</h3><p>推荐这样写：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">switch</span> (integer) &#123;  </div><div class="line">  <span class="keyword">case</span> <span class="number">1</span>:  &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">   &#125;</div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">  <span class="keyword">case</span> <span class="number">2</span>: &#123;  </div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>;  </div><div class="line">  &#125;  </div><div class="line">  <span class="keyword">case</span> <span class="number">3</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">default</span>:&#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-使用枚举类型时，不能有default分支，-除了使用枚举类型以外，都必须有default分支"><a href="#2-使用枚举类型时，不能有default分支，-除了使用枚举类型以外，都必须有default分支" class="headerlink" title="2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支"></a>2. 使用枚举类型时，不能有default分支， 除了使用枚举类型以外，都必须有default分支</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="type">RWTLeftMenuTopItemType</span> menuType = <span class="type">RWTLeftMenuTopItemMain</span>;  </div><div class="line"><span class="keyword">switch</span> (menuType) &#123;  </div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemMain</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">   &#125;</div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemShows</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">case</span> <span class="type">RWTLeftMenuTopItemSchedule</span>: &#123;</div><div class="line">    <span class="comment">// ...  </span></div><div class="line">    <span class="keyword">break</span>; </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在Switch语句使用枚举类型的时候，如果使用了default分支，在将来就无法通过编译器来检查新增的枚举类型了。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><hr>
<h3 id="1-一个函数的长度必须限制在50行以内"><a href="#1-一个函数的长度必须限制在50行以内" class="headerlink" title="1. 一个函数的长度必须限制在50行以内"></a>1. 一个函数的长度必须限制在50行以内</h3><p>通常来说，在阅读一个函数的时候，如果视需要跨过很长的垂直距离会非常影响代码的阅读体验。如果需要来回滚动眼球或代码才能看全一个方法，就会很影响思维的连贯性，对阅读代码的速度造成比较大的影响。最好的情况是在不滚动眼球或代码的情况下一眼就能将该方法的全部代码映入眼帘。</p>
<h3 id="2-一个函数只做一件事（单一原则）"><a href="#2-一个函数只做一件事（单一原则）" class="headerlink" title="2. 一个函数只做一件事（单一原则）"></a>2. 一个函数只做一件事（单一原则）</h3><p>每个函数的职责都应该划分的很明确（就像类一样）。</p>
<p>推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dataConfiguration()</div><div class="line">viewConfiguration()</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dataConfiguration</span><span class="params">()</span></span></div><div class="line">&#123;   </div><div class="line">   ...</div><div class="line">   viewConfiguration()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-对于有返回值的函数（方法），每一个分支都必须有返回值"><a href="#3-对于有返回值的函数（方法），每一个分支都必须有返回值" class="headerlink" title="3. 对于有返回值的函数（方法），每一个分支都必须有返回值"></a>3. 对于有返回值的函数（方法），每一个分支都必须有返回值</h3><p>推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(condition1)&#123;</div><div class="line">        <span class="keyword">return</span> count1</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</div><div class="line">        <span class="keyword">return</span> count2</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">       <span class="keyword">return</span> defaultCount</div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">function</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(condition1)&#123;</div><div class="line">        <span class="keyword">return</span> count1</div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(condition2)&#123;</div><div class="line">        <span class="keyword">return</span> count2</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-对输入参数的正确性和有效性进行检查，参数错误立即返回"><a href="#4-对输入参数的正确性和有效性进行检查，参数错误立即返回" class="headerlink" title="4. 对输入参数的正确性和有效性进行检查，参数错误立即返回"></a>4. 对输入参数的正确性和有效性进行检查，参数错误立即返回</h3><p>推荐这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(param1,param2)</span></span></div><div class="line">&#123;</div><div class="line">      <span class="keyword">if</span>(param1 is unavailable)&#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    </div><div class="line">      <span class="keyword">if</span>(param2 is unavailable)&#123;</div><div class="line">           <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">     <span class="comment">//Do some right thing</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数"><a href="#5-如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数" class="headerlink" title="5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数"></a>5. 如果在不同的函数内部有相同的功能，应该把相同的功能抽取出来单独作为另一个函数</h3><p>原来的调用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> logic() &#123;</div><div class="line">  a();</div><div class="line">  b()；</div><div class="line">  <span class="keyword">if</span> (logic1 condition) &#123;</div><div class="line">    c();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    d();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将a，b函数抽取出来作为单独的函数<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> basicConfig() &#123;</div><div class="line">  a();</div><div class="line">  b();</div><div class="line">&#125;</div><div class="line">  </div><div class="line"><span class="keyword">void</span> logic1() &#123;</div><div class="line">  basicConfig();</div><div class="line">  c();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> logic2() &#123;</div><div class="line">  basicConfig();</div><div class="line">  d();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="6-将函数内部比较复杂的逻辑提取出来作为单独的函数"><a href="#6-将函数内部比较复杂的逻辑提取出来作为单独的函数" class="headerlink" title="6. 将函数内部比较复杂的逻辑提取出来作为单独的函数"></a>6. 将函数内部比较复杂的逻辑提取出来作为单独的函数</h3><p>一个函数内的不清晰（逻辑判断比较多，行数较多）的那片代码，往往可以被提取出去，构成一个新的函数，然后在原来的地方调用它这样你就可以使用有意义的函数名来代替注释，增加程序的可读性。</p>
<p>举一个发送邮件的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">openEmailSite();</div><div class="line">login();</div><div class="line"></div><div class="line">writeTitle(title);</div><div class="line">writeContent(content);</div><div class="line">writeReceiver(receiver);</div><div class="line">addAttachment(attachment);</div><div class="line"></div><div class="line">send();</div></pre></td></tr></table></figure></p>
<p>中间的部分稍微长一些，我们可以将它们提取出来：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeEmail</span><span class="params">(title, content,receiver,attachment)</span></span></div><div class="line">&#123;</div><div class="line">  writeTitle(title);</div><div class="line">  writeContent(content);</div><div class="line">  writeReceiver(receiver);</div><div class="line">  addAttachment(attachment); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后再看一下原来的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">openEmailSite();</div><div class="line">login();</div><div class="line">writeEmail(title, content,receiver,attachment)</div><div class="line">send();</div></pre></td></tr></table></figure></p>
<h3 id="8-避免使用全局变量，类成员（class-member）来传递信息，尽量使用局部变量和参数。"><a href="#8-避免使用全局变量，类成员（class-member）来传递信息，尽量使用局部变量和参数。" class="headerlink" title="8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。"></a>8. 避免使用全局变量，类成员（class member）来传递信息，尽量使用局部变量和参数。</h3><p>在一个类里面，经常会有传递某些变量的情况。而如果需要传递的变量是某个全局变量或者属性的时候，有些朋友不喜欢将它们作为参数，而是在方法内部就直接访问了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">   <span class="keyword">var</span> x;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">updateX</span><span class="params">()</span></span> &#123;</div><div class="line">      ...</div><div class="line">      x = ...;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">func</span> <span class="title">printX</span><span class="params">()</span></span> &#123;</div><div class="line">     updateX();</div><div class="line">     <span class="built_in">print</span>(x);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在printX方法里面，updateX和print方法之间并没有值的传递，乍一看我们可能不知道x从哪里来的，导致程序的可读性降低了。</p>
<p>而如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个类，而且更加容易理解，不易出错：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">func updateX() -&gt; String&#123;</div><div class="line">    x = ...;</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> func printX() &#123;</div><div class="line">   String x = updateX();</div><div class="line">   print(x);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><hr>
<p>优秀的代码大部分是可以自描述的，我们完全可以用程代码本身来表达它到底在干什么，而不需要注释的辅助。</p>
<p>但并不是说一定不能写注释，有以下三种情况比较适合写注释：</p>
<ol>
<li>公共接口（注释要告诉阅读代码的人，当前类能实现什么功能）。</li>
<li>涉及到比较深层专业知识的代码（注释要体现出实现原理和思想）。</li>
<li>容易产生歧义的代码（但是严格来说，容易让人产生歧义的代码是不允许存在的）。</li>
</ol>
<p>除了上述这三种情况，如果别人只能依靠注释才能读懂你的代码的时候，就要反思代码出现了什么问题。</p>
<p>最后，对于注释的内容，相对于“做了什么”，更应该说明“为什么这么做”。</p>
<h2 id="Code-Review"><a href="#Code-Review" class="headerlink" title="Code Review"></a>Code Review</h2><hr>
<p>换行、注释、方法长度、代码重复等这些是通过机器检查出来的问题，是无需通过人来做的。</p>
<p>而且除了审查需求的实现的程度，bug是否无处藏身以外，更应该关注代码的设计。比如类与类之间的耦合程度，设计的可扩展性，复用性，是否可以将某些方法抽出来作为接口等等。</p>
<h1 id="三-iOS规范"><a href="#三-iOS规范" class="headerlink" title="三. iOS规范"></a>三. iOS规范</h1><h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><hr>
<h3 id="1-变量名必须使用驼峰格式"><a href="#1-变量名必须使用驼峰格式" class="headerlink" title="1. 变量名必须使用驼峰格式"></a>1. 变量名必须使用驼峰格式</h3><p>类，协议使用大驼峰：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">HomePageViewController.h</div><div class="line">&lt;HeaderViewDelegate&gt;</div></pre></td></tr></table></figure></p>
<p>对象等局部变量使用小驼峰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *personName = <span class="string">@""</span>;</div><div class="line"><span class="built_in">NSUInteger</span> totalCount = <span class="number">0</span>;</div></pre></td></tr></table></figure>
<h3 id="2-变量的名称必须同时包含功能与类型"><a href="#2-变量的名称必须同时包含功能与类型" class="headerlink" title="2. 变量的名称必须同时包含功能与类型"></a>2. 变量的名称必须同时包含功能与类型</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIButton</span> *addBtn <span class="comment">//添加按钮</span></div><div class="line"><span class="built_in">UILabel</span> *nameLbl <span class="comment">//名字标签</span></div><div class="line"><span class="built_in">NSString</span> *addressStr<span class="comment">//地址字符串</span></div></pre></td></tr></table></figure>
<h3 id="3-系统常用类作实例变量声明时加入后缀"><a href="#3-系统常用类作实例变量声明时加入后缀" class="headerlink" title="3. 系统常用类作实例变量声明时加入后缀"></a>3. 系统常用类作实例变量声明时加入后缀</h3><table>
<thead>
<tr>
<th>类型</th>
<th>后缀</th>
</tr>
</thead>
<tbody>
<tr>
<td>UIViewController</td>
<td>VC</td>
</tr>
<tr>
<td>UIView</td>
<td>View</td>
</tr>
<tr>
<td>UILabel</td>
<td>Lbl</td>
</tr>
<tr>
<td>UIButton</td>
<td>Btn</td>
</tr>
<tr>
<td>UIImage</td>
<td>Img</td>
</tr>
<tr>
<td>UIImageView</td>
<td>ImagView </td>
</tr>
<tr>
<td>NSArray</td>
<td>Array</td>
</tr>
<tr>
<td>NSMutableArray</td>
<td>Marray</td>
</tr>
<tr>
<td>NSDictionary</td>
<td>Dict</td>
</tr>
<tr>
<td>NSMutableDictionary</td>
<td>Mdict</td>
</tr>
<tr>
<td>NSString</td>
<td>Str</td>
</tr>
<tr>
<td>NSMutableString</td>
<td>MStr</td>
</tr>
<tr>
<td>NSSet</td>
<td>Set</td>
</tr>
<tr>
<td>NSMutableSet</td>
<td>Mset</td>
</tr>
</tbody>
</table>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><hr>
<h3 id="1-常量以相关类名作为前缀"><a href="#1-常量以相关类名作为前缀" class="headerlink" title="1. 常量以相关类名作为前缀"></a>1. 常量以相关类名作为前缀</h3><p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> ZOCSignInViewControllerFadeOutAnimationDuration = <span class="number">0.4</span>;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSTimeInterval</span> fadeOutTime = <span class="number">0.4</span>;</div></pre></td></tr></table></figure>
<h3 id="2-建议使用类型常量，不建议使用-define预处理命令"><a href="#2-建议使用类型常量，不建议使用-define预处理命令" class="headerlink" title="2. 建议使用类型常量，不建议使用#define预处理命令"></a>2. 建议使用类型常量，不建议使用#define预处理命令</h3><p>首先比较一下这两种声明常量的区别：</p>
<ul>
<li>预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。</li>
<li>类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。</li>
</ul>
<p>使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的：</p>
<ul>
<li>不具备类型信息。</li>
<li>可以被任意修改。</li>
</ul>
<h3 id="3-对外公开某个常量："><a href="#3-对外公开某个常量：" class="headerlink" title="3. 对外公开某个常量："></a>3. 对外公开某个常量：</h3><p>如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串（通知的名称），那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。</p>
<p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头文件</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> ZOCCacheControllerDidClearCacheNotification;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实现文件</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCCacheControllerDidClearCacheNotification = <span class="string">@"ZOCCacheControllerDidClearCacheNotification"</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">CGFloat</span> ZOCImageThumbnailHeight = <span class="number">50.0</span>f;</div></pre></td></tr></table></figure>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define CompanyName @<span class="meta-string">"Apple Inc."</span> </span></div><div class="line"><span class="meta">#define magicNumber 42</span></div></pre></td></tr></table></figure>
<h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><hr>
<h3 id="1-宏、常量名都要使用大写字母，用下划线‘-’分割单词。"><a href="#1-宏、常量名都要使用大写字母，用下划线‘-’分割单词。" class="headerlink" title="1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。"></a>1. 宏、常量名都要使用大写字母，用下划线‘_’分割单词。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define URL_GAIN_QUOTE_LIST @<span class="meta-string">"/v1/quote/list"</span></span></div><div class="line"><span class="meta">#define URL_UPDATE_QUOTE_LIST @<span class="meta-string">"/v1/quote/update"</span></span></div><div class="line"><span class="meta">#define URL_LOGIN  @<span class="meta-string">"/v1/user/login”</span></span></div></pre></td></tr></table></figure>
<h3 id="2-宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。"><a href="#2-宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。" class="headerlink" title="2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。"></a>2. 宏定义中如果包含表达式或变量，表达式和变量必须用小括号括起来。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define MY_MIN(A, B)  ((A)&gt;(B)?(B):(A))</span></div></pre></td></tr></table></figure>
<h2 id="CGRect函数"><a href="#CGRect函数" class="headerlink" title="CGRect函数"></a>CGRect函数</h2><hr>
<p>其实iOS内部已经提供了相应的获取CGRect各个部分的函数了，它们的可读性比较高，而且简短，推荐使用：</p>
<p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame; </div><div class="line"><span class="built_in">CGFloat</span> x = <span class="built_in">CGRectGetMinX</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> y = <span class="built_in">CGRectGetMinY</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> width = <span class="built_in">CGRectGetWidth</span>(frame); </div><div class="line"><span class="built_in">CGFloat</span> height = <span class="built_in">CGRectGetHeight</span>(frame); </div><div class="line"><span class="built_in">CGRect</span> frame = <span class="built_in">CGRectMake</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, width, height);</div></pre></td></tr></table></figure></p>
<p>而不是<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">CGRect</span> frame = <span class="keyword">self</span>.view.frame;  </div><div class="line"><span class="built_in">CGFloat</span> x = frame.origin.x;  </div><div class="line"><span class="built_in">CGFloat</span> y = frame.origin.y;  </div><div class="line"><span class="built_in">CGFloat</span> width = frame.size.width;  </div><div class="line"><span class="built_in">CGFloat</span> height = frame.size.height;  </div><div class="line"><span class="built_in">CGRect</span> frame = (<span class="built_in">CGRect</span>)&#123; .origin = <span class="built_in">CGPointZero</span>, .size = frame.size &#125;;</div></pre></td></tr></table></figure></p>
<h2 id="范型"><a href="#范型" class="headerlink" title="范型"></a>范型</h2><hr>
<p>建议在定义NSArray和NSDictionary时使用泛型，可以保证程序的安全性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *testArr = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Hello"</span>, <span class="string">@"world"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSNumber</span> *&gt; *dic = @&#123;<span class="string">@"key"</span>:@(<span class="number">1</span>), <span class="string">@"age"</span>:@(<span class="number">10</span>)&#125;;</div></pre></td></tr></table></figure>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><hr>
<p>为常用的Block类型创建typedef</p>
<p>如果我们需要重复创建某种block（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value)&#123;</div><div class="line">     // Implementation</div><div class="line">     return someInt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个Block有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型：</p>
<figure class="highlight plain"><figcaption><span>int(^EOCSomeBlock)(BOOL flag, int value);```</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">再次定义的时候，就可以通过简单的赋值来实现：</div></pre></td></tr></table></figure>
<p>EOCSomeBlock block = ^(BOOL flag, int value){<br>     // Implementation<br>};</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">定义作为参数的Block：</div></pre></td></tr></table></figure>
<ul>
<li>(void)startWithCompletionHandler: (void(^)(NSData <em>data, NSError </em>error))completion;</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">这里的Block有一个NSData参数，一个NSError参数并没有返回值</div></pre></td></tr></table></figure>
<p>typedef void(^EOCCompletionHandler)(NSData <em>data, NSError </em>error);</p>
<ul>
<li>(void)startWithCompletionHandler:(EOCCompletionHandler)completion;”<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">通过typedef定义Block签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。</div><div class="line"></div><div class="line"></div><div class="line">## 字面量语法</div><div class="line">---</div><div class="line"></div><div class="line">尽量使用字面量值来创建 NSString , NSDictionary , NSArray , NSNumber 这些不可变对象：</div><div class="line"></div><div class="line">推荐这样写：</div><div class="line">```objc</div><div class="line">NSArray *names = @[@&quot;Brian&quot;, @&quot;Matt&quot;, @&quot;Chris&quot;, @&quot;Alex&quot;, @&quot;Steve&quot;, @&quot;Paul&quot;];</div><div class="line">NSDictionary *productManagers = @&#123;@&quot;iPhone&quot; : @&quot;Kate&quot;, @&quot;iPad&quot; : @&quot;Kamal&quot;, @&quot;Mobile Web&quot; : @&quot;Bill&quot;&#125;; </div><div class="line">NSNumber *shouldUseLiterals = @YES;NSNumber *buildingZIPCode = @10018;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *names = [<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"Brian"</span>, <span class="string">@"Matt"</span>, <span class="string">@"Chris"</span>, <span class="string">@"Alex"</span>, <span class="string">@"Steve"</span>, <span class="string">@"Paul"</span>, <span class="literal">nil</span>];</div><div class="line"><span class="built_in">NSDictionary</span> *productManagers = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys: <span class="string">@"Kate"</span>, <span class="string">@"iPhone"</span>, <span class="string">@"Kamal"</span>, <span class="string">@"iPad"</span>, <span class="string">@"Bill"</span> ];</div><div class="line"><span class="built_in">NSNumber</span> *shouldUseLiterals = [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>];<span class="built_in">NSNumber</span> *buildingZIPCode = [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">10018</span>];</div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><hr>
<h3 id="1-属性的命名使用小驼峰"><a href="#1-属性的命名使用小驼峰" class="headerlink" title="1. 属性的命名使用小驼峰"></a>1. 属性的命名使用小驼峰</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIButton</span> *confirmButton;</div></pre></td></tr></table></figure>
<h3 id="2-属性的关键字推荐按照-原子性，读写，内存管理的顺序排列"><a href="#2-属性的关键字推荐按照-原子性，读写，内存管理的顺序排列" class="headerlink" title="2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列"></a>2. 属性的关键字推荐按照 原子性，读写，内存管理的顺序排列</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">strong</span>) <span class="built_in">UIView</span> *headerView;</div></pre></td></tr></table></figure>
<h3 id="3-Block属性应该使用copy关键字"><a href="#3-Block属性应该使用copy关键字" class="headerlink" title="3. Block属性应该使用copy关键字"></a>3. Block属性应该使用copy关键字</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^ErrorCodeBlock) (<span class="keyword">id</span> errorCode,<span class="built_in">NSString</span> *message);</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) ErrorCodeBlock errorBlock;<span class="comment">//将block拷贝到堆中</span></div></pre></td></tr></table></figure>
<h3 id="4-形容词性的BOOL属性的getter应该加上is前缀"><a href="#4-形容词性的BOOL属性的getter应该加上is前缀" class="headerlink" title="4. 形容词性的BOOL属性的getter应该加上is前缀"></a>4. 形容词性的BOOL属性的getter应该加上is前缀</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">getter</span>=isEditable) <span class="built_in">BOOL</span> editable;</div></pre></td></tr></table></figure>
<h3 id="5-使用getter方法做懒加载"><a href="#5-使用getter方法做懒加载" class="headerlink" title="5. 使用getter方法做懒加载"></a>5. 使用getter方法做懒加载</h3><p>实例化一个对象是需要耗费资源的，如果这个对象里的某个属性的实例化要调用很多配置和计算，就需要懒加载它，在使用它的前一刻对它进行实例化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSDateFormatter</span> *)dateFormatter &#123;</div><div class="line">    <span class="keyword">if</span> (!_dateFormatter) &#123;</div><div class="line">           _dateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">           <span class="built_in">NSLocale</span> *enUSPOSIXLocale = [[<span class="built_in">NSLocale</span> alloc] initWithLocaleIdentifier:<span class="string">@"en_US_POSIX"</span>];</div><div class="line">           [_dateFormatter setLocale:enUSPOSIXLocale];</div><div class="line">           [_dateFormatter setDateFormat:<span class="string">@"yyyy-MM-dd'T'HH:mm:ss.SSS"</span>];</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> _dateFormatter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是也有对这种做法的争议：getter方法可能会产生某些副作用，例如如果它修改了全局变量，可能会产生难以排查的错误。</p>
<h3 id="6-除了init和dealloc方法，建议都使用点语法访问属性"><a href="#6-除了init和dealloc方法，建议都使用点语法访问属性" class="headerlink" title="6. 除了init和dealloc方法，建议都使用点语法访问属性"></a>6. 除了init和dealloc方法，建议都使用点语法访问属性</h3><p>使用点语法的好处：</p>
<h4 id="setter："><a href="#setter：" class="headerlink" title="setter："></a>setter：</h4><ol>
<li>setter会遵守内存管理语义(strong, copy, weak)。</li>
<li>通过在内部设置断点，有助于调试bug。</li>
<li>可以过滤一些外部传入的值。</li>
<li>捕捉KVO通知。</li>
</ol>
<h4 id="getter："><a href="#getter：" class="headerlink" title="getter："></a>getter：</h4><ol>
<li>允许子类化。</li>
<li>通过在内部设置断点，有助于调试bug。</li>
<li>实现懒加载（lazy initialization）。</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>懒加载的属性，必须通过点语法来读取数据。因为懒加载是通过重写getter方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。</li>
<li>在init和dealloc方法里面使用点语法的后果是：因为没有绕过setter和getter，在setter和getter里面可能会有很多其他的操作。而且如果它的子类重载了它的setter和getter方法，那么就可能导致该子类调用其他的方法。</li>
</ol>
</blockquote>
<h3 id="7-不要滥用点语法，要区分好方法调用和属性访问"><a href="#7-不要滥用点语法，要区分好方法调用和属性访问" class="headerlink" title="7. 不要滥用点语法，要区分好方法调用和属性访问"></a>7. 不要滥用点语法，要区分好方法调用和属性访问</h3><p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">view.backgroundColor = [<span class="built_in">UIColor</span> orangeColor]; </div><div class="line">[<span class="built_in">UIApplication</span> sharedApplication].delegate;</div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[view setBackgroundColor:[<span class="built_in">UIColor</span> orangeColor]]; </div><div class="line"><span class="built_in">UIApplication</span>.sharedApplication.delegate;</div></pre></td></tr></table></figure>
<h3 id="8-尽量使用不可变对象"><a href="#8-尽量使用不可变对象" class="headerlink" title="8. 尽量使用不可变对象"></a>8. 尽量使用不可变对象</h3><p>建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是：</p>
<ul>
<li>在头文件中，设置对象属性为<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- 在实现文件中设置为```readwrite```。</div><div class="line"></div><div class="line">这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。</div><div class="line"></div><div class="line">如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。所以当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本,例如：</div><div class="line"></div><div class="line">在公共API中：</div></pre></td></tr></table></figure></li>
</ul>
<p>@interface EOCPerson : NSObject</p>
<p>@property (nonatomic, copy, readonly) NSString <em>firstName;<br>@property (nonatomic, copy, readonly) NSString </em>lastName;<br>@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合</p>
<ul>
<li>(id)initWithFirstName:(NSString<em>)firstName andLastName:(NSString</em>)lastName;</li>
<li>(void)addFriend:(EOCPerson*)person;</li>
<li>(void)removeFriend:(EOCPerson*)person;</li>
</ul>
<p>@end</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。</div><div class="line"></div><div class="line">在实现文件里：</div></pre></td></tr></table></figure>
<p>@interface EOCPerson ()</p>
<p>@property (nonatomic, copy, readwrite) NSString <em>firstName;<br>@property (nonatomic, copy, readwrite) NSString </em>lastName;</p>
<p>@end</p>
<p>@implementation EOCPerson {<br>     NSMutableSet *_internalFriends;  //实现文件里的可变集合<br>}</p>
<ul>
<li><p>(NSSet*)friends {<br>   return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型<br>}</p>
</li>
<li><p>(void)addFriend:(EOCPerson*)person {<br>  [_internalFriends addObject:person]; //在外部增加集合元素的操作<br>  //do something when add element<br>}</p>
</li>
<li><p>(void)removeFriend:(EOCPerson*)person {<br>  [_internalFriends removeObject:person]; //在外部移除元素的操作<br>  //do something when remove element<br>}</p>
</li>
<li><p>(id)initWithFirstName:(NSString<em>)firstName andLastName:(NSString</em>)lastName {</p>
<p>   if ((self = [super init])) {</p>
<pre><code>_firstName = firstName;
_lastName = lastName;
_internalFriends = [NSMutableSet new];
</code></pre><p>  }<br>return self;<br>}</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">我们可以看到，在实现文件里，保存一个可变set来记录外部的增删操作。</div><div class="line"></div><div class="line">这里最重要的代码是：</div></pre></td></tr></table></figure>
<ul>
<li>(NSSet*)friends {<br>return [_internalFriends copy];<br>}<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;这个是friends属性的获取方法：它将当前保存的可变set复制了一不可变的set并返回。因此，外部读取到的set都将是不可变的版本。</div><div class="line"></div><div class="line">## 方法</div><div class="line">----</div><div class="line"></div><div class="line">### 1. 方法名中不应使用and，而且签名要与对应的参数名保持高度一致</div><div class="line"></div><div class="line">推荐这样写：</div><div class="line"></div><div class="line">```objc</div><div class="line">- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithWidth:(<span class="built_in">CGFloat</span>)width andHeight:(<span class="built_in">CGFloat</span>)height;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWith:(<span class="keyword">int</span>)width and:(<span class="keyword">int</span>)height;</div></pre></td></tr></table></figure>
<h3 id="2-方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。"><a href="#2-方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。" class="headerlink" title="2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。"></a>2. 方法实现时，如果参数过长，则令每个参数占用一行，以冒号对齐。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)doSomethingWith:(<span class="built_in">NSString</span> *)theFoo</div><div class="line">                   rect:(<span class="built_in">CGRect</span>)theRect</div><div class="line">               interval:(<span class="built_in">CGFloat</span>)theInterval</div><div class="line">&#123;</div><div class="line">   <span class="comment">//Implementation</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-私有方法应该在实现文件中申明。"><a href="#3-私有方法应该在实现文件中申明。" class="headerlink" title="3. 私有方法应该在实现文件中申明。"></a>3. 私有方法应该在实现文件中申明。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></div><div class="line">- (<span class="keyword">void</span>)basicConfiguration;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></div><div class="line">- (<span class="keyword">void</span>)basicConfiguration</div><div class="line">&#123;</div><div class="line">   <span class="comment">//Do some basic configuration</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="4-方法名用小写字母开头的单词组合而成"><a href="#4-方法名用小写字母开头的单词组合而成" class="headerlink" title="4. 方法名用小写字母开头的单词组合而成"></a>4. 方法名用小写字母开头的单词组合而成</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span> *)descriptionWithLocale:(<span class="keyword">id</span>)locale;</div></pre></td></tr></table></figure>
<h3 id="5-方法名前缀"><a href="#5-方法名前缀" class="headerlink" title="5. 方法名前缀"></a>5. 方法名前缀</h3><ul>
<li>刷新视图的方法名要以<code>refresh</code>为首。</li>
<li>更新数据的方法名要以<code>update</code>为首。</li>
</ul>
<p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)refreshHeaderViewWithCount:(<span class="built_in">NSUInteger</span>)count;</div><div class="line">- (<span class="keyword">void</span>)updateDataSourceWithViewModel:(ViewModel*)viewModel;</div></pre></td></tr></table></figure>
<h2 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h2><hr>
<p>如果某些功能（方法）具备可复用性，我们就需要将它们抽取出来放入一个抽象接口文件中（在iOS中，抽象接口即协议），让不同类型的对象遵循这个协议，从而拥有相同的功能。</p>
<p>因为协议是不依赖于某个对象的，所以通过协议，我们可以解开两个对象之间的耦合。如何理解呢？我们来看一下下面这个例子：</p>
<p>现在有一个需求：在一个<code>UITableViewController</code>里面拉取feed并展示出来。</p>
<h3 id="方案一："><a href="#方案一：" class="headerlink" title="方案一："></a>方案一：</h3><p>定义一个拉取feed的类<code>ZOCFeedParser</code>，这个类有一些代理方法实现feed相关功能：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)feedParserDidStart:(ZOCFeedParser *)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; </div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didParseFeedItem:(ZOCFeedItemDTO *)item; </div><div class="line">- (<span class="keyword">void</span>)feedParserDidFinish:(ZOCFeedParser *)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(ZOCFeedParser *)parser didFailWithError:(<span class="built_in">NSError</span> *)error;<span class="keyword">@end</span> </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCFeedParser</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;ZOCFeedParserDelegate&gt; delegate; </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> *url; </div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url; </div><div class="line">- (<span class="built_in">BOOL</span>)start; </div><div class="line">- (<span class="keyword">void</span>)stop; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>然后在<code>ZOCTableViewController</code>里面传入<code>ZOCFeedParser</code>，并遵循其代理方法，实现feed的拉取功能。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCTableViewController</span> : <span class="title">UITableViewController</span>&lt;<span class="title">ZOCFeedParserDelegate</span>&gt;</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFeedParser:(ZOCFeedParser *)feedParser; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>具体应用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span> *feedURL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://bbc.co.uk/feed.rss"</span>]; </div><div class="line">ZOCFeedParser *feedParser = [[ZOCFeedParser alloc] initWithURL:feedURL]; </div><div class="line">ZOCTableViewController *tableViewController = [[ZOCTableViewController alloc] initWithFeedParser:feedParser]; </div><div class="line">feedParser.delegate = tableViewController;</div></pre></td></tr></table></figure>
<p>OK，现在我们实现了需求：在<code>ZOCTableViewController</code>里面存放了一个<code>ZOCFeedParser</code>对象来处理feed的拉取功能。</p>
<p>但这里有一个严重的耦合问题：<code>ZOCTableViewController</code>只能通过<code>ZOCFeedParser</code>对象来处理feed的拉取功能。<br>于是我们重新审视一下这个需求：其实我们实际上只需要<code>ZOCTableViewController</code>拉取feed就可以了，而具体是由哪个对象来拉取，<code>ZOCTableViewController</code>并不需要关心。</p>
<p>也就是说，我们需要提供给<code>ZOCTableViewController</code>的是一个更范型的对象，这个对象具备了拉取feed的功能就好了，而不应该仅仅局限于某个具体的对象（<code>ZOCFeedParser</code>）。所以，刚才的设计需要重新做一次修改：</p>
<h3 id="方案二："><a href="#方案二：" class="headerlink" title="方案二："></a>方案二：</h3><p>首先需要在一个接口文件<code>ZOCFeedParserProtocol.h</code>里面定义抽象的，具有拉取feed功能的协议：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)feedParserDidStart:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedInfo:(ZOCFeedInfoDTO *)info; </div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didParseFeedItem:(ZOCFeedItemDTO *)item; </div><div class="line">- (<span class="keyword">void</span>)feedParserDidFinish:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser;</div><div class="line">- (<span class="keyword">void</span>)feedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)parser didFailWithError:(<span class="built_in">NSError</span> *)error;<span class="keyword">@end</span> </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCFeedParserProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;ZOCFeedParserDelegate&gt; delegate; </div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURL</span> *url;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)start;</div><div class="line">- (<span class="keyword">void</span>)stop;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>而原来的<code>ZOCFeedParser</code>仅仅是需要遵循上面这个协议就具备了拉取feed的功能：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCFeedParser</span> : <span class="title">NSObject</span> &lt;<span class="title">ZOCFeedParserProtocol</span>&gt; </span></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span> *)url;<span class="comment">//仅仅需要通过传入url即可，其他事情都交给ZOCFeedParserProtocol@end</span></div></pre></td></tr></table></figure>
<p>而且，<code>ZOCTableViewController</code>也不直接依赖于<code>ZOCFeedParser</code>对象，我们只需要传给它一个遵循<code>&lt;ZOCFeedParserProtocol&gt;</code>的对象即可。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCTableViewController</span> : <span class="title">UITableViewController</span> &lt;<span class="title">ZOCFeedParserDelegate</span>&gt;</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithFeedParser:(<span class="keyword">id</span>&lt;ZOCFeedParserProtocol&gt;)feedParser;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>这样一来，<code>ZOCTableViewController</code>和<code>ZOCFeedParser</code>之间就没有直接的关系了。以后，如果我们想：</p>
<ul>
<li>给这个feed拉取器增加新的功能：仅需要修改<code>ZOCFeedParserProtocol.h</code>文件。</li>
<li>更换一个feed拉取器实例：创建一个新类型来遵循<code>ZOCFeedParserProtocol.h</code>即可。</li>
</ul>
<h2 id="iOS-中委托的设计"><a href="#iOS-中委托的设计" class="headerlink" title="iOS 中委托的设计"></a>iOS 中委托的设计</h2><hr>
<h3 id="1-要区分好代理和数据源的区别"><a href="#1-要区分好代理和数据源的区别" class="headerlink" title="1. 要区分好代理和数据源的区别"></a>1. 要区分好代理和数据源的区别</h3><p>在iOS开发中的委托模式包含了delegate（代理）和datasource（数据源）。虽然二者同属于委托模式，但是这两者是有区别的。这个区别就是二者的信息流方向是不同的：</p>
<ul>
<li>delegate ：事件发生的时候，委托者需要通知代理。（信息流从委托者到代理）</li>
<li>datasource：委托者需要从数据源拉取数据。（信息流从数据源到委托者）</li>
</ul>
<p>然而包括苹果也没有做好榜样，将它们彻底的区分开。就拿UITableView来说，在它的delegate方法中有一个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div></pre></td></tr></table></figure></p>
<p>这个方法正确地体现了代理的作用：委托者（tableview）告诉代理（控制器）“我的某个cell被点击了”。但是，UITableViewDelegate的方法列表里还有这个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div></pre></td></tr></table></figure>
<p>该方法的作用是 由控制器来告诉tabievlew的行高，也就是说，它的信息流是从控制器（数据源）到委托者（tableview）的。准确来讲，它应该是一个数据源方法，而不是代理方法。</p>
<p>在UITableViewDataSource中，就有标准的数据源方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView;</div></pre></td></tr></table></figure>
<p>这个方法的作用就是让tableview向控制器拉取一个section数量的数据。</p>
<p>所以，在我们设计一个视图控件的代理和数据源时，一定要区分好二者的区别，合理地划分哪些方法属于代理方法，哪些方法属于数据源方法。</p>
<h3 id="2-代理方法的第一个参数必须为委托者"><a href="#2-代理方法的第一个参数必须为委托者" class="headerlink" title="2. 代理方法的第一个参数必须为委托者"></a>2. 代理方法的第一个参数必须为委托者</h3><p>代理方法必须以委托者作为第一个参数（参考UITableViewDelegate）的方法。其目的是为了区分不同委托着的实例。因为同一个控制器是可以作为多个tableview的代理的。若要区分到底是哪个tableview的cell被点击了，就需要在``</p>
<ul>
<li>(void)tableView:(UITableView <em>)tableView didSelectRowAtIndexPath:(NSIndexPath </em>)indexPath``方法中做个区分。</li>
</ul>
<h3 id="向代理发送消息时需要判断其是否实现该方法"><a href="#向代理发送消息时需要判断其是否实现该方法" class="headerlink" title="向代理发送消息时需要判断其是否实现该方法"></a>向代理发送消息时需要判断其是否实现该方法</h3><p>最后，在委托着向代理发送消息的时候，需要判断委托着是否实现了这个代理方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(signUpViewControllerDidPressSignUpButton:)]) &#123; </div><div class="line"> [<span class="keyword">self</span>.delegate signUpViewControllerDidPressSignUpButton:<span class="keyword">self</span>]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-遵循代理过多的时候，换行对齐显示"><a href="#3-遵循代理过多的时候，换行对齐显示" class="headerlink" title="3. 遵循代理过多的时候，换行对齐显示"></a>3. 遵循代理过多的时候，换行对齐显示</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ShopViewController</span> () &lt;<span class="title">UIGestureRecognizerDelegate</span>,</span></div><div class="line">                                  HXSClickEventDelegate,</div><div class="line">                                  <span class="built_in">UITableViewDelegate</span>,</div><div class="line">                                  <span class="built_in">UITableViewDataSource</span>&gt;</div></pre></td></tr></table></figure>
<h3 id="4-代理的方法需要明确必须执行和可不执行"><a href="#4-代理的方法需要明确必须执行和可不执行" class="headerlink" title="4. 代理的方法需要明确必须执行和可不执行"></a>4. 代理的方法需要明确必须执行和可不执行</h3><p>代理方法在默认情况下都是必须执行的，然而在设计一组代理方法的时候，有些方法可以不是必须执行（是因为存在默认配置），这些方法就需要使用<code>@optional</code>关键字来修饰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">ZOCServiceDelegate</span> &lt;<span class="title">NSObject</span>&gt;@<span class="title">optional</span>- (<span class="title">void</span>)<span class="title">generalService</span>:(<span class="title">ZOCGeneralService</span> *)<span class="title">service</span> <span class="title">didRetrieveEntries</span>:(<span class="title">NSArray</span> *)<span class="title">entries</span>; </span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><hr>
<h3 id="1-类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间"><a href="#1-类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间" class="headerlink" title="1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间"></a>1. 类的名称应该以三个大写字母为前缀；创建子类的时候，应该把代表子类特点的部分放在前缀和父类名的中间</h3><p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//父类</span></div><div class="line">ZOCSalesListViewController</div><div class="line"></div><div class="line"><span class="comment">//子类</span></div><div class="line">ZOCDaySalesListViewController</div><div class="line">ZOCMonthSalesListViewController</div></pre></td></tr></table></figure></p>
<h3 id="2-initializer-amp-amp-dealloc"><a href="#2-initializer-amp-amp-dealloc" class="headerlink" title="2. initializer &amp;&amp; dealloc"></a>2. initializer &amp;&amp; dealloc</h3><p>推荐：</p>
<ul>
<li>将 dealloc 方法放在实现文件的最前面</li>
<li>将init方法放在dealloc方法后面。如果有多个初始化方法，应该将指定初始化方法放在最前面，其他初始化方法放在其后。</li>
</ul>
<h4 id="2-1-dealloc方法里面应该直接访问实例变量，不应该用点语法访问"><a href="#2-1-dealloc方法里面应该直接访问实例变量，不应该用点语法访问" class="headerlink" title="2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问"></a>2.1 dealloc方法里面应该直接访问实例变量，不应该用点语法访问</h4><h4 id="2-2-init方法的写法："><a href="#2-2-init方法的写法：" class="headerlink" title="2.2 init方法的写法："></a>2.2 init方法的写法：</h4><ul>
<li>init方法返回类型必须是instancetype，不能是id。</li>
<li>必须先实现[super init]。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init &#123; </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; <span class="comment">// call the designated initializer </span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123; </div><div class="line">        <span class="comment">// Custom initialization </span></div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-3-指定初始化方法"><a href="#2-3-指定初始化方法" class="headerlink" title="2.3 指定初始化方法"></a>2.3 指定初始化方法</h4><p>指定初始化方法(designated initializer)是提供所有的（最多的）参数的初始化方法，间接初始化方法(secondary initializer)有一个或部分参数的初始化方法。</p>
<p>注意事项1：间接初始化方法必须调用指定初始化方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZOCEvent</span> </span></div><div class="line"></div><div class="line"><span class="comment">//指定初始化方法</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title date:(<span class="built_in">NSDate</span> *)date </div><div class="line">location:(<span class="built_in">CLLocation</span> *)location</div><div class="line">&#123; </div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init]; </div><div class="line">      <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">         _title = title; </div><div class="line">         _date = date; </div><div class="line">         _location = location; </div><div class="line">      &#125; </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">//间接初始化方法</span></div><div class="line">-  (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title date:(<span class="built_in">NSDate</span> *)date</div><div class="line">&#123; </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithTitle:title date:date location:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//间接初始化方法</span></div><div class="line">-  (<span class="keyword">instancetype</span>)initWithTitle:(<span class="built_in">NSString</span> *)title </div><div class="line">&#123; </div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithTitle:title date:[<span class="built_in">NSDate</span> date] location:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"> <span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>注意事项2：如果直接父类有指定初始化方法，则必须调用其指定初始化方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:nibNameOrNil bundle:nibBundleOrNil]; </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意事项3：如果想在当前类自定义一个新的全能初始化方法，则需要如下几个步骤</p>
<ol>
<li>定义新的指定初始化方法，并确保调用了直接父类的初始化方法。</li>
<li>重载直接父类的初始化方法，在内部调用新定义的指定初始化方法。</li>
<li>为新的指定初始化方法写文档。</li>
</ol>
<p>看一个标准的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ZOCNewsViewController</span></span></div><div class="line"></div><div class="line"><span class="comment">//新的指定初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithNews:(ZOCNews *)news &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithNibName:<span class="literal">nil</span> bundle:<span class="literal">nil</span>]; </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _news = news;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="comment">// 重载父类的初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithNibName:(<span class="built_in">NSString</span> *)nibNameOrNil bundle:(<span class="built_in">NSBundle</span> *)nibBundleOrNil&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithNews:<span class="literal">nil</span>]; </div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这里，重载父类的初始化方法并在内部调用新定义的指定初始化方法的原因是你不能确定调用者调用的就一定是你定义的这个新的指定初始化方法，而不是原来从父类继承来的指定初始化方法。</p>
<p>假设你没有重载父类的指定初始化方法，而调用者却恰恰调用了父类的初始化方法。那么调用者可能永远都调用不到你自己定义的新指定初始化方法了。</p>
<p>而如果你成功定义了一个新的指定初始化方法并能保证调用者一定能调用它，你最好要在文档中明确写出哪一个才是你定义的新初始化方法。或者你也可以使用编译器指令<code>__attribute__((objc_designated_initializer))</code>来标记它。</p>
<h3 id="3-所有返回类对象和实例对象的方法都应该使用instancetype"><a href="#3-所有返回类对象和实例对象的方法都应该使用instancetype" class="headerlink" title="3. 所有返回类对象和实例对象的方法都应该使用instancetype"></a>3. 所有返回类对象和实例对象的方法都应该使用instancetype</h3><p>将instancetype关键字作为返回值的时候，可以让编译器进行类型检查，同时适用于子类的检查，这样就保证了返回类型的正确性（一定为当前的类对象或实例对象）</p>
<p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCPerson</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)personWithName:(<span class="built_in">NSString</span> *)name; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ZOCPerson</span></span></div><div class="line">+ (<span class="keyword">id</span>)personWithName:(<span class="built_in">NSString</span> *)name; </div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="4-在类的头文件中尽量少引用其他头文件"><a href="#4-在类的头文件中尽量少引用其他头文件" class="headerlink" title="4. 在类的头文件中尽量少引用其他头文件"></a>4. 在类的头文件中尽量少引用其他头文件</h3><p>有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// EOCPerson.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">EOCEmployer</span>;</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EOCEmployer *employer;<span class="comment">//将EOCEmployer作为属性</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// EOCPerson.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"EOCEmployer.h"</span></span></div></pre></td></tr></table></figure>
<p>这样做有什么优点呢：</p>
<blockquote>
<ul>
<li>不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。</li>
<li>可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。</li>
</ul>
</blockquote>
<p>但是个别的时候，必须在头文件中引入其他类的头文件:</p>
<blockquote>
<p>主要有两种情况：</p>
<ol>
<li>该类继承于某个类，则应该引入父类的头文件。</li>
<li>该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。</li>
</ol>
</blockquote>
<h3 id="5-类的布局"><a href="#5-类的布局" class="headerlink" title="5. 类的布局"></a>5. 类的布局</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">#pragma mark - Life Cycle Methods</span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewDidAppear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewWillDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line">- (<span class="keyword">void</span>)viewDidDisappear:(<span class="built_in">BOOL</span>)animated</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Override Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Intial Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Network Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Target Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Public Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Private Methods</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - UITableViewDataSource  </span></div><div class="line"><span class="meta">#pragma mark - UITableViewDelegate  </span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Lazy Loads</span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSCopying  </span></div><div class="line"></div><div class="line"><span class="meta">#pragma mark - NSObject  Methods</span></div></pre></td></tr></table></figure>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><hr>
<h3 id="1-分类添加的方法需要添加前缀和下划线"><a href="#1-分类添加的方法需要添加前缀和下划线" class="headerlink" title="1. 分类添加的方法需要添加前缀和下划线"></a>1. 分类添加的方法需要添加前缀和下划线</h3><p>推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">ZOCTimeExtensions</span>)</span></div><div class="line"> - (<span class="built_in">NSString</span> *)zoc_timeAgoShort;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>不推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSDate</span> (<span class="title">ZOCTimeExtensions</span>) </span></div><div class="line">- (<span class="built_in">NSString</span> *)timeAgoShort;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h3 id="2-把类的实现代码分散到便于管理的多个分类中"><a href="#2-把类的实现代码分散到便于管理的多个分类中" class="headerlink" title="2. 把类的实现代码分散到便于管理的多个分类中"></a>2. 把类的实现代码分散到便于管理的多个分类中</h3><p>一个类可能会有很多公共方法，而且这些方法往往可以用某种特有的逻辑来分组。我们可以利用Objecctive-C的分类机制，将类的这些方法按一定的逻辑划入几个分区中。</p>
<p>举个🌰：</p>
<p>先看一个没有使用无分类的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSArray *friends;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">/* Friendship methods */</div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">/* Work methods */</div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line"></div><div class="line">/* Play methods */</div><div class="line">- (void)goToTheCinema;</div><div class="line">- (void)goToSportsGame;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>分类之后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCPerson : NSObject</div><div class="line"></div><div class="line">@property (nonatomic, copy, readonly) NSString *firstName;</div><div class="line">@property (nonatomic, copy, readonly) NSString *lastName;</div><div class="line">@property (nonatomic, strong, readonly) NSArray *friends;</div><div class="line"></div><div class="line">- (id)initWithFirstName:(NSString*)firstName</div><div class="line"></div><div class="line">andLastName:(NSString*)lastName;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Work)</div><div class="line"></div><div class="line">- (void)performDaysWork;</div><div class="line">- (void)takeVacationFromWork;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCPerson (Play)</div><div class="line"></div><div class="line">- (void)goToTheCinema;</div><div class="line">- (void)goToSportsGame;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>其中，FriendShip分类的实现代码可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// EOCPerson+Friendship.h</div><div class="line">#import &quot;EOCPerson.h&quot;</div><div class="line"></div><div class="line">@interface EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person;</div><div class="line">- (void)removeFriend:(EOCPerson*)person;</div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">// EOCPerson+Friendship.m</div><div class="line">#import &quot;EOCPerson+Friendship.h&quot;</div><div class="line"></div><div class="line">@implementation EOCPerson (Friendship)</div><div class="line"></div><div class="line">- (void)addFriend:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)removeFriend:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (BOOL)isFriendsWith:(EOCPerson*)person &#123;</div><div class="line"> /* ... */</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在新建分类文件时，一定要引入被分类的类文件。</p>
</blockquote>
<p>通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。</p>
<p>利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。</p>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><hr>
<h3 id="1-单例不能作为容器对象来使用"><a href="#1-单例不能作为容器对象来使用" class="headerlink" title="1. 单例不能作为容器对象来使用"></a>1. 单例不能作为容器对象来使用</h3><p>单例对象不应该暴露出任何属性，也就是说它不能作为让外部存放对象的容器。它应该是一个处理某些特定任务的工具，比如在iOS中的GPS和加速度传感器。我们只能从他们那里得到一些特定的数据。</p>
<h3 id="2-使用dispatch-once来生成单例"><a href="#2-使用dispatch-once来生成单例" class="headerlink" title="2. 使用dispatch_once来生成单例"></a>2. 使用dispatch_once来生成单例</h3><p>推荐这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123; </div><div class="line"> <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance = <span class="literal">nil</span>; </div><div class="line"> <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken = <span class="number">0</span>;</div><div class="line">       <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </div><div class="line">  sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">  &#125;); </div><div class="line"> <span class="keyword">return</span> sharedInstance; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不推荐这样写：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)sharedInstance &#123; </div><div class="line"> <span class="keyword">static</span> <span class="keyword">id</span> sharedInstance; </div><div class="line"> <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123; </div><div class="line"> <span class="keyword">if</span> (sharedInstance == <span class="literal">nil</span>) &#123;  sharedInstance = [[MyClass alloc] init]; </div><div class="line"> &#125; &#125; </div><div class="line"> <span class="keyword">return</span> sharedInstance; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="相等性的判断"><a href="#相等性的判断" class="headerlink" title="相等性的判断"></a>相等性的判断</h2><hr>
<p>判断两个person类是否相等的合理做法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-  (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> == object) &#123;  <span class="keyword">return</span> <span class="literal">YES</span>; <span class="comment">//判断内存地址</span></div><div class="line"> &#125; </div><div class="line">  <span class="keyword">if</span> (![object isKindOfClass:[ZOCPerson <span class="keyword">class</span>]]) &#123; </div><div class="line">     <span class="keyword">return</span> <span class="literal">NO</span>; <span class="comment">//是否为当前类或派生类 &#125; </span></div><div class="line"> <span class="keyword">return</span> [<span class="keyword">self</span> isEqualToPerson:(ZOCPerson *)object]; </div><div class="line"> </div><div class="line">&#125;</div><div class="line"><span class="comment">//自定义的判断相等性的方法</span></div><div class="line">-  (<span class="built_in">BOOL</span>)isEqualToPerson:(Person *)person &#123; </div><div class="line">        <span class="keyword">if</span> (!person) &#123;  <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">  &#125; <span class="built_in">BOOL</span> namesMatch = (!<span class="keyword">self</span>.name &amp;&amp; !person.name) || [<span class="keyword">self</span>.name isEqualToString:person.name]; <span class="built_in">BOOL</span> birthdaysMatch = (!<span class="keyword">self</span>.birthday &amp;&amp; !person.birthday) || [<span class="keyword">self</span>.birthday isEqualToDate:person.birthday]; <span class="keyword">return</span> haveEqualNames &amp;&amp; haveEqualBirthdays; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="方法文档"><a href="#方法文档" class="headerlink" title="方法文档"></a>方法文档</h2><hr>
<p>一个函数(方法)必须有一个字符串文档来解释，除非它：</p>
<ul>
<li>非公开，私有函数。</li>
<li>很短。</li>
<li>显而易见。</li>
</ul>
<p>而其余的，包括公开接口，重要的方法，分类，以及协议，都应该伴随文档（注释）：</p>
<ul>
<li>以/开始</li>
<li>第二行识总结性的语句</li>
<li>第三行永远是空行</li>
<li>在与第二行开头对齐的位置写剩下的注释。</li>
</ul>
<p>建议这样写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/This comment serves to demonstrate the format of a doc string.</div><div class="line"></div><div class="line">Note that the summary line is always at most one line <span class="keyword">long</span>, and after the opening block comment,</div><div class="line">and each line of text is preceded by a single space.</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>看一个指定初始化方法的注释：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/ </div><div class="line">  *  Designated initializer. *</div><div class="line">  *  @param store The store <span class="keyword">for</span> CRUD operations.</div><div class="line">  *  @param searchService The search service used to query the store. </div><div class="line">  *  @return A ZOCCRUDOperationsStore object.</div><div class="line">  */ </div><div class="line">- (<span class="keyword">instancetype</span>)initWithOperationsStore:(<span class="keyword">id</span>&lt;ZOCGenericStoreProtocol&gt;)store searchService:(<span class="keyword">id</span>&lt;ZOCGenericSearchServiceProtocol&gt;)searchService;</div></pre></td></tr></table></figure></p>
<h3 id="多用队列，少用同步锁来避免资源抢夺"><a href="#多用队列，少用同步锁来避免资源抢夺" class="headerlink" title="多用队列，少用同步锁来避免资源抢夺"></a>多用队列，少用同步锁来避免资源抢夺</h3><hr>
<p>多个线程执行同一份代码时，很可能会造成数据不同步。建议使用GCD来为代码加锁的方式解决这个问题。</p>
<h4 id="方案一：使用串行同步队列来将读写操作都安排到同一个队列里："><a href="#方案一：使用串行同步队列来将读写操作都安排到同一个队列里：" class="headerlink" title="方案一：使用串行同步队列来将读写操作都安排到同一个队列里："></a>方案一：使用串行同步队列来将读写操作都安排到同一个队列里：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_queue_create(<span class="string">"com.effectiveobjectivec.syncQueue"</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="comment">//读取字符串</span></div><div class="line">- (<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">         __block <span class="built_in">NSString</span> *localSomeString;</div><div class="line">         <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">            localSomeString = _someString;</div><div class="line">        &#125;);</div><div class="line">         <span class="keyword">return</span> localSomeString;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//设置字符串</span></div><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，读写操作都在串行队列进行，就不容易出错。</p>
<p>但是，还有一种方法可以让性能更高：</p>
<h4 id="方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"><a href="#方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。" class="headerlink" title="方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"></a>方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"></div><div class="line"><span class="comment">//读取字符串</span></div><div class="line">- (<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     __block <span class="built_in">NSString</span> *localSomeString;</div><div class="line">     <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">     <span class="keyword">return</span> localSomeString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置字符串</span></div><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span>*)someString &#123;</div><div class="line"></div><div class="line">     dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。<br>这里的<code>dispatch_barrier_async</code>方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。</p>
<h2 id="实现description方法打印自定义对象信息"><a href="#实现description方法打印自定义对象信息" class="headerlink" title="实现description方法打印自定义对象信息"></a>实现description方法打印自定义对象信息</h2><hr>
<p>在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：<code>object = &lt;EOCPerson: 0x7fd9a1600600&gt;</code></p>
<p>这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。</p>
<p>但是！如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。</p>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)description &#123;</div><div class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p, %@ %@&gt;"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>, firstName, lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，显示了内存地址，还有该类的所有属性。</p>
<p>而且，如果我们将这些属性值放在字典里打印，则更具有可读性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)description &#123;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p, %@&gt;"</span>,[<span class="keyword">self</span> <span class="keyword">class</span>],<span class="keyword">self</span>,</div><div class="line">   </div><div class="line">    @&#123;    <span class="string">@"title"</span>:_title,</div><div class="line">       <span class="string">@"latitude"</span>:@(_latitude),</div><div class="line">      <span class="string">@"longitude"</span>:@(_longitude)&#125;</div><div class="line">    ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">location = &lt;EOCLocation: <span class="number">0x7f98f2e01d20</span>, &#123;</div><div class="line"></div><div class="line">    latitude = <span class="string">"51.506"</span>;</div><div class="line">   longitude = <span class="number">0</span>;</div><div class="line">       title = London;</div><div class="line">&#125;&gt;</div></pre></td></tr></table></figure>
<p>我们可以看到，通过重写<code>description</code>方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。</p>
<h2 id="NSArray-amp-NSMutableArray"><a href="#NSArray-amp-NSMutableArray" class="headerlink" title="NSArray&amp; NSMutableArray"></a>NSArray&amp; NSMutableArray</h2><hr>
<h3 id="1-addObject之前要非空判断。"><a href="#1-addObject之前要非空判断。" class="headerlink" title="1. addObject之前要非空判断。"></a>1. addObject之前要非空判断。</h3><h3 id="2-取下标的时候要判断是否越界。"><a href="#2-取下标的时候要判断是否越界。" class="headerlink" title="2. 取下标的时候要判断是否越界。"></a>2. 取下标的时候要判断是否越界。</h3><h3 id="3-取第一个元素或最后一个元素的时候使用firtstObject和lastObject"><a href="#3-取第一个元素或最后一个元素的时候使用firtstObject和lastObject" class="headerlink" title="3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject"></a>3. 取第一个元素或最后一个元素的时候使用firtstObject和lastObject</h3><h2 id="NSCache"><a href="#NSCache" class="headerlink" title="NSCache"></a>NSCache</h2><hr>
<h3 id="1-构建缓存时选用NSCache-而非NSDictionary"><a href="#1-构建缓存时选用NSCache-而非NSDictionary" class="headerlink" title="1. 构建缓存时选用NSCache 而非NSDictionary"></a>1. 构建缓存时选用NSCache 而非NSDictionary</h3><p>如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。</p>
<p>在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。</p>
<h3 id="2-NSCache优于NSDictionary的几点："><a href="#2-NSCache优于NSDictionary的几点：" class="headerlink" title="2. NSCache优于NSDictionary的几点："></a>2. NSCache优于NSDictionary的几点：</h3><ul>
<li>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。</li>
<li>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。</li>
<li>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</li>
</ul>
<h2 id="NSNotification"><a href="#NSNotification" class="headerlink" title="NSNotification"></a>NSNotification</h2><hr>
<h3 id="1-通知的名称"><a href="#1-通知的名称" class="headerlink" title="1. 通知的名称"></a>1. 通知的名称</h3><p>建议将通知的名字作为常量，保存在一个专门的类中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Const.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCFooDidBecomeBarNotification</div><div class="line"></div><div class="line"><span class="comment">// Const.m</span></div><div class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> ZOCFooDidBecomeBarNotification = <span class="string">@"ZOCFooDidBecomeBarNotification"</span>;</div></pre></td></tr></table></figure>
<h3 id="2-通知的移除"><a href="#2-通知的移除" class="headerlink" title="2. 通知的移除"></a>2. 通知的移除</h3><p>通知必须要在对象销毁之前移除掉。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><hr>
<h3 id="1-Xcode工程文件的物理路径要和逻辑路径保持一致。"><a href="#1-Xcode工程文件的物理路径要和逻辑路径保持一致。" class="headerlink" title="1. Xcode工程文件的物理路径要和逻辑路径保持一致。"></a>1. Xcode工程文件的物理路径要和逻辑路径保持一致。</h3><h3 id="2-忽略没有使用变量的编译警告"><a href="#2-忽略没有使用变量的编译警告" class="headerlink" title="2. 忽略没有使用变量的编译警告"></a>2. 忽略没有使用变量的编译警告</h3><p>对于某些暂时不用，以后可能用到的临时变量，为了避免警告，我们可以使用如下方法将这个警告消除：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)giveMeFive &#123; </div><div class="line"> <span class="built_in">NSString</span> *foo; </div><div class="line"> <span class="meta">#pragma unused (foo) </span></div><div class="line"> <span class="keyword">return</span> <span class="number">5</span>; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-手动标明警告和错误"><a href="#3-手动标明警告和错误" class="headerlink" title="3. 手动标明警告和错误"></a>3. 手动标明警告和错误</h3><h4 id="手动明确一个错误："><a href="#手动明确一个错误：" class="headerlink" title="手动明确一个错误："></a>手动明确一个错误：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)divide:(<span class="built_in">NSInteger</span>)dividend by:(<span class="built_in">NSInteger</span>)divisor &#123; </div><div class="line"> <span class="meta">#error Whoa, buddy, you need to check for zero here! </span></div><div class="line"> <span class="keyword">return</span> (dividend / divisor); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="手动明确一个警告："><a href="#手动明确一个警告：" class="headerlink" title="手动明确一个警告："></a>手动明确一个警告：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">float</span>)divide:(<span class="keyword">float</span>)dividend by:(<span class="keyword">float</span>)divisor &#123; </div><div class="line"> <span class="meta">#warning Dude, don't compare floating point numbers like this! </span></div><div class="line"> <span class="keyword">if</span> (divisor != <span class="number">0.0</span>) &#123; </div><div class="line">  <span class="keyword">return</span> (dividend / divisor); </div><div class="line"> &#125; <span class="keyword">else</span> &#123;  <span class="keyword">return</span> NAN; </div><div class="line"> &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h1 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h1><ol>
<li><a href="http://www.jianshu.com/p/7645a5ea7f46" target="_blank" rel="external">王垠：编程的智慧</a></li>
<li><a href="http://tech.meituan.com/clean-code.html" target="_blank" rel="external">美团点评技术团队：聊聊clean code</a></li>
<li><a href="https://github.com/oa414/objc-zen-book-cn/">禅与 Objective-C 编程艺术</a></li>
<li><a href="http://www.jianshu.com/nb/6074358" target="_blank" rel="external">J_Knight 的文集：iOS - 《Effective Objective-C 2.0》</a></li>
<li><a href="http://www.jianshu.com/p/08be5b30ff82" target="_blank" rel="external">蝴蝶之梦天使：iOS代码编程规范-根据项目经验汇总</a></li>
<li><a href="http://www.jianshu.com/p/003f2d777ee8" target="_blank" rel="external">高家二少爷：Objective-C高质量代码参考规范</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-a9d78ce3d5e7114f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;配图来自：nipic.com&quot;&gt;&lt;/p&gt;
&lt;p&gt;利用上周的业余时间把这篇规范整理了出来，我会将这篇规范作为我们iOS团队的代码规范，并且还会根据读者的反馈，项目的实践和研究的深入做不定时更新，还希望各位朋友看了多多指正和批评。&lt;/p&gt;
&lt;p&gt;这篇规范一共分为三个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;核心原则：介绍了这篇代码规范所遵循的核心原则。&lt;/li&gt;
&lt;li&gt;通用规范：不局限于iOS的通用性的代码规范（使用C语言和Swift语言）。&lt;/li&gt;
&lt;li&gt;iOS规范：仅适用于iOS的代码规范（使用Objective-C语言）。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>2017年5月iOS招人心得（附面试题）</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/06/08/2017%E5%B9%B45%E6%9C%88iOS%E6%8B%9B%E4%BA%BA%E5%BF%83%E5%BE%97%EF%BC%88%E9%99%84%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%89/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/06/08/2017年5月iOS招人心得（附面试题）/</id>
    <published>2017-06-08T05:28:16.000Z</published>
    <updated>2017-06-08T05:29:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-62c64645adc0ec72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="配图来自：https://pixabay.com"></p>
<blockquote>
<p>就在上个月中旬，技术老大让我招两个1-2年的iOS开发，把简历的筛选和第一轮技术面试的任务交给了我。</p>
</blockquote>
<p>从筛选第一份简历，准备面试题，到成功招到两个人一共花了两个星期多一点，总体来说还是比较顺利的。两位通过者都比较稳重踏实，而且对技术也比较有追求。这也可能和我筛选简历比较谨慎有关系，这次筛选简历所花费的精力是不比面试花费的少的。</p>
<p>虽然时间跨度不是很长，但是毕竟是第一次，所以有些感触，想总结出来分享给大家。这篇总结分为两个部分：</p>
<ul>
<li>第一部分是我当时准备的面试题</li>
<li>第二部分是我的心得</li>
</ul>
<p>我重点在本文的第二部分说一下这次面试别人的心得体会。而关于第一部分的面试题，文中不提供答案（因为不是本文的重点）。</p>
<a id="more"></a>
<h1 id="第一部分：面试题"><a href="#第一部分：面试题" class="headerlink" title="第一部分：面试题"></a>第一部分：面试题</h1><hr>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol>
<li>为什么说Objective-C是一门动态的语言？</li>
<li>讲一下MVC和MVVM，MVP？</li>
<li>为什么代理要用weak？代理的delegate和dataSource有什么区别？block和代理的区别?</li>
<li>属性的实质是什么？包括哪几个部分？属性默认的关键字都有哪些？@dynamic关键字和@synthesize关键字是用来做什么的？</li>
<li>属性的默认关键字是什么？</li>
<li>NSString为什么要用copy关键字，如果用strong会有什么问题？</li>
<li>如何令自己所写的对象具有拷贝功能?</li>
<li>可变集合类 和 不可变集合类的 copy 和 mutablecopy有什么区别？如果是集合是内容复制的话，集合里面的元素也是内容复制么？</li>
<li>为什么IBOutlet修饰的UIView也适用weak关键字？</li>
<li>nonatomic和atomic的区别？atomic是绝对的线程安全么？为什么？如果不是，那应该如何实现？</li>
<li>UICollectionView自定义layout如何实现？</li>
<li>用StoryBoard开发界面有什么弊端？如何避免？</li>
<li>进程和线程的区别？同步异步的区别？并行和并发的区别？</li>
<li>线程间通信？</li>
<li>GCD的一些常用的函数？（group，barrier，信号量，线程同步）</li>
<li>如何使用队列来避免资源抢夺？</li>
<li>数据持久化的几个方案（fmdb用没用过）</li>
<li>说一下AppDelegate的几个方法？从后台到前台调用了哪些方法？第一次启动调用了哪些方法？从前台到后台调用了哪些方法？</li>
<li>NSCache优于NSDictionary的几点？</li>
<li>知不知道Designated Initializer？使用它的时候有什么需要注意的问题？</li>
<li>实现description方法能取到什么效果？</li>
<li>objc使用什么机制管理对象内存？</li>
</ol>
<h3 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h3><h4 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h4><ol>
<li>block的实质是什么？一共有几种block？都是什么情况下生成的？</li>
<li>为什么在默认情况下无法修改被block捕获的变量？ __block都做了什么？ </li>
<li>模拟一下循环引用的一个情况？block实现界面反向传值如何实现？</li>
</ol>
<h4 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h4><ol>
<li>objc在向一个对象发送消息时，发生了什么？</li>
<li>什么时候会报unrecognized selector错误？iOS有哪些机制来避免走到这一步？</li>
<li>能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</li>
<li>runtime如何实现weak变量的自动置nil？</li>
<li>给类添加一个属性后，在类结构体里哪些元素会发生变化？</li>
</ol>
<h4 id="RunLoop"><a href="#RunLoop" class="headerlink" title="RunLoop"></a>RunLoop</h4><ol>
<li>runloop是来做什么的？runloop和线程有什么关系？主线程默认开启了runloop么？子线程呢？</li>
<li>runloop的mode是用来做什么的？有几种mode？</li>
<li>为什么把NSTimer对象以NSDefaultRunLoopMode（kCFRunLoopDefaultMode）添加到主运行循环以后，滑动scrollview的时候NSTimer却不动了？</li>
<li>苹果是如何实现Autorelease Pool的？</li>
</ol>
<h4 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h4><ol>
<li>isa指针？（对象的isa，类对象的isa，元类的isa都要说）</li>
<li>类方法和实例方法有什么区别？</li>
<li>介绍一下分类，能用分类做什么？内部是如何实现的？它为什么会覆盖掉原来的方法？</li>
<li>运行时能增加成员变量么？能增加属性么？如果能，如何增加？如果不能，为什么？</li>
<li>objc中向一个nil对象发送消息将会发生什么？（返回值是对象，是标量，结构体）</li>
</ol>
<h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><ol>
<li>UITableview的优化方法（缓存高度，异步绘制，减少层级，hide，避免离屏渲染）</li>
<li>有没有用过运行时，用它都能做什么？（交换方法，创建类，给新创建的类增加方法，改变isa指针）</li>
<li>看过哪些第三方框架的源码？都是如何实现的？（如果没有，问一下多图下载的设计）</li>
<li>SDWebImage的缓存策略？</li>
<li>AFN为什么添加一条常驻线程？</li>
<li>KVO的使用？实现原理？（为什么要创建子类来实现）</li>
<li>KVC的使用？实现原理？（KVC拿到key以后，是如何赋值的？知不知道集合操作符，能不能访问私有属性，能不能直接访问_ivar）</li>
</ol>
<h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><ol>
<li>有已经上线的项目么？</li>
<li>项目里哪个部分是你完成的？（找一个亮点问一下如何实现的）</li>
<li>开发过程中遇到过什么困难，是如何解决的？</li>
</ol>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><ol>
<li>遇到一个问题完全不能理解的时候，是如何帮助自己理解的？举个例子？</li>
<li>有看书的习惯么？最近看的一本是什么书？有什么心得？</li>
<li>有没有使用一些笔记软件？会在多平台同步以及多渠道采集么？（如果没有，问一下是如何复习知识的）</li>
<li>有没有使用清单类，日历类的软件？（如果没有，问一下是如何安排，计划任务的）</li>
<li>平常看博客么？有没有自己写过？（如果写，有哪些收获？如果没有写，问一下不写的原因）</li>
</ol>
<p>有关技术类的问题可以在评论区留言，我重点说一下这轮面试的心得和体会。</p>
<h1 id="第二部分：心得"><a href="#第二部分：心得" class="headerlink" title="第二部分：心得"></a>第二部分：心得</h1><hr>
<h3 id="面试者千万不要答非所问"><a href="#面试者千万不要答非所问" class="headerlink" title="面试者千万不要答非所问"></a>面试者千万不要答非所问</h3><p>如果让我选一个让面试官觉得印象减分的点，答非所问应该是首当其冲的。</p>
<blockquote>
<p>面试者一定要知道面试官问的点是什么。</p>
</blockquote>
<ul>
<li>如果在知道面试官问的点，但是自己却不知道答案的时候，可以提出思路，思考过程。其实有几次面试者在我的引导下很容易就把答案说出来了，认清问题的点是解决问题的一半。</li>
<li>如果没有理解好面试官问的问题，一定要事先和面试官确认好。</li>
</ul>
<p>其实这也属于沟通能力的一点：如果不能保证和对方沟通内容的一致性，自己弄个filter把对方的话都曲解了，以后合作的时候又怎能保证沟通好呢？</p>
<h3 id="面试者一定不要来得太早"><a href="#面试者一定不要来得太早" class="headerlink" title="面试者一定不要来得太早"></a>面试者一定不要来得太早</h3><blockquote>
<p>这里说的来得太早，是来得太早并告知面试官自己已经来了。</p>
</blockquote>
<p>因为在约定好的面试时间之前，往往面试官还有别的事情在做，如果他知道你来的很早，就可能会扰乱他的计划。有一位面试者早来了1个小时，结果把我们的面试计划打乱了，而且正好是我的第一次面试，所以真的是有点措手不及。</p>
<p>求职者和公司定下来的时间属于一个约定，约定是要遵守的。而且遵守约定同样也是对对方的尊重。如果入职之前都没能把握好，入职之后又如何能保证把握好呢？</p>
<h3 id="实践与理论的脱节，让人很不安"><a href="#实践与理论的脱节，让人很不安" class="headerlink" title="实践与理论的脱节，让人很不安"></a>实践与理论的脱节，让人很不安</h3><blockquote>
<p>能做出来项目，但是基础知识很薄弱</p>
</blockquote>
<p>几乎每位面试者都能给我展示他做的一些app，虽然没有很难的功能，但也都算是有板有眼。可让我比较意外的是，虽然能做出有模有样的app，但当我问到很多基础的问题的时候却答不上来，比如属性和成员变量的区别，属性的默认关键字，Designated Initializer的概念等等。。</p>
<p>这不禁让我怀疑他们的代码的稳定性，更怀疑他们治学，做技术的态度。</p>
<p>虽说技术活需要实践的磨练，但和理论脱节的技术是钻不深的。可能有人会说我的面试题过于理论，实际中用不到。但有些时候，在实际开发中遇到的一些问题往往就是因为一些很基本的东西没有弄清导致的，相信你我都深有体会。</p>
<p>而且，我们都知道技术的提升是阶梯式的。什么是阶梯式的呢？就是可能我们会有比较长的时间才会有一个突破。但这个突破来的有多快，提升的有多高，是跟平时每个细小知识点的掌握程度是分不开的。</p>
<p>因为知识也是有复利效应的，准确地掌握越多的知识点，在以后的学习过程中，这些知识点相互之间想成的积极作用会越来越大：对新知识的理解更快，对问题的定位会更准，解决问题的方法也会越多。相反，如果你每个问题都得过且过，这些结果的复合作用就会导致你今后很难会有所突破了。</p>
<h3 id="真的可能被简历骗到"><a href="#真的可能被简历骗到" class="headerlink" title="真的可能被简历骗到"></a>真的可能被简历骗到</h3><blockquote>
<p>上家的薪资很高，但是实际能力很不符</p>
</blockquote>
<p>有一位面试者在简历里号称上一个工作拿了15k，但当我问到NSString属性使用strong还是copy作为关键字的时候他却说是strong，甚至连delegate都拿不准使用strong还是weak，我就有些奇怪了。</p>
<h3 id="看技术博客和技术书籍的人还是很少的"><a href="#看技术博客和技术书籍的人还是很少的" class="headerlink" title="看技术博客和技术书籍的人还是很少的"></a>看技术博客和技术书籍的人还是很少的</h3><blockquote>
<p>只依赖于公司里的项目应该是不够的，毕竟不是每个公司里都有上乘的代码和技术</p>
</blockquote>
<p>面试了大概20个人，但是真正有看过技术博客和技术书籍的真的不多，更别提Github了。不过其中一位面试通过者是有github账号的，并且有几个小项目，印象非常好，加了不少分。</p>
<p>我相信在这一行的未来，简历里面github账号和博客绝对会越来越受重视：</p>
<ul>
<li>一方面简历真的是应接不暇，而且同时千篇一律，很难找出亮点。</li>
<li>另一方面，如果可以把自己的代码和成长展示给招聘公司，就会使得自己的能力在公司面前变得更加纯粹和透明，更有助于找到适合你自己的公司。</li>
</ul>
<p>以上就是我上个月的面试心得，希望大家多交流，有说的不对的地方还请多指正。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-62c64645adc0ec72.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;配图来自：https://pixabay.com&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;就在上个月中旬，技术老大让我招两个1-2年的iOS开发，把简历的筛选和第一轮技术面试的任务交给了我。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从筛选第一份简历，准备面试题，到成功招到两个人一共花了两个星期多一点，总体来说还是比较顺利的。两位通过者都比较稳重踏实，而且对技术也比较有追求。这也可能和我筛选简历比较谨慎有关系，这次筛选简历所花费的精力是不比面试花费的少的。&lt;/p&gt;
&lt;p&gt;虽然时间跨度不是很长，但是毕竟是第一次，所以有些感触，想总结出来分享给大家。这篇总结分为两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一部分是我当时准备的面试题&lt;/li&gt;
&lt;li&gt;第二部分是我的心得&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我重点在本文的第二部分说一下这次面试别人的心得体会。而关于第一部分的面试题，文中不提供答案（因为不是本文的重点）。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>使用Block实现KVO</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/05/15/%E4%BD%BF%E7%94%A8Block%E5%AE%9E%E7%8E%B0KVO/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/05/15/使用Block实现KVO/</id>
    <published>2017-05-15T00:24:28.000Z</published>
    <updated>2017-05-15T00:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS开发中，我们可以通过KVO机制来监听某个对象的某个属性的变化。</p>
<p>用过KVO的同学都应该知道，KVO的回调是以代理的形式实现的：在给某个对象添加观察以后，需要在另外一个地方实现回调代理方法。这种设计给人感觉比较分散，因此突然想试试用Block来实现KVO，将添加观察的代码和回调处理的代码写在一起。在学习了<a href="https://github.com/okcomp/ImplementKVO">ImplementKVO</a>的实现以后，自己也写了一个：<a href="https://github.com/knightsj/SJKVOController">SJKVOController</a></p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjkvocontrollerblogimage.png" alt="使用Block来实现KVO"></p>
<h1 id="SJKVOController的用法"><a href="#SJKVOController的用法" class="headerlink" title="SJKVOController的用法"></a>SJKVOController的用法</h1><p>只需要引入<code>NSObject+SJKVOController.h</code>头文件就可以使用SJKVOController。<br>先看一下它的头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"SJKVOHeader.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">SJKVOController</span>)</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//============== add observer ===============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys withBlock:(SJKVOBlock)block;</div><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key withBlock:(SJKVOBlock)block;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//============= remove observer =============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys;</div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer;</div><div class="line">- (<span class="keyword">void</span>)sj_removeAllObservers;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//============= list observers ===============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_listAllObservers;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<blockquote>
<p>从上面的API可以看出，这个小轮子：</p>
<ol>
<li>支持一次观察同一对象的多个属性。</li>
<li>可以一次只观察一个对象的一个属性。</li>
<li>可以移除对某个对象对多个属性的观察。</li>
<li>可以移除对某个对象对某个属性的观察。</li>
<li>可以移除某个观察自己的对象。</li>
<li>可以移除所有观察自己的对象。</li>
<li>打印出所有观察自己的对象的信息，包括对象本身，观察的属性，setter方法。</li>
</ol>
</blockquote>
<p>下面来结合Demo讲解一下如何使用这个小轮子：</p>
<p>在点击上面两个按钮中的任意一个，增加观察：</p>
<p>一次性添加：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)addObserversTogether:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *keys = @[<span class="string">@"number"</span>,<span class="string">@"color"</span>];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_addObserver:<span class="keyword">self</span> forKeys:keys withBlock:^(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"number"</span>]) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="keyword">self</span>.numberLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,newValue];</div><div class="line">            &#125;);</div><div class="line">            </div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([key isEqualToString:<span class="string">@"color"</span>])&#123;</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                <span class="keyword">self</span>.numberLabel.backgroundColor = newValue;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>分两次添加：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)addObserverSeparatedly:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_addObserver:<span class="keyword">self</span> forKey:<span class="string">@"number"</span> withBlock:^(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">self</span>.numberLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@"</span>,newValue];</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_addObserver:<span class="keyword">self</span> forKey:<span class="string">@"color"</span> withBlock:^(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">self</span>.numberLabel.backgroundColor = newValue;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>添加以后，点击最下面的按钮来显示所有的观察信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)showAllObservingItems:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_listAllObservers];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:==================== Start Listing All Observers: ==================== </div><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:observer item:&#123;observer: &lt;ViewController: <span class="number">0x7fa1577054f0</span>&gt; | key: color | <span class="keyword">setter</span>: setColor:&#125;</div><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:observer item:&#123;observer: &lt;ViewController: <span class="number">0x7fa1577054f0</span>&gt; | key: number | <span class="keyword">setter</span>: setNumber:&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在这里我重写了description方法，打印出了每个观察的对象和key,以及setter方法。</p>
</blockquote>
<p>现在点击更新按钮，则会更新model的number和color属性，从而触发KVO：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)updateNumber:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//trigger KVO : number</span></div><div class="line">    <span class="built_in">NSInteger</span> newNumber = arc4random() % <span class="number">100</span>;</div><div class="line">    <span class="keyword">self</span>.model.number = [<span class="built_in">NSNumber</span> numberWithInteger:newNumber];</div><div class="line">    </div><div class="line">    <span class="comment">//trigger KVO : color</span></div><div class="line">    <span class="built_in">NSArray</span> *colors = @[[<span class="built_in">UIColor</span> redColor],[<span class="built_in">UIColor</span> yellowColor],[<span class="built_in">UIColor</span> blueColor],[<span class="built_in">UIColor</span> greenColor]];</div><div class="line">    <span class="built_in">NSInteger</span> colorIndex = arc4random() % <span class="number">3</span>;</div><div class="line">    <span class="keyword">self</span>.model.color = colors[colorIndex];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到中间的Label上面显示的数字和背景色都在变化，成功实现了KVO：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjkvocontrolllergif1.gif" alt="同时观察颜色和数字的变化"></p>
<p>现在我们移除观察，点击remove按钮</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)removeAllObservingItems:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    [<span class="keyword">self</span>.model sj_removeAllObservers];   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在移除了所有的观察者以后，则会打印出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:Removed all obserbing objects of object:&lt;Model: <span class="number">0x60000003b700</span>&gt;</div></pre></td></tr></table></figure></p>
<p>而且如果在这个时候打印观察者list，则会输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80499</span>:<span class="number">4242749</span>] SJKVOLog:There is no observers obserbing object:&lt;Model: <span class="number">0x60000003b700</span>&gt;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，这里的移除可以有多种选择：可以移某个对象的某个key，也可以移除某个对象的几个keys，为了验证，我们可以结合list方法来验证一下移除是否成功：</p>
<h4 id="验证1-在添加number和color的观察后，移除nunber的观察："><a href="#验证1-在添加number和color的观察后，移除nunber的观察：" class="headerlink" title="验证1:在添加number和color的观察后，移除nunber的观察："></a>验证1:在添加number和color的观察后，移除nunber的观察：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)removeAllObservingItems:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    [<span class="keyword">self</span>.model sj_removeObserver:<span class="keyword">self</span> forKey:<span class="string">@"number"</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在移除以后，我们调用list方法，输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80850</span>:<span class="number">4278383</span>] SJKVOLog:==================== Start Listing All Observers: ====================</div><div class="line">SJKVOController[<span class="number">80850</span>:<span class="number">4278383</span>] SJKVOLog:observer item:&#123;observer: &lt;ViewController: <span class="number">0x7ffeec408560</span>&gt; | key: color | <span class="keyword">setter</span>: setColor:&#125;</div></pre></td></tr></table></figure></p>
<p>现在只有color属性被观察了。看一下实际的效果：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjkvocontrolllergif2.gif" alt="只观察颜色的变化"></p>
<p>我们可以看到，现在只有color在变，而数字没有变化了，验证此移除方法正确。</p>
<h4 id="验证2-在添加number和color的观察后，移除nunber和color的观察："><a href="#验证2-在添加number和color的观察后，移除nunber和color的观察：" class="headerlink" title="验证2:在添加number和color的观察后，移除nunber和color的观察："></a>验证2:在添加number和color的观察后，移除nunber和color的观察：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">IBAction</span>)removeAllObservingItems:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.model sj_removeObserver:<span class="keyword">self</span> forKeys:@[<span class="string">@"number"</span>,<span class="string">@"color"</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在移除以后，我们调用list方法，输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SJKVOController[<span class="number">80901</span>:<span class="number">4283311</span>] SJKVOLog:There is no observers obserbing object:&lt;Model: <span class="number">0x600000220fa0</span>&gt;</div></pre></td></tr></table></figure></p>
<p>现在color和number属性都不被观察了。看一下实际的效果：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjkvocontrolllergif3.gif" alt="颜色和数字的变化都不再被观察"></p>
<p>我们可以看到，现在color和number都不变了，验证此移除方法正确。</p>
<p>OK，现在知道了怎么用SJKVOController，我下面给大家看一下代码：</p>
<h1 id="SJKVOController代码解析"><a href="#SJKVOController代码解析" class="headerlink" title="SJKVOController代码解析"></a>SJKVOController代码解析</h1><p>先大致讲解一下SJKVOController的实现思路：</p>
<ol>
<li>为了减少侵入性，SJKVOController被设计为NSObject的一个分类。</li>
<li>SJKVOController仿照了KVO的实现思路，在添加观察以后在运行时动态生成当前类的子类，给这个子类添加被观察的属性的set方法并使用isa swizzle的方式将当前对象转换为当前类的子类的实现。</li>
<li>同时，这个子类还使用了关联对象来保存一个“观察项”的set，每一个观察项封装了一次观察的行为（有去重机制）：包括观察自己的对象，自己被观察的属性，以及传进来的block。</li>
<li>在当前类，也就是子类的set方法被调用的时候做三件事情：<ul>
<li>第一件事情是使用KVC来找出当前属性的旧值。</li>
<li>第二件事情是调用父类（原来的类）的set方法（设新值）。</li>
<li>第三件事是根据当前的观察对象和key，在观察项set里面找出对应的block并调用。</li>
</ul>
</li>
</ol>
<p>再来看一下这个小轮子的几个类：</p>
<ul>
<li>SJKVOController：实现KVO主要功能的类。</li>
<li>SJKVOObserverItem：封装观察项的类。</li>
<li>SJKVOTool：setter和getter的相互转换和相关运行时查询方法等。</li>
<li>SJKVOError：封装错误类型。</li>
<li>SJKVOHeader：引用了运行时的头文件。</li>
</ul>
<p> 下面开始一个一个来讲解每个类的源码：</p>
<h2 id="SJKVOController"><a href="#SJKVOController" class="headerlink" title="SJKVOController"></a>SJKVOController</h2><p>再看一下头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">"SJKVOHeader.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSObject</span> (<span class="title">SJKVOController</span>)</span></div><div class="line"></div><div class="line"><span class="comment">//============== add observer ===============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys withBlock:(SJKVOBlock)block;</div><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key withBlock:(SJKVOBlock)block;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//============= remove observer =============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys;</div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer forKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer;</div><div class="line">- (<span class="keyword">void</span>)sj_removeAllObservers;</div><div class="line"></div><div class="line"><span class="comment">//============= list observers ===============//</span></div><div class="line">- (<span class="keyword">void</span>)sj_listAllObservers;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>每个方法的意思相信读者已经能看懂了，现在讲一下具体的实现。从<code>sj_addObserver:forKey withBlock:</code>开始：</p>
<h3 id="sj-addObserver-forKey-withBlock-方法："><a href="#sj-addObserver-forKey-withBlock-方法：" class="headerlink" title="sj_addObserver:forKey withBlock:方法："></a>sj_addObserver:forKey withBlock:方法：</h3><p>除去一些错误的判断，该方法作了下面几件事情：</p>
<h4 id="1-判断当前被观察的类是否存在与传入key对应的setter方法："><a href="#1-判断当前被观察的类是否存在与传入key对应的setter方法：" class="headerlink" title="1.判断当前被观察的类是否存在与传入key对应的setter方法："></a>1.判断当前被观察的类是否存在与传入key对应的setter方法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SEL setterSelector = <span class="built_in">NSSelectorFromString</span>([SJKVOTool setterFromGetter:key]);</div><div class="line">Method setterMethod = [SJKVOTool objc_methodFromClass:[<span class="keyword">self</span> <span class="keyword">class</span>] selector:setterSelector];</div><div class="line"><span class="comment">//error: no corresponding setter mothod</span></div><div class="line"><span class="keyword">if</span> (!setterMethod) &#123;</div><div class="line">     SJLog(<span class="string">@"%@"</span>,[SJKVOError errorNoMatchingSetterForKey:key]);</div><div class="line">     <span class="keyword">return</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-如果有，判断当前被观察到类是否已经是KVO类-在KVO机制中，如果某个对象一旦被观察，则这个对象就变成了带有包含KVO前缀的类的实例-。如果已经是KVO类，则将当前实例的isa指针指向其父类（最开始被观察的类）："><a href="#2-如果有，判断当前被观察到类是否已经是KVO类-在KVO机制中，如果某个对象一旦被观察，则这个对象就变成了带有包含KVO前缀的类的实例-。如果已经是KVO类，则将当前实例的isa指针指向其父类（最开始被观察的类）：" class="headerlink" title="2. 如果有，判断当前被观察到类是否已经是KVO类(在KVO机制中，如果某个对象一旦被观察，则这个对象就变成了带有包含KVO前缀的类的实例)。如果已经是KVO类，则将当前实例的isa指针指向其父类（最开始被观察的类）："></a>2. 如果有，判断当前被观察到类是否已经是KVO类(在KVO机制中，如果某个对象一旦被观察，则这个对象就变成了带有包含KVO前缀的类的实例)。如果已经是KVO类，则将当前实例的isa指针指向其父类（最开始被观察的类）：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//get original class(current class,may be KVO class)</span></div><div class="line"><span class="built_in">NSString</span> *originalClassName = <span class="built_in">NSStringFromClass</span>(OriginalClass);</div><div class="line"></div><div class="line"><span class="comment">//如果当前的类是带有KVO前缀的类(也就是已经被观察到类),则需要将KVO前缀的类删除，并讲</span></div><div class="line"><span class="keyword">if</span> ([originalClassName hasPrefix:SJKVOClassPrefix]) &#123;</div><div class="line">    <span class="comment">//now,the OriginalClass is KVO class, we should destroy it and make new one</span></div><div class="line">    Class CurrentKVOClass = OriginalClass;</div><div class="line">    object_setClass(<span class="keyword">self</span>, class_getSuperclass(OriginalClass));</div><div class="line">    objc_disposeClassPair(CurrentKVOClass);</div><div class="line">    originalClassName = [originalClassName substringFromIndex:(SJKVOClassPrefix.length)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-如果不是KVO类（说明当前实例没有被观察），则创建一个带有KVO前缀的类，并将当前实例的isa指针指向这个新建的类："><a href="#3-如果不是KVO类（说明当前实例没有被观察），则创建一个带有KVO前缀的类，并将当前实例的isa指针指向这个新建的类：" class="headerlink" title="3. 如果不是KVO类（说明当前实例没有被观察），则创建一个带有KVO前缀的类，并将当前实例的isa指针指向这个新建的类："></a>3. 如果不是KVO类（说明当前实例没有被观察），则创建一个带有KVO前缀的类，并将当前实例的isa指针指向这个新建的类：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//create a KVO class</span></div><div class="line">Class KVOClass = [<span class="keyword">self</span> createKVOClassFromOriginalClassName:originalClassName];</div><div class="line"></div><div class="line"><span class="comment">//swizzle isa from self to KVO class</span></div><div class="line">object_setClass(<span class="keyword">self</span>, KVOClass);</div></pre></td></tr></table></figure>
<p>看一下如何新建一个新的类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (Class)createKVOClassFromOriginalClassName:(<span class="built_in">NSString</span> *)originalClassName</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSString</span> *kvoClassName = [SJKVOClassPrefix stringByAppendingString:originalClassName];</div><div class="line">    Class KVOClass = <span class="built_in">NSClassFromString</span>(kvoClassName);</div><div class="line">    </div><div class="line">    <span class="comment">// KVO class already exists</span></div><div class="line">    <span class="keyword">if</span> (KVOClass) &#123;</div><div class="line">        <span class="keyword">return</span> KVOClass;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// if there is no KVO class, then create one</span></div><div class="line">    KVOClass = objc_allocateClassPair(OriginalClass, kvoClassName.UTF8String, <span class="number">0</span>);<span class="comment">//OriginalClass is super class</span></div><div class="line">    </div><div class="line">    <span class="comment">// pretending to be the original class:return the super class in class method</span></div><div class="line">    Method clazzMethod = class_getInstanceMethod(OriginalClass, <span class="keyword">@selector</span>(<span class="keyword">class</span>));</div><div class="line">    class_addMethod(KVOClass, <span class="keyword">@selector</span>(<span class="keyword">class</span>), (IMP)return_original_class, method_getTypeEncoding(clazzMethod));</div><div class="line">    </div><div class="line">    <span class="comment">// finally, register this new KVO class</span></div><div class="line">    objc_registerClassPair(KVOClass);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> KVOClass;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-查看观察项set，如果这个set里面有已经保存的观察项，则需要新建一个空的观察项set，将已经保存的观察项放入这个新建的set里面："><a href="#4-查看观察项set，如果这个set里面有已经保存的观察项，则需要新建一个空的观察项set，将已经保存的观察项放入这个新建的set里面：" class="headerlink" title="4. 查看观察项set，如果这个set里面有已经保存的观察项，则需要新建一个空的观察项set，将已经保存的观察项放入这个新建的set里面："></a>4. 查看观察项set，如果这个set里面有已经保存的观察项，则需要新建一个空的观察项set，将已经保存的观察项放入这个新建的set里面：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//if we already have some history observer items, we should add them into new KVO class</span></div><div class="line"><span class="built_in">NSMutableSet</span>* observers = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers);</div><div class="line"><span class="keyword">if</span> (observers.count &gt; <span class="number">0</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableSet</span> *newObservers = [[<span class="built_in">NSMutableSet</span> alloc] initWithCapacity:<span class="number">5</span>];</div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers, newObservers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (SJKVOObserverItem *item <span class="keyword">in</span> observers) &#123;</div><div class="line">        [<span class="keyword">self</span> KVOConfigurationWithObserver:item.observer key:item.key block:item.block kvoClass:KVOClass setterSelector:item.setterSelector setterMethod:setterMethod];</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下如何保存观察项的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)KVOConfigurationWithObserver:(<span class="built_in">NSObject</span> *)observer key:(<span class="built_in">NSString</span> *)key block:(SJKVOBlock)block kvoClass:(Class)kvoClass setterSelector:(SEL)setterSelector setterMethod:(Method)setterMethod</div><div class="line">&#123;</div><div class="line">    <span class="comment">//add setter method in KVO Class</span></div><div class="line">    <span class="keyword">if</span>(![SJKVOTool detectClass:OriginalClass hasSelector:setterSelector])&#123;</div><div class="line">        class_addMethod(kvoClass, setterSelector, (IMP)kvo_setter_implementation, method_getTypeEncoding(setterMethod));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//add item of this observer&amp;&amp;key pair</span></div><div class="line">    [<span class="keyword">self</span> addObserverItem:observer key:key setterSelector:setterSelector setterMethod:setterMethod block:block];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里首先给KVO类增加了setter方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//implementation of KVO setter method</span></div><div class="line"><span class="keyword">void</span> kvo_setter_implementation(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> newValue)</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *setterName = <span class="built_in">NSStringFromSelector</span>(_cmd);</div><div class="line">    <span class="built_in">NSString</span> *getterName = [SJKVOTool getterFromSetter:setterName];</div><div class="line">    </div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!getterName) &#123;</div><div class="line">        SJLog(<span class="string">@"%@"</span>,[SJKVOError errorTransferSetterToGetterFaildedWithSetterName:setterName]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// create a super class of a specific instance</span></div><div class="line">    Class superclass = class_getSuperclass(OriginalClass);</div><div class="line">    </div><div class="line">    <span class="keyword">struct</span> objc_super superclass_to_call = &#123;</div><div class="line">        .super_class = superclass,  <span class="comment">//super class</span></div><div class="line">        .receiver = <span class="keyword">self</span>,           <span class="comment">//insatance of this class</span></div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="comment">// cast method pointer</span></div><div class="line">    <span class="keyword">void</span> (*objc_msgSendSuperCasted)(<span class="keyword">void</span> *, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)objc_msgSendSuper;</div><div class="line">    </div><div class="line">    <span class="comment">// call super's setter, the supper is the original class</span></div><div class="line">    objc_msgSendSuperCasted(&amp;superclass_to_call, _cmd, newValue);</div><div class="line">    </div><div class="line">    <span class="comment">// look up observers and call the blocks</span></div><div class="line">    <span class="built_in">NSMutableSet</span> *observers = objc_getAssociatedObject(<span class="keyword">self</span>,&amp;SJKVOObservers);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (observers.count &lt;= <span class="number">0</span>) &#123;</div><div class="line">        SJLog(<span class="string">@"%@"</span>,[SJKVOError errorNoObserverOfObject:<span class="keyword">self</span>]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//get the old value</span></div><div class="line">    <span class="keyword">id</span> oldValue = [<span class="keyword">self</span> valueForKey:getterName];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (SJKVOObserverItem *item <span class="keyword">in</span> observers) &#123;</div><div class="line">        <span class="keyword">if</span> ([item.key isEqualToString:getterName]) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">                <span class="comment">//call block</span></div><div class="line">                item.block(<span class="keyword">self</span>, getterName, oldValue, newValue);</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实例化对应的观察项：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObserverItem:(<span class="built_in">NSObject</span> *)observer</div><div class="line">                    key:(<span class="built_in">NSString</span> *)key</div><div class="line">         setterSelector:(SEL)setterSelector</div><div class="line">           setterMethod:(Method)setterMethod</div><div class="line">                  block:(SJKVOBlock)block</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableSet</span> *observers = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers);</div><div class="line">    <span class="keyword">if</span> (!observers) &#123;</div><div class="line">        observers = [[<span class="built_in">NSMutableSet</span> alloc] initWithCapacity:<span class="number">10</span>];</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers, observers, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    SJKVOObserverItem *item = [[SJKVOObserverItem alloc] initWithObserver:observer Key:key setterSelector:setterSelector setterMethod:setterMethod block:block];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (item) &#123;</div><div class="line">        [observers addObject:item];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="5-判断新的观察是否会与已经保存的观察项重复（当观察对象和key一致的时候），如果重复，则不添加新的观察："><a href="#5-判断新的观察是否会与已经保存的观察项重复（当观察对象和key一致的时候），如果重复，则不添加新的观察：" class="headerlink" title="5. 判断新的观察是否会与已经保存的观察项重复（当观察对象和key一致的时候），如果重复，则不添加新的观察："></a>5. 判断新的观察是否会与已经保存的观察项重复（当观察对象和key一致的时候），如果重复，则不添加新的观察：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">/ /ignore same observer and key:<span class="keyword">if</span> the observer and key are same with saved observerItem,we should not add them one more time</div><div class="line"><span class="built_in">BOOL</span> findSameObserverAndKey = <span class="literal">NO</span>;</div><div class="line"><span class="keyword">if</span> (observers.count&gt;<span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (SJKVOObserverItem *item <span class="keyword">in</span> observers) &#123;</div><div class="line">        <span class="keyword">if</span> ( (item.observer == observer) &amp;&amp; [item.key isEqualToString:key]) &#123;</div><div class="line">            findSameObserverAndKey = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!findSameObserverAndKey) &#123;</div><div class="line">    [<span class="keyword">self</span> KVOConfigurationWithObserver:observer key:key block:block kvoClass:KVOClass setterSelector:setterSelector setterMethod:setterMethod];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而一次性添加多个key的方法，也只是调用多次一次性添加单个key的方法罢了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sj_addObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">               forKeys:(<span class="built_in">NSArray</span> &lt;<span class="built_in">NSString</span> *&gt;*)keys</div><div class="line">             withBlock:(SJKVOBlock)block</div><div class="line">&#123;</div><div class="line">    <span class="comment">//error: keys array is nil or no elements</span></div><div class="line">    <span class="keyword">if</span> (keys.count == <span class="number">0</span>) &#123;</div><div class="line">        SJLog(<span class="string">@"%@"</span>,[SJKVOError errorInvalidInputObservingKeys]);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//one key corresponding to one specific item, not the observer</span></div><div class="line">    [keys enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> * key, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        [<span class="keyword">self</span> sj_addObserver:observer forKey:key withBlock:block];</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于移除观察的实现，只是在观察项set里面找出封装了对应的观察对象和key的观察项就可以了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sj_removeObserver:(<span class="built_in">NSObject</span> *)observer</div><div class="line">                   forKey:(<span class="built_in">NSString</span> *)key</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableSet</span>* observers = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (observers.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        SJKVOObserverItem *removingItem = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">for</span> (SJKVOObserverItem* item <span class="keyword">in</span> observers) &#123;</div><div class="line">            <span class="keyword">if</span> (item.observer == observer &amp;&amp; [item.key isEqualToString:key]) &#123;</div><div class="line">                removingItem = item;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (removingItem) &#123;</div><div class="line">            [observers removeObject:removingItem];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再看一下移除所有观察者：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)sj_removeAllObservers</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSMutableSet</span>* observers = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;SJKVOObservers);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (observers.count &gt; <span class="number">0</span>) &#123;</div><div class="line">        [observers removeAllObjects];</div><div class="line">        SJLog(<span class="string">@"SJKVOLog:Removed all obserbing objects of object:%@"</span>,<span class="keyword">self</span>);</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        SJLog(<span class="string">@"SJKVOLog:There is no observers obserbing object:%@"</span>,<span class="keyword">self</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="SJKVOObserverItem"><a href="#SJKVOObserverItem" class="headerlink" title="SJKVOObserverItem"></a>SJKVOObserverItem</h2><p>这个类负责封装每一个观察项的信息，包括：</p>
<ul>
<li>观察者对象。</li>
<li>被观察的key。</li>
<li>setter方法名（SEL）</li>
<li>setter方法（Method）</li>
<li>回调的block</li>
</ul>
<blockquote>
<p>需要注意的是:<br>在这个小轮子里，对于同一个对象可以观察不同的key的情况，是将这两个key区分开来的，是属于不同的观察项。所以应该用不同的<code>SJKVOObserverItem</code>实例来封装。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SJKVOBlock)(<span class="keyword">id</span> observedObject, <span class="built_in">NSString</span> *key, <span class="keyword">id</span> oldValue, <span class="keyword">id</span> newValue);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJKVOObserverItem</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSObject</span> *observer;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *key;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SEL setterSelector;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) Method setterMethod;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   SJKVOBlock block;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithObserver:(<span class="built_in">NSObject</span> *)observer Key:(<span class="built_in">NSString</span> *)key setterSelector:(SEL)setterSelector setterMethod:(Method)setterMethod block:(SJKVOBlock)block;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="SJKVOTool"><a href="#SJKVOTool" class="headerlink" title="SJKVOTool"></a>SJKVOTool</h2><p>这个类负责setter方法与getter方法相互转换，以及和运行时相关的操作，服务于<code>SJKVOController</code>。看一下它的头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/message.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJKVOTool</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">//setter &lt;-&gt; getter</span></div><div class="line">+ (<span class="built_in">NSString</span> *)getterFromSetter:(<span class="built_in">NSString</span> *)<span class="keyword">setter</span>;</div><div class="line">+ (<span class="built_in">NSString</span> *)setterFromGetter:(<span class="built_in">NSString</span> *)<span class="keyword">getter</span>;</div><div class="line"></div><div class="line"><span class="comment">//get method from a class by a specific selector</span></div><div class="line">+ (Method)objc_methodFromClass:(Class)cls selector:(SEL)selector;</div><div class="line"></div><div class="line"><span class="comment">//check a class has a specific selector or not</span></div><div class="line">+ (<span class="built_in">BOOL</span>)detectClass:(Class)cls hasSelector:(SEL)selector;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>##SJKVOError</p>
<p>这个小轮子仿照了<a href="https://github.com/jsonmodel/jsonmodel">JSONModel</a>的错误管理方式，用单独的一个类<code>SJKVOError</code>来返回各种错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</div><div class="line">    </div><div class="line">    SJKVOErrorTypeNoObervingObject,</div><div class="line">    SJKVOErrorTypeNoObervingKey,</div><div class="line">    SJKVOErrorTypeNoObserverOfObject,</div><div class="line">    SJKVOErrorTypeNoMatchingSetterForKey,</div><div class="line">    SJKVOErrorTypeTransferSetterToGetterFailded,</div><div class="line">    SJKVOErrorTypeInvalidInputObservingKeys,</div><div class="line">    </div><div class="line">&#125; SJKVOErrorTypes;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJKVOError</span> : <span class="title">NSError</span></span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>)errorNoObervingObject;</div><div class="line">+ (<span class="keyword">id</span>)errorNoObervingKey;</div><div class="line">+ (<span class="keyword">id</span>)errorNoMatchingSetterForKey:(<span class="built_in">NSString</span> *)key;</div><div class="line">+ (<span class="keyword">id</span>)errorTransferSetterToGetterFaildedWithSetterName:(<span class="built_in">NSString</span> *)setterName;</div><div class="line">+ (<span class="keyword">id</span>)errorNoObserverOfObject:(<span class="keyword">id</span>)object;</div><div class="line">+ (<span class="keyword">id</span>)errorInvalidInputObservingKeys;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>OK，这样就介绍完了，希望各位同学可以积极指正～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS开发中，我们可以通过KVO机制来监听某个对象的某个属性的变化。&lt;/p&gt;
&lt;p&gt;用过KVO的同学都应该知道，KVO的回调是以代理的形式实现的：在给某个对象添加观察以后，需要在另外一个地方实现回调代理方法。这种设计给人感觉比较分散，因此突然想试试用Block来实现KVO，将添加观察的代码和回调处理的代码写在一起。在学习了&lt;a href=&quot;https://github.com/okcomp/ImplementKVO&quot;&gt;ImplementKVO&lt;/a&gt;的实现以后，自己也写了一个：&lt;a href=&quot;https://github.com/knightsj/SJKVOController&quot;&gt;SJKVOController&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/sjkvocontrollerblogimage.png&quot; alt=&quot;使用Block来实现KVO&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;SJKVOController的用法&quot;&gt;&lt;a href=&quot;#SJKVOController的用法&quot; class=&quot;headerlink&quot; title=&quot;SJKVOController的用法&quot;&gt;&lt;/a&gt;SJKVOController的用法&lt;/h1&gt;&lt;p&gt;只需要引入&lt;code&gt;NSObject+SJKVOController.h&lt;/code&gt;头文件就可以使用SJKVOController。&lt;br&gt;先看一下它的头文件：&lt;br&gt;&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#import &lt;span class=&quot;meta-string&quot;&gt;&quot;SJKVOHeader.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;NSObject&lt;/span&gt; (&lt;span class=&quot;title&quot;&gt;SJKVOController&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//============== add observer ===============//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_addObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer forKeys:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; &amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt;*)keys withBlock:(SJKVOBlock)block;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_addObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer forKey:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)key withBlock:(SJKVOBlock)block;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//============= remove observer =============//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_removeObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer forKeys:(&lt;span class=&quot;built_in&quot;&gt;NSArray&lt;/span&gt; &amp;lt;&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *&amp;gt;*)keys;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_removeObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer forKey:(&lt;span class=&quot;built_in&quot;&gt;NSString&lt;/span&gt; *)key;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_removeObserver:(&lt;span class=&quot;built_in&quot;&gt;NSObject&lt;/span&gt; *)observer;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_removeAllObservers;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//============= list observers ===============//&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;- (&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;)sj_listAllObservers;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;@end&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C 高级编程》干货三部曲（三）：GCD篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/04/24/%E3%80%8AObjective-C%20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9AGCD%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/04/24/《Objective-C 高级编程》干货三部曲（三）：GCD篇/</id>
    <published>2017-04-24T01:21:34.000Z</published>
    <updated>2017-04-24T08:28:36.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>我们知道在iOS开发中，一共有四种多线程技术：pthread，NSThread，GCD，NSOperation：</p>
<ul>
<li>前两者是面向线程开发的多线程技术，需要开发者自己去维护线程的生命周期，比较繁琐。</li>
<li>后两者是面向队列开发的多线程技术，开发者仅仅定义想执行的任务追加到适当的Dispatch Queue（队列）中并设置一些优先级，依赖等操作就可以了，其他的事情可以交给系统来做。</li>
</ul>
<p>在这一章里，作者主要介绍了GCD技术，它是基于C语言的API，开发者只需要将任务放在block内，并指定好追加的队列，就可以完成多线程开发。</p>
<p>但是多线程开发时容易发生的一些问题：</p>
<ul>
<li>多个线程更新相同的资源：数据竞争。</li>
<li>多个线程相互持续等待：死锁。</li>
<li>使用太多的线程导致消耗内存。</li>
</ul>
<p>虽然解决这些问题的代价是会使程序的复杂度上升，但是多线程技术仍然是必须使用的：因为使用多线程编程可以保证应用程序的响应性能。如果耗时操作阻塞了主线程的RunLoop，会导致用户界面无法响应用户的操作，所以必须开启子线程将耗时操作放在子线程中处理。那么我们应该怎么进行多线程开发呢？在讲解之前先看一下本文结构（GCD部分）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程》 干货三部曲"></p>
<p>本文的Demo地址：<a href="https://github.com/knightsj/iOS_Demo/tree/master/%5B12%5D.%20gcd_demo">knightsj/iOS_Demo/gcd_demo</a><br>虽然文章里应给出了详细的输出结果，但还是希望读者可以将demo下载后仔细对照一下代码并体会。</p>
<a id="more"></a>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>Dispatch Queue是执行处理的等待队列，按照任务（block）追加到队列里的顺序，先进先出执行处理。</p>
<p>而等待队列有两种</p>
<ul>
<li>Serial Dispatch Queue：串行队列，等待当前执行任务处理结束的队列。</li>
<li>Concurrent Dispatch Queue:并发队列，不等待当前执行任务处理结束的队列。</li>
</ul>
<h2 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h2><p>将任务追加到串行队列：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)serialQueue</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"serial queue"</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">6</span>; index ++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"task index %ld in serial queue"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">0</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">1</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">2</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">3</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">4</span> <span class="keyword">in</span> serial queue</div><div class="line">gcd_demo[<span class="number">33484</span>:<span class="number">2481120</span>] task index <span class="number">5</span> <span class="keyword">in</span> serial queue</div></pre></td></tr></table></figure></p>
<blockquote>
<p>通过dispatch_queue_create函数可以创建队列，第一个函数为队列的名称，第二个参数是<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;为了避免重复代码，我在这里使用了for循环，将任务追加到了queue中。</div><div class="line"></div><div class="line">&gt;注意，这里的任务是按照顺序执行的。说明任务是以阻塞的形式执行的：必须等待上一个任务执行完成才能执行现在的任务。也就是说：一个Serial Dispatch Queue中同时只能执行一个追加处理（任务block），而且系统对于一个Serial Dispatch Queue只生成并使用一个线程。</div><div class="line"></div><div class="line"></div><div class="line">但是，如果我们将6个任务分别追加到6个Serial Dispatch Queue中，那么系统就会同时处理这6个任务（因为会另开启6个子线程）：</div><div class="line"></div><div class="line"></div><div class="line">```objc</div><div class="line">- (void)multiSerialQueue</div><div class="line">&#123;</div><div class="line">    for (NSInteger index = 0; index &lt; 10; index ++) &#123;</div><div class="line">        //新建一个serial queue</div><div class="line">        dispatch_queue_t queue = dispatch_queue_create(&quot;different serial queue&quot;, NULL);</div><div class="line">        dispatch_async(queue, ^&#123;</div><div class="line">            NSLog(@&quot;serial queue index : %ld&quot;,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485282</span>] serial queue index : <span class="number">1</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485264</span>] serial queue index : <span class="number">0</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485267</span>] serial queue index : <span class="number">2</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485265</span>] serial queue index : <span class="number">3</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485291</span>] serial queue index : <span class="number">4</span></div><div class="line">gcd_demo[<span class="number">33576</span>:<span class="number">2485265</span>] serial queue index : <span class="number">5</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>从输出结果可以看出来，这里的6个任务并不是按顺序执行的。</p>
</blockquote>
<p>需要注意的是：一旦开发者新建了一个串行队列，系统一定会开启一个子线程，所以在使用串行队列的时候，一定只创建真正需要创建的串行队列，避免资源浪费。</p>
<h2 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h2><p>将任务追加到并发队列：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)concurrentQueue</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"concurrent queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">6</span>; index ++) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"task index %ld in concurrent queue"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484160</span>] task index <span class="number">1</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484159</span>] task index <span class="number">0</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484162</span>] task index <span class="number">2</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484182</span>] task index <span class="number">3</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484183</span>] task index <span class="number">4</span> <span class="keyword">in</span> concurrent queue</div><div class="line">gcd_demo[<span class="number">33550</span>:<span class="number">2484160</span>] task index <span class="number">5</span> <span class="keyword">in</span> concurrent queue</div></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，dispatch_queue_create函数的第二个参数是<code>DISPATCH_QUEUE_CONCURRENT</code>。</p>
<p>注意，这里追加到并发队列的6个任务并不是按照顺序执行的，符合上面并发队列的定义。</p>
<p>扩展知识：iOS和OSX基于Dispatch Queue中的处理数，CPU核数，以及CPU负荷等当前系统的状态来决定Concurrent Dispatch Queue中并发处理的任务数。</p>
</blockquote>
<h2 id="队列的命名"><a href="#队列的命名" class="headerlink" title="队列的命名"></a>队列的命名</h2><p>现在我们知道dispatch_queue_create方法第一个参数指定了这个新建队列的名称，推荐使用逆序quan cheng全程域名(FQDN,fully qualified domain name)。这个名称可以在Xcode和CrashLog中显示出来，对bug的追踪很有帮助。</p>
<p>在继续讲解之前做个小总结，现在我们知道了：</p>
<ul>
<li>如何创建串行队列和并发队列。</li>
<li>将任务追加到这两种队列里以后的执行效果。</li>
<li>将任务追加到多个串行队列会使这几个任务在不同的线程执行。</li>
</ul>
<p>实际上，系统给我们提供了两种特殊的队列，分别对应串行队列和并发队列：</p>
<h2 id="系统提供的队列"><a href="#系统提供的队列" class="headerlink" title="系统提供的队列"></a>系统提供的队列</h2><h3 id="Main-Dispatch-Queue"><a href="#Main-Dispatch-Queue" class="headerlink" title="Main Dispatch Queue"></a>Main Dispatch Queue</h3><p>主队列：放在这个队列里的任务会追加到主线程的RunLoop中执行。需要刷新UI的时候我们可以直接获取这个队列，将任务追加到这个队列中。</p>
<h3 id="Globle-Dispatch-Queue"><a href="#Globle-Dispatch-Queue" class="headerlink" title="Globle Dispatch Queue"></a>Globle Dispatch Queue</h3><p>全局并发队列：开发者可以不需要特意通过dispatch_queue_create方法创建一个Concurrent Dispatch Queue，可以将任务直接放在这个全局并发队列里面。</p>
<p>有一个常见的例子可以充分体现二者的使用方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取全局并发队列进行耗时操作 </span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">          <span class="comment">//加载图片</span></div><div class="line">          <span class="built_in">NSData</span> *dataFromURL = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageURL];</div><div class="line">          <span class="built_in">UIImage</span> *imageFromData = [<span class="built_in">UIImage</span> imageWithData:dataFromURL];</div><div class="line"></div><div class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">              <span class="comment">//获取主队列，在图片加载完成后更新UIImageView</span></div><div class="line">              <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:imageFromData];          </div><div class="line">      &#125;);      </div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<h1 id="GCD的各种函数"><a href="#GCD的各种函数" class="headerlink" title="GCD的各种函数"></a>GCD的各种函数</h1><h2 id="dispatch-set-target-queue"><a href="#dispatch-set-target-queue" class="headerlink" title="dispatch_set_target_queue"></a>dispatch_set_target_queue</h2><p>这个函数有两个作用：</p>
<ol>
<li>改变队列的优先级。</li>
<li>防止多个串行队列的并发执行。</li>
</ol>
<h3 id="改变队列的优先级"><a href="#改变队列的优先级" class="headerlink" title="改变队列的优先级"></a>改变队列的优先级</h3><p>dispatch_queue_create方法生成的串行队列合并发队列的优先级都是与默认优先级的Globle Dispatch Queue一致。</p>
<p>如果想要变更某个队列的优先级，需要使用dispatch_set_target_queue函数。<br>举个🌰：创建一个在后台执行动作处理的Serial Dispatch Queue<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//需求：生成一个后台的串行队列</span></div><div class="line">- (<span class="keyword">void</span>)changePriority</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"queue"</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> bgQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, <span class="number">0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//第一个参数：需要改变优先级的队列；</span></div><div class="line">    <span class="comment">//第二个参数：目标队列</span></div><div class="line">    dispatch_set_target_queue(queue, bgQueue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="防止多个串行队列的并发执行"><a href="#防止多个串行队列的并发执行" class="headerlink" title="防止多个串行队列的并发执行"></a>防止多个串行队列的并发执行</h3><p>有时，我们将不能并发执行的处理追加到多个Serial Dispatch Queue中时，可以使用dispatch_set_target_queue函数将目标函数定为某个Serial Dispatch Queue，就可以防止这些处理的并发执行。</p>
<p>代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">        <span class="comment">//5个串行队列</span></div><div class="line">        <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"serial_queue"</span>, <span class="literal">NULL</span>);</div><div class="line">        [array addObject:serial_queue];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">dispatch_queue_t</span> queue, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,idx);</div><div class="line">    &#125;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999714</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999726</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999717</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999715</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">40329</span>:<span class="number">2999730</span>] 任务<span class="number">4</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到，如果仅仅是将任务追加到5个串行队列中，那么这些任务就会并发执行。</p>
</blockquote>
<p>那接下来看看使用dispatch_set_target_queue方法以后：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多个串行队列，设置了target queue</span></div><div class="line"><span class="built_in">NSMutableArray</span> *array = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"><span class="built_in">dispatch_queue_t</span> serial_queue_target = dispatch_queue_create(<span class="string">"queue_target"</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">      </div><div class="line">    <span class="comment">//分别给每个队列设置相同的target queue  </span></div><div class="line">    <span class="built_in">dispatch_queue_t</span> serial_queue = dispatch_queue_create(<span class="string">"serial_queue"</span>, <span class="literal">NULL</span>);</div><div class="line">    dispatch_set_target_queue(serial_queue, serial_queue_target);</div><div class="line">    [array addObject:serial_queue];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">[array enumerateObjectsUsingBlock:^(<span class="built_in">dispatch_queue_t</span> queue, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,idx);</div><div class="line">    &#125;);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">40408</span>:<span class="number">3004382</span>] 任务<span class="number">4</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>很显然，这些任务就按顺序执行了。</p>
</blockquote>
<h2 id="dispatch-after"><a href="#dispatch-after" class="headerlink" title="dispatch_after"></a>dispatch_after</h2><p>dispatch_after解决的问题：某个线程里，在指定的时间后处理某个任务：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">3</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"三秒之后追加到队列"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>注意：不是在3秒之后处理任务，准确来说是3秒之后追加到队列。所以说，如果这个线程的runloop执行1/60秒一次，那么这个block最快会在3秒后执行，最慢会在（3+1/60）秒后执行。而且，如果这个队列本身还有延迟，那么这个block的延迟执行时间会更多。</p>
<h2 id="dispatch-group"><a href="#dispatch-group" class="headerlink" title="dispatch_group"></a>dispatch_group</h2><p>如果遇到这样到需求：全部处理完多个预处理任务(block_1 ~ 4)后执行某个任务（block_finish），我们有两个方法：</p>
<ul>
<li>如果预处理任务需要一个接一个的执行：将所有需要先处理完的任务追加到Serial Dispatch Queue中，并在最后追加最后处理的任务(block_finish)。</li>
<li>如果预处理任务需要并发执行：需要使用dispatch_group函数，将这些预处理的block追加到global dispatch queue中。</li>
</ul>
<p>分别详细讲解一下两种需求的实现方式：</p>
<h3 id="预处理任务需要一个接一个的执行："><a href="#预处理任务需要一个接一个的执行：" class="headerlink" title="预处理任务需要一个接一个的执行："></a>预处理任务需要一个接一个的执行：</h3><p>这个需求的实现方式相对简单一点，只要将所有的任务（block_1 ~ 4 + block_finish）放在一个串行队列中即可，因为都是按照顺序执行的，只要不做多余的事情，这些任务就会乖乖地按顺序执行。</p>
<h3 id="预处理任务需要一个接一个的执行：-1"><a href="#预处理任务需要一个接一个的执行：-1" class="headerlink" title="预处理任务需要一个接一个的执行："></a>预处理任务需要一个接一个的执行：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">        dispatch_group_async(group, queue, ^&#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,index);</div><div class="line">        &#125;);</div><div class="line">&#125;</div><div class="line">    </div><div class="line">dispatch_group_notify(group, queue, ^&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"最后的任务"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057237</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057235</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057234</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057253</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057237</span>] 任务<span class="number">4</span></div><div class="line">gcd_demo[<span class="number">40905</span>:<span class="number">3057237</span>] 最后的任务</div></pre></td></tr></table></figure></p>
<p>因为这些预处理任务都是追加到global dispatch queue中的，所以这些任务的执行任务的顺序是不定的。但是最后的任务一定是最后输出的。</p>
<blockquote>
<p>dispatch_group_notify函数监听传入的group中任务的完成，等这些任务全部执行以后，再将第三个参数（block）追加到第二个参数的queue（相同的queue）中。</p>
</blockquote>
<h2 id="dispatch-group-wait"><a href="#dispatch-group-wait" class="headerlink" title="dispatch_group_wait"></a>dispatch_group_wait</h2><p>dispatch_group_wait 也是配合dispatch_group 使用的，利用这个函数，我们可以设定group内部所有任务执行完成的超时时间。</p>
<p>一共有两种情况：超时的情况和没有超时的情况：</p>
<h3 id="超时的情况："><a href="#超时的情况：" class="headerlink" title="超时的情况："></a>超时的情况：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_wait_1</div><div class="line">&#123;</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">        dispatch_group_async(group, queue, ^&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i ++) &#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">    <span class="keyword">long</span> result = dispatch_group_wait(group, time);</div><div class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"group内部的任务全部结束"</span>);</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"虽然过了超时时间，group还有任务没有完成"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087481</span>] 虽然过了超时时间，group还有任务没有完成，结果是判定为超时</div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087563</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087564</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087579</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087566</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">41277</span>:<span class="number">3087563</span>] 任务<span class="number">4</span></div></pre></td></tr></table></figure></p>
<h3 id="没有超时的情况："><a href="#没有超时的情况：" class="headerlink" title="没有超时的情况："></a>没有超时的情况：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_wait_2</div><div class="line">&#123;</div><div class="line">    dispatch_group_t group = dispatch_group_create();</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index ++) &#123;</div><div class="line">        dispatch_group_async(group, queue, ^&#123;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt; <span class="number">100000000</span>; i ++) &#123;</div><div class="line">                </div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"任务%ld"</span>,index);</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, <span class="number">1</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</div><div class="line">    <span class="keyword">long</span> result = dispatch_group_wait(group, time);</div><div class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"group内部的任务全部结束"</span>);</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"虽然过了超时时间，group还有任务没有完成"</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092079</span>] 任务<span class="number">2</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092076</span>] 任务<span class="number">3</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092092</span>] 任务<span class="number">1</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092077</span>] 任务<span class="number">0</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3092079</span>] 任务<span class="number">4</span></div><div class="line">gcd_demo[<span class="number">41357</span>:<span class="number">3091956</span>] group内部的任务全部结束，在超时的时间以内完成，结果判定为没有超时</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：<br>一旦调用dispatch_group_wait以后，当经过了函数中指定的超时时间后 或者 指定的group内的任务全部执行后会返回这个函数的结果：</p>
<ul>
<li>经过了函数中指定的超时时间后，group内部的任务没有全部完成，判定为超时，否则，没有超时</li>
<li>指定的group内的任务全部执行后，经过的时间长于超时时间，判定为超时，否则，没有超时。</li>
</ul>
<p>也就是说：<br>如果指定的超时时间为DISPATCH_TIME_NOW，那么则没有等待，立即判断group内的任务是否完成。</p>
<p>可以看出，指定的超时时间为DISPATCH_TIME_NOW的时候相当于dispatch_group_notify函数的使用：判断group内的任务是否都完成。</p>
</blockquote>
<p>然而dispatch_group_notify函数是作者推荐的，因为通过这个函数可以直接设置最后任务所被追加的队列，使用起来相对比较方便。</p>
<h2 id="dispatch-barrier-async"><a href="#dispatch-barrier-async" class="headerlink" title="dispatch_barrier_async"></a>dispatch_barrier_async</h2><p>关于解决数据竞争的方法：读取处理是可以并发的，但是写入处理却是不允许并发执行的。</p>
<p>所以合理的方案是这样的：</p>
<ul>
<li>读取处理追加到concurrent dispatch queue中</li>
<li>写入处理在任何一个读取处理没有执行的状态下，追加到serial dispatch queue中（也就是说，在写入处理结束之前，读取处理不可执行）。</li>
</ul>
<p>我们看看如何使用dispatch_barrier_async来解决这个问题。</p>
<p>为了帮助大家理解，我构思了一个例子：</p>
<ol>
<li>3名董事和总裁开会，在每个人都查看完合同之后，由总裁签字。</li>
<li>总裁签字之后，所有人再审核一次合同。</li>
</ol>
<p>这个需求有三个关键点：</p>
<ul>
<li>关键点1：所有与会人员查看和审核合同，是同时进行的，无序的行为。</li>
<li>关键点2：只有与会人员都查看了合同之后，总裁才能签字。</li>
<li>关键点3:   只有总裁签字之后，才能进行审核。</li>
</ul>
<p>用代码看一下：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_barrier</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> meetingQueue = dispatch_queue_create(<span class="string">"com.meeting.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"总裁查看合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事1查看合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事2查看合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事3查看合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_barrier_async(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"总裁签字"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"总裁审核合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事1审核合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事2审核合同"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(meetingQueue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"董事3审核合同"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140315</span>] 总裁查看合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140296</span>] 董事<span class="number">1</span>查看合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140297</span>] 董事<span class="number">3</span>查看合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140299</span>] 董事<span class="number">2</span>查看合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140299</span>] 总裁签字</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140299</span>] 总裁审核合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140297</span>] 董事<span class="number">1</span>审核合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140296</span>] 董事<span class="number">2</span>审核合同</div><div class="line">gcd_demo[<span class="number">41791</span>:<span class="number">3140320</span>] 董事<span class="number">3</span>审核合同</div></pre></td></tr></table></figure></p>
<blockquote>
<p>在这里，我们可以将meetingQueue看成是会议的时间线。总裁签字这个行为相当于写操作，其他都相当于读操作。使用dispatch_barrier_async以后，之前的所有并发任务都会被dispatch_barrier_async里的任务拦截掉，就像函数名称里的“栅栏”一样。</p>
</blockquote>
<p>因此，使用Concurrent Dispatch Queue 和 dispatch_barrier_async 函数可以实现高效率的数据库访问和文件访问。</p>
<h2 id="dispatch-sync"><a href="#dispatch-sync" class="headerlink" title="dispatch_sync"></a>dispatch_sync</h2><p>到目前为止的所有例子都使用的是异步函数，有异步就一定会有同步，那么现在就来区分一下同步和异步函数的区别：</p>
<ul>
<li>dispatch_async：异步函数，这个函数会立即返回，不做任何等待，它所指定的block“非同步地”追加到指定的队列中。</li>
<li>dispatch_sync：同步函数，这个函数不会立即返回，它会一直等待追加到特定队列中的制定block完成工作后才返回，所以它的目的（也是效果）是阻塞当前线程。</li>
</ul>
<p>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_sync_1</div><div class="line">&#123;</div><div class="line">    <span class="comment">//同步处理</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"同步处理开始"</span>);</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSInteger</span> num = <span class="number">0</span>;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        <span class="comment">//模仿耗时操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i ++) &#123;</div><div class="line">            num++;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"同步处理完毕"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,num);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x60800006fa40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] 同步处理开始</div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x60800006fa40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] 同步处理完毕</div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] <span class="number">1000000000</span></div><div class="line">gcd_demo[<span class="number">5604</span>:<span class="number">188687</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x60800006fa40</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div></pre></td></tr></table></figure></p>
<p>在最开始的时候只打印前两行，循环完毕之后才打印后面的内容。<br>因为是同步函数，它阻塞了当前线程（主线程），所以只能等到block内部的任务都结束后，才能打印下面的两行。</p>
<p>但是如果使用异步函数会怎样呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_sync_2</div><div class="line">&#123;</div><div class="line">    <span class="comment">//异步处理</span></div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"异步处理开始"</span>);</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSInteger</span> num = <span class="number">0</span>;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="comment">//模仿耗时操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt; <span class="number">1000000000</span>; i ++) &#123;</div><div class="line">            num++;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"异步处理完毕"</span>);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,num);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194233</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x600000071f00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194233</span>] 异步处理开始</div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194233</span>] <span class="number">0</span></div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194233</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x600000071f00</span>&gt;&#123;number = <span class="number">1</span>, name = main&#125;</div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194280</span>] &lt;<span class="built_in">NSThread</span>: <span class="number">0x608000260400</span>&gt;&#123;number = <span class="number">3</span>, name = (null)&#125;</div><div class="line">gcd_demo[<span class="number">5685</span>:<span class="number">194280</span>] 异步处理完毕</div></pre></td></tr></table></figure></p>
<p>我们可以看到，不同于上面的情况，block下面的两个输出是先打印的（因为没有经过for循环的计算，num的值是0）。因为是异步处理，所以没有等待block中任务的完成就立即返回了。</p>
<p>了解了同步异步的区别之后，我们看一下使用同步函数容易发生的问题：如果给同步函数传入的队列是串行队列的时候就会容易造成死锁。看一下一个死锁的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_sync_3</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务1"</span>);</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div><div class="line">    <span class="built_in">dispatch_sync</span>(queue, ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"任务2"</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"任务3"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码只能输出任务1，并形成死锁。<br>因为任务2被追加到了主队列的最后，所以它需要等待任务3执行完成。<br>但又因为是同步函数，任务3也在等待任务2执行完成。<br>二者互相等待，所以形成了死锁。</p>
<h2 id="dispatch-apply"><a href="#dispatch-apply" class="headerlink" title="dispatch_apply"></a>dispatch_apply</h2><p>通过dispatch_apply函数，我们可以按照指定的次数将block追加到指定的队列中。并等待全部处理执行结束。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_apply_1</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,index);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240332</span>] <span class="number">1</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240331</span>] <span class="number">0</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240334</span>] <span class="number">2</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240332</span>] <span class="number">4</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240334</span>] <span class="number">6</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240331</span>] <span class="number">5</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240332</span>] <span class="number">7</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240334</span>] <span class="number">8</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240331</span>] <span class="number">9</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240259</span>] <span class="number">3</span></div><div class="line">gcd_demo[<span class="number">6128</span>:<span class="number">240259</span>] 完毕</div></pre></td></tr></table></figure>
<p>我们也可以用这个函数来遍历数组，取得下标进行操作:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_apply_2</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>,@<span class="number">10</span>,@<span class="number">43</span>,@<span class="number">13</span>,@<span class="number">33</span>];</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    dispatch_apply([array count], queue, ^(size_t index) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array[index]);</div><div class="line">    &#125;);</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244316</span>] <span class="number">10</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244313</span>] <span class="number">1</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244316</span>] <span class="number">33</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244314</span>] <span class="number">43</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244261</span>] <span class="number">13</span></div><div class="line">gcd_demo[<span class="number">6180</span>:<span class="number">244261</span>] 完毕</div></pre></td></tr></table></figure></p>
<p>我们可以看到dispatch_apply函数与dispatch_sync函数同样具有阻塞的作用（dispatch_apply函数返回后才打印完毕）。</p>
<p>我们也可以在dispatch_async函数里执行dispatch_apply函数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_apply_3</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span> *array = @[@<span class="number">1</span>,@<span class="number">10</span>,@<span class="number">43</span>,@<span class="number">13</span>,@<span class="number">33</span>];</div><div class="line">        __block  <span class="built_in">NSInteger</span> sum = <span class="number">0</span>;</div><div class="line">    </div><div class="line">        dispatch_apply([array count], queue, ^(size_t index) &#123;</div><div class="line">            <span class="built_in">NSNumber</span> *number = array[index];</div><div class="line">            <span class="built_in">NSInteger</span> num = [number integerValue];</div><div class="line">            sum += num;</div><div class="line">        &#125;);</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="comment">//回到主线程，拿到总和</span></div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"完毕"</span>);</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%ld"</span>,sum);</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="dispatch-suspend-dispatch-resume"><a href="#dispatch-suspend-dispatch-resume" class="headerlink" title="dispatch_suspend/dispatch_resume"></a>dispatch_suspend/dispatch_resume</h2><p>挂起函数调用后对已经执行的处理没有影响，但是追加到队列中但是尚未执行的处理会在此之后停止执行。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dispatch_suspend(queue);</div><div class="line">dispatch_resume(queue);</div></pre></td></tr></table></figure>
<h2 id="dispatch-once"><a href="#dispatch-once" class="headerlink" title="dispatch_once"></a>dispatch_once</h2><p>通过dispatch_once处理的代码只执行一次，而且是线程安全的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dispatch_once_1</div><div class="line">&#123;</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">5</span>; index++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">            [<span class="keyword">self</span> onceCode];</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)onceCode</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"只执行一次的代码"</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcd_demo[<span class="number">7556</span>:<span class="number">361196</span>] 只执行一次的代码</div></pre></td></tr></table></figure></p>
<p>该函数主要用于单例模式的使用。</p>
<p>到这里终于总结完啦，这本书加深了我对iOS内存管理，block以及GCD的理解，希望我写的这三篇能对您有所帮助～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程：iOS与OS X多线程和内存管理》&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们知道在iOS开发中，一共有四种多线程技术：pthread，NSThread，GCD，NSOperation：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前两者是面向线程开发的多线程技术，需要开发者自己去维护线程的生命周期，比较繁琐。&lt;/li&gt;
&lt;li&gt;后两者是面向队列开发的多线程技术，开发者仅仅定义想执行的任务追加到适当的Dispatch Queue（队列）中并设置一些优先级，依赖等操作就可以了，其他的事情可以交给系统来做。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在这一章里，作者主要介绍了GCD技术，它是基于C语言的API，开发者只需要将任务放在block内，并指定好追加的队列，就可以完成多线程开发。&lt;/p&gt;
&lt;p&gt;但是多线程开发时容易发生的一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个线程更新相同的资源：数据竞争。&lt;/li&gt;
&lt;li&gt;多个线程相互持续等待：死锁。&lt;/li&gt;
&lt;li&gt;使用太多的线程导致消耗内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然解决这些问题的代价是会使程序的复杂度上升，但是多线程技术仍然是必须使用的：因为使用多线程编程可以保证应用程序的响应性能。如果耗时操作阻塞了主线程的RunLoop，会导致用户界面无法响应用户的操作，所以必须开启子线程将耗时操作放在子线程中处理。那么我们应该怎么进行多线程开发呢？在讲解之前先看一下本文结构（GCD部分）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程》 干货三部曲&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文的Demo地址：&lt;a href=&quot;https://github.com/knightsj/iOS_Demo/tree/master/%5B12%5D.%20gcd_demo&quot;&gt;knightsj/iOS_Demo/gcd_demo&lt;/a&gt;&lt;br&gt;虽然文章里应给出了详细的输出结果，但还是希望读者可以将demo下载后仔细对照一下代码并体会。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C 高级编程》干货三部曲（二）：Blocks篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/04/17/%E3%80%8AObjective-C%20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9ABlocks%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/04/17/《Objective-C 高级编程》干货三部曲（二）：Blocks篇/</id>
    <published>2017-04-17T00:22:24.000Z</published>
    <updated>2017-04-17T00:41:17.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>这一章讲解了Block相关的知识。因为作者将Objective-C的代码转成了C++的代码，所以第一次看的时候非常吃力，我自己也不记得看了多少遍了。</p>
<p>这篇总结不仅仅只有这本书中的内容，还有一点在其他博客里看过的Block的相关知识，并加上了自己的理解，而且文章结构也和原书不太一致，是经过我的整理重新排列出来的。</p>
<p>先看一下本文结构（Blocks部分）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程》 干货三部曲"></p>
<a id="more"></a>
<h1 id="需要先知道的"><a href="#需要先知道的" class="headerlink" title="需要先知道的"></a>需要先知道的</h1><h2 id="Objective-C-转-C-的方法"><a href="#Objective-C-转-C-的方法" class="headerlink" title="Objective-C 转 C++的方法"></a>Objective-C 转 C++的方法</h2><p>因为需要看Block操作的C++源码，所以需要知道转换的方法，自己转过来看一看：</p>
<ol>
<li>在OC源文件block.m写好代码。</li>
<li>打开终端，cd到block.m所在文件夹。</li>
<li>输入<code>clang -rewrite-objc block.m</code>，就会在当前文件夹内自动生成对应的block.cpp文件。</li>
</ol>
<h2 id="关于几种变量的特点"><a href="#关于几种变量的特点" class="headerlink" title="关于几种变量的特点"></a>关于几种变量的特点</h2><p>c语言的函数中可能使用的变量：</p>
<ul>
<li>函数的参数</li>
<li>自动变量（局部变量）</li>
<li>静态变量（静态局部变量）</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>而且，由于存储区域特殊，这其中有三种变量是可以在任何时候以任何状态调用的：</p>
<ul>
<li>静态变量</li>
<li>静态全局变量</li>
<li>全局变量</li>
</ul>
<p>而其他两种，则是有各自相应的作用域，超过作用域后，会被销毁。</p>
<p>好了，知道了这两点，理解下面的内容就容易一些了。</p>
<h1 id="Block的实质"><a href="#Block的实质" class="headerlink" title="Block的实质"></a>Block的实质</h1><p>先说结论：Block实质是Objective-C对闭包的对象实现，简单说来，Block就是对象。</p>
<p>下面分别从表层到底层来分析一下：</p>
<h2 id="表层分析Block的实质：它是一个类型"><a href="#表层分析Block的实质：它是一个类型" class="headerlink" title="表层分析Block的实质：它是一个类型"></a>表层分析Block的实质：它是一个类型</h2><p>Block是一种类型，一旦使用了Block就相当于生成了可赋值给Block类型变量的值。举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (^blk)(<span class="keyword">int</span>) = ^(<span class="keyword">int</span> count)&#123;</div><div class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ul>
<li>等号左侧的代码表示了这个Block的类型：它接受一个int参数，返回一个int值。</li>
<li>等号右侧的代码是这个Block的值：它是等号左侧定义的block类型的一种实现。</li>
</ul>
<p>如果我们在项目中经常使用某种相同类型的block，我们可以用<code>typedef</code>来抽象出这种类型的Block：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>(^AddOneBlock)(<span class="keyword">int</span> count);</div><div class="line"></div><div class="line">AddOneBlock block = ^(<span class="keyword">int</span> count)&#123;</div><div class="line">        <span class="keyword">return</span> count + <span class="number">1</span>;<span class="comment">//具体实现代码</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这样一来，block的赋值和传递就变得相对方便一些了, 因为block的类型已经抽象了出来。</p>
<h2 id="深层分析Block的实质：它是Objective-C对象"><a href="#深层分析Block的实质：它是Objective-C对象" class="headerlink" title="深层分析Block的实质：它是Objective-C对象"></a>深层分析Block的实质：它是Objective-C对象</h2><p>Block其实就是Objective-C对象，因为它的结构体中含有isa指针。</p>
<p>下面将Objective-C的代码转化为C++的代码来看一下block的实现。</p>
<p><strong>OC代码:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        printf(<span class="string">"Block\n"</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>C++代码:</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">  <span class="keyword">void</span> *isa;</div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;</div><div class="line">  <span class="keyword">void</span> *FuncPtr;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//block结构体</span></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">    </div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">    </div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  </div><div class="line">  <span class="comment">//Block构造函数</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;<span class="comment">//isa指针</span></div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">    </div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//将来被调用的block内部的代码：block值被转换为C的函数代码</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">        printf(<span class="string">"Block\n"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">    </div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">    </div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="comment">//main 函数</span></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先我们看一下从原来的block值（OC代码块）转化而来的C++代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">    printf(<span class="string">"Block\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里，*__cself 是指向Block的值的指针，也就相当于是Block的值它自己（相当于C++里的this，OC里的self）。</p>
<p>而且很容易看出来，<strong>cself 是指向</strong>main_block_impl_0结构体实现的指针。<br>结合上句话，也就是说Block结构体就是<strong>main_block_impl_0结构体。Block的值就是通过</strong>main_block_impl_0构造出来的。</p>
</blockquote>
<p>下面来看一下这个结构体的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">    </div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">    </div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  </div><div class="line">  <span class="comment">//构造函数</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>可以看出，__main_block_impl_0结构体有三个部分：</p>
<p>第一个是成员变量impl，它是实际的函数指针，它指向__main_block_func_0。来看一下它的结构体的声明：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __block_impl &#123;</div><div class="line">  <span class="keyword">void</span> *isa;</div><div class="line">  <span class="keyword">int</span> Flags;</div><div class="line">  <span class="keyword">int</span> Reserved;  <span class="comment">//今后版本升级所需的区域</span></div><div class="line">  <span class="keyword">void</span> *FuncPtr; <span class="comment">//函数指针</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>第二个是成员变量是指向__main_block_desc_0结构体的Desc指针，是用于描述当前这个block的附加信息的，包括结构体的大小等等信息</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">    </div><div class="line">  size_t reserved;  <span class="comment">//今后升级版本所需区域</span></div><div class="line">  size_t Block_size;<span class="comment">//block的大小</span></div><div class="line">    </div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div></pre></td></tr></table></figure>
<p>第三个部分是<strong>main_block_impl_0结构体的构造函数，</strong>main_block_impl_0 就是该 block 的实现</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">__main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>在这个结构体的构造函数里，isa指针保持这所属类的结构体的实例的指针。__main_block_imlp_0结构体就相当于Objective-C类对象的结构体，这里的_NSConcreteStackBlock相当于Block的结构体实例,<strong>也就是说block其实就是Objective-C对于闭包的对象实现</strong>。</p>
<h1 id="Block截获自动变量和对象"><a href="#Block截获自动变量和对象" class="headerlink" title="Block截获自动变量和对象"></a>Block截获自动变量和对象</h1><h2 id="Block截获自动变量（局部变量）"><a href="#Block截获自动变量（局部变量）" class="headerlink" title="Block截获自动变量（局部变量）"></a>Block截获自动变量（局部变量）</h2><p>使用Block的时候，不仅可以使用其内部的参数，还可以使用Block外部的局部变量。而一旦在Block内部使用了其外部变量，这些变量就会被Block保存。</p>
<p>有趣的是，即使在Block外部修改这些变量，存在于Block内部的这些变量也不会被修改。来看一下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</div><div class="line">    </div><div class="line">PrintTwoIntBlock block = ^()&#123;</div><div class="line">    printf(<span class="string">"%d, %d\n"</span>,a,b);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">block();<span class="comment">//10 20</span></div><div class="line">    </div><div class="line">a += <span class="number">10</span>;</div><div class="line">b += <span class="number">30</span>;</div><div class="line">    </div><div class="line">printf(<span class="string">"%d, %d\n"</span>,a,b);<span class="comment">//20 50</span></div><div class="line">    </div><div class="line">block();<span class="comment">//10 20</span></div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，在外部修改a，b的值以后，再次调用block时，里面的打印仍然和之前是一样的。给人的感觉是，外部到局部变量和被Block内部截获的变量并不是同一份。</p>
</blockquote>
<p>那如果在内部修改a，b的值会怎么样呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</div><div class="line">    </div><div class="line">PrintTwoIntBlock block = ^()&#123;</div><div class="line">    <span class="comment">//编译不通过</span></div><div class="line">    a = <span class="number">30</span>;</div><div class="line">    b = <span class="number">10</span>;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">block();</div></pre></td></tr></table></figure>
<p>如果不进行额外操作，局部变量一旦被Block保存，在Block内部就不能被修改了。</p>
<p>但是需要注意的是，这里的修改是指整个变量的赋值操作，变更该对象的操作是允许的，比如在不加上__block修饰符的情况下，给在block内部的可变数组添加对象的操作是可以的。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableArray</span> *array = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array); <span class="comment">//@[]</span></div><div class="line">    </div><div class="line">PrintTwoIntBlock block = ^()&#123;</div><div class="line">    [array addObject:@<span class="number">1</span>];</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">block();</div><div class="line">    </div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,array);<span class="comment">//@[1]</span></div></pre></td></tr></table></figure>
<p>OK，现在我们知道了三点：</p>
<ol>
<li>Block可以截获局部变量。</li>
<li>修改Block外部的局部变量，Block内部被截获的局部变量不受影响。</li>
<li>修改Block内部到局部变量，编译不通过。</li>
</ol>
<p>为了解释2，3点，我们通过C++的代码来看一下Block在截获变量的时候都发生了什么：<br><strong>C代码：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>;</div><div class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        printf(fmt,val);</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    val = <span class="number">2</span>;</div><div class="line">    fmt = <span class="string">"These values were changed. var = %d\n"</span>;</div><div class="line">    </div><div class="line">    blk();</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>C++代码：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  </div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;  <span class="comment">//被添加</span></div><div class="line">  <span class="keyword">int</span> val;          <span class="comment">//被添加</span></div><div class="line">  </div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></div><div class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></div><div class="line"></div><div class="line">        printf(fmt,val);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> dmy = <span class="number">256</span>;</div><div class="line">    <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"var = %d\n"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val));</div><div class="line"></div><div class="line">    val = <span class="number">2</span>;</div><div class="line">    fmt = <span class="string">"These values were changed. var = %d\n"</span>;</div><div class="line"></div><div class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>单独抽取__main_block_impl_0来看一下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt; <span class="comment">//截获的自动变量</span></div><div class="line">  <span class="keyword">int</span> val;         <span class="comment">//截获的自动变量</span></div><div class="line">  </div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<ol>
<li>我们可以看到，在block内部语法表达式中使用的自动变量（fmt，val）被作为成员变量追加到了__main_block_impl_0结构体中（注意：block没有使用的自动变量不会被追加，如dmy变量）。</li>
<li>在初始化block结构体实例时（请看<strong>main_block_impl_0的构造函数），还需要截获的自动变量fmt和val来初始化</strong>main_block_impl_0结构体实例，因为增加了被截获的自动变量，block的体积会变大。</li>
</ol>
<p>再来看一下函数体的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = __cself-&gt;fmt; <span class="comment">// bound by copy</span></div><div class="line">  <span class="keyword">int</span> val = __cself-&gt;val; <span class="comment">// bound by copy</span></div><div class="line">  printf(fmt,val);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>从这里看就更明显了：fmt,var都是从__cself里面获取的，更说明了二者是属于block的。而且从注释来看（注释是由clang自动生成的），这两个变量是值传递，而不是指针传递，也就是说Block仅仅截获自动变量的值，所以这就解释了<strong>即使改变了外部的自动变量的值，也不会影响Block内部的值</strong>。</p>
</blockquote>
<p>那为什么在默认情况下改变Block内部到变量会导致编译不通过呢？<br>我的思考是：既然我们无法在Block中改变外部变量的值，所以也就没有必要在Block内部改变变量的值了，因为Block内部和外部的变量实际上是两种不同的存在：前者是Block内部结构体的一个成员变量，后者是在栈区里的临时变量。</p>
<p>现在我们知道：被截获的自动变量的值是无法直接修改的，但是有两个方法可以解决这个问题：</p>
<ol>
<li>改变存储于特殊存储区域的变量。</li>
<li>通过__block修饰符来改变。</li>
</ol>
<h2 id="1-改变存储于特殊存储区域的变量"><a href="#1-改变存储于特殊存储区域的变量" class="headerlink" title="1. 改变存储于特殊存储区域的变量"></a>1. 改变存储于特殊存储区域的变量</h2><ul>
<li>全局变量，可以直接访问。</li>
<li>静态全局变量，可以直接访问。</li>
<li>静态变量，直接指针引用。</li>
</ul>
<p>我们还是用OC和C++代码的对比看一下具体的实现:</p>
<p><strong>OC代码：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> global_val = <span class="number">1</span>;<span class="comment">//全局变量</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;<span class="comment">//全局静态变量</span></div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;<span class="comment">//静态变量</span></div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        global_val *=<span class="number">1</span>;</div><div class="line">        static_global_val *=<span class="number">2</span>;</div><div class="line">        static_val *=<span class="number">3</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>C++代码：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> global_val = <span class="number">1</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">int</span> *static_val;</div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span></div><div class="line"></div><div class="line">  global_val *=<span class="number">1</span>;</div><div class="line">  static_global_val *=<span class="number">2</span>;</div><div class="line">  (*static_val) *=<span class="number">3</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，</p>
<ul>
<li><p>全局变量和全局静态变量没有被截获到block里面，它们的访问是不经过block的(与__cself无关)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span></div><div class="line"></div><div class="line">  global_val *=<span class="number">1</span>;</div><div class="line">  static_global_val *=<span class="number">2</span>;</div><div class="line">  (*static_val) *=<span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>访问静态变量（static_val）时，将静态变量的指针传递给__main_block_impl_0结构体的构造函数并保存：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">int</span> *static_val;<span class="comment">//是指针，不是值</span></div><div class="line">  </div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>那么有什么方法可以在Block内部给变量赋值呢？– 通过<strong>block关键字。在讲解</strong>block关键字之前，讲解一下Block截获对象：</p>
<h2 id="Block截获对象"><a href="#Block截获对象" class="headerlink" title="Block截获对象"></a>Block截获对象</h2><p>我们看一下在block里截获了array对象的代码，array超过了其作用域存在：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">blk_t blk;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    blk = [^(<span class="keyword">id</span> object)&#123;</div><div class="line">        [array addObject:object];</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>,[array count]);</div><div class="line">            </div><div class="line">    &#125; <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line">    </div><div class="line">blk([<span class="built_in">NSObject</span> new]);</div><div class="line">blk([<span class="built_in">NSObject</span> new]);</div><div class="line">blk([<span class="built_in">NSObject</span> new]);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">block_demo[<span class="number">28963</span>:<span class="number">1629127</span>] array count = <span class="number">1</span></div><div class="line">block_demo[<span class="number">28963</span>:<span class="number">1629127</span>] array count = <span class="number">2</span></div><div class="line">block_demo[<span class="number">28963</span>:<span class="number">1629127</span>] array count = <span class="number">3</span></div></pre></td></tr></table></figure></p>
<p>看一下C++代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  <span class="keyword">id</span> array;<span class="comment">//截获的对象</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">id</span> _array, <span class="keyword">int</span> flags=<span class="number">0</span>) : array(_array) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>值得注意的是，在OC中，C结构体里不能含有被<strong>strong修饰的变量，因为编译器不知道应该何时初始化和废弃C结构体。但是OC的运行时库能够准确把握Block从栈复制到堆，以及堆上的block被废弃的时机，在实现上是通过</strong>main_block_copy_0函数和__main_block_dispose_0函数进行的:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;array, (<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;</div><div class="line">    _Block_object_dispose((<span class="keyword">void</span>*)src-&gt;array, <span class="number">3</span><span class="comment">/*BLOCK_FIELD_IS_OBJECT*/</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其中，_Block_object_assign相当于retain操作，将对象赋值在对象类型的结构体成员变量中。<br>_Block_object_dispose相当于release操作。</p>
</blockquote>
<p>这两个函数调用的时机是在什么时候呢？</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>被调用时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>__main_block_copy_0</td>
<td>从栈复制到堆时</td>
</tr>
<tr>
<td>__main_block_dispose_0</td>
<td>堆上的Block被废弃时</td>
</tr>
</tbody>
</table>
<p><strong>什么时候栈上的Block会被复制到堆呢？</strong></p>
<ul>
<li>调用block的copy函数时</li>
<li>Block作为函数返回值返回时</li>
<li>将Block赋值给附有__strong修饰符id类型的类或者Block类型成员变量时</li>
<li>方法中含有usingBlock的Cocoa框架方法或者GCD的API中传递Block时</li>
</ul>
<p><strong>什么时候Block被废弃呢？</strong></p>
<p>堆上的Block被释放后，谁都不再持有Block时调用dispose函数。</p>
<p>__weak关键字：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">        <span class="keyword">id</span> array = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">        <span class="keyword">id</span> __<span class="keyword">weak</span> array2 = array;</div><div class="line">        blk = ^(<span class="keyword">id</span> object)&#123;</div><div class="line">            [array2 addObject:object];</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"array count = %ld"</span>,[array2 count]);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    blk([<span class="built_in">NSObject</span> new]);</div><div class="line">    blk([<span class="built_in">NSObject</span> new]);</div><div class="line">    blk([<span class="built_in">NSObject</span> new]);</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">block_demo[<span class="number">32084</span>:<span class="number">1704240</span>] array count = <span class="number">0</span></div><div class="line">block_demo[<span class="number">32084</span>:<span class="number">1704240</span>] array count = <span class="number">0</span></div><div class="line">block_demo[<span class="number">32084</span>:<span class="number">1704240</span>] array count = <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>因为array在变量作用域结束时被释放，nil被赋值给了array2中。</p>
<h1 id="block的实现原理"><a href="#block的实现原理" class="headerlink" title="__block的实现原理"></a>__block的实现原理</h1><h2 id="block修饰局部变量"><a href="#block修饰局部变量" class="headerlink" title="__block修饰局部变量"></a>__block修饰局部变量</h2><p>先通过OC代码来看一下给局部变量添加__block关键字后的效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">__block <span class="keyword">int</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</div><div class="line">    </div><div class="line">PrintTwoIntBlock block = ^()&#123;</div><div class="line">    a -= <span class="number">10</span>;</div><div class="line">    printf(<span class="string">"%d, %d\n"</span>,a,b);</div><div class="line">&#125;;</div><div class="line">    </div><div class="line">block();<span class="comment">//0 20</span></div><div class="line">    </div><div class="line">a += <span class="number">20</span>;</div><div class="line">b += <span class="number">30</span>;</div><div class="line">    </div><div class="line">printf(<span class="string">"%d, %d\n"</span>,a,b);<span class="comment">//20 50</span></div><div class="line">    </div><div class="line">block();/<span class="number">10</span> <span class="number">20</span></div></pre></td></tr></table></figure>
<p>我们可以看到，__block变量在block内部就可以被修改了。</p>
<blockquote>
<p>加上<strong>block之后的变量称之为</strong>block变量，</p>
</blockquote>
<p>先简单说一下<strong>block的作用：
</strong>block说明符用于指定将变量值设置到哪个存储区域中，也就是说，当自动变量加上__block说明符之后，会改变这个自动变量的存储区域。</p>
<p>接下来我们还是用clang工具看一下C++的代码：</p>
<p>OC代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    __block <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        val = <span class="number">1</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C++代码<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</div><div class="line">  <span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_val_0 *__forwarding;</div><div class="line"> <span class="keyword">int</span> __flags;</div><div class="line"> <span class="keyword">int</span> __size;</div><div class="line"> <span class="keyword">int</span> val;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</div><div class="line">  __Block_byref_val_0 *val = __cself-&gt;val; <span class="comment">// bound by ref</span></div><div class="line"></div><div class="line">        (val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_copy_0(<span class="keyword">struct</span> __main_block_impl_0*dst, <span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_assign((<span class="keyword">void</span>*)&amp;dst-&gt;val, (<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_dispose_0(<span class="keyword">struct</span> __main_block_impl_0*src) &#123;_Block_object_dispose((<span class="keyword">void</span>*)src-&gt;val, <span class="number">8</span><span class="comment">/*BLOCK_FIELD_IS_BYREF*/</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __main_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">  <span class="keyword">void</span> (*<span class="keyword">copy</span>)(<span class="keyword">struct</span> __main_block_impl_0*, <span class="keyword">struct</span> __main_block_impl_0*);</div><div class="line">  <span class="keyword">void</span> (*dispose)(<span class="keyword">struct</span> __main_block_impl_0*);</div><div class="line">&#125; __main_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;;</div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在__main_block_impl_0里面发生了什么呢？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_val_0 *val; <span class="comment">// by ref</span></div><div class="line">  </div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_val_0 *_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">&gt;__main_block_impl_0里面增加了一个成员变量，它是一个结构体指针，指向了 __Block_byref_val_0结构体的一个实例。那么这个结构体是什么呢？</div><div class="line"></div><div class="line">这个结构体是变量val在被__block修饰后生成的！！</div><div class="line">该结构体声明如下：</div><div class="line">```objc</div><div class="line"><span class="keyword">struct</span> __Block_byref_val_0 &#123;</div><div class="line">  <span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_val_0 *__forwarding;</div><div class="line"> <span class="keyword">int</span> __flags;</div><div class="line"> <span class="keyword">int</span> __size;</div><div class="line"> <span class="keyword">int</span> val;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，这个结构体最后的成员变量就相当于原来自动变量。<br>这里有两个成员变量需要特别注意：</p>
<ol>
<li>val：保存了最初的val变量，也就是说原来单纯的int类型的val变量被__block修饰后生成了一个结构体。这个结构体其中一个成员变量持有原来的val变量。</li>
<li><strong>forwarding：通过</strong>forwarding，可以实现无论<strong>block变量配置在栈上还是堆上都能正确地访问</strong>block变量，也就是说__forwarding是指向自身的。</li>
</ol>
<p>用一张图来直观看一下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-072e7b29e7daf0e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"><br>怎么实现的？</p>
<ol>
<li>最初，<strong>block变量在栈上时，它的成员变量</strong>forwarding指向栈上的__block变量结构体实例。</li>
<li>在<strong>block被复制到堆上时，会将</strong>forwarding的值替换为堆上的目标<strong>block变量用结构体实例的地址。而在堆上的目标</strong>block变量自己的__forwarding的值就指向它自己。</li>
</ol>
<p>我们可以看到，这里面增加了指向<strong>Block_byref_val_0结构体实例的指针。这里//by ref这个由clang生成的注释，说明它是通过指针来引用</strong>Block_byref_val_0结构体实例val的。</p>
<p>因此<strong>Block_byref_val_0结构体并不在</strong>main_block_impl_0结构体中，目的是为了使得多个Block中使用__block变量。</p>
<p>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    __block <span class="keyword">int</span> val = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk0)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        val = <span class="number">12</span>;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> (^blk1)(<span class="keyword">void</span>) = ^&#123;</div><div class="line">        val = <span class="number">13</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    __attribute__((__blocks__(<span class="keyword">byref</span>))) __Block_byref_val_0 val = &#123;(<span class="keyword">void</span>*)<span class="number">0</span>,(__Block_byref_val_0 *)&amp;val, <span class="number">0</span>, <span class="keyword">sizeof</span>(__Block_byref_val_0), <span class="number">10</span>&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk0)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*blk1)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__main_block_impl_1((<span class="keyword">void</span> *)__main_block_func_1, &amp;__main_block_desc_1_DATA, (__Block_byref_val_0 *)&amp;val, <span class="number">570425344</span>));</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在main函数里，两个block都引用了__Block_byref_val_0结构体的实例val。</p>
<p>那么__block修饰对象的时候是怎么样的呢？</p>
<h2 id="block修饰对象"><a href="#block修饰对象" class="headerlink" title="__block修饰对象"></a>__block修饰对象</h2><p>__block可以指定任何类型的自动变量。下面来指定id类型的对象:</p>
<p>看一下__block变量的结构体：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __Block_byref_obj_0 &#123;</div><div class="line">  <span class="keyword">void</span> *__isa;</div><div class="line">__Block_byref_obj_0 *__forwarding;</div><div class="line"> <span class="keyword">int</span> __flags;</div><div class="line"> <span class="keyword">int</span> __size;</div><div class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_copy)(<span class="keyword">void</span>*, <span class="keyword">void</span>*);</div><div class="line"> <span class="keyword">void</span> (*__Block_byref_id_object_dispose)(<span class="keyword">void</span>*);</div><div class="line"> <span class="keyword">id</span> obj;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>被__strong修饰的id类型或对象类型自动变量的copy和dispose方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_copy_131(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src) &#123;</div><div class="line"> _Block_object_assign((<span class="keyword">char</span>*)dst + <span class="number">40</span>, *(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __Block_byref_id_object_dispose_131(<span class="keyword">void</span> *src) &#123;</div><div class="line"> _Block_object_dispose(*(<span class="keyword">void</span> * *) ((<span class="keyword">char</span>*)src + <span class="number">40</span>), <span class="number">131</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同样，当Block持有被__strong修饰的id类型或对象类型自动变量时：</p>
<ul>
<li>如果__block对象变量从栈复制到堆时，使用_Block_object_assign函数，</li>
<li>当堆上的__block对象变量被废弃时，使用_Block_object_dispose函数。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __main_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __main_block_desc_0* Desc;</div><div class="line">  __Block_byref_obj_0 *obj; <span class="comment">// by ref</span></div><div class="line">  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, __Block_byref_obj_0 *_obj, <span class="keyword">int</span> flags=<span class="number">0</span>) : obj(_obj-&gt;__forwarding) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteStackBlock;</div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以看到，obj被添加到了<strong>main_block_impl_0结构体中，它是</strong>Block_byref_obj_0类型。</p>
<h1 id="三种Block"><a href="#三种Block" class="headerlink" title="三种Block"></a>三种Block</h1><p>细心的同学会发现，在上面Block的构造函数__main_block_impl_0中的isa指针指向的是&amp;_NSConcreteStackBlock，它表示当前的Block位于栈区中。实际上，一共有三种类型的Block：</p>
<table>
<thead>
<tr>
<th>Block的类</th>
<th>存储域</th>
<th>拷贝效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈拷贝到堆</td>
</tr>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody>
</table>
<h2 id="全局Block：-NSConcreteGlobalBlock"><a href="#全局Block：-NSConcreteGlobalBlock" class="headerlink" title="全局Block：_NSConcreteGlobalBlock"></a>全局Block：_NSConcreteGlobalBlock</h2><p>因为全局Block的结构体实例设置在程序的数据存储区，所以可以在程序的任意位置通过指针来访问，它的产生条件：</p>
<ul>
<li>记述全局变量的地方有block语法时。</li>
<li>block不截获的自动变量时。</li>
</ul>
<p>以上两个条件只要满足一个就可以产生全局Block，下面分别用C++来展示一下第一种条件下的全局Block：</p>
<p>c代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^&#123;printf(<span class="string">"Global Block\n"</span>);&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    blk();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>C++代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> __blk_block_impl_0 &#123;</div><div class="line">  <span class="keyword">struct</span> __block_impl impl;</div><div class="line">  <span class="keyword">struct</span> __blk_block_desc_0* Desc;</div><div class="line">  __blk_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __blk_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>) &#123;</div><div class="line">    impl.isa = &amp;_NSConcreteGlobalBlock;<span class="comment">//全局</span></div><div class="line">    impl.Flags = flags;</div><div class="line">    impl.FuncPtr = fp;</div><div class="line">    Desc = desc;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> __blk_block_func_0(<span class="keyword">struct</span> __blk_block_impl_0 *__cself) &#123;</div><div class="line">printf(<span class="string">"Global Block\n"</span>);&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> __blk_block_desc_0 &#123;</div><div class="line">  size_t reserved;</div><div class="line">  size_t Block_size;</div><div class="line">&#125; __blk_block_desc_0_DATA = &#123; <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> __blk_block_impl_0)&#125;;</div><div class="line"></div><div class="line"><span class="keyword">static</span> __blk_block_impl_0 __global_blk_block_impl_0((<span class="keyword">void</span> *)__blk_block_func_0, &amp;__blk_block_desc_0_DATA);</div><div class="line"><span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = ((<span class="keyword">void</span> (*)())&amp;__global_blk_block_impl_0);</div><div class="line"></div><div class="line"><span class="keyword">int</span> main()</div><div class="line">&#123;</div><div class="line">    ((<span class="keyword">void</span> (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到Block结构体构造函数里面isa指针被赋予的是&amp;_NSConcreteGlobalBlock，说明它是一个全局Block。</p>
</blockquote>
<h2 id="栈Block：-NSConcreteStackBlock"><a href="#栈Block：-NSConcreteStackBlock" class="headerlink" title="栈Block：_NSConcreteStackBlock"></a>栈Block：_NSConcreteStackBlock</h2><p>在生成Block以后，如果这个Block不是全局Block，那么它就是为_NSConcreteStackBlock对象，但是如果其所属的变量作用域名结束，该block就被废弃。在栈上的__block变量也是如此。</p>
<p>但是，如果Block变量和__block变量复制到了堆上以后，则不再会受到变量作用域结束的影响了，因为它变成了堆Block：</p>
<h2 id="堆Block：-NSConcreteMallocBlock"><a href="#堆Block：-NSConcreteMallocBlock" class="headerlink" title="堆Block：_NSConcreteMallocBlock"></a>堆Block：_NSConcreteMallocBlock</h2><blockquote>
<p>将栈block复制到堆以后，block结构体的isa成员变量变成了_NSConcreteMallocBlock。</p>
</blockquote>
<p>其他两个类型的Block在被复制后会发生什么呢？</p>
<table>
<thead>
<tr>
<th>Block类型</th>
<th>存储位置</th>
<th>copy操作的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>_NSConcreteGlobalBlock</td>
<td>程序的数据区域</td>
<td>什么也不做</td>
</tr>
<tr>
<td>_NSConcreteStackBlock</td>
<td>栈</td>
<td>从栈拷贝到堆</td>
</tr>
<tr>
<td>_NSConcreteMallocBlock</td>
<td>堆</td>
<td>引用计数增加</td>
</tr>
</tbody>
</table>
<p>而大多数情况下，编译器会进行判断，自动将block从栈上复制到堆：</p>
<ul>
<li>block作为函数值返回的时候</li>
<li>部分情况下向方法或函数中传递block的时候<ul>
<li>Cocoa框架的方法而且方法名中含有usingBlock等时。</li>
<li>Grand Central Dispatch 的API。</li>
</ul>
</li>
</ul>
<p>除了这两种情况，基本都需要我们手动复制block。</p>
<p>那么__block变量在Block执行copy操作后会发生什么呢？</p>
<ol>
<li>任何一个block被复制到堆上时，__block变量也会一并从栈复制到堆上，并被该Block持有。</li>
<li>如果接着有其他Block被复制到堆上的话，被复制的Block会持有<strong>block变量，并增加</strong>block的引用计数，反过来如果Block被废弃，它所持有的__block也就被释放（不再有block引用它）。</li>
</ol>
<h1 id="Block循环引用"><a href="#Block循环引用" class="headerlink" title="Block循环引用"></a>Block循环引用</h1><p>如果在Block内部使用__strong修饰符的对象类型的自动变量，那么当Block从栈复制到堆的时候，该对象就会被Block所持有。</p>
<p>所以如果这个对象还同时持有Block的话，就容易发生循环引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    blk_t blk_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>,<span class="keyword">self</span>);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>Block blk_t持有self，而self也同时持有作为成员变量的blk_t</p>
<h2 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>,weakSelf);</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^blk_t)(<span class="keyword">void</span>);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    blk_t blk_;</div><div class="line">    <span class="keyword">id</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"obj_ = %@"</span>,obj_);<span class="comment">//循环引用警告</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Block语法内的obj<em>截获了self,因为ojb</em>是self的成员变量，因此，block如果想持有obj_，就必须引用先引用self，所以同样会造成循环引用。就好比你如果想去某个商场里的咖啡厅，就需要先知道商场在哪里一样。</p>
<p>如果某个属性用的是weak关键字呢？<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSArray</span> *array;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"array = %@"</span>,_array);<span class="comment">//循环引用警告</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>还是会有循环引用的警告提示，因为循环引用的是self和block之间的事情，这个被Block持有的成员变量是strong还是weak都没有关系,而且即使是基本类型（assign）也是一样。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span>()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> index;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"index = %ld"</span>,_index);<span class="comment">//循环引用警告</span></div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="block修饰符"><a href="#block修饰符" class="headerlink" title="__block修饰符"></a>__block修饰符</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    __block <span class="keyword">id</span> temp = <span class="keyword">self</span>;<span class="comment">//temp持有self</span></div><div class="line">    </div><div class="line">    <span class="comment">//self持有blk_</span></div><div class="line">    blk_ = ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"self = %@"</span>,temp);<span class="comment">//blk_持有temp</span></div><div class="line">        temp = <span class="literal">nil</span>;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)execBlc</div><div class="line">&#123;</div><div class="line">    blk_();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以如果不执行blk_（将temp设为nil），则无法打破这个循环。</p>
<p>一旦执行了blk_，就只有</p>
<ul>
<li>self持有blk_</li>
<li>blk_持有temp</li>
</ul>
<p>使用__block 避免循环比较有什么特点呢？</p>
<ul>
<li>通过__block可以控制对象的持有时间。</li>
<li>为了避免循环引用必须执行block，否则循环引用一直存在。</li>
</ul>
<p>所以我们应该根据实际情况，根据当前Block的用途来决定到底用<strong>block，还是</strong>weak或__unsafe_unretained。</p>
<h1 id="扩展文献："><a href="#扩展文献：" class="headerlink" title="扩展文献："></a>扩展文献：</h1><ol>
<li><a href="http://www.jianshu.com/p/ee9756f3d5f6" target="_blank" rel="external">深入研究Block捕获外部变量和__block实现原理</a></li>
<li><a href="http://www.jianshu.com/p/e03292674e60" target="_blank" rel="external">让我们来深入浅出block吧</a></li>
<li><a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程：iOS与OS X多线程和内存管理》&quot;&gt;&lt;/p&gt;
&lt;p&gt;这一章讲解了Block相关的知识。因为作者将Objective-C的代码转成了C++的代码，所以第一次看的时候非常吃力，我自己也不记得看了多少遍了。&lt;/p&gt;
&lt;p&gt;这篇总结不仅仅只有这本书中的内容，还有一点在其他博客里看过的Block的相关知识，并加上了自己的理解，而且文章结构也和原书不太一致，是经过我的整理重新排列出来的。&lt;/p&gt;
&lt;p&gt;先看一下本文结构（Blocks部分）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程》 干货三部曲&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Objective-C 高级编程》干货三部曲（一）：引用计数篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/04/10/%E3%80%8AObjective-C%20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/04/10/《Objective-C 高级编程》干货三部曲（一）：引用计数篇/</id>
    <published>2017-04-10T00:40:50.000Z</published>
    <updated>2017-04-14T04:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结了<a href="http://www.jianshu.com/nb/6074358" target="_blank" rel="external">Effective Objective-C</a>之后，还想读一本进阶的iOS书，毫不犹豫选中了《Objective-C 高级编程》：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>这本书有三个章节，我针对每一章节进行总结并加上适当的扩展分享给大家。可以从下面这张图来看一下这三篇的整体结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程》 干货三部曲"></p>
<p>注意，这个结构并不和书中的结构一致，而是以书中的结构为参考，稍作了调整。</p>
<p>本篇是第一篇：引用计数，简单说两句：<br>Objective-C通过 retainCount 的机制来决定对象是否需要释放。 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。</p>
<a id="more"></a>
<p>先看一下手动内存管理：</p>
<h1 id="手动内存管理"><a href="#手动内存管理" class="headerlink" title="手动内存管理"></a>手动内存管理</h1><p>我个人觉得，学习一项新的技术之前，需要先了解一下它的核心思想。理解了核心思想之后，对技术点的把握就会更快一些：</p>
<h2 id="内存管理的思想"><a href="#内存管理的思想" class="headerlink" title="内存管理的思想"></a>内存管理的思想</h2><ul>
<li>思想一：自己生成的对象，自己持有。</li>
<li>思想二：非自己生成的对象，自己也能持有。</li>
<li>思想三：不再需要自己持有的对象时释放对象。</li>
<li>思想四：非自己持有的对象无法释放。</li>
</ul>
<p>从上面的思想来看，我们对对象的操作可以分为三种：生成，持有，释放，再加上废弃，一共有四种。它们所对应的Objective-C的方法和引用计数的变化是：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>Objecctive-C方法</th>
<th>引用计数的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy等方法</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain方法</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release方法</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc方法</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>用书中的图来直观感受一下这四种操作：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-5ced77c57afcfab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>下面开始逐一解释上面的四条思想：</p>
<h3 id="思想一：自己生成的对象，自己持有"><a href="#思想一：自己生成的对象，自己持有" class="headerlink" title="思想一：自己生成的对象，自己持有"></a>思想一：自己生成的对象，自己持有</h3><p>在生成对象时，使用以下面名称开头的方法生成对象以后，就会持有该对象：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure>
<p>这行代码过后，指向生成并持有[[NSObject alloc] init]的指针被赋给了obj，也就是说obj这个指针强引用[[NSObject alloc] init]这个对象。</p>
<p>同样适用于new方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure></p>
<p>注意：<br>这种将持有对象的指针赋给指针变量的情况不只局限于上面这四种方法名称，还包括以他们开头的所有方法名称：</p>
<ul>
<li>allocThisObject</li>
<li>newThatObject</li>
<li>copyThisObject</li>
<li>mutableCopyThatObject</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1 = [obj0 allocObject];<span class="comment">//符合上述命名规则，生成并持有对象</span></div></pre></td></tr></table></figure>
<p>它的内部实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)allocObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反过来，如果不符合上述的命名规则，那么就不会持有生成的对象，<br>看一个不符合上述命名规则的返回对象的createObject方法的内部实现🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)createObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">    [obj autorelease];<span class="comment">//取得对象，但自己不持有</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>经由这个方法返回以后，无法持有这个返回的对象。因为这里使用了autorelease。autorelease提供了这样一个功能：在对象超出其指定的生存范围时能够自动并正确地释放（详细会在后面介绍）。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-97b23d0108e4cadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<blockquote>
<p>也就是说，生成一个调用方不持有的对象是可以通过autorelease来实现的（例如NSMutableArray的array类方法）。</p>
<p>我的个人理解是：通过autorelease方法，使对象的持有权转移给了自动释放池。所以实现了：调用方拿到了对象，但这个对象还不被调用方所持有。</p>
</blockquote>
<p>由这个不符合命名规则的例子来引出思想二：</p>
<h3 id="思想二：非自己生成的对象，自己也能持有"><a href="#思想二：非自己生成的对象，自己也能持有" class="headerlink" title="思想二：非自己生成的对象，自己也能持有"></a>思想二：非自己生成的对象，自己也能持有</h3><p>我们现在知道，仅仅通过上面那个不符合命名规则的返回对象实例的方法是无法持有对象的。但是我们可以通过某个操作来持有这个返回的对象：这个方法就是通过retain方法来让指针变量持有这个新生成的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj <span class="keyword">retain</span>];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里[NSMutableArray array]返回的非自己持有的对象正是通过上文介绍过的autorelease方法实现的。所以如果想持有这个对象，需要执行retain方法才可以。</p>
</blockquote>
<h3 id="思想三：不再需要自己持有的对象时释放对象"><a href="#思想三：不再需要自己持有的对象时释放对象" class="headerlink" title="思想三：不再需要自己持有的对象时释放对象"></a>思想三：不再需要自己持有的对象时释放对象</h3><p>对象的持有者<strong>有义务</strong>在不再需要这个对象的时候<strong>主动</strong>将这个对象释放。注意，是<strong>有义务</strong>，而不是有权利，注意两个词的不同。</p>
<p>来看一下释放对象的例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj doSomething];<span class="comment">//使用该对象做一些事情</span></div><div class="line">[obj release];<span class="comment">//事情做完了，释放该对象</span></div></pre></td></tr></table></figure></p>
<p>同样适用于非自己生成并持有的对象（参考思想二）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj <span class="keyword">retain</span>];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj soSomething];<span class="comment">//使用该对象做一些事情</span></div><div class="line">[obj release];<span class="comment">//事情做完了，释放该对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>可能遇到的面试题</strong>：调用对象的release方法会销毁对象吗？<br>答案是不会：调用对象的release方法只是将对象的引用计数器-1，当对象的引用计数器为0的时候会调用了对象的dealloc 方法才能进行释放对象的内存。</p>
</blockquote>
<h3 id="思想四：无法释放非自己持有的对象"><a href="#思想四：无法释放非自己持有的对象" class="headerlink" title="思想四：无法释放非自己持有的对象"></a>思想四：无法释放非自己持有的对象</h3><p>在释放对象的时候，我们只能释放已经持有的对象，非自己持有的对象是不能被自己释放的。这很符合常识：就好比你自己才能从你自己的银行卡里取钱，取别人的卡里的钱是不对的（除非他的钱归你管。。。只是随便举个例子）。</p>
<h4 id="两种不允许的情况："><a href="#两种不允许的情况：" class="headerlink" title="两种不允许的情况："></a>两种不允许的情况：</h4><h4 id="1-释放一个已经废弃了的对象"><a href="#1-释放一个已经废弃了的对象" class="headerlink" title="1.  释放一个已经废弃了的对象"></a>1.  释放一个已经废弃了的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj doSomething];<span class="comment">//使用该对象</span></div><div class="line">[obj release];<span class="comment">//释放该对象，不再持有了</span></div><div class="line">[obj release];<span class="comment">//释放已经废弃了的对象，崩溃</span></div></pre></td></tr></table></figure>
<h4 id="2-释放自己不持有的对象"><a href="#2-释放自己不持有的对象" class="headerlink" title="2. 释放自己不持有的对象"></a>2. 释放自己不持有的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj release];<span class="comment">//释放了非自己持有的对象</span></div></pre></td></tr></table></figure>
<p>思考：哪些情况会使对象失去拥有者呢？</p>
<ol>
<li>将指向某对象的指针变量指向另一个对象。</li>
<li>将指向某对象的指针变量设置为nil。</li>
<li>当程序释放对象的某个拥有者时。</li>
<li>从collection类中删除对象时。</li>
</ol>
<p>现在知道了引用计数式内存管理的四个思想，我们再来看一下四个操作引用计数的方法：</p>
<h2 id="alloc-retain-release-dealloc的实现"><a href="#alloc-retain-release-dealloc的实现" class="headerlink" title="alloc/retain/release/dealloc的实现"></a>alloc/retain/release/dealloc的实现</h2><p>某种意义上，GNUstep 和 Foundation 框架的实现是相似的。所以这本书的作者通过GNUstep的源码来推测了苹果Cocoa框架的实现。</p>
<p>下面开始针对每一个方法，同时用GNUstep和苹果的实现方式（追踪程序的执行和作者的猜测）来对比一下各自的实现。</p>
<h3 id="GNUstep实现："><a href="#GNUstep实现：" class="headerlink" title="GNUstep实现："></a>GNUstep实现：</h3><h4 id="alloc方法"><a href="#alloc方法" class="headerlink" title="alloc方法"></a>alloc方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m alloc:</span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>) alloc</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">+ (<span class="keyword">id</span>) allocWithZone: (<span class="built_in">NSZone</span>*)z</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSAllocateObject</span>(<span class="keyword">self</span>, <span class="number">0</span>, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里NSAllocateObject方法分配了对象，看一下它的内部实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m NSAllocateObject:</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> obj_layout &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> retained;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">NSAllocateObject</span>(Class aClass, <span class="built_in">NSUInteger</span> extraBytes, <span class="built_in">NSZone</span> *zone)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> size = 计算容纳对象所需内存大小;</div><div class="line">    <span class="keyword">id</span> new = <span class="built_in">NSZoneMalloc</span>(zone, <span class="number">1</span>, size);<span class="comment">//返回新的实例</span></div><div class="line">    memset (new, <span class="number">0</span>, size);</div><div class="line">    new = (<span class="keyword">id</span>)&amp;((obj)new)[<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>NSAllocateObject函数通过NSZoneMalloc函数来分配存放对象所需要的内存空间。</li>
<li>obj_layout是用来保存引用计数，并将其写入对象内存头部。</li>
</ol>
</blockquote>
<p>对象的引用计数可以通过retainCount方法来取得：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GNUstep/modules/core/base/Source/<span class="built_in">NSObject</span>.m retainCount:</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span></div><div class="line"><span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> ((obj_layout)anObject)[<span class="number">-1</span>].retained;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，给NSExtraRefCount传入anObject以后，通过访问对象内存头部的.retained变量，来获取引用计数。</p>
<h4 id="retain方法"><a href="#retain方法" class="headerlink" title="retain方法"></a>retain方法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GNUstep/modules/core/base/Source/NSObject.m retain:</div><div class="line"></div><div class="line">- (id)retain</div><div class="line">&#123;</div><div class="line">    NSIncrementExtraRefCount(self);</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">inline void NSIncrementExtraRefCount(id anObject)</div><div class="line">&#123;</div><div class="line">    //retained变量超出最大值,抛出异常</div><div class="line">    if (((obj)anObject)[-1].retained == UINT_MAX - 1)&#123;</div><div class="line">        [NSException raise: NSInternalInconsistencyException</div><div class="line">        format: @"NSIncrementExtraRefCount() asked to increment too far”];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ((obj_layout)anObject)[-1].retained++;//retained变量+1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m release</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果当前的引用计数 = 0，调用dealloc函数</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> dealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果当前的retained值 = 0.则返回yes</span></div><div class="line">    <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果大于0，则-1，并返回NO</span></div><div class="line">    ((obj)anObject)[<span class="number">-1</span>].retained--;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="dealloc方法"><a href="#dealloc方法" class="headerlink" title="dealloc方法"></a>dealloc方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m dealloc</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    obj_layout o = &amp;((obj_layout)anObject)[<span class="number">-1</span>];</div><div class="line">    free(o);<span class="comment">//释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下上面的几个方法：</p>
<ul>
<li>Objective-C对象中保存着引用计数这一整数值。</li>
<li>调用alloc或者retain方法后，引用计数+1。</li>
<li>调用release后，引用计数-1。</li>
<li>引用计数为0时，调用dealloc方法废弃对象。</li>
</ul>
<p>下面看一下苹果的实现：</p>
<h3 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a>苹果的实现</h3><h4 id="alloc方法-1"><a href="#alloc方法-1" class="headerlink" title="alloc方法"></a>alloc方法</h4><p>通过在NSObject类的alloc类方法上设置断点，我们可以看到执行所调用的函数：</p>
<ul>
<li>+alloc</li>
<li>+allocWithZone:</li>
<li>class_createInstance//生成实例</li>
<li>calloc//分配内存块</li>
</ul>
<p>retainCount:</p>
<ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashGetCountOfKey</li>
</ul>
<h4 id="retain方法-1"><a href="#retain方法-1" class="headerlink" title="retain方法"></a>retain方法</h4><ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashAddValue</li>
</ul>
<h4 id="release方法-1"><a href="#release方法-1" class="headerlink" title="release方法"></a>release方法</h4><ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashRemoveValue</li>
</ul>
<p>我们可以看到他们都调用了一个共同的 __CFdoExternRefOperation 方法。</p>
<p>看一下它的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">CFBasicHashRef</span> table = 取得对象的散列表(obj);</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line"> </div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">    <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        count = <span class="built_in">CFBasicHashAddValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，__CFDoExternRefOperation通过switch语句 针对不同的操作来进行具体的方法调用，如果 op 是 OPERATION_retain，就去掉用具体实现 retain 的方法，以此类推。</p>
<p>可以猜想上层的retainCount,retain,release方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">NSUInteger</span>)____CFDoExternRefOperation(OPERATION_retainCount,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)____CFDoExternRefOperation(OPERATION_retain,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这里返回值应该是id，原书这里应该是错了</span></div><div class="line">- (<span class="keyword">id</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)____CFDoExternRefOperation(OPERATION_release,<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们观察一下switch里面每个语句里的执行函数名称，似乎和散列表（Hash）有关，这说明苹果对引用计数的管理应该是通过散列表来执行的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-46b607c905f2355d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>在这张表里，key为内存块地址，而对应的值为引用计数。也就是说，它保存了这样的信息：一些被引用的内存块各自对应的引用计数。</p>
<p>那么使用散列表来管理内存有什么好处呢？</p>
<p>因为计数表保存内存块地址，我们就可以通过这张表来：</p>
<ul>
<li>确认损坏内存块的位置。</li>
<li>在检测内存泄漏时，可以查看各对象的持有者是否存在。</li>
</ul>
<h2 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h2><h3 id="autorelease-介绍"><a href="#autorelease-介绍" class="headerlink" title="autorelease 介绍"></a>autorelease 介绍</h3><p>当对象超出其作用域时，对象实例的release方法就会被调用，autorelease的具体使用方法如下：</p>
<ol>
<li>生成并持有NSAutoreleasePool对象。</li>
<li>调用已分配对象的autorelease方法。</li>
<li>废弃NSAutoreleasePool对象。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-e4e905eeda890869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>所有调用过autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release方法（引用计数-1）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];<span class="comment">//相当于obj调用release方法</span></div></pre></td></tr></table></figure></p>
<p>NSRunLoop在每次循环过程中，NSAutoreleasePool对象都会被生成或废弃。<br>也就是说，如果有大量的autorelease变量，在NSAutoreleasePool对象废弃之前（一旦监听到RunLoop即将进入睡眠等待状态，就释放NSAutoreleasePool），都不会被销毁，容易导致内存激增的问题:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageArray.count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = imageArray[i];</div><div class="line">    [image doSomething];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0a9bf49d47a0e3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>因此，我们有必要在适当的时候再嵌套一个自动释放池来管理临时生成的autorelease变量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageArray.count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//临时pool</span></div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line">    <span class="built_in">UIImage</span> *image = imageArray[i];</div><div class="line">    [image doSomething];</div><div class="line">    [pool drain];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-157c469ad6fff139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<blockquote>
<p>可能会出的面试题：什么时候会创建自动释放池？<br>答：运行循环检测到事件并启动后，就会创建自动释放池，而且子线程的 runloop 默认是不工作的，无法主动创建，必须手动创建。<br>举个🌰：<br>自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则在出了作用域以后，自动释放对象会因为没有自动释放池去处理自己而造成内存泄露。</p>
</blockquote>
<h3 id="autorelease实现"><a href="#autorelease实现" class="headerlink" title="autorelease实现"></a>autorelease实现</h3><p>和上文一样，我们还是通过GNUstep和苹果的实现来分别看一下。</p>
<h4 id="GNUstep-实现"><a href="#GNUstep-实现" class="headerlink" title="GNUstep 实现"></a>GNUstep 实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m autorelease</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)autorelease</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果调用NSObject类的autorelease方法，则该对象就会被追加到正在使用的NSAutoreleasePool对象中的数组里（作者假想了一个简化的源代码）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSAutoreleasePool.m addObject</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = 取得正在使用的<span class="built_in">NSAutoreleasePool</span>对象</div><div class="line">    <span class="keyword">if</span> (pool != <span class="literal">nil</span>)&#123;</div><div class="line">        [pool addObject:anObj];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSAutoreleasePool对象不存在"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">    [pool.array addObject:anObj];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法，然后这个对象就被追加到正在使用的NSAutoreleasePool对象中的数组里。</p>
<p>再来看一下NSAutoreleasePool的drain方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drain</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> dealloc];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> emptyPool];</div><div class="line">    [array release];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)emptyPool</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">id</span> obj <span class="keyword">in</span> array)&#123;</div><div class="line">        [obj release];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在emptyPool方法里，确实是对数组里每一个对象进行了release操作。</p>
<h4 id="苹果的实现-1"><a href="#苹果的实现-1" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>我们可以通过objc4/NSObject.mm来确认苹果中autorelease的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">objc4/<span class="built_in">NSObject</span>.mm AutoreleasePoolPage</div><div class="line"> </div><div class="line"><span class="keyword">class</span> AutoreleasePoolPage</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//生成或者持有 NSAutoreleasePool 类对象</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//废弃 NSAutoreleasePool 类对象</span></div><div class="line">        releaseAll();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//相当于 NSAutoreleasePool 类的 addObject 类方法</span></div><div class="line">        AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例;</div><div class="line">       autoreleaesPoolPage-&gt;add(obj)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</div><div class="line">    &#123;   </div><div class="line">        <span class="comment">//将对象追加到内部数组中</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> releaseAll()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//调用内部数组中对象的 release 方法</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//压栈</span></div><div class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//出栈</span></div><div class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看一下外部的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">// 等同于 objc_autoreleasePoolPush</span></div><div class="line"> </div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line"><span class="comment">// 等同于 objc_autorelease(obj)</span></div><div class="line"> </div><div class="line">[<span class="built_in">NSAutoreleasePool</span> showPools];</div><div class="line"><span class="comment">// 查看 NSAutoreleasePool 状况</span></div><div class="line"> </div><div class="line">[pool drain];</div><div class="line"><span class="comment">// 等同于 objc_autoreleasePoolPop(pool)</span></div></pre></td></tr></table></figure>
<p>看函数名就可以知道，对autorelease分别执行push、pop操作。销毁对象时执行release操作。</p>
<blockquote>
<p><strong>可能出现的面试题：苹果是如何实现autoreleasepool的？</strong><br>autoreleasepool以一个队列数组的形式实现,主要通过下列三个函数完成.<br>•    objc_autoreleasepoolPush（压入）<br>•    objc_autoreleasepoolPop（弹出）<br>•    objc_autorelease（释放内部）</p>
</blockquote>
<h1 id="ARC内存管理"><a href="#ARC内存管理" class="headerlink" title="ARC内存管理"></a>ARC内存管理</h1><h2 id="内存管理的思想-1"><a href="#内存管理的思想-1" class="headerlink" title="内存管理的思想"></a>内存管理的思想</h2><p>上面学习了非ARC机制下的手动管理内存思想，针对引用计数的操作和自动释放池的相关内容。现在学习一下在ARC机制下的相关知识。</p>
<p>ARC和非ARC机制下的内存管理思想是一致的：</p>
<ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放对象。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<p>在ARC机制下，编译器就可以自动进行内存管理，减少了开发的工作量。但我们有时仍需要四种所有权修饰符来配合ARC来进行内存管理</p>
<h2 id="四种所有权修饰符"><a href="#四种所有权修饰符" class="headerlink" title="四种所有权修饰符"></a>四种所有权修饰符</h2><p>但是，在ARC机制下我们有的时候需要追加所有权声明(以下内容摘自官方文档)：</p>
<ul>
<li><strong>__strong</strong>：is the default. An object remains “alive” as long as there is a strong pointer to it.</li>
<li><strong>__weak</strong>：specifies a reference that does not keep the referenced object alive. A weak reference is set to nil when there are no strong references to the object.</li>
<li><strong>__unsafe_unretained</strong>：specifies a reference that does not keep the referenced object alive and is not set to nil when there are no strong references to the object. If the object it references is deallocated, the pointer is left dangling.</li>
<li><strong>__autoreleasing</strong>：is used to denote arguments that are passed by reference (id *) and are autoreleased on return.</li>
</ul>
<p>下面分别讲解一下这几个修饰符：</p>
<h3 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h3><p>__strong修饰符 是id类型和对象类型默认的所有权修饰符：</p>
<h4 id="strong使用方法："><a href="#strong使用方法：" class="headerlink" title="__strong使用方法："></a>__strong使用方法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>等同于：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure></p>
<p>看一下内存管理的过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj持有对象</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//obj超出其作用域，强引用失效</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>__strong修饰符表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃。</p>
</blockquote>
<p>在__strong修饰符修饰的变量之间相互赋值的情况：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj0 持有对象A</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj1 持有对象B</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj2 = <span class="literal">nil</span>;<span class="comment">//ojb2不持有任何对象</span></div><div class="line">obj0 = obj1;<span class="comment">//obj0强引用对象B；而对象A不再被ojb0引用，被废弃</span></div><div class="line">obj2 = obj0;<span class="comment">//obj2强引用对象B（现在obj0，ojb1，obj2都强引用对象B）</span></div><div class="line">obj1 = <span class="literal">nil</span>;<span class="comment">//obj1不再强引用对象B</span></div><div class="line">obj0 = <span class="literal">nil</span>;<span class="comment">//obj0不再强引用对象B</span></div><div class="line">obj2 = <span class="literal">nil</span>;<span class="comment">//obj2不再强引用对象B，不再有任何强引用引用对象B，对象B被废弃</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>而且，<strong>strong可以使一个变量初始化为nil：id </strong>strong obj0;<br>同样适用于：id <strong>weak obj1; id </strong>autoreleasing obj2;</p>
</blockquote>
<p>做个总结：被__strong修饰后，相当于强引用某个对象。对象一旦有一个强引用引用自己，引用计数就会+1，就不会被系统废弃。而这个对象如果不再被强引用的话，就会被系统废弃。</p>
<h4 id="strong内部实现："><a href="#strong内部实现：" class="headerlink" title="__strong内部实现："></a>__strong内部实现：</h4><p>生成并持有对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj持有对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = objc_mesgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(init));</div><div class="line">objc_release(obj);<span class="comment">//超出作用域，释放对象</span></div></pre></td></tr></table></figure></p>
<p>再看一下使用命名规则以外的构造方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(array));</div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>objc_retainAutoreleasedReturnValue的作用：持有对象，将对象注册到autoreleasepool并返回。</p>
</blockquote>
<p>同样也有objc_autoreleaseReturnValue，来看一下它的使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)array</div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)array</div><div class="line">&#123;</div><div class="line">   <span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">   objc_msgSend(obj,, <span class="keyword">@selector</span>(init));</div><div class="line">   <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>objc_autoreleaseReturnValue:返回注册到autoreleasepool的对象。</p>
</blockquote>
<h3 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h3><h4 id="weak使用方法："><a href="#weak使用方法：" class="headerlink" title="__weak使用方法："></a>__weak使用方法：</h4><p>__weak修饰符大多解决的是循环引用的问题：如果两个对象都互相强引用对方，同时都失去了外部对自己的引用，那么就会形成“孤岛”，这个孤岛将永远无法被释放，举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj</div><div class="line">&#123;</div><div class="line">    obj_ = obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> test0 = [[Test alloc] init];<span class="comment">//test0强引用对象A</span></div><div class="line">    <span class="keyword">id</span> test1 = [[Test alloc] init];<span class="comment">//test1强引用对象B</span></div><div class="line">    [test0 setObject:test1];<span class="comment">//test0强引用对象B</span></div><div class="line">    [test1 setObject:test0];<span class="comment">//test1强引用对象A</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为生成对象（第一，第二行）和set方法（第三，第四行）都是强引用，所以会造成两个对象互相强引用对方的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f2164aea2490deac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>所以，我们需要打破其中一种强引用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj_;<span class="comment">//由__strong变成了__weak</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这样一来，二者就只是弱引用对方了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-98777f8ef5bbfc13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<h4 id="weak内部实现"><a href="#weak内部实现" class="headerlink" title="__weak内部实现"></a>__weak内部实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1;</div><div class="line">objc_initWeak(&amp;obj1,obj);<span class="comment">//初始化附有__weak的变量</span></div><div class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(&amp;obj1);<span class="comment">//取出附有__weak修饰符变量所引用的对象并retain</span></div><div class="line">objc_autorelease(tmp);<span class="comment">//将对象注册到autoreleasepool中</span></div><div class="line">objc_destroyWeak(&amp;obj1);<span class="comment">//释放附有__weak的变量</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这确认了<strong>weak的一个功能：使用附有</strong>weak修饰符的变量，即是使用注册到autoreleasepool中的对象。</p>
</blockquote>
<p>这里需要着重讲解一下objc_initWeak方法和objc_destroyWeak方法：</p>
<ul>
<li>objc_initWeak:初始化附有__weak的变量，具体通过执行objc_strongWeak(&amp;obj1, obj)方法，将obj对象以&amp;obj1作为key放入一个weak表（Hash）中。</li>
<li>objc_destroyWeak：释放附有__weak的变量。具体通过执行objc_storeWeak(&amp;obj1,0)方法，在weak表中查询&amp;obj1这个键，将这个键从weak表中删除。</li>
</ul>
<blockquote>
<p>注意：因为同一个对象可以赋值给多个附有__weak的变量中，所以对于同一个键值，可以注册多个变量的地址。</p>
</blockquote>
<p>当一个对象不再被任何人持有，则需要释放它，过程为：</p>
<ul>
<li>objc_dealloc</li>
<li>dealloc</li>
<li>_objc_rootDealloc</li>
<li>objc_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating<ul>
<li>从weak表中获取废弃对象的地址</li>
<li>将包含在记录中的所有附有__weak修饰符变量的地址赋值为nil</li>
<li>从weak表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址</li>
</ul>
</li>
</ul>
<h3 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h3><h4 id="autoreleasing使用方法"><a href="#autoreleasing使用方法" class="headerlink" title="__autoreleasing使用方法"></a>__autoreleasing使用方法</h4><p>ARC下，可以用@autoreleasepool来替代NSAutoreleasePool类对象，用__autoreleasing修饰符修饰变量来替代ARC无效时调用对象的autorelease方法（对象被注册到autoreleasepool）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6dcb0d1fd878deeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>说到<strong>autoreleasing修饰符，就不得不提</strong>weak：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span>  __<span class="keyword">weak</span> obj1 = obj0;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>,[obj1 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure></p>
<p>等同于：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</div><div class="line"><span class="keyword">id</span> __autoreleasing tmp = obj1;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>,[tmp <span class="keyword">class</span>]);<span class="comment">//实际访问的是注册到自动个释放池的对象</span></div></pre></td></tr></table></figure>
<p>注意一下两段等效的代码里，NSLog语句里面访问的对象是不一样的，它说明：在访问__weak修饰符的变量（obj1）时必须访问注册到autoreleasepool的对象（tmp）。为什么呢？</p>
<p>因为__weak修饰符只持有对象的弱引用，也就是说在将来访问这个对象的时候，无法保证它是否还没有被废弃。因此，如果把这个对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。</p>
<h4 id="autoreleasing内部实现"><a href="#autoreleasing内部实现" class="headerlink" title="__autoreleasing内部实现"></a>__autoreleasing内部实现</h4><p>将对象赋值给附有__autoreleasing修饰符的变量等同于ARC无效时调用对象的autorelease方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">    <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();<span class="comment">//pool入栈</span></div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</div><div class="line">objc_autorelease(obj);</div><div class="line">objc_autoreleasePoolPop(pool);<span class="comment">//pool出栈</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们可以看到pool入栈，执行autorelease，出栈的三个方法。</p>
</blockquote>
<h2 id="ARC下的规则"><a href="#ARC下的规则" class="headerlink" title="ARC下的规则"></a>ARC下的规则</h2><p>我们知道了在ARC机制下编译器会帮助我们管理内存，但是在编译期，我们还是要遵守一些规则，作者为我们列出了以下的规则：</p>
<ol>
<li>不能使用retain/release/retainCount/autorelease</li>
<li>不能使用NSAllocateObject/NSDeallocateObject</li>
<li>必须遵守内存管理的方法名规则</li>
<li>不要显式调用dealloc</li>
<li>使用@autorelease块代替NSAutoreleasePool</li>
<li>不能使用区域（NSZone）</li>
<li>对象型变量不能作为C语言结构体的成员</li>
<li>显式转换id和void*</li>
</ol>
<h3 id="1-不能使用retain-release-retainCount-autorelease"><a href="#1-不能使用retain-release-retainCount-autorelease" class="headerlink" title="1. 不能使用retain/release/retainCount/autorelease"></a>1. 不能使用retain/release/retainCount/autorelease</h3><p>在ARC机制下使用retain/release/retainCount/autorelease方法，会导致编译器报错。</p>
<h3 id="2-不能使用NSAllocateObject-NSDeallocateObject"><a href="#2-不能使用NSAllocateObject-NSDeallocateObject" class="headerlink" title="2. 不能使用NSAllocateObject/NSDeallocateObject"></a>2. 不能使用NSAllocateObject/NSDeallocateObject</h3><p>在ARC机制下使用NSAllocateObject/NSDeallocateObject方法，会导致编译器报错。</p>
<h3 id="3-必须遵守内存管理的方法名规则"><a href="#3-必须遵守内存管理的方法名规则" class="headerlink" title="3. 必须遵守内存管理的方法名规则"></a>3. 必须遵守内存管理的方法名规则</h3><p>对象的生成／持有的方法必须遵循以下命名规则：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
<li>init</li>
</ul>
<p>前四种方法已经介绍完。而关于init方法的要求则更为严格：</p>
<ul>
<li>必须是实例方法</li>
<li>必须返回对象</li>
<li>返回对象的类型必须是id类型或方法声明类的对象类型</li>
</ul>
<h3 id="4-不要显式调用dealloc"><a href="#4-不要显式调用dealloc" class="headerlink" title="4. 不要显式调用dealloc"></a>4. 不要显式调用dealloc</h3><p>对象被废弃时，无论ARC是否有效，系统都会调用对象的dealloc方法。</p>
<p>我们只能在dealloc方法里写一些对象被废弃时需要进行的操作（例如移除已经注册的观察者对象）但是不能手动调用dealloc方法。</p>
<p>注意在ARC无效的时候，还需要调用[super dealloc]：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">//该对象的处理</span></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-使用-autorelease块代替NSAutoreleasePool"><a href="#5-使用-autorelease块代替NSAutoreleasePool" class="headerlink" title="5. 使用@autorelease块代替NSAutoreleasePool"></a>5. 使用@autorelease块代替NSAutoreleasePool</h3><p>ARC下须使用使用@autorelease块代替NSAutoreleasePool。</p>
<h3 id="6-不能使用区域（NSZone）"><a href="#6-不能使用区域（NSZone）" class="headerlink" title="6. 不能使用区域（NSZone）"></a>6. 不能使用区域（NSZone）</h3><p>NSZone已经在目前的运行时系统（<strong>OBC2</strong>被设定的环境）被忽略了。</p>
<h3 id="7-对象型变量不能作为C语言结构体的成员"><a href="#7-对象型变量不能作为C语言结构体的成员" class="headerlink" title="7. 对象型变量不能作为C语言结构体的成员"></a>7. 对象型变量不能作为C语言结构体的成员</h3><p>C语言的结构体如果存在Objective-C对象型变量，便会引起错误，因为C语言在规约上没有方法来管理结构体成员的生存周期 。</p>
<h3 id="8-显式转换id和void"><a href="#8-显式转换id和void" class="headerlink" title="8. 显式转换id和void*"></a>8. 显式转换id和void*</h3><p>非ARC下，这两个类型是可以直接赋值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj = [NSObject alloc] init];</div><div class="line">void *p = obj;</div><div class="line">id o = p;</div></pre></td></tr></table></figure>
<p>但是在ARC下就会引起编译错误。为了避免错误，我们需要通过__bridege来转换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span>*)obj;<span class="comment">//显式转换</span></div><div class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;<span class="comment">//显式转换</span></div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>来看一下属性的声明与所有权修饰符的关系</p>
<table>
<thead>
<tr>
<th>属性关键字</th>
<th>所有权 修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>__unsafe_unretained</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
</tr>
</tbody>
</table>
<p>说一下<strong>unsafe_unretained：
</strong>unsafe_unretained表示存取方法会直接为实例变量赋值。</p>
<p>这里的“unsafe”是相对于weak而言的。我们知道weak指向的对象被销毁时，指针会自动设置为nil。而__unsafe_unretained却不会，而是成为空指针。需要注意的是：当处理非对象属性的时候就不会出现空指针的问题。</p>
<p>这样第一章就介绍完了，第二篇会在下周一发布^^</p>
<hr>
<p>扩展文献：</p>
<ol>
<li><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Apple:Transitioning to ARC Release Notes</a> </li>
<li><a href="http://www.jianshu.com/p/6cf682f90fa2" target="_blank" rel="external">蚊香酱:可能是史上最全面的内存管理文章</a></li>
<li><a href="http://www.jianshu.com/p/0ad9957e3716" target="_blank" rel="external">微笑和飞飞:可能碰到的iOS笔试面试题（6）–内存管理</a></li>
<li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00RWORA1O/ref=sr_1_1?ie=UTF8&amp;qid=1491531635&amp;sr=8-1&amp;keywords=ios%E7%BC%96%E7%A8%8B" target="_blank" rel="external">《iOS编程(第4版)》</a> </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结了&lt;a href=&quot;http://www.jianshu.com/nb/6074358&quot;&gt;Effective Objective-C&lt;/a&gt;之后，还想读一本进阶的iOS书，毫不犹豫选中了《Objective-C 高级编程》：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程：iOS与OS X多线程和内存管理》&quot;&gt;&lt;/p&gt;
&lt;p&gt;这本书有三个章节，我针对每一章节进行总结并加上适当的扩展分享给大家。可以从下面这张图来看一下这三篇的整体结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程》 干货三部曲&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，这个结构并不和书中的结构一致，而是以书中的结构为参考，稍作了调整。&lt;/p&gt;
&lt;p&gt;本篇是第一篇：引用计数，简单说两句：&lt;br&gt;Objective-C通过 retainCount 的机制来决定对象是否需要释放。 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>基于MVVM，用于快速搭建设置页，个人信息页的框架</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/03/20/%E5%9F%BA%E4%BA%8EMVVM%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%AE%BE%E7%BD%AE%E9%A1%B5%EF%BC%8C%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E9%A1%B5%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%88%E9%99%84%EF%BC%9A%E4%BB%BF%E5%BE%AE%E4%BF%A1iOS%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E7%8E%B0%E9%A1%B5%EF%BC%8C%E4%B8%AA%E4%BA%BA%E9%A1%B5%EF%BC%8C%E8%AE%BE%E7%BD%AE%E9%A1%B5Demo%EF%BC%89/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/03/20/基于MVVM，用于快速搭建设置页，个人信息页的框架（附：仿微信iOS客户端发现页，个人页，设置页Demo）/</id>
    <published>2017-03-20T05:47:51.000Z</published>
    <updated>2017-05-15T00:13:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="更新记录："><a href="#更新记录：" class="headerlink" title="更新记录："></a>更新记录：</h3><p><strong>2017.4.23：新增支持数据源完全依赖网络请求的情况。</strong><br><strong>2017.4.22：新增支持请求新数据后刷新表格。</strong><br><strong>2017.4.21： 新增CocoaPods支持：pod ‘SJStaticTableView’, ‘~&gt; 1.2.0’。</strong></p>
<hr>
<p>写一个小小轮子～</p>
<p>写UITableView的时候，我们经常遇到的是完全依赖于网络请求，需要自定义的动态cell的需求（比如微博帖子列表）。但是同时，大多数app里面几乎也都有设置页，个人页等其他以静态表格为主的页面。</p>
<p>而且这些页面的共性比较多：</p>
<ol>
<li>大多数情况下在进入页面之前就已经拿到所有数据。</li>
<li>cell样式单一，自定义cell出现的几率比较小（几乎都是高度为44的cell）。</li>
<li>多数都分组。</li>
</ol>
<p>因为自己非常想写一个开源的东西出来（也可以暴露自己的不足），同时又受限于水平，所以就打算写这么一个比较简单，又具有通用性的框架：<strong>一个定制性比较高的适合在个人页和设置页使用的UITableView</strong>。</p>
<p>在真正写之前，看了几篇类似的文章，挑出三篇自己觉得比较好的：</p>
<ol>
<li><a href="https://www.objc.io/issues/1-view-controllers/table-views/" target="_blank" rel="external">Clean Table View Code</a> </li>
<li><a href="http://www.jianshu.com/p/504c61a9dc82" target="_blank" rel="external">如何写好一个UITableView</a></li>
<li><a href="http://www.jianshu.com/p/81d0c573f7a8" target="_blank" rel="external">利用MVVM设计快速开发个人中心、设置等模块</a></li>
</ol>
<p>看完总结之后，利用上周3天的业余时间写好了这个框架，为了它实用性，我仿照了微信客户端的发现页，个人页和设置页写了一个Demo，来看一下效果图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/85789de80b62c93ff0c9f77b603dba70" alt="发现页 | 个人页 | 个人信息页 | 设置页"></p>
<blockquote>
<p>项目所用资源来自：<a href="https://github.com/zhengwenming/WeChat">GitHub:zhengwenming/WeChat</a><br>Demo地址：<a href="https://github.com/knightsj/SJStaticTableView">GitHub: knightsj/SJStaticTableView</a></p>
</blockquote>
<a id="more"></a>
<p>为了体现出这个框架的定制性，我自己也在里面添加了两个页面，入口在设置页里面：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/a38f9f8459fbd168e3f434e5cff27526" alt="分组定制 | 同组定制"></p>
<blockquote>
<p>先不要纠结分组定制和同组定制的具体意思，在后面讲到定制性的时候我会详细说明。现在只是让大家看一下效果。</p>
</blockquote>
<p>在大概了解了功能之后，开始详细介绍这个框架。写这篇介绍的原因倒不是希望有多少人来用，而是表达一下我自己的思路而已。各位觉得不好的地方请多批评。</p>
<p>在正式讲解之前，先介绍一下本篇的基本目录：</p>
<ol>
<li>用到的技术点。</li>
<li>功能说明。</li>
<li>使用方法。</li>
<li>定制性介绍。</li>
<li>新增支持刷新功能。</li>
<li>新增支持数据源完全依赖网络请求。</li>
</ol>
<h1 id="1-用到的技术点"><a href="#1-用到的技术点" class="headerlink" title="1. 用到的技术点"></a>1. 用到的技术点</h1><hr>
<p>框架整体来说还是比较简单的，主要还是基于苹果的<code>UITableView</code>组件，为了解耦和责任分离，主要运用了以下技术点：</p>
<ul>
<li><strong>MVVM</strong>：采用MVVM架构，将每一行“纯粹”的数据交给一个单独的<code>ViewModel</code>,让其持有每个cell的数据（行高，cell类型，文本宽度，图片高度等等）。而且每一个section也对应一个<code>ViewModel</code>，它持有当前section的配置数据（title，header和footer的高度等等）。</li>
<li><strong>轻UIViewController</strong>：分离<code>UITableViewDataSource</code>与<code>UIViewController</code>，让单独一个类来实现<code>UITableViewDataSource</code>的职能。</li>
<li><strong>block</strong>：使用block来调用cell的绘制方法。</li>
<li><strong>分类</strong>：使用分类来定义每一种不同的cell的绘制方法。</li>
</ul>
<p>知道了主要运用的技术点以后，给大家详细介绍一下该框架的功能。</p>
<h1 id="2-功能介绍"><a href="#2-功能介绍" class="headerlink" title="2. 功能介绍"></a>2. 功能介绍</h1><hr>
<p>这个框架可以用来快速搭建设置页，个人信息页能静态表格页面，使用者只需要给tableView的DataSource传入元素是viewModel的数组就可以了。</p>
<p>虽说这类页面的布局还是比较单一的，但是还是会有几种不同的情况（cell的布局类型），我对比较常见的cell布局做了封装，使用者可以直接使用。</p>
<p>我在定义这些cell的类型的时候，大致划分了两类：</p>
<ol>
<li>第一类是系统风格的cell，大多数情况下，cell高度为44；在cell左侧会有一张图，一个label，也可以只存在一种（但是只存在图片的情况很少）；在cell右侧一般都有一个向右的箭头，而且有时这个箭头的左侧还可能有label，image，也可以两个都有。</li>
<li>第二类就是自定义的cell了，它的高度不一定是44，而且布局和系统风格的cell很不一样，需要用户自己添加。</li>
</ol>
<p>基于这两大类，再细分了几种情况，可以由下面这张图来直观看一下：</p>
<p>既然是cell的类型，那么就类型的枚举就需要定义在cell的viewModel里面：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SJStaticCellType) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//系统风格的各种cell类型，已封装好，可以直接用</span></div><div class="line">    SJStaticCellTypeSystemLogout,                          <span class="comment">//退出登录cell</span></div><div class="line">    SJStaticCellTypeSystemAccessoryNone,                   <span class="comment">//右侧没有任何控件</span></div><div class="line">    SJStaticCellTypeSystemAccessorySwitch,                 <span class="comment">//右侧是开关</span></div><div class="line">    SJStaticCellTypeSystemAccessoryDisclosureIndicator,    <span class="comment">//右侧是三角箭头(箭头左侧可以有一个image或者一个label，或者二者都有，根据传入的参数决定)</span></div><div class="line">    </div><div class="line">    <span class="comment">//需要用户自己添加的自定义cell类型</span></div><div class="line">    SJStaticCellTypeMeAvatar,                              <span class="comment">//个人页“我”cell    </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>来一张图直观得体会一下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/1f8db817518311481d64d30ec481cf71" alt="支持cell类型"></p>
<p>在这里有三点需要说一下：</p>
<ol>
<li>这里面除了自定义的cell以外，其他类型的cell都不需要开发者自己布局，都已经被我封装好，只需要在cell的<code>ViewModel</code>里面传入相应的类型和数据（文字，图片）即可。</li>
<li>因为左侧的两个控件（图片和文字）是至少存在一个而且左右顺序固定（图片永远在最左侧），所以该框架通过开发者传入的左侧需要显示的图片和文字，可以自己进行cell的布局。所以类型的判断主要作用于cell的右侧。</li>
<li>值得一提的是，在”最右侧是一个箭头”子分支的五个类型其实都属于一个类型，只需要传入文字和图片，以及文字图片的显示顺序参数（这个参数只在同时存在图片和文字的时候有效）就可以自行判断布局。</li>
</ol>
<p>在了解了该框架的功能之后，我们先看一下如何使用这个框架：</p>
<h1 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h1><hr>
<h2 id="集成方法："><a href="#集成方法：" class="headerlink" title="集成方法："></a>集成方法：</h2><ol>
<li>静态：手动将SJStaticTableViewComponent文件夹拖入到工程中。</li>
<li>动态：CocoaPods：<code>pod &#39;SJStaticTableView&#39;, &#39;~&gt; 1.1.2</code>。</li>
</ol>
<p>具体的方法先用文字说明一下：</p>
<ol>
<li>将要开发的页面的ViewController继承<code>SJStaticTableViewController</code>。</li>
<li>在新ViewController里实现<code>createDataSource</code>方法，将viewModel数组传给控制器的<code>dataSource</code>属性。</li>
<li>根据不同的cell类型，调用不同的cell绘制方法。</li>
<li>如果需要接受cell的点击，需要实现<code>didSelectViewModel</code>方法。</li>
</ol>
<p>可能感觉比较抽象，我拿设置页来具体说明一下：</p>
<p>先看一下设置页的布局：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/d1ea6240a3760acbcb92198f1c454044" alt="设置页"></p>
<p>然后我们看一下设置的ViewController的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.navigationItem.title = <span class="string">@"设置"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)createDataSource</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.dataSource = [[SJStaticTableViewDataSource alloc] initWithViewModelsArray:[Factory settingPageData] configureBlock:^(SJStaticTableViewCell *cell, SJStaticTableviewCellViewModel *viewModel) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">switch</span> (viewModel.staticCellType)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessoryDisclosureIndicator:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessoryDisclosureIndicatorCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessorySwitch:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessorySwitchCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemLogout:</div><div class="line">            &#123;</div><div class="line">                [cell configureLogoutTableViewCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessoryNone:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessoryNoneCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)didSelectViewModel:(SJStaticTableviewCellViewModel *)viewModel atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">switch</span> (viewModel.identifier)</div><div class="line">    &#123;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"退出登录"</span>);</div><div class="line">            [<span class="keyword">self</span> showAlertWithMessage:<span class="string">@"真的要退出登录嘛？"</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">8</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"清理缓存"</span>);</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">9</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"跳转到定制性cell展示页面 - 分组"</span>);</div><div class="line">            SJCustomCellsViewController *vc = [[SJCustomCellsViewController alloc] init];</div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">10</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"跳转到定制性cell展示页面 - 同组"</span>);</div><div class="line">            SJCustomCellsOneSectionViewController *vc = [[SJCustomCellsOneSectionViewController alloc] init];</div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，你可能会有这些疑问：</p>
<ol>
<li>UITableViewDataSource方法哪儿去了？</li>
<li>viewModel数组是如何设置的？</li>
<li>cell的绘制方法是如何区分的？</li>
<li>UITableViewDelegate的方法哪里去了？</li>
</ol>
<p>下面我会一一解答，看完了下面的解答，就能几乎完全掌握这个框架的思路了：</p>
<h3 id="问题1：UITableViewDataSource方法哪儿去了？"><a href="#问题1：UITableViewDataSource方法哪儿去了？" class="headerlink" title="问题1：UITableViewDataSource方法哪儿去了？"></a>问题1：UITableViewDataSource方法哪儿去了？</h3><p>我自己封装了一个类<code>SJStaticTableViewDataSource</code>专门作为数据源，需要控制器给它一个viewModel数组。</p>
<p>来看一下它的实现文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableViewDataSource.m</span></div><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.viewModelsArray.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.cellViewModelsArray.count;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">//获取section的ViewModel</span></div><div class="line">    SJStaticTableviewSectionViewModel *sectionViewModel = <span class="keyword">self</span>.viewModelsArray[indexPath.section];</div><div class="line">    <span class="comment">//获取cell的viewModel</span></div><div class="line">    SJStaticTableviewCellViewModel *cellViewModel = sectionViewModel.cellViewModelsArray[indexPath.row];</div><div class="line">    </div><div class="line">    SJStaticTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellViewModel.cellID];</div><div class="line">    <span class="keyword">if</span> (!cell) &#123;</div><div class="line">        cell = [[SJStaticTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:cellViewModel.cellID];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.cellConfigureBlock(cell,cellViewModel);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.sectionHeaderTitle;  </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForFooterInSection:(<span class="built_in">NSInteger</span>)section</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.sectionFooterTitle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>表格的cell和section都设置了与其对应的viewModel，用于封装其对应的数据：</p>
</blockquote>
<p>cell的viewModel(大致看一下即可，后面有详细说明)：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SJStaticCellType) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//系统风格的各种cell类型，已封装好，可以直接用</span></div><div class="line">    SJStaticCellTypeSystemLogout,                          <span class="comment">//退出登录cell（已封装好）</span></div><div class="line">    SJStaticCellTypeSystemAccessoryNone,                   <span class="comment">//右侧没有任何控件</span></div><div class="line">    SJStaticCellTypeSystemAccessorySwitch,                 <span class="comment">//右侧是开关</span></div><div class="line">    SJStaticCellTypeSystemAccessoryDisclosureIndicator,    <span class="comment">//右侧是三角箭头(箭头左侧可以有一个image或者一个label，或者二者都有，根据传入的参数决定)</span></div><div class="line">    </div><div class="line">    <span class="comment">//需要用户自己添加的自定义cell类型</span></div><div class="line">    SJStaticCellTypeMeAvatar,                              <span class="comment">//个人页“我”cell</span></div><div class="line">    </div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SwitchValueChagedBlock)(<span class="built_in">BOOL</span> isOn);           <span class="comment">//switch开关切换时调用的block</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableviewCellViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SJStaticCellType staticCellType;                  <span class="comment">//类型</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *cellID;                                  <span class="comment">//cell reuser identifier</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> identifier;                              <span class="comment">//区别每个cell，用于点击</span></div><div class="line"></div><div class="line"><span class="comment">// =============== 系统默认cell左侧 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span>  *leftImage;                               <span class="comment">//左侧的image，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> leftImageSize;                              <span class="comment">//左侧image的大小，存在默认设置</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *leftTitle;                               <span class="comment">//cell主标题，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *leftLabelTextColor;                       <span class="comment">//当前组cell左侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *leftLabelTextFont;                         <span class="comment">//当前组cell左侧label里文字的字体</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> leftImageAndLabelGap;                      <span class="comment">//左侧image和label的距离，存在默认值</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// =============== 系统默认cell右侧 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *indicatorLeftTitle;                      <span class="comment">//右侧箭头左侧的文本，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *indicatorLeftLabelTextColor;              <span class="comment">//右侧文字的颜色，存在默认设置，也可以自定义</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *indicatorLeftLabelTextFont;                <span class="comment">//右侧文字的字体，存在默认设置，也可以自定义</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *indicatorLeftImage;                       <span class="comment">//右侧箭头左侧的image，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> indicatorLeftImageSize;                     <span class="comment">//右侧尖头左侧image大小，存在默认设置，也可以自定义</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>)  <span class="built_in">BOOL</span> hasIndicatorImageAndLabel;         <span class="comment">//右侧尖头左侧的文本和image是否同时存在，只能通过内部计算</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> indicatorLeftImageAndLabelGap;             <span class="comment">//右侧尖头左侧image和label的距离，存在默认值</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isImageFirst;                                 <span class="comment">//右侧尖头左侧的文本和image同时存在时，是否是image挨着箭头，默认为YES</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) SwitchValueChagedBlock switchValueDidChangeBlock;    <span class="comment">//切换switch开关的时候调用的block</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// =============== 长宽数据 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;                                <span class="comment">//cell高度,默认是44，可以设置</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span>  leftTitleLabelSize;                        <span class="comment">//左侧默认Label的size，传入text以后内部计算</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span>  indicatorLeftLabelSize;                    <span class="comment">//右侧label的size</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// =============== 自定义cell的数据放在这里 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *avatarImage;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *codeImage;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *userName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *userID;</div></pre></td></tr></table></figure></p>
<p>section的viewModel(大致看一下即可，后面有详细说明)：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableviewSectionViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sectionHeaderTitle;         <span class="comment">//该section的标题</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sectionFooterTitle;         <span class="comment">//该section的标题</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>  *cellViewModelsArray;        <span class="comment">//该section的数据源</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span>  sectionHeaderHeight;         <span class="comment">//header的高度</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span>  sectionFooterHeight;         <span class="comment">//footer的高度</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> leftImageSize;                 <span class="comment">//当前组cell左侧image的大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *leftLabelTextColor;          <span class="comment">//当前组cell左侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *leftLabelTextFont;            <span class="comment">//当前组cell左侧label里文字的字体</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> leftImageAndLabelGap;         <span class="comment">//当前组左侧image和label的距离，存在默认值</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *indicatorLeftLabelTextColor; <span class="comment">//当前组cell右侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *indicatorLeftLabelTextFont;   <span class="comment">//当前组cell右侧label里文字的字体</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> indicatorLeftImageSize;        <span class="comment">//当前组cell右侧image的大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> indicatorLeftImageAndLabelGap;<span class="comment">//当前组cell右侧image和label的距离，存在默认值</span></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCellViewModelsArray:(<span class="built_in">NSArray</span> *)cellViewModelsArray;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>你可能会觉得属性太多了，但这些属性的存在意义是为cell的定制性服务的，在后文会有解释。</p>
</blockquote>
<p>现在了解了我封装好的数据源，cell的viewModel，section的viewModel以后，我们看一下第二个问题：</p>
<h2 id="问题2：-viewModel数组是如何设置的？"><a href="#问题2：-viewModel数组是如何设置的？" class="headerlink" title="问题2： viewModel数组是如何设置的？"></a>问题2： viewModel数组是如何设置的？</h2><p>我们来看一下设置页的viewModel数组的设置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)settingPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">// ========== section 0</span></div><div class="line">    SJStaticTableviewCellViewModel *vm0 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm0.leftTitle = <span class="string">@"账号与安全"</span>;</div><div class="line">    vm0.identifier = <span class="number">0</span>;</div><div class="line">    vm0.indicatorLeftTitle = <span class="string">@"已保护"</span>;</div><div class="line">    vm0.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"ProfileLockOn"</span>];</div><div class="line">    vm0.isImageFirst = <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section0 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm0]];</div><div class="line">    </div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">// ========== section 1</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftTitle = <span class="string">@"新消息通知"</span>;</div><div class="line">    vm1.identifier = <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//额外添加switch</span></div><div class="line">    SJStaticTableviewCellViewModel *vm7 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftTitle = <span class="string">@"夜间模式"</span>;</div><div class="line">    vm7.switchValueDidChangeBlock = ^(<span class="built_in">BOOL</span> isON)&#123;</div><div class="line">        <span class="built_in">NSString</span> *message = isON?<span class="string">@"打开夜间模式"</span>:<span class="string">@"关闭夜间模式"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,message);</div><div class="line">    &#125;;</div><div class="line">    vm7.staticCellType = SJStaticCellTypeSystemAccessorySwitch;</div><div class="line">    vm7.identifier = <span class="number">7</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm8 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm8.leftTitle = <span class="string">@"清理缓存"</span>;</div><div class="line">    vm8.indicatorLeftTitle = <span class="string">@"12.3M"</span>;</div><div class="line">    vm8.identifier = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftTitle = <span class="string">@"隐私"</span>;</div><div class="line">    vm2.identifier = <span class="number">2</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftTitle = <span class="string">@"通用"</span>;</div><div class="line">    vm3.identifier = <span class="number">3</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1,vm7,vm8,vm2,vm3]];</div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">// ========== section 2</span></div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftTitle = <span class="string">@"帮助与反馈"</span>;</div><div class="line">    vm4.identifier = <span class="number">4</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftTitle = <span class="string">@"关于微信"</span>;</div><div class="line">    vm5.identifier = <span class="number">5</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section2 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm4,vm5]];</div><div class="line">    </div><div class="line"></div><div class="line"></div><div class="line">      <span class="comment">// ========== section 4</span></div><div class="line">    SJStaticTableviewCellViewModel *vm9 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm9.leftTitle = <span class="string">@"定制性cell展示页面 - 分组"</span>;</div><div class="line">    vm9.identifier = <span class="number">9</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm10 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm10.leftTitle = <span class="string">@"定制性cell展示页面 - 同组"</span>;</div><div class="line">    vm10.identifier = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section4 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm9,vm10]];</div><div class="line">    </div><div class="line">    </div><div class="line"></div><div class="line">    <span class="comment">// ========== section 3</span></div><div class="line">    SJStaticTableviewCellViewModel *vm6 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.staticCellType = SJStaticCellTypeSystemLogout;</div><div class="line">    vm6.cellID = <span class="string">@"logout"</span>;</div><div class="line">    vm6.identifier = <span class="number">6</span>;</div><div class="line">   </div><div class="line">    SJStaticTableviewSectionViewModel *section3 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm6]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section0,section1,section2,section4,section3];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，交给dataSource的数组是一个二维数组：</p>
<ul>
<li>第一维是section数组，元素是每一个section对应的viewModel：<code>SJStaticTableviewSectionViewModel</code>。</li>
<li>第二维是cell数组，元素是每一个cell对应的viewModel:<code>SJStaticTableviewCellViewModel</code>。</li>
</ul>
<p>有几个<code>SJStaticTableviewCellViewModel</code>的属性需要强调一下：</p>
<ol>
<li>isImageFirst：因为该页面第一组的cell右侧的箭头左边同时存在一个image和一个label，所以需要额外设置二者的顺序。因为默认紧挨着箭头的是图片，所以我们需要重新设置它为NO，作用是让label紧挨着箭头。</li>
<li>identifier：这个属性是一个整数，它用来标记每个cell，用于在用户点击cell的时候进行判断。我没有将用户的点击与cell的index相关联，是因为有的时候因为需求我们可能会更改cell的顺序或者删除某个cell，所以依赖cell的index是不妥的，容易出错。</li>
<li>cellID：这个属性用来cell的复用。因为总是有个别cell的布局是不同的：在这里出现了一个退出登录的cell，所以需要和其他的cell区别开来（cellID可以不用设置，有默认值，用来标记最常用的cell类型）。</li>
</ol>
<p>显然，<code>Factory</code>类属于<code>Model</code>，它将“纯数据”交给了dataSource使用的两个viewModel。这个类是我自己定义的，读者在使用这个框架的时候可以根据需求自己定义。</p>
<p>现在知道了数据源的设置方法，我们看一下第三个问题：</p>
<h3 id="问题3：cell的绘制方法是如何区分的？"><a href="#问题3：cell的绘制方法是如何区分的？" class="headerlink" title="问题3：cell的绘制方法是如何区分的？"></a>问题3：cell的绘制方法是如何区分的？</h3><p>心细的同学会发现，在dataSource的<code>cellForRow:</code>方法里，我用了block方法来绘制了cell。</p>
<p>先看一下这个block的定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SJStaticCellConfigureBlock)(SJStaticTableViewCell *cell, SJStaticTableviewCellViewModel * viewModel);</div></pre></td></tr></table></figure></p>
<p>这个block在控制器里面回调，通过判断cell的类型来绘制不同的cell。</p>
<p>那么不同类型的cell是如何区分的呢？<br>— 我用的是分类。</p>
<p>有分类，就一定有一个被分类的类： <code>SJStaticTableViewCell</code></p>
<p>看一下它的头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//所有cell都是这个类的分类</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> : <span class="title">UITableViewCell</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SJStaticTableviewCellViewModel *viewModel;</div><div class="line"></div><div class="line"><span class="comment">// =============== 系统风格cell的所有控件 =============== //</span></div><div class="line"></div><div class="line"><span class="comment">//左半部分</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *leftImageView;               <span class="comment">//左侧的ImageView</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *leftTitleLabel;                  <span class="comment">//左侧的Label</span></div><div class="line"></div><div class="line"><span class="comment">//右半部分</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *indicatorArrow;              <span class="comment">//右侧的箭头</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *indicatorLeftImageView;      <span class="comment">//右侧的箭头的左边的imageview</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *indicatorLeftLabel;              <span class="comment">//右侧的箭头的左边的Label</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UISwitch</span> *indicatorSwitch;                <span class="comment">//右侧的箭头的左边的开关</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *logoutLabel;                     <span class="comment">//退出登录的label</span></div><div class="line"></div><div class="line"><span class="comment">// =============== 用户自定义的cell里面的控件 =============== //</span></div><div class="line"></div><div class="line"><span class="comment">//MeViewController里面的头像cell</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *avatarImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *codeImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *avatarIndicatorImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *userNameLabel;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *userIdLabel;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//统一的，布局cell左侧部分的内容（标题 ／ 图片 + 标题），所有系统风格的cell都要调用这个方法</span></div><div class="line">- (<span class="keyword">void</span>)layoutLeftPartSubViewsWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>在这里我定义了所有的控件和一个布局cell左侧的控件的方法。因为几乎所有的分类的左侧几乎都是类似的，所以将它抽取出来。</p>
<p>那么究竟有几个分类呢？（可以参考上面cellViewModel头文件里的枚举类型）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧有剪头的cell（最常见）</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessoryDisclosureIndicator</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessoryDisclosureIndicatorCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧没有控件的cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessoryNone</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessoryNoneCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧是开关的 cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessorySwitch</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessorySwitchCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//退出登录cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">Logout</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureLogoutTableViewCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个自定义的cell（在个人页的第一排）</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">MeAvatar</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureMeAvatarTableViewCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在使用这个框架的时候，如果遇到不满足当前需求的情况，可以自己添加分类。</p>
<h3 id="问题4：UITableViewDelegate的方法哪里去了？"><a href="#问题4：UITableViewDelegate的方法哪里去了？" class="headerlink" title="问题4：UITableViewDelegate的方法哪里去了？"></a>问题4：UITableViewDelegate的方法哪里去了？</h3><p>说到<code>UITableViewDelegate</code>的代理方法，我们最熟悉的莫过于<code>didSelectRowAtIndexPath:</code>了。</p>
<p>但是我在写这个框架的时候，自己定义了一个继承于<code>UITableViewDelegate</code>的代理：<code>SJStaticTableViewDelegate</code>，并给它添加了一个代理方法：<br>``<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SJStaticTableViewDelegate</span> &lt;<span class="title">UITableViewDelegate</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)didSelectViewModel: (SJStaticTableviewCellViewModel *)viewModel atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这个方法返回的是当前点击的cell对应的viewModel，弱化了indexPath的作用。</p>
<p>为什么要这么做？</p>
<p>想一想原来点击cell的代理方法：<code>didSelectRowAtIndexPath:</code>。我们通过这个点击方法，拿到的是cell对应的indexPath，然后再通过这个indexPath，就可以在数据源里面查找对应的模型（viewModel或者model）。</p>
<p>因此，我定义的这个方法直接返回了被点击cell对应的viewModel，等于说帮使用者节省了一个步骤。当然如果要使用的话也可以使用系统原来的<code>didSelectRowAtIndexPath:</code>方法。</p>
<p>来看一下这个新的代理方法是如何实现的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableView.m</span></div><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.sjDelegate) &amp;&amp; [<span class="keyword">self</span>.sjDelegate respondsToSelector:<span class="keyword">@selector</span>(didSelectViewModel:atIndexPath:)]) &#123;</div><div class="line">        </div><div class="line">        SJStaticTableviewCellViewModel *cellViewModel = [<span class="keyword">self</span>.sjDataSource tableView:tableView cellViewModelAtIndexPath:indexPath];</div><div class="line">        [<span class="keyword">self</span>.sjDelegate didSelectViewModel:cellViewModel atIndexPath:indexPath];</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">self</span>.sjDelegate)&amp;&amp; [<span class="keyword">self</span>.sjDelegate respondsToSelector:<span class="keyword">@selector</span>(tableView:didSelectRowAtIndexPath:)])&#123;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.sjDelegate tableView:tableView didSelectRowAtIndexPath:indexPath];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在读者应该大致了解了这个框架的实现思路，现在我讲一下这个框架的定制性。</p>
<h1 id="4-定制性"><a href="#4-定制性" class="headerlink" title="4. 定制性"></a>4. 定制性</h1><hr>
<p>这个框架有一个配置文件：SJConst.h，它定义了这个框架的所有默认数据和默认配置，比如cell左侧lable的字体，颜色；左侧label和image的距离；右侧label的字体和颜色，右侧图片的默认大小等等。来看一下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef SJConst_h</span></div><div class="line"><span class="meta">#define SJConst_h</span></div><div class="line"></div><div class="line"><span class="comment">//distance</span></div><div class="line"><span class="meta">#define SJScreenWidth      [UIScreen mainScreen].bounds.size.width</span></div><div class="line"><span class="meta">#define SJScreenHeight     [UIScreen mainScreen].bounds.size.height</span></div><div class="line"></div><div class="line"><span class="meta">#define SJTopGap 8               //same as bottom gap</span></div><div class="line"><span class="meta">#define SJLeftGap 12             //same as right gap</span></div><div class="line"><span class="meta">#define SJLeftMiddleGap 10       //in left  part: the gap between image and label</span></div><div class="line"><span class="meta">#define SJRightMiddleGap 6       //in right part: the gap between image and label</span></div><div class="line"><span class="meta">#define SJImgWidth 30            //default width and height</span></div><div class="line"><span class="meta">#define SJTitleWidthLimit 180    //limt width of left and right labels</span></div><div class="line"></div><div class="line"><span class="comment">//image</span></div><div class="line"><span class="meta">#define SJIndicatorArrow @<span class="meta-string">"arrow"</span></span></div><div class="line"></div><div class="line"><span class="comment">//font</span></div><div class="line"><span class="meta">#define SJLeftTitleTextFont               [UIFont systemFontOfSize:15]</span></div><div class="line"><span class="meta">#define SJLogoutButtonFont                [UIFont systemFontOfSize:16]</span></div><div class="line"><span class="meta">#define SJIndicatorLeftTitleTextFont      [UIFont systemFontOfSize:13]</span></div><div class="line"></div><div class="line"><span class="comment">//color</span></div><div class="line"><span class="meta">#define SJColorWithRGB(R,G,B,A)           [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]</span></div><div class="line"><span class="meta">#define SJLeftTitleTextColor              [UIColor blackColor]</span></div><div class="line"><span class="meta">#define SJIndicatorLeftTitleTextColor     SJColorWithRGB(136,136,136,1)</span></div><div class="line"></div><div class="line"><span class="meta">#endif /* SJConst_h */</span></div></pre></td></tr></table></figure>
<p>这里定义的默认配置在cellViewModel和sectionViewModel初始化的时候使用：</p>
<p>cell的viewModel：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableviewCellViewModel.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;        </div><div class="line">        _cellHeight = <span class="number">44</span>;</div><div class="line">        _cellID = <span class="string">@"defaultCell"</span>;</div><div class="line">        _staticCellType = SJStaticCellTypeSystemAccessoryDisclosureIndicator;<span class="comment">//默认是存在三角箭头的cell</span></div><div class="line">        _isImageFirst = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//都是默认配置</span></div><div class="line">        _leftLabelTextFont = SJLeftTitleTextFont;</div><div class="line">        _leftLabelTextColor = SJLeftTitleTextColor;</div><div class="line">        _leftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _leftImageAndLabelGap = SJLeftMiddleGap;</div><div class="line">        _indicatorLeftLabelTextFont = SJIndicatorLeftTitleTextFont;</div><div class="line">        _indicatorLeftLabelTextColor = SJIndicatorLeftTitleTextColor;</div><div class="line">        _indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _indicatorLeftImageAndLabelGap = SJRightMiddleGap;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>section的viewModel：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithCellViewModelsArray:(<span class="built_in">NSArray</span> *)cellViewModelsArray</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _sectionHeaderHeight = <span class="number">10</span>;</div><div class="line">        _sectionFooterHeight = <span class="number">10</span>;</div><div class="line">        _leftLabelTextFont = SJLeftTitleTextFont;</div><div class="line">        _leftLabelTextColor = SJLeftTitleTextColor;</div><div class="line">        _leftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _leftImageAndLabelGap = SJLeftMiddleGap;</div><div class="line">        _indicatorLeftLabelTextFont = SJIndicatorLeftTitleTextFont;</div><div class="line">        _indicatorLeftLabelTextColor = SJIndicatorLeftTitleTextColor;</div><div class="line">        _indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _indicatorLeftImageAndLabelGap = SJRightMiddleGap;</div><div class="line">        _cellViewModelsArray = cellViewModelsArray;        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，这个默认配置只有一组，但是可能一个app里面同时存在一个设置页和一个个人页。而这两个页面的风格也可能是不一样的，所以这个默认配置只能给其中一个页面，另一个页面需要另外配置，于是就有了定制性的功能。</p>
<p>再来看一下展示定制性效果的图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/dc3d7675b3eedb3dbe4ac3b7bb20d7db" alt="分组定制 | 同组定制"></p>
<p>参照这个效果图，我们看一下这两个页面的数据源是如何设置的：</p>
<p>分组页面：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)customCellsPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">//默认配置</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm1.leftTitle = <span class="string">@"全部默认配置，用于对照"</span>;</div><div class="line">    vm1.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm1.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1]];</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm2.leftTitle = <span class="string">@"左侧图片变小"</span>;</div><div class="line">    vm2.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm2.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section2 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm2]];</div><div class="line">    section2.leftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>);</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm3.leftTitle = <span class="string">@"字体变小变红"</span>;</div><div class="line">    vm3.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm3.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section3 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm3]];</div><div class="line">    section3.leftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">8</span>];</div><div class="line">    section3.leftLabelTextColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm4.leftTitle = <span class="string">@"左侧两个控件距离变大"</span>;</div><div class="line">    vm4.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm4.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section4 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm4]];</div><div class="line">    section4.leftImageAndLabelGap = <span class="number">20</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm5.leftTitle = <span class="string">@"右侧图片变小"</span>;</div><div class="line">    vm5.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm5.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section5 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm5]];</div><div class="line">    section5.indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">15</span>, <span class="number">15</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm6= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm6.leftTitle = <span class="string">@"右侧字体变大变蓝"</span>;</div><div class="line">    vm6.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm6.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section6 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm6]];</div><div class="line">    section6.indicatorLeftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18</span>];</div><div class="line">    section6.indicatorLeftLabelTextColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm7= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm7.leftTitle = <span class="string">@"右侧两个控件距离变大"</span>;</div><div class="line">    vm7.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm7.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section7 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm7]];</div><div class="line">    section7.indicatorLeftImageAndLabelGap = <span class="number">18</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section1,section2,section3,section4,section5,section6,section7];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到，定制的代码都作用于section的viewModel。</p>
</blockquote>
<p>同组页面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)customCellsOneSectionPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">//默认配置</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm1.leftTitle = <span class="string">@"全部默认配置，用于对照"</span>;</div><div class="line">    vm1.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm1.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm2.leftTitle = <span class="string">@"左侧图片变小"</span>;</div><div class="line">    vm2.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm2.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm2.leftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm3.leftTitle = <span class="string">@"字体变小变红"</span>;</div><div class="line">    vm3.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm3.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm3.leftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">8</span>];</div><div class="line">    vm3.leftLabelTextColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm4.leftTitle = <span class="string">@"左侧两个控件距离变大"</span>;</div><div class="line">    vm4.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm4.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm4.leftImageAndLabelGap = <span class="number">20</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm5.leftTitle = <span class="string">@"右侧图片变小"</span>;</div><div class="line">    vm5.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm5.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm5.indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">15</span>, <span class="number">15</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm6= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm6.leftTitle = <span class="string">@"右侧字体变大变蓝"</span>;</div><div class="line">    vm6.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm6.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm6.indicatorLeftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18</span>];</div><div class="line">    vm6.indicatorLeftLabelTextColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm7= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm7.leftTitle = <span class="string">@"右侧两个控件距离变大"</span>;</div><div class="line">    vm7.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm7.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm7.indicatorLeftImageAndLabelGap = <span class="number">18</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1,vm2,vm3,vm4,vm5,vm6,vm7]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section1];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为了方便比较，同组页面的定制和分组是一致的。我们可以看到，定制代码都作用于cell的viewModel上了。</p>
</blockquote>
<p>为什么要有同组和分组展示？</p>
<p>同组和分组展示的目的，是为了展示这个框架的两种定制性。</p>
<ul>
<li><p>分组页面所展示的是section级的定制性：cell的配置任务交给section层的viewModel。一旦设置，该section里面的所有cell都能保持这一配置。</p>
</li>
<li><p>同组页面所展示的是cell级的定制性：cell的配置任务交给cell层的viewModel。一旦设置，只有当前cell具有这个配置，不影响其他cell。</p>
</li>
</ul>
<p>其实为了省事，只在section层的viewModel上配置即可（如果给每个cell都给设置相同的配置太不优雅了），因为从设计角度来看，一个section里面的cell的风格不一致的情况比较少见（我觉得不符合设计）：比如在一个section里面，不太可能两个cell里面的图片大小是不一样的，或者字体大小也不一样。</p>
<p>还是看一下section级的定制代码吧：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧label的字体</span></div><div class="line">- (<span class="keyword">void</span>)setLeftLabelTextFont:(<span class="built_in">UIFont</span> *)leftLabelTextFont</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_leftLabelTextFont != leftLabelTextFont) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> font1:_leftLabelTextFont hasSameFontSizeOfFont2:leftLabelTextFont]) &#123;</div><div class="line">            </div><div class="line">            _leftLabelTextFont = leftLabelTextFont;</div><div class="line">            </div><div class="line">            <span class="comment">//如果新的宽度大于原来的宽度，需要重新设置，否则不需要</span></div><div class="line">            [_cellViewModelsArray enumerateObjectsUsingBlock:^(SJStaticTableviewCellViewModel * viewModel, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">                viewModel.leftLabelTextFont = _leftLabelTextFont;</div><div class="line">                <span class="built_in">CGSize</span> size = [<span class="keyword">self</span> sizeForTitle:viewModel.leftTitle withFont:_leftLabelTextFont];</div><div class="line">                <span class="keyword">if</span> (size.width &gt; viewModel.leftTitleLabelSize.width) &#123;</div><div class="line">                    viewModel.leftTitleLabelSize = size;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧label的字的颜色</span></div><div class="line">- (<span class="keyword">void</span>)setLeftLabelTextColor:(<span class="built_in">UIColor</span> *)leftLabelTextColor</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> color1:_leftLabelTextColor hasTheSameRGBAOfColor2:leftLabelTextColor]) &#123;</div><div class="line">         _leftLabelTextColor = leftLabelTextColor;</div><div class="line">        [_cellViewModelsArray makeObjectsPerformSelector:<span class="keyword">@selector</span>(setLeftLabelTextColor:) withObject:_leftLabelTextColor];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧图片等大小</span></div><div class="line">- (<span class="keyword">void</span>)setLeftImageSize:(<span class="built_in">CGSize</span>)leftImageSize</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewCellViewModel *viewMoel = _cellViewModelsArray.firstObject;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> cellHeight = viewMoel.cellHeight;</div><div class="line">    <span class="keyword">if</span> ( (!<span class="built_in">CGSizeEqualToSize</span>(_leftImageSize, leftImageSize)) &amp;&amp; (leftImageSize.height &lt; cellHeight)) &#123;</div><div class="line">        _leftImageSize = leftImageSize;</div><div class="line">        [_cellViewModelsArray enumerateObjectsUsingBlock:^(SJStaticTableviewCellViewModel *viewModel, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop)</div><div class="line">        &#123;</div><div class="line">            viewMoel.leftImageSize = _leftImageSize;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为每个section都持有它内部的所有cell的viewModel，所以在set方法里面，如果发现传进来的配置与当前配置不一致，就需要更新所有cell的viewModel对应的属性。</p>
<p>既然section的ViewModel能做这些，为什么还要有一个cell层的配置呢？</p>
<p>– 只是为了提高配置的自由度罢了，万一突然来个需求需要某个cell很独特呢？（大家应该知道我说的神么意思 ^^）</p>
<p>cell的viewModel属性的set方法的实现和section的一致，这里就不上代码了。</p>
<h1 id="5-新增支持刷新功能"><a href="#5-新增支持刷新功能" class="headerlink" title="5. 新增支持刷新功能"></a>5. 新增支持刷新功能</h1><p>在1.1.2版本支持了：在更新数据源后，刷新数据源。<br>举个例子：在发现页模拟网络请求，在请求结束后更新某个cell的viewmodel：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//模拟网络请求</span></div><div class="line">dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//请求成功x</span></div><div class="line">        <span class="built_in">NSDictionary</span> *responseDict = @&#123;<span class="string">@"title_info"</span>:<span class="string">@"新游戏上架啦"</span>,</div><div class="line">                                       <span class="string">@"title_icon"</span>:<span class="string">@"game_1"</span>,</div><div class="line">                                       <span class="string">@"game_info"</span>:<span class="string">@"一起来玩斗地主呀！"</span>,</div><div class="line">                                       <span class="string">@"game_icon"</span>:<span class="string">@"doudizhu"</span></div><div class="line">                                       &#125;;</div><div class="line">        <span class="comment">//将要刷新cell的indexPath</span></div><div class="line">        <span class="built_in">NSIndexPath</span> *indexPath = [<span class="built_in">NSIndexPath</span> indexPathForRow:<span class="number">1</span> inSection:<span class="number">3</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//获取cell对应的viewModel</span></div><div class="line">        SJStaticTableviewCellViewModel *viewModel = [<span class="keyword">self</span>.dataSource tableView:<span class="keyword">self</span>.tableView cellViewModelAtIndexPath:indexPath];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (viewModel) &#123;</div><div class="line">            <span class="comment">//更新viewModel</span></div><div class="line">            viewModel.leftTitle = responseDict[<span class="string">@"title_info"</span>];</div><div class="line">            viewModel.leftImage = [<span class="built_in">UIImage</span> imageNamed:responseDict[<span class="string">@"title_icon"</span>]];</div><div class="line">            viewModel.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:responseDict[<span class="string">@"game_icon"</span>]];</div><div class="line">            viewModel.indicatorLeftTitle = responseDict[<span class="string">@"game_info"</span>];</div><div class="line">            </div><div class="line">            <span class="comment">//刷新tableview</span></div><div class="line">            [<span class="keyword">self</span>.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationFade</span>];</div><div class="line">        &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2017/4/24/8906383a490f9507e37f9f122e2a4eee" alt="更新数据源后刷新表格"></p>
<h1 id="6-新增支持数据源完全依赖网络请求"><a href="#6-新增支持数据源完全依赖网络请求" class="headerlink" title="6. 新增支持数据源完全依赖网络请求"></a>6. 新增支持数据源完全依赖网络请求</h1><p>在1.2.0版本支持了：数据源完全依赖网络请求的情况。</p>
<p>现在的最新版本里，SJStaticViewController在创建的时候分为两种情况:</p>
<ol>
<li>SJDefaultDataTypeExist：在表格生成之前就存在数据，可以是表格的全部数据，也可以是表格的默认数据（后来通过网络请求来更新部分数据，参考上一节）。</li>
<li>SJDefaultDataTypeNone：意味着当前没有任何的默认数据可以使用，也就是无法生成tableview，需要在网络请求拿到数据后，再手动调用生成数据源，生成表格的方法。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableViewController.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> : <span class="built_in">NSUInteger</span> &#123;</div><div class="line">    </div><div class="line">    SJDefaultDataTypeExist,    <span class="comment">//在表格生成之前就有数据（1. 完全不依赖网络请求，有现成的完整数据 2. 先生成默认数据，然后通过网络请求来更新数据并刷新表格）</span></div><div class="line">    SJDefaultDataTypeNone,     <span class="comment">//无法生成默认数据，需要完全依赖网络请求，在拿到数据后，生成表格</span></div><div class="line">    </div><div class="line">&#125;SJDefaultDataType;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithDefaultDataType:(SJDefaultDataType)defualtDataType;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableViewController.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithDefaultDataType:(SJDefaultDataType)defualtDataType</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.defualtDataType = defualtDataType;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> initWithDefaultDataType:SJDefaultDataTypeExist];<span class="comment">//默认是SJDefaultDataTypeExist</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    [<span class="keyword">self</span> configureNav];</div><div class="line">    </div><div class="line">    <span class="comment">//在能够提供给tableivew全部，或者部分数据源的情况下，可以先构造出tableview；</span></div><div class="line">    <span class="comment">//否则，需要在网络请求结束后，手动调用configureTableView方法</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.defualtDataType == SJDefaultDataTypeExist) &#123;</div><div class="line">        [<span class="keyword">self</span> configureTableView];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//只有在SJDefaultDataTypeExist的时候才会自动调用，否则需要手动调用</span></div><div class="line">- (<span class="keyword">void</span>)configureTableView</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> createDataSource];<span class="comment">//生成数据源</span></div><div class="line">    [<span class="keyword">self</span> createTableView];<span class="comment">//生成表格</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一个例子，我们将表情页设置为<code>SJDefaultDataTypeNone</code>，那么就意味着我们需要手动调用<code>configureTableView</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">     <span class="keyword">self</span>.navigationItem.title = <span class="string">@"表情"</span>;</div><div class="line">    [<span class="keyword">self</span> networkRequest];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)networkRequest</div><div class="line">&#123;</div><div class="line">    [MBProgressHUD showHUDAddedTo: <span class="keyword">self</span>.view animated:<span class="literal">YES</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//模拟网络请求</span></div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1.5</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        [MBProgressHUD hideHUDForView: <span class="keyword">self</span>.view animated:<span class="literal">YES</span>];</div><div class="line">         <span class="keyword">self</span>.modelsArray = [Factory emoticonPage];<span class="comment">//网络请求后，将数据保存在self.modelsArray里面</span></div><div class="line">        [<span class="keyword">self</span> configureTableView];<span class="comment">//手动调用</span></div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)createDataSource</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.dataSource = [[SJStaticTableViewDataSource alloc] initWithViewModelsArray:<span class="keyword">self</span>.modelsArray configureBlock:^(SJStaticTableViewCell *cell, SJStaticTableviewCellViewModel *viewModel) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">switch</span> (viewModel.staticCellType) &#123;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessoryDisclosureIndicator:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessoryDisclosureIndicatorCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下效果图：<br><img src="https://user-gold-cdn.xitu.io/2017/4/24/dddb4eed3379c043133ba38d2d8ef1a4.png" alt=""><br>好了，到这里就讲差不多了，代码量虽然不多，但是都说清楚还是感觉挺需要时间想的。</p>
<p>希望如果各位觉得哪里不好，可以给出您的宝贵意见～</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;更新记录：&quot;&gt;&lt;a href=&quot;#更新记录：&quot; class=&quot;headerlink&quot; title=&quot;更新记录：&quot;&gt;&lt;/a&gt;更新记录：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;2017.4.23：新增支持数据源完全依赖网络请求的情况。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2017.4.22：新增支持请求新数据后刷新表格。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;2017.4.21： 新增CocoaPods支持：pod ‘SJStaticTableView’, ‘~&amp;gt; 1.2.0’。&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;写一个小小轮子～&lt;/p&gt;
&lt;p&gt;写UITableView的时候，我们经常遇到的是完全依赖于网络请求，需要自定义的动态cell的需求（比如微博帖子列表）。但是同时，大多数app里面几乎也都有设置页，个人页等其他以静态表格为主的页面。&lt;/p&gt;
&lt;p&gt;而且这些页面的共性比较多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大多数情况下在进入页面之前就已经拿到所有数据。&lt;/li&gt;
&lt;li&gt;cell样式单一，自定义cell出现的几率比较小（几乎都是高度为44的cell）。&lt;/li&gt;
&lt;li&gt;多数都分组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为自己非常想写一个开源的东西出来（也可以暴露自己的不足），同时又受限于水平，所以就打算写这么一个比较简单，又具有通用性的框架：&lt;strong&gt;一个定制性比较高的适合在个人页和设置页使用的UITableView&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在真正写之前，看了几篇类似的文章，挑出三篇自己觉得比较好的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.objc.io/issues/1-view-controllers/table-views/&quot;&gt;Clean Table View Code&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/504c61a9dc82&quot;&gt;如何写好一个UITableView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/81d0c573f7a8&quot;&gt;利用MVVM设计快速开发个人中心、设置等模块&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看完总结之后，利用上周3天的业余时间写好了这个框架，为了它实用性，我仿照了微信客户端的发现页，个人页和设置页写了一个Demo，来看一下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2017/4/24/85789de80b62c93ff0c9f77b603dba70&quot; alt=&quot;发现页 | 个人页 | 个人信息页 | 设置页&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目所用资源来自：&lt;a href=&quot;https://github.com/zhengwenming/WeChat&quot;&gt;GitHub:zhengwenming/WeChat&lt;/a&gt;&lt;br&gt;Demo地址：&lt;a href=&quot;https://github.com/knightsj/SJStaticTableView&quot;&gt;GitHub: knightsj/SJStaticTableView&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/03/14/%E5%85%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%8D%E6%98%AFiOS%E7%A8%8B%E5%BA%8F%E5%91%98%20%E2%80%94%20%E5%86%99%E7%BB%99%E5%B9%BF%E5%A4%A7%E9%9D%9E%E7%A7%91%E7%8F%ADiOS%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%80%E7%AF%87%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/03/14/先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结/</id>
    <published>2017-03-14T00:37:08.000Z</published>
    <updated>2017-03-20T07:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-10c56d4121bfe78d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Objective-C | Swift | C"></p>
<p>这篇面试总结很短，也没有面试题的答案，只是写给像我一样的非科班iOS开发者的一些话。</p>
<p>昨天进行了人生第一次视频面试，一共三个小时的技术面，还没见到人事，应该是挂了。</p>
<p>不过整个过程下来感触还是蛮多的，除了感受到面试官的牛X之外，也知道自己平时在学习中的不足。</p>
<h4 id="先介绍一下面试中觉得比较吃力的问题："><a href="#先介绍一下面试中觉得比较吃力的问题：" class="headerlink" title="先介绍一下面试中觉得比较吃力的问题："></a>先介绍一下面试中觉得比较吃力的问题：</h4><ol>
<li>如果让你实现属性的weak，如何实现的？</li>
<li>如果让你来实现属性的atomic，如何实现？</li>
<li>KVO为什么要创建一个子类来实现？</li>
<li>类结构体的组成，isa指针指向了什么？（这里应该将元类和根元类也说一下）</li>
<li>RunLoop有几种事件源？有几种模式？</li>
<li>方法列表的数据结构是什么？</li>
<li>分类是如何实现的？它为什么会覆盖掉原来的方法？</li>
</ol>
<p>另外值得一提的就是问了我自己写的博客里的东西（JSONModel的解析，EOC的笔记）等等。。</p>
<a id="more"></a>
<h4 id="这次面试让我深刻意识到了两点："><a href="#这次面试让我深刻意识到了两点：" class="headerlink" title="这次面试让我深刻意识到了两点："></a>这次面试让我深刻意识到了两点：</h4><ol>
<li>对于每个设计，不能只停留在“会用”而已，应该理解它的实现机制，而且几乎每个设计都是与数据结构息息相关的，理解了数据结构和指针会有助于理解这些设计。</li>
<li>了解设计的原理之后，还要知其所以然：为什么这么设计？最好还要知道这个设计存在什么缺陷，这个缺陷是哪个解决类似问题的设计所没有的？</li>
</ol>
<p>第一点是“how”的问题，第二点是“why”的问题，然而我相信有不少人只停留在“what”和“using”上。</p>
<p>在面试的时候，我强烈感受到了面试官的功力之深：给我的感觉，对他而言，几乎所有的设计都可以用某种数据结构解释出来（有的时候也会结合指针），对知识点理解得非常透彻：即便是很简单知识点，也能说出很多深层次的东西来。而我自己只是刚开始学数据结构不久，在面对提到数据结构的问题几乎是没有思路的。</p>
<h4 id="我想说的："><a href="#我想说的：" class="headerlink" title="我想说的："></a>我想说的：</h4><p>所以我觉得对于广大非科班的iOS开发来说，如果想在iOS开发上走远，就必须尽快补充数据结构，算法，指针等计算机基础知识，不然会对知识的理解形成很大的阻力。因为只有知道了这些基础知识，才能更深入得理解每一个技术点，而且以后如果学习其他的语言，也会更高效一些。</p>
<p>简单来说就一句话：先是程序员，然后才是iOS程序员。只有这样思考，路才能越走越宽，越走越快，越走越远。</p>
<p>现在iOS开发形势这么不好，市场要过滤掉那些计算机基础知识薄弱的人也是情有可原的。</p>
<blockquote>
<p>所谓的现在的“不好”，只是相对于之前“不正常的好”的不好。现在这个行业变得“不好”，其实是因为这个行业正在变得好，应该值得我们高兴才是。</p>
</blockquote>
<p>所以对于我们这群人（非科班的iOS开发者），应该提高忧患意识，未雨绸缪，更何况，雨已经来过了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0dc7553fc98a04f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-10c56d4121bfe78d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Objective-C | Swift | C&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇面试总结很短，也没有面试题的答案，只是写给像我一样的非科班iOS开发者的一些话。&lt;/p&gt;
&lt;p&gt;昨天进行了人生第一次视频面试，一共三个小时的技术面，还没见到人事，应该是挂了。&lt;/p&gt;
&lt;p&gt;不过整个过程下来感触还是蛮多的，除了感受到面试官的牛X之外，也知道自己平时在学习中的不足。&lt;/p&gt;
&lt;h4 id=&quot;先介绍一下面试中觉得比较吃力的问题：&quot;&gt;&lt;a href=&quot;#先介绍一下面试中觉得比较吃力的问题：&quot; class=&quot;headerlink&quot; title=&quot;先介绍一下面试中觉得比较吃力的问题：&quot;&gt;&lt;/a&gt;先介绍一下面试中觉得比较吃力的问题：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;如果让你实现属性的weak，如何实现的？&lt;/li&gt;
&lt;li&gt;如果让你来实现属性的atomic，如何实现？&lt;/li&gt;
&lt;li&gt;KVO为什么要创建一个子类来实现？&lt;/li&gt;
&lt;li&gt;类结构体的组成，isa指针指向了什么？（这里应该将元类和根元类也说一下）&lt;/li&gt;
&lt;li&gt;RunLoop有几种事件源？有几种模式？&lt;/li&gt;
&lt;li&gt;方法列表的数据结构是什么？&lt;/li&gt;
&lt;li&gt;分类是如何实现的？它为什么会覆盖掉原来的方法？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外值得一提的就是问了我自己写的博客里的东西（JSONModel的解析，EOC的笔记）等等。。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>JSONModel源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/22/JSONModel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/22/JSONModel源码解析/</id>
    <published>2017-02-22T01:16:56.000Z</published>
    <updated>2017-03-20T07:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列的<a href="http://www.jianshu.com/nb/9137726" target="_blank" rel="external">源码解析</a>分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。</p>
<p>想来想去，还是从<a href="https://github.com/jsonmodel/jsonmodel">JSONModel</a>开始吧～</p>
<p>首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。</p>
<p>该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。</p>
<a id="more"></a>
<p>在讲解源码之前，有必要先给不会使用JSONModel的同学们通过实际的例子来介绍一下它的使用方法（而且后面的源码解析部分也是结合这些例子给出的，因为结合例子有助于加快理解）：</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="1-最基本的使用"><a href="#1-最基本的使用" class="headerlink" title="1. 最基本的使用"></a>1. 最基本的使用</h2><p>第一种就是单纯地传入一个字典，并转换成模型：<br>首先我们需要定义我们自己的模型类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sex;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>然后再使用字典来转换为模型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                        <span class="string">@"gender"</span>:<span class="string">@"male"</span>,</div><div class="line">                      &#125;;</div><div class="line"> <span class="built_in">NSError</span> *error;</div><div class="line"> Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;Person&gt; </div><div class="line">   [name]: Jack</div><div class="line">   [sex]: male</div><div class="line">   [gender]: 23</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure></p>
<p>可以看出来，该框架的使用非常方便，一行代码就将模型转换好了。<br>但是该框架的功能远不止这些：</p>
<h2 id="2-转换属性名称"><a href="#2-转换属性名称" class="headerlink" title="2. 转换属性名称"></a>2. 转换属性名称</h2><p>有的时候，传入的字典里的key发生了变化（比如接口重构之类的原因），但是我们前端这边已经写好的模型属性可能不容易被修改（因为业务逻辑很复杂什么的），所以这个时候，最好有一个转化的功能。</p>
<p>在这里举个例子：原来字典里的<code>gender</code>这个key变成了<code>sex</code>，这就需要我们定义一个转换的mapper（<code>JSONKeyMapper</code>）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">+ (JSONKeyMapper *)keyMapper</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[JSONKeyMapper alloc] initWithModelToJSONDictionary:@&#123;</div><div class="line">                                                                  <span class="string">@"gender"</span>: <span class="string">@"sex"</span>,                                                             &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一来，<code>JSONKeyMapper</code>就会自动帮我们做转换。<br>为了验证效果，我们修改一下传入的字典里的<code>gender</code>字段为<code>sex</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                        <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</div><div class="line">                      &#125;;</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>再看一下输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Person&gt; </div><div class="line">   [name]: Jack</div><div class="line">   [age]: 23</div><div class="line">   [gender]: male</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure>
<p>没有受到传入字典里key值的变化的影响，是吧？</p>
<h2 id="3-自定义错误"><a href="#3-自定义错误" class="headerlink" title="3. 自定义错误"></a>3. 自定义错误</h2><p>除了一些框架里自己处理的错误（比如传入的对象不是字典等），框架的作者也允许我们自己定义属于我们自己的错误。</p>
<p>比如，当<code>age</code>对应的数值小于25的时候，打印出<code>Too young!</code>,并阻止模型的转换：</p>
<p>首先，我们在模型的实现文件里添加：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validate:(<span class="built_in">NSError</span> **)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">super</span> validate:error])</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.age &lt; <span class="number">25</span>)</div><div class="line">    &#123;</div><div class="line">        *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Too young!"</span> code:<span class="number">10</span> userInfo:<span class="literal">nil</span>];</div><div class="line">        <span class="built_in">NSError</span> *errorLog = *error;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,errorLog.domain);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] Too young!</div><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] (null)</div></pre></td></tr></table></figure></p>
<p>打印了错误，而且模型也没有被转换。</p>
<h2 id="4-模型嵌套"><a href="#4-模型嵌套" class="headerlink" title="4. 模型嵌套"></a>4. 模型嵌套</h2><p>有的时候，我们需要在模型里加一个数组，而这个数组里面的元素是另一个对象：这就涉及到了模型的嵌套。</p>
<p>举个例子，我们让上面的<code>Person</code>对象含有一个数组<code>Friends</code>，它里面的元素是对象<code>Friend</code>，也就是好友信息。若要实现模型的嵌套，我们只需在原来的模型类里增加一个协议<code>Friend</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"JSONModel.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Friend</span>;</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Friend</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;Friend&gt; *friends;<span class="comment">//数组，嵌套模型</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>而且要在<code>Person</code>的实现文件里加上这一段代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Friend</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意！如果不添加，则会令程序崩溃。</p>
<p>最后，在使用的时候，我们只需将持有一个数组的字典里传入即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[</div><div class="line">                      @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Peter"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">35</span>,</div><div class="line">                        &#125;,</div><div class="line">                   ];</div><div class="line">    </div><div class="line"> <span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                           <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                           <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                           <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</div><div class="line">                           <span class="string">@"friends"</span>:array,<span class="comment">//朋友列表（模型嵌套）</span></div><div class="line">                         &#125;;</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person);</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Person&gt; </div><div class="line">   [age]: 23</div><div class="line">   [gender]: male</div><div class="line">   [friends]: (</div><div class="line">       "&lt;Friend&gt; \n   [name]: Peter\n   [age]: 35\n&lt;/Friend&gt;"</div><div class="line">   )</div><div class="line">   [name]: Jack</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，person对象里含有一个数组，这个数组只有一个元素，对应着上面字典里的array里的信息。</p>
<p>OK，这样一来，大家已经可以掌握该框架的主要用法了，现在开始详细讲解代码：</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>本篇源码解析主要围绕着<code>initWithDictionary:error:</code>来展开，在这一个方法里作者做到了所有的容错和模型的转化。</p>
<p>按照老规矩，先上流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-94b356eeb7b560e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字典-&gt;模型"></p>
<p>该流程图对应的方法实现是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//方法1. 参数为nil</span></div><div class="line">    <span class="keyword">if</span> (!dict) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法2. 参数不是nil，但也不是字典</span></div><div class="line">    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法3. 初始化</span></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//初始化失败</span></div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO）</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span>.__keyMapper error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法5. 核心方法：字典的key与模型的属性的映射</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span>.__keyMapper validation:<span class="literal">YES</span> error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法7. 终于通过了！成功返回model</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>方法1-4:都是对错误的发现与处理。</li>
<li>方法5:是真正的mapping。</li>
<li>方法6:是作者给用户自己定义错误的方法，如果复合了用户自己定义的错误，那么即使mapping成功了，也要返回nil。<br>-方法7:成功返回模型对象。</li>
</ul>
<p>在讲解代码之前，有必要先了解一下JSONModel所持有的一些数据：</p>
<ul>
<li><p><strong>关联对象kClassPropertiesKey</strong>:(用来保存所有属性信息的NSDictionary)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       age = <span class="string">"@property primitive age (Setters = [])"</span>;</div><div class="line">      name = <span class="string">"@property NSString* name (Standard JSON type, Setters = [])"</span>;</div><div class="line">    gender = <span class="string">"@property NSString* gender (Standard JSON type, Setters = [])"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>关联对象kClassRequiredPropertyNamesKey</strong>：(用来保存所有属性的名称NSSet)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;(</div><div class="line">    name,</div><div class="line">    age,</div><div class="line">    gender</div><div class="line">)&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>关联对象kMapperObjectKey</strong>：(用来保存JSONKeyMapper)：自定义的mapper，具体的使用方法在上面的例子中可以看到。</p>
</li>
</ul>
<ul>
<li><strong>JSONModelClassProperty</strong>：封装的jsonmodel的一个属性，它包含了对应属性的名字（name：gender），类型（type：NSString），是否是JSONModel支持的类型（isStandardJSONType：YES/NO），是否是可变对象（isMutable:YES/NO）等属性。</li>
</ul>
<p>再大致讲解一下整个的流程：<br>首先，在这个模型类的对象被初始化的时候，遍历自身到所有的父类（直到JSONModel为止），获取所有的属性，并将其保存在一个字典里。获取传入字典的所有key，将这些key与保存的所有属性进行匹配。如果匹配成功，则进行kvc赋值。</p>
<p>OK，现在从上到下逐步讲解上段代码：</p>
<p>首先，在<code>load</code>方法里，定义了该框架支持的类型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;           </div><div class="line">            <span class="comment">//兼容的对象属性</span></div><div class="line">            allowedJSONTypes = @[</div><div class="line">                [<span class="built_in">NSString</span> <span class="keyword">class</span>], [<span class="built_in">NSNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSDecimalNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>], [<span class="built_in">NSDictionary</span> <span class="keyword">class</span>], [<span class="built_in">NSNull</span> <span class="keyword">class</span>], <span class="comment">//immutable JSON classes</span></div><div class="line">                [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>] <span class="comment">//mutable JSON classes</span></div><div class="line">            ];</div><div class="line">            <span class="comment">//兼容的基本类型属性</span></div><div class="line">            allowedPrimitiveTypes = @[</div><div class="line">                <span class="string">@"BOOL"</span>, <span class="string">@"float"</span>, <span class="string">@"int"</span>, <span class="string">@"long"</span>, <span class="string">@"double"</span>, <span class="string">@"short"</span>,</div><div class="line">                <span class="comment">//and some famous aliases</span></div><div class="line">                <span class="string">@"NSInteger"</span>, <span class="string">@"NSUInteger"</span>,</div><div class="line">                <span class="string">@"Block"</span></div><div class="line">            ];</div><div class="line">            <span class="comment">//转换器</span></div><div class="line">            valueTransformer = [[JSONValueTransformer alloc] init];</div><div class="line">            </div><div class="line">            <span class="comment">//自己的类型</span></div><div class="line">            JSONModelClass = <span class="built_in">NSClassFromString</span>(<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们看一下从方法3的init方法开始，作者都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> __setup__];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)__setup__</div><div class="line">&#123;</div><div class="line">    <span class="comment">//只有第一次实例化时，才执行</span></div><div class="line">    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kClassPropertiesKey)) &#123;</div><div class="line">        [<span class="keyword">self</span> __inspectProperties];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果存在自定义的mapper，则将它保存在关联对象里面，key是kMapperObjectKey</span></div><div class="line">    <span class="keyword">id</span> mapper = [[<span class="keyword">self</span> <span class="keyword">class</span>] keyMapper];</div><div class="line">    <span class="keyword">if</span> ( mapper &amp;&amp; !objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kMapperObjectKey) ) &#123;</div><div class="line">        objc_setAssociatedObject(</div><div class="line">                                 <span class="keyword">self</span>.class,</div><div class="line">                                 &amp;kMapperObjectKey,</div><div class="line">                                 mapper,</div><div class="line">                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></div><div class="line">                                 );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得注意的是，这里的<code>__inspectProperties:</code>方法是该框架的核心方法之一：它的任务是保存了所有需要赋值的属性。用作在将来与传进来字典进行映射：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)__inspectProperties</div><div class="line">&#123;</div><div class="line"><span class="comment">//    最终保存所有属性的字典，形式为：</span></div><div class="line"><span class="comment">//    &#123;</span></div><div class="line"><span class="comment">//        age = "@property primitive age (Setters = [])";</span></div><div class="line"><span class="comment">//        friends = "@property NSArray*&lt;Friend&gt; friends (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//        gender = "@property NSString* gender (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//        name = "@property NSString* name (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span>* propertyIndex = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    <span class="comment">//获取当前的类名</span></div><div class="line">    Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];    </div><div class="line">    <span class="built_in">NSScanner</span>* scanner = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSString</span>* propertyType = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 循环条件：当class 是 JSONModel自己的时候终止</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">class</span> != [JSONModel <span class="keyword">class</span>]) &#123;        </div><div class="line">        <span class="comment">//属性的个数</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</div><div class="line">        <span class="comment">//获得属性列表（所有@property声明的属性）</span></div><div class="line">        objc_property_t *properties = class_copyPropertyList(<span class="keyword">class</span>, &amp;propertyCount);</div><div class="line">        <span class="comment">//遍历所有的属性</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</div><div class="line">            <span class="comment">//获得属性名称</span></div><div class="line">            objc_property_t property = properties[i];<span class="comment">//获得当前的属性</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);<span class="comment">//name（C字符串）            </span></div><div class="line">            <span class="comment">//JSONModel里的每一个属性，都被封装成一个JSONModelClassProperty对象</span></div><div class="line">            JSONModelClassProperty* p = [[JSONModelClassProperty alloc] init];</div><div class="line">            p.name = @(propertyName);<span class="comment">//propertyName:属性名称，例如：name，age，gender</span></div><div class="line">            <span class="comment">//获得属性类型</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *attrs = property_getAttributes(property);</div><div class="line">            <span class="built_in">NSString</span>* propertyAttributes = @(attrs);</div><div class="line">            <span class="comment">// T@\"NSString\",C,N,V_name</span></div><div class="line">            <span class="comment">// Tq,N,V_age</span></div><div class="line">            <span class="comment">// T@\"NSString\",C,N,V_gender</span></div><div class="line">            <span class="comment">// T@"NSArray&lt;Friend&gt;",&amp;,N,V_friends            </span></div><div class="line">            <span class="built_in">NSArray</span>* attributeItems = [propertyAttributes componentsSeparatedByString:<span class="string">@","</span>];</div><div class="line">            <span class="comment">//说明是只读属性，不做任何操作</span></div><div class="line">            <span class="keyword">if</span> ([attributeItems containsObject:<span class="string">@"R"</span>]) &#123;</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">//to next property</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//检查出是布尔值</span></div><div class="line">            <span class="keyword">if</span> ([propertyAttributes hasPrefix:<span class="string">@"Tc,"</span>]) &#123;</div><div class="line">                p.structName = <span class="string">@"BOOL"</span>;<span class="comment">//使其变为结构体</span></div><div class="line">            &#125;            </div><div class="line">            <span class="comment">//实例化一个scanner</span></div><div class="line">            scanner = [<span class="built_in">NSScanner</span> scannerWithString: propertyAttributes];</div><div class="line">            [scanner scanUpToString:<span class="string">@"T"</span> intoString: <span class="literal">nil</span>];</div><div class="line">            [scanner scanString:<span class="string">@"T"</span> intoString:<span class="literal">nil</span>];</div><div class="line">            <span class="comment">//http://blog.csdn.net/kmyhy/article/details/8258858           </span></div><div class="line">            <span class="keyword">if</span> ([scanner scanString:<span class="string">@"@\""</span> intoString: &amp;propertyType]) &#123;                </div><div class="line">                 <span class="comment">//属性是一个对象</span></div><div class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@"\"&lt;"</span>]</div><div class="line">                                        intoString:&amp;propertyType];<span class="comment">//propertyType -&gt; NSString                </span></div><div class="line">                p.type = <span class="built_in">NSClassFromString</span>(propertyType);<span class="comment">// p.type = @"NSString"</span></div><div class="line">                p.isMutable = ([propertyType rangeOfString:<span class="string">@"Mutable"</span>].location != <span class="built_in">NSNotFound</span>); <span class="comment">//判断是否是可变的对象</span></div><div class="line">                p.isStandardJSONType = [allowedJSONTypes containsObject:p.type];<span class="comment">//是否是该框架兼容的类型</span></div><div class="line">                <span class="comment">//存在协议(数组，也就是嵌套模型)</span></div><div class="line">                <span class="keyword">while</span> ([scanner scanString:<span class="string">@"&lt;"</span> intoString:<span class="literal">NULL</span>]) &#123;</div><div class="line">                    <span class="built_in">NSString</span>* protocolName = <span class="literal">nil</span>;</div><div class="line">                    [scanner scanUpToString:<span class="string">@"&gt;"</span> intoString: &amp;protocolName];</div><div class="line">                    <span class="keyword">if</span> ([protocolName isEqualToString:<span class="string">@"Optional"</span>]) &#123;</div><div class="line">                        p.isOptional = <span class="literal">YES</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Index"</span>]) &#123;</div><div class="line"><span class="meta">#pragma GCC diagnostic push</span></div><div class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">                        p.isIndex = <span class="literal">YES</span>;</div><div class="line"><span class="meta">#pragma GCC diagnostic pop</span></div><div class="line">                        objc_setAssociatedObject(</div><div class="line">                                                 <span class="keyword">self</span>.class,</div><div class="line">                                                 &amp;kIndexPropertyNameKey,</div><div class="line">                                                 p.name,</div><div class="line">                                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></div><div class="line">                                                 );</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Ignore"</span>]) &#123;</div><div class="line">                        p = <span class="literal">nil</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        p.protocol = protocolName;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//到最接近的&gt;为止</span></div><div class="line">                    [scanner scanString:<span class="string">@"&gt;"</span> intoString:<span class="literal">NULL</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;            </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ([scanner scanString:<span class="string">@"&#123;"</span> intoString: &amp;propertyType])                </div><div class="line">                <span class="comment">//属性是结构体</span></div><div class="line">                [scanner scanCharactersFromSet:[<span class="built_in">NSCharacterSet</span> alphanumericCharacterSet]</div><div class="line">                                    intoString:&amp;propertyType];</div><div class="line">                p.isStandardJSONType = <span class="literal">NO</span>;</div><div class="line">                p.structName = propertyType;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//属性是基本类型：Tq,N,V_age</span></div><div class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@","</span>]</div><div class="line">                                        intoString:&amp;propertyType];</div><div class="line">                <span class="comment">//propertyType:q</span></div><div class="line">                propertyType = valueTransformer.primitivesNames[propertyType];              </div><div class="line">                <span class="comment">//propertyType:long</span></div><div class="line">                <span class="comment">//基本类型数组</span></div><div class="line">                <span class="keyword">if</span> (![allowedPrimitiveTypes containsObject:propertyType]) &#123;</div><div class="line">                    <span class="comment">//类型不支持</span></div><div class="line">                    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"JSONModelProperty type not allowed"</span></div><div class="line">                                                   reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Property type of %@.%@ is not supported by JSONModel."</span>, <span class="keyword">self</span>.class, p.name]</div><div class="line">                                                 userInfo:<span class="literal">nil</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSString</span> *nsPropertyName = @(propertyName);            </div><div class="line">            <span class="comment">//可选的</span></div><div class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsOptional:nsPropertyName])&#123;</div><div class="line">                p.isOptional = <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//可忽略的</span></div><div class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsIgnored:nsPropertyName])&#123;</div><div class="line">                p = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//集合类</span></div><div class="line">            Class customClass = [[<span class="keyword">self</span> <span class="keyword">class</span>] classForCollectionProperty:nsPropertyName];            </div><div class="line">            <span class="keyword">if</span> (customClass) &#123;</div><div class="line">                p.protocol = <span class="built_in">NSStringFromClass</span>(customClass);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//忽略block</span></div><div class="line">            <span class="keyword">if</span> ([propertyType isEqualToString:<span class="string">@"Block"</span>]) &#123;</div><div class="line">                p = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果字典里不存在，则添加到属性字典里（终于添加上去了。。。）</span></div><div class="line">            <span class="keyword">if</span> (p &amp;&amp; ![propertyIndex objectForKey:p.name]) &#123;</div><div class="line">                [propertyIndex setValue:p forKey:p.name];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//setter 和 getter</span></div><div class="line">            <span class="keyword">if</span> (p)</div><div class="line">            &#123;   <span class="comment">//name -&gt;Name</span></div><div class="line">                <span class="built_in">NSString</span> *name = [p.name stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:[p.name substringToIndex:<span class="number">1</span>].uppercaseString];</div><div class="line">                <span class="comment">// getter</span></div><div class="line">                SEL <span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"JSONObjectFor%@"</span>, name]);</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>])</div><div class="line">                    p.customGetter = <span class="keyword">getter</span>;</div><div class="line">                <span class="comment">// setters</span></div><div class="line">                p.customSetters = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">                SEL genericSetter = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@WithJSONObject:"</span>, name]);</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:genericSetter])</div><div class="line">                    p.customSetters[<span class="string">@"generic"</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;genericSetter objCType:<span class="keyword">@encode</span>(SEL)];</div><div class="line">                <span class="keyword">for</span> (Class type <span class="keyword">in</span> allowedJSONTypes)</div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">NSString</span> *<span class="keyword">class</span> = <span class="built_in">NSStringFromClass</span>([JSONValueTransformer classByResolvingClusterClasses:type]);</div><div class="line">                    <span class="keyword">if</span> (p.customSetters[<span class="keyword">class</span>])</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    SEL <span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@With%@:"</span>, name, <span class="keyword">class</span>]);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">setter</span>])</div><div class="line">                        p.customSetters[<span class="keyword">class</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;<span class="keyword">setter</span> objCType:<span class="keyword">@encode</span>(SEL)];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        free(properties);</div><div class="line">        <span class="comment">//再指向自己的父类，知道等于JSONModel才停止</span></div><div class="line">        <span class="keyword">class</span> = [<span class="keyword">class</span> superclass];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//最后保存所有当前类，JSONModel的所有的父类的属性</span></div><div class="line">    objc_setAssociatedObject(</div><div class="line">                             <span class="keyword">self</span>.class,</div><div class="line">                             &amp;kClassPropertiesKey,</div><div class="line">                             [propertyIndex <span class="keyword">copy</span>],</div><div class="line">                             OBJC_ASSOCIATION_RETAIN</div><div class="line">                             );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意几点：</p>
<ol>
<li>作者利用一个<code>while</code>函数，获取当前类和当前类的除JSONModel的所有父类的属性保存在一个字典中。在将来用于和传入的字典进行映射。</li>
<li>作者用<code>JSONModelClassProperty</code>类封装了JSONModel的每一个属性。这个类有两个重要的属性：一个是<code>name</code>，它是属性的名称(例如gender)。另一个是<code>type</code>，它是属性的类型（例如NSString）。</li>
<li>作者将属性分为了如下几个类型：<ol>
<li>对象（不含有协议）。</li>
<li>对象（含有协议，属于模型嵌套）。</li>
<li>基本数据类型。</li>
<li>结构体。</li>
</ol>
</li>
</ol>
</blockquote>
<p>我们来看一下方法4的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)__doesDictionary:(<span class="built_in">NSDictionary</span>*)dict matchModelWithKeyMapper:(JSONKeyMapper*)keyMapper error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//拿到字典里所有的key</span></div><div class="line">    <span class="built_in">NSArray</span>* incomingKeysArray = [dict allKeys];    </div><div class="line">    <span class="comment">//返回保存所有属性名称的数组(name,age,gender...)</span></div><div class="line">    <span class="built_in">NSMutableSet</span>* requiredProperties = [<span class="keyword">self</span> __requiredPropertyNames].mutableCopy;    </div><div class="line">    <span class="comment">//从array拿到set</span></div><div class="line">    <span class="built_in">NSSet</span>* incomingKeys = [<span class="built_in">NSSet</span> setWithArray: incomingKeysArray];</div><div class="line">    <span class="comment">//如果用户自定义了mapper，则进行转换</span></div><div class="line">    <span class="keyword">if</span> (keyMapper || globalKeyMapper) &#123;</div><div class="line">        <span class="built_in">NSMutableSet</span>* transformedIncomingKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity: requiredProperties.count];</div><div class="line">        <span class="built_in">NSString</span>* transformedName = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//便利需要转换的属性列表</span></div><div class="line">        <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</div><div class="line">            <span class="comment">//被转换成的属性名称 gender（模型内） -&gt; sex（字典内）</span></div><div class="line">            transformedName = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</div><div class="line">            <span class="comment">//拿到sex以后，查看传入的字典里是否有sex对应的值</span></div><div class="line">            <span class="keyword">id</span> value;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                value = [dict valueForKeyPath:transformedName];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                value = dict[transformedName];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果值存在，则将sex添加到传入的keys数组中</span></div><div class="line">            <span class="keyword">if</span> (value) &#123;</div><div class="line">                [transformedIncomingKeys addObject: property.name];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        incomingKeys = transformedIncomingKeys;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//查看当前的model的属性的集合是否大于传入的属性集合，如果是，则返回错误。</span></div><div class="line">    <span class="comment">//也就是说模型类里的属性是不能多于传入字典里的key的，例如：</span></div><div class="line">    <span class="keyword">if</span> (![requiredProperties isSubsetOfSet:incomingKeys]) &#123;</div><div class="line">        <span class="comment">//获取多出来的属性</span></div><div class="line">        [requiredProperties minusSet:incomingKeys];</div><div class="line">        <span class="comment">//not all required properties are in - invalid input</span></div><div class="line">        JMLog(<span class="string">@"Incoming data was invalid [%@ initWithDictionary:]. Keys missing: %@"</span>, <span class="keyword">self</span>.class, requiredProperties);</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMissingKeys:requiredProperties];</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不需要了，释放掉</span></div><div class="line">    incomingKeys= <span class="literal">nil</span>;</div><div class="line">    requiredProperties= <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里需要需要注意的：</p>
<ol>
<li>model类里面定义的属性集合是不能大于传入的字典里的key集合的。</li>
<li>如果存在了用户自定义的mapper，则需要按照用户的定义来进行转换。<br>（在这里是奖gender转换为了sex）。</li>
</ol>
</blockquote>
<p>最后来看一下本框架第二个核心代码(上面的方法5)，也就是真正从字典里获取值并赋给当前模型对象的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)__importDictionary:(<span class="built_in">NSDictionary</span>*)dict withKeyMapper:(JSONKeyMapper*)keyMapper validation:(<span class="built_in">BOOL</span>)validation error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//遍历保存的所有属性的字典</span></div><div class="line">    <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</div><div class="line">        <span class="comment">//将属性的名称拿过来，作为key，用这个key来查找传进来的字典里对应的值</span></div><div class="line">        <span class="built_in">NSString</span>* jsonKeyPath = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</div><div class="line">        <span class="comment">//用来保存从字典里获取的值</span></div><div class="line">        <span class="keyword">id</span> jsonValue;        </div><div class="line">        <span class="keyword">@try</span> &#123;</div><div class="line">            jsonValue = [dict valueForKeyPath: jsonKeyPath];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">            jsonValue = dict[jsonKeyPath];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//字典不存在对应的key</span></div><div class="line">        <span class="keyword">if</span> (isNull(jsonValue)) &#123;</div><div class="line">            <span class="comment">//如果这个key是可以不存在的</span></div><div class="line">            <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;            </div><div class="line">            <span class="comment">//如果这个key是必须有的，则返回错误</span></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Value of required model key %@ is null"</span>, property.name];</div><div class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//获取 取到的值的类型</span></div><div class="line">        Class jsonValueClass = [jsonValue <span class="keyword">class</span>];</div><div class="line">        <span class="built_in">BOOL</span> isValueOfAllowedType = <span class="literal">NO</span>;</div><div class="line">        <span class="comment">//查看是否是本框架兼容的属性类型</span></div><div class="line">        <span class="keyword">for</span> (Class allowedType <span class="keyword">in</span> allowedJSONTypes) &#123;</div><div class="line">            <span class="keyword">if</span> ( [jsonValueClass isSubclassOfClass: allowedType] ) &#123;</div><div class="line">                isValueOfAllowedType = <span class="literal">YES</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//如果不兼容，则返回NO，mapping失败</span></div><div class="line">        <span class="keyword">if</span> (isValueOfAllowedType==<span class="literal">NO</span>) &#123;</div><div class="line">            <span class="comment">//type not allowed</span></div><div class="line">            JMLog(<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass));</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass)];</div><div class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是兼容的类型：</span></div><div class="line">        <span class="keyword">if</span> (property) &#123;</div><div class="line">            <span class="comment">// 查看是否有自定义setter，并设置</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __customSetValue:jsonValue forProperty:property]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 基本类型</span></div><div class="line">            <span class="keyword">if</span> (property.type == <span class="literal">nil</span> &amp;&amp; property.structName==<span class="literal">nil</span>) &#123;</div><div class="line">                <span class="comment">//kvc赋值</span></div><div class="line">                <span class="keyword">if</span> (jsonValue != [<span class="keyword">self</span> valueForKey:property.name]) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果传来的值是空，即使当前的属性对应的值不是空，也要将空值赋给它</span></div><div class="line">            <span class="keyword">if</span> (isNull(jsonValue)) &#123;</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> valueForKey:property.name] != <span class="literal">nil</span>) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:<span class="literal">nil</span> forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 1. 属性本身是否是jsonmodel类型</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __isJSONModelSubClass:property.type]) &#123;</div><div class="line">                <span class="comment">//通过自身的转模型方法，获取对应的值</span></div><div class="line">                JSONModelError* initErr = <span class="literal">nil</span>;</div><div class="line">                <span class="keyword">id</span> value = [[property.type alloc] initWithDictionary: jsonValue error:&amp;initErr];</div><div class="line">                <span class="keyword">if</span> (!value) &#123;               </div><div class="line">                    <span class="comment">//如果该属性不是必须的，则略过</span></div><div class="line">                    <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;</div><div class="line">                    <span class="comment">//如果该属性是必须的，则返回错误</span></div><div class="line">                    <span class="keyword">if</span>((err != <span class="literal">nil</span>) &amp;&amp; (initErr != <span class="literal">nil</span>))</div><div class="line">                    &#123;</div><div class="line">                        *err = [initErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;            </div><div class="line">                <span class="comment">//当前的属性值为空，则赋值</span></div><div class="line">                <span class="keyword">if</span> (![value isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:value forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果不是jsonmodel的类型，则可能是一些普通的类型：NSArray，NSString。。。</span></div><div class="line">                <span class="comment">// 是否是模型嵌套（带有协议）</span></div><div class="line">                <span class="keyword">if</span> (property.protocol) &#123;</div><div class="line">                    <span class="comment">//转化为数组，这个数组就是例子中的friends属性。</span></div><div class="line">                    jsonValue = [<span class="keyword">self</span> __transform:jsonValue forProperty:property error:err];</div><div class="line">                   </div><div class="line">                    <span class="keyword">if</span> (!jsonValue) &#123;</div><div class="line">                        <span class="keyword">if</span> ((err != <span class="literal">nil</span>) &amp;&amp; (*err == <span class="literal">nil</span>)) &#123;</div><div class="line">                            <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Failed to transform value, but no error was set during transformation. (%@)"</span>, property];</div><div class="line">                            JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                            *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 对象类型</span></div><div class="line">                <span class="keyword">if</span> (property.isStandardJSONType &amp;&amp; [jsonValue isKindOfClass: property.type]) &#123;</div><div class="line">                    <span class="comment">//可变类型</span></div><div class="line">                    <span class="keyword">if</span> (property.isMutable) &#123;</div><div class="line">                        jsonValue = [jsonValue mutableCopy];</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//赋值</span></div><div class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</div><div class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 当前的值的类型与对应的属性的类型不一样的时候，需要查看用户是否自定义了转换器（例如从NSSet到NSArray转换：- (NSSet *)NSSetFromNSArray:(NSArray *)array）</span></div><div class="line">                <span class="keyword">if</span> (</div><div class="line">                    (![jsonValue isKindOfClass:property.type] &amp;&amp; !isNull(jsonValue))</div><div class="line">                    ||</div><div class="line">                    <span class="comment">//the property is mutable</span></div><div class="line">                    property.isMutable</div><div class="line">                    ||</div><div class="line">                    <span class="comment">//custom struct property</span></div><div class="line">                    property.structName</div><div class="line">                    ) &#123;</div><div class="line">                    <span class="comment">// searched around the web how to do this better</span></div><div class="line">                    <span class="comment">// but did not find any solution, maybe that's the best idea? (hardly)</span></div><div class="line">                    Class sourceClass = [JSONValueTransformer classByResolvingClusterClasses:[jsonValue <span class="keyword">class</span>]];</div><div class="line">                    <span class="comment">//JMLog(@"to type: [%@] from type: [%@] transformer: [%@]", p.type, sourceClass, selectorName);</span></div><div class="line"></div><div class="line">                    <span class="comment">//build a method selector for the property and json object classes</span></div><div class="line">                    <span class="built_in">NSString</span>* selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@From%@:"</span>,</div><div class="line">                                              (property.structName? property.structName : property.type), <span class="comment">//target name</span></div><div class="line">                                              sourceClass]; <span class="comment">//source name</span></div><div class="line">                    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line">                    <span class="comment">//查看自定义的转换器是否存在</span></div><div class="line">                    <span class="built_in">BOOL</span> foundCustomTransformer = <span class="literal">NO</span>;</div><div class="line">                    <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</div><div class="line">                        foundCustomTransformer = <span class="literal">YES</span>;                        </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//try for hidden custom transformer</span></div><div class="line">                        selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"__%@"</span>,selectorName];</div><div class="line">                        selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line">                        <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</div><div class="line">                            foundCustomTransformer = <span class="literal">YES</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//如果存在自定义转换器，则进行转换</span></div><div class="line">                    <span class="keyword">if</span> (foundCustomTransformer) &#123;                        </div><div class="line">                        IMP imp = [valueTransformer methodForSelector:selector];</div><div class="line">                        <span class="keyword">id</span> (*func)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)imp;</div><div class="line">                        jsonValue = func(valueTransformer, selector, jsonValue);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">                            [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];                        </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;                       </div><div class="line">                        <span class="comment">//没有自定义转换器，返回错误</span></div><div class="line">                        <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ type not supported for %@.%@"</span>, property.type, [<span class="keyword">self</span> <span class="keyword">class</span>], property.name];</div><div class="line">                        JSONModelError* dataErr = [JSONModelError errorInvalidDataWithTypeMismatch:msg];</div><div class="line">                        *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;                        </div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 3.4) handle "all other" cases (if any)</span></div><div class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是：</p>
<ul>
<li>作者在最后给属性赋值的时候使用的是kvc的<code>setValue:ForKey:</code>的方法。</li>
<li>作者判断了模型里的属性的类型是否是JSONModel的子类，可见作者的考虑是非常周全的。</li>
<li>整个框架看下来，有很多的地方涉及到了错误判断，作者将将错误类型单独抽出一个类（<code>JSONModelError</code>），里面支持的错误类型很多，可以侧面反应作者思维之缜密。而且这个做法也可以在我们写自己的框架或者项目中使用。</li>
</ul>
</blockquote>
<p>错误判断的一个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JSONModelError.m</span></div><div class="line">+(<span class="keyword">id</span>)errorInvalidDataWithMessage:(<span class="built_in">NSString</span>*)message</div><div class="line">&#123;</div><div class="line">    message = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Invalid JSON data: %@"</span>, message];</div><div class="line">    <span class="keyword">return</span> [JSONModelError errorWithDomain:JSONModelErrorDomain</div><div class="line">                                      code:kJSONModelErrorInvalidData</div><div class="line">                                  userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:message&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>夸了作者这么多，唯一我个人不太喜欢的地方就是if语句下只有一行的时候，作者不喜欢加上大括号：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">    [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div></pre></td></tr></table></figure></p>
<p>但是我觉得应该加的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])&#123;</div><div class="line">  [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ul>
<li>作者用NSScanner来扫描字符串，将从类结构体里拿过来的属性的描述字符串<code>T@\&quot;NSString\&quot;,C,N,V_name</code>中扫描出了类型：<code>NSString</code>。</li>
<li>作者两次用到了NSSet：当集合里的元素顺序不重要的时候，优先考虑用NSSet。</li>
</ul>
<p>总的来说这个框架的难度还是不大的，但可能因为是第一次阅读不涉及UIVIiew的框架，感觉有些枯燥，不过慢慢习惯就好啦～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列的&lt;a href=&quot;http://www.jianshu.com/nb/9137726&quot;&gt;源码解析&lt;/a&gt;分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。&lt;/p&gt;
&lt;p&gt;想来想去，还是从&lt;a href=&quot;https://github.com/jsonmodel/jsonmodel&quot;&gt;JSONModel&lt;/a&gt;开始吧～&lt;/p&gt;
&lt;p&gt;首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。&lt;/p&gt;
&lt;p&gt;该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>VVeboTableView源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/14/VVeboTableView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/14/VVeboTableView源码解析/</id>
    <published>2017-02-14T02:57:30.000Z</published>
    <updated>2017-03-20T07:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次分享一个关于性能优化的源码。</p>
<p>我们知道<code>UITabelView</code>在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，<code>UITabelView</code>的性能将直接影响这个app的性能。</p>
<p>如果<code>UITabelView</code>里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。</p>
<p>但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。</p>
<p>最近在看一些iOS性能优化的文章，我找到了<a href="https://github.com/johnil/VVeboTableViewDemo">VVeboTableView</a>这个框架。严格来说这个不属于框架，而是作者用自己的方式优化<code>UITableView</code>的一个实现。</p>
<p>作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？</p>
<p>看了源码之后，我把作者的思路整理了出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png" alt="优化思路图"></p>
<p>下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。</p>
<a id="more"></a>
<h2 id="1-减少CPU／GPU计算量"><a href="#1-减少CPU／GPU计算量" class="headerlink" title="1. 减少CPU／GPU计算量"></a>1. 减少CPU／GPU计算量</h2><h3 id="1-1-cell的重用机制"><a href="#1-1-cell的重用机制" class="headerlink" title="1.1 cell的重用机制"></a>1.1 cell的重用机制</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//cell重用</span></div><div class="line">    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cell==<span class="literal">nil</span>) &#123;</div><div class="line">        cell = [[VVeboTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:<span class="string">@"cell"</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制</span></div><div class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分就不赘述了，相信大家都可以掌握。</p>
<h3 id="1-2-将cell高度和-cell里的控件的frame缓存在model里"><a href="#1-2-将cell高度和-cell里的控件的frame缓存在model里" class="headerlink" title="1.2 将cell高度和 cell里的控件的frame缓存在model里"></a>1.2 将cell高度和 cell里的控件的frame缓存在model里</h3><p>这一步我们需要在字典转模型里统一计算(不需要看代码细节，只需要知道这里在模型里保存了需要保存的控件的frame和整个cell的高度即可)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadData&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> temp) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *user = dict[<span class="string">@"user"</span>];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *retweet = [dict valueForKey:<span class="string">@"retweeted_status"</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (retweet) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">            ...</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</div><div class="line">                <span class="built_in">CGSize</span> size = [subData[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_SUBCONTENT) lineSpace:<span class="number">5</span>];</div><div class="line">                <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</div><div class="line">                subData[<span class="string">@"textRect"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_BIG, width, sizeHeight)];</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                <span class="keyword">if</span> (subData[<span class="string">@"pic_urls"</span>] &amp;&amp; [subData[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</div><div class="line">                    sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</div><div class="line">                &#125;</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                subData[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            data[<span class="string">@"subData"</span>] = subData;</div><div class="line">           </div><div class="line">        </div><div class="line">            <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</div><div class="line">            <span class="built_in">CGSize</span> size = [data[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_CONTENT) lineSpace:<span class="number">5</span>];</div><div class="line">            <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</div><div class="line">            ...</div><div class="line">            sizeHeight += SIZE_GAP_TOP+SIZE_AVATAR+SIZE_GAP_BIG;</div><div class="line">            <span class="keyword">if</span> (data[<span class="string">@"pic_urls"</span>] &amp;&amp; [data[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</div><div class="line">                sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [data valueForKey:<span class="string">@"subData"</span>];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (subData) &#123;</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                <span class="built_in">CGRect</span> frame = [subData[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">                ...</div><div class="line">                sizeHeight += frame.size.height;</div><div class="line">                data[<span class="string">@"subData"</span>] = subData;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            sizeHeight += <span class="number">30</span>;</div><div class="line">            data[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</div><div class="line">        &#125;</div><div class="line">        [datas addObject:data];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取高度缓存</span></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *dict = datas[indexPath.row];</div><div class="line">    <span class="keyword">float</span> height = [dict[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>].size.height;</div><div class="line">    <span class="keyword">return</span> height;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到，作者根据帖子类型的不同：原贴(subData)的存在与否），来逐渐叠加cell的高度。</p>
<p>而缓存的控件的frame，我们在下面讲解绘制cell的代码里详细介绍。</p>
<h3 id="1-3-减少cell内部控件的层级"><a href="#1-3-减少cell内部控件的层级" class="headerlink" title="1.3 减少cell内部控件的层级"></a>1.3 减少cell内部控件的层级</h3><p>我们先来看一下一个带有原贴的转发贴的布局：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_3.png" alt="布局"></p>
<p>可能有小伙伴会将上中下这三个部分各自封装成一个view，再通过每个view来管理各自的子view。但是这个框架的作者却将它们都排列到一层上。</p>
<p>减少了子view的层级，有助于减少cpu对各种约束的计算。这在子view的数量，层级都很多的情况下对cpu的压力会减轻很多。</p>
<h3 id="1-4-通过覆盖圆角图片来实现头像的圆角效果"><a href="#1-4-通过覆盖圆角图片来实现头像的圆角效果" class="headerlink" title="1.4 通过覆盖圆角图片来实现头像的圆角效果"></a>1.4 通过覆盖圆角图片来实现头像的圆角效果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头像，frame固定</span></div><div class="line">avatarView = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];<span class="comment">//[[VVeboAvatarView alloc] initWithFrame:avatarRect];</span></div><div class="line">avatarView.frame = <span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_TOP, SIZE_AVATAR, SIZE_AVATAR);</div><div class="line">avatarView.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</div><div class="line">avatarView.hidden = <span class="literal">NO</span>;</div><div class="line">avatarView.tag = <span class="built_in">NSIntegerMax</span>;</div><div class="line">avatarView.clipsToBounds = <span class="literal">YES</span>;</div><div class="line">[<span class="keyword">self</span>.contentView addSubview:avatarView];</div><div class="line"><span class="comment">//覆盖在头像上面的图片，制造圆角效果：frame</span></div><div class="line">cornerImage = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, SIZE_AVATAR+<span class="number">5</span>, SIZE_AVATAR+<span class="number">5</span>)];</div><div class="line">cornerImage.center = avatarView.center;</div><div class="line">cornerImage.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"corner_circle@2x.png"</span>];</div><div class="line">cornerImage.tag = <span class="built_in">NSIntegerMax</span>;</div><div class="line">[<span class="keyword">self</span>.contentView addSubview:cornerImage];</div></pre></td></tr></table></figure>
<p>在这里，作者没有使用任何复杂的技术来实现图片的圆角（使用layer或者裁剪图片），只是将一张圆角颜色和cell背景色一致的图片覆盖在了原来的头像上，实现了圆角的效果（但是这个方法不太适用于有多个配色方案的app）。</p>
<h2 id="2-按需加载cell"><a href="#2-按需加载cell" class="headerlink" title="2. 按需加载cell"></a>2. 按需加载cell</h2><p>上文提到过，<code>UITableView</code>持有一个<code>needLoadArr</code>数组，它保存着需要刷新的cell的<code>NSIndexPath</code>。</p>
<p>我们先来看一下<code>needLoadArr</code>是如何使用的：</p>
<h3 id="2-1-在cellForRow-方法里只加载可见cell"><a href="#2-1-在cellForRow-方法里只加载可见cell" class="headerlink" title="2.1 在cellForRow:方法里只加载可见cell"></a>2.1 在cellForRow:方法里只加载可见cell</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    ...</div><div class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)drawCell:(VVeboTableViewCell *)cell withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSDictionary</span> *data = [datas objectAtIndex:indexPath.row];    </div><div class="line">    ...</div><div class="line">    cell.data = data;</div><div class="line">    <span class="comment">//当前的cell的indexPath不在needLoadArr里面，不用绘制</span></div><div class="line">    <span class="keyword">if</span> (needLoadArr.count&gt;<span class="number">0</span>&amp;&amp;[needLoadArr indexOfObject:indexPath]==<span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        [cell clear];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//将要滚动到顶部，不绘制</span></div><div class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//真正绘制cell的代码</span></div><div class="line">    [cell draw];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"><a href="#2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引" class="headerlink" title="2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"></a>2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引</h3><p>知道了如何使用<code>needLoadArr</code>，我们看一下<code>needLoadArr</code>里面的元素师如何添加和删除。</p>
<h4 id="添加元素NSIndexPath"><a href="#添加元素NSIndexPath" class="headerlink" title="添加元素NSIndexPath"></a>添加元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//targetContentOffset ： 停止后的contentOffset</span></div><div class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</div><div class="line">    </div><div class="line">    <span class="comment">//当前可见第一行row的index</span></div><div class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</div><div class="line">    </div><div class="line">    <span class="comment">//设置最小跨度，当滑动的速度很快，超过这个跨度时候执行按需加载</span></div><div class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//快速滑动(跨度超过了8个cell)</span></div><div class="line">    <span class="keyword">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//某个区域里的单元格的indexPath</span></div><div class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</div><div class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (velocity.y&lt;<span class="number">0</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//向上滚动</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</div><div class="line">            </div><div class="line">            <span class="comment">//超过倒数第3个</span></div><div class="line">            <span class="keyword">if</span> (indexPath.row+<span class="number">3</span>&lt;datas.count) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">1</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">3</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//向下滚动</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp firstObject];</div><div class="line">            <span class="comment">//超过正数第3个</span></div><div class="line">            <span class="keyword">if</span> (indexPath.row&gt;<span class="number">3</span>) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//添加arr里的内容到needLoadArr的末尾</span></div><div class="line">        [needLoadArr addObjectsFromArray:arr];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道了如何向<code>needLoadArr</code>里添加元素，现在看一下何时（重置）清理这个array：</p>
<h4 id="移除元素NSIndexPath"><a href="#移除元素NSIndexPath" class="headerlink" title="移除元素NSIndexPath"></a>移除元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用户触摸时第一时间加载内容</span></div><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!scrollToToping) &#123;</div><div class="line">        [needLoadArr removeAllObjects];</div><div class="line">        [<span class="keyword">self</span> loadContent];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    [needLoadArr removeAllObjects];</div><div class="line">&#125;</div><div class="line"><span class="comment">//将要滚动到顶部</span></div><div class="line">- (<span class="built_in">BOOL</span>)scrollViewShouldScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//停止滚动</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> loadContent];</div><div class="line">&#125;</div><div class="line"><span class="comment">//滚动到了顶部</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewDidScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> loadContent];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，当手指触碰到tableview时 和 开始拖动tableview的时候就要清理这个数组。</p>
<p>而且在手指触碰到tableview时和 tableview停止滚动后就会执行<code>loadContent</code>方法，用来加载可见区域的cell。</p>
<p><code>loadContent</code>方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadContent&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//正在滚动到顶部</span></div><div class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//可见cell数</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.indexPathsForVisibleRows.count&lt;=<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//触摸的时候刷新可见cell</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.visibleCells&amp;&amp;<span class="keyword">self</span>.visibleCells.count&gt;<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> temp <span class="keyword">in</span> [<span class="keyword">self</span>.visibleCells <span class="keyword">copy</span>]) &#123;</div><div class="line">            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;</div><div class="line">            [cell draw];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里注意一下，tableview的<code>visibleCells</code>属性是可见的cell的数组。</p>
<h2 id="3-异步处理cell"><a href="#3-异步处理cell" class="headerlink" title="3. 异步处理cell"></a>3. 异步处理cell</h2><p>在讲解cell是如何显示出来之前，我们大致看一下这个cell都有哪些控件：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_4.png" alt="控件名称"></p>
<p>了解到控件的名称，位置之后，我们看一下作者是如何布局这些控件的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_2.png" alt="控件布局"><br>在上面可以大致看出来，除了需要异步网络加载的头像(avatarView)和帖子图片(multiPhotoScrollView)，作者都将这些控件画在了一张图上面（postBgView）。</p>
<p>而且我们可以看到，在postBgView上面需要异步显示的内容分为四种：</p>
<ol>
<li>UIImageView：本地图片（comments, more,reposts）。</li>
<li>UIView：背景，分割线(topLine)。</li>
<li>NSString：name，from字符串。</li>
<li>Label：原贴的detailLabel 和 当前贴的 label。</li>
</ol>
<p>下面结合代码来讲解这四种绘制：</p>
<p>首先看一下cell内部的核心绘制方法：</p>
<p>现在我们来看一下cell绘制的核心方法,draw方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将cell的主要内容绘制到图片上</span></div><div class="line">- (<span class="keyword">void</span>)draw&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//drawed = YES说明正在绘制，则立即返回。因为绘制是异步的，所以在开始绘制之后需要立即设为yes，防止重复绘制</span></div><div class="line">    <span class="keyword">if</span> (drawed) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//标记当前的绘制</span></div><div class="line">    <span class="built_in">NSInteger</span> flag = drawColorFlag;</div><div class="line">    </div><div class="line">    drawed = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//获取整个cell的frame，已经换存在模型里了</span></div><div class="line">        <span class="built_in">CGRect</span> rect = [_data[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//开启图形上下文</span></div><div class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">YES</span>, <span class="number">0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//获取图形上下文</span></div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        </div><div class="line">        <span class="comment">//背景颜色</span></div><div class="line">        [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">        </div><div class="line">        <span class="comment">//通过rect填充背景颜色</span></div><div class="line">        <span class="built_in">CGContextFillRect</span>(context, rect);</div><div class="line">        </div><div class="line">        <span class="comment">//如果有原帖（说明当前贴是转发贴）</span></div><div class="line">        <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">            </div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">243</span>/<span class="number">255.0</span> green:<span class="number">243</span>/<span class="number">255.0</span> blue:<span class="number">243</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGRect</span> subFrame = [_data[<span class="string">@"subData"</span>][<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, subFrame);</div><div class="line">            </div><div class="line">            <span class="comment">//原帖上面的分割线</span></div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, subFrame.origin.y, rect.size.width, <span class="number">.5</span>));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</div><div class="line">            <span class="keyword">float</span> x = leftX;</div><div class="line">            <span class="keyword">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class="number">6</span>))/<span class="number">2</span><span class="number">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class="number">-5</span>;</div><div class="line">            </div><div class="line">            <span class="comment">//绘制名字</span></div><div class="line">            [_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</div><div class="line">                             andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                                andHeight:rect.size.height];</div><div class="line">            </div><div class="line">            <span class="comment">//绘制名字下面的info</span></div><div class="line">            y += SIZE_FONT_NAME+<span class="number">5</span>;</div><div class="line">            <span class="keyword">float</span> fromX = leftX;</div><div class="line">            <span class="keyword">float</span> size = [<span class="built_in">UIScreen</span> screenWidth]-leftX;</div><div class="line">            <span class="built_in">NSString</span> *from = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@  %@"</span>, _data[<span class="string">@"time"</span>], _data[<span class="string">@"from"</span>]];</div><div class="line">            </div><div class="line">            [from drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE)</div><div class="line">                   andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                      andHeight:rect.size.height andWidth:size];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//评论角</span></div><div class="line">            <span class="built_in">CGRect</span> countRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30</span>, [<span class="built_in">UIScreen</span> screenWidth], <span class="number">30</span>);</div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, countRect);</div><div class="line">            <span class="keyword">float</span> alpha = <span class="number">1</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">float</span> x = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT<span class="number">-10</span>;</div><div class="line">            <span class="built_in">NSString</span> *comments = _data[<span class="string">@"comments"</span>];</div><div class="line">            <span class="keyword">if</span> (comments) &#123;</div><div class="line">                <span class="built_in">CGSize</span> size = [comments sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</div><div class="line">                </div><div class="line">                x -= size.width;</div><div class="line">                </div><div class="line">                <span class="comment">//图片文字</span></div><div class="line">                [comments drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                                andFont:FontWithSize(<span class="number">12</span>)</div><div class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                              andHeight:rect.size.height];</div><div class="line">                </div><div class="line">                <span class="comment">//评论图片（bundle里的图片）</span></div><div class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div><div class="line">                </div><div class="line">                commentsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, [<span class="built_in">UIScreen</span> screenWidth]-x+<span class="number">5</span>, <span class="number">50</span>);</div><div class="line">                x -= <span class="number">20</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//转发角</span></div><div class="line">            <span class="built_in">NSString</span> *reposts = _data[<span class="string">@"reposts"</span>];</div><div class="line">            <span class="keyword">if</span> (reposts) &#123;</div><div class="line">                <span class="built_in">CGSize</span> size = [reposts sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</div><div class="line">                </div><div class="line">                x -= MAX(size.width, <span class="number">5</span>)+SIZE_GAP_BIG;</div><div class="line">                </div><div class="line">                <span class="comment">//转发文字</span></div><div class="line">                [reposts drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                                andFont:FontWithSize(<span class="number">12</span>)</div><div class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                 </div><div class="line">                             andHeight:rect.size.height];</div><div class="line">               </div><div class="line">                <span class="comment">//转发图片（bundle里的图片）</span></div><div class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_repost.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">11</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div><div class="line">                repostsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, commentsRect.origin.x-x, <span class="number">50</span>);</div><div class="line">                x -= <span class="number">20</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//更多角</span></div><div class="line">            [<span class="string">@"•••"</span> drawInContext:context</div><div class="line">                     withPosition:<span class="built_in">CGPointMake</span>(SIZE_GAP_LEFT, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                          andFont:FontWithSize(<span class="number">11</span>)</div><div class="line">                     andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">.5</span>]</div><div class="line">                        andHeight:rect.size.height];</div><div class="line">            </div><div class="line">            <span class="comment">//绘制原帖底部的分割线</span></div><div class="line">            <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">                [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">                <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30.5</span>, rect.size.width, <span class="number">.5</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//将整个contex转化为图片，赋给背景imageview</span></div><div class="line">        <span class="built_in">UIImage</span> *temp = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">if</span> (flag==drawColorFlag) &#123;</div><div class="line">                postBGView.frame = rect;</div><div class="line">                postBGView.image = <span class="literal">nil</span>;</div><div class="line">                postBGView.image = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//绘制两个label的text</span></div><div class="line">    [<span class="keyword">self</span> drawText];</div><div class="line">    </div><div class="line">    <span class="comment">//加载帖子里的网路图片，使用SDWebImage</span></div><div class="line">    [<span class="keyword">self</span> loadThumb];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面抽出每一种绘制内容的代码，分别讲解：</p>
<h3 id="3-1-异步加载网络图片"><a href="#3-1-异步加载网络图片" class="headerlink" title="3.1 异步加载网络图片"></a>3.1 异步加载网络图片</h3><p>关于网络图片的异步加载和缓存，作者使用了第三方框架：<code>SDWebImage</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setData:(<span class="built_in">NSDictionary</span> *)data&#123;</div><div class="line">    _data = data;</div><div class="line">    [avatarView setBackgroundImage:<span class="literal">nil</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    <span class="keyword">if</span> ([data valueForKey:<span class="string">@"avatarUrl"</span>]) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:[data valueForKey:<span class="string">@"avatarUrl"</span>]];</div><div class="line">        [avatarView sd_setBackgroundImageWithURL:url forState:<span class="built_in">UIControlStateNormal</span> placeholderImage:<span class="literal">nil</span> options:SDWebImageLowPriority];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于<code>SDWebImage</code>，我相信大家都不会陌生，我前一阵写了一篇源码解析，有兴趣的话可以看一下：<a href="http://www.jianshu.com/p/93696717b4a3" target="_blank" rel="external">SDWebImage源码解析</a>。</p>
<h3 id="3-2-异步绘制本地图片"><a href="#3-2-异步绘制本地图片" class="headerlink" title="3.2 异步绘制本地图片"></a>3.2 异步绘制本地图片</h3><p>本地图片的绘制，只需要提供图片在bundle内部的名字和frame就可以绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div></pre></td></tr></table></figure>
<p>###3.3  异步绘制UIView</p>
<p>对于<code>UIView</code>的绘制，我们只需要知道要绘制的<code>UIView</code>的frame和颜色即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//背景颜色</span></div><div class="line">[[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">        </div><div class="line"><span class="comment">//通过rect填充背景颜色</span></div><div class="line"><span class="built_in">CGContextFillRect</span>(context, rect);</div></pre></td></tr></table></figure>
<p>讲到现在，就剩下了关于文字的绘制，包括脱离了UILabel的纯文本的绘制和UILabel里文本的绘制，我们先说一下关于简单的纯NSString的绘制：</p>
<h3 id="3-4-异步绘制NSString"><a href="#3-4-异步绘制NSString" class="headerlink" title="3.4  异步绘制NSString"></a>3.4  异步绘制NSString</h3><p>作者通过传入字符串的字体，颜色和行高，以及位置就实现了纯文本的绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘制名字</span></div><div class="line">[_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</div><div class="line">                 andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">             andHeight:rect.size.height];</div></pre></td></tr></table></figure>
<p>这个方法是作者在<code>NSString</code>的一个分类里自定义的，我们看一下它的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)context withPosition:(<span class="built_in">CGPoint</span>)p andFont:(<span class="built_in">UIFont</span> *)font andTextColor:(<span class="built_in">UIColor</span> *)color andHeight:(<span class="keyword">float</span>)height andWidth:(<span class="keyword">float</span>)width&#123;    </div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(width, font.pointSize+<span class="number">10</span>);    </div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);    </div><div class="line">    <span class="comment">//移动坐标系统，所有点的y增加了height</span></div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,height);</div><div class="line">    </div><div class="line">    <span class="comment">//缩放坐标系统，所有点的x乘以1.0，所有的点的y乘以-1.0</span></div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//文字颜色</span></div><div class="line">    <span class="built_in">UIColor</span>* textColor = color;</div><div class="line">    </div><div class="line">    <span class="comment">//生成CTFont</span></div><div class="line">    <span class="built_in">CTFontRef</span> font1 = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)font.fontName, font.pointSize,<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//用于创建CTParagraphStyleRef的一些基本数据</span></div><div class="line">    <span class="built_in">CGFloat</span> minimumLineHeight = font.pointSize,maximumLineHeight = minimumLineHeight+<span class="number">10</span>, linespace = <span class="number">5</span>;</div><div class="line">    <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByTruncatingTail;</div><div class="line">    </div><div class="line">    <span class="comment">//左对齐</span></div><div class="line">    <span class="built_in">CTTextAlignment</span> alignment = kCTLeftTextAlignment;</div><div class="line">    </div><div class="line">    <span class="comment">//创建CTParagraphStyleRef</span></div><div class="line">    <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</div><div class="line">        &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</div><div class="line">    &#125;,<span class="number">6</span>);</div><div class="line">    <span class="comment">//设置属性字典；对象，key</span></div><div class="line">    <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</div><div class="line">                                (__bridge <span class="keyword">id</span>)font1,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</div><div class="line">                                textColor.CGColor,kCTForegroundColorAttributeName,</div><div class="line">                                style,kCTParagraphStyleAttributeName,</div><div class="line">                                <span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">//生成path，添加到cgcontex上</span></div><div class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</div><div class="line">    <span class="built_in">CGPathAddRect</span>(path,<span class="literal">NULL</span>,<span class="built_in">CGRectMake</span>(p.x, height-p.y-size.height,(size.width),(size.height)));</div><div class="line">    </div><div class="line">    <span class="comment">//生成CF属性字符串</span></div><div class="line">    <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="keyword">self</span> attributes:attributes];</div><div class="line">    <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)attributedStr;</div><div class="line">    </div><div class="line">    <span class="comment">//从attributedString拿到ctframesetter</span></div><div class="line">    <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</div><div class="line">    </div><div class="line">    <span class="comment">//从framesetter拿到 core text 的 ctframe</span></div><div class="line">    <span class="built_in">CTFrameRef</span> ctframe = <span class="built_in">CTFramesetterCreateFrame</span>(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="built_in">CFAttributedStringGetLength</span>(attributedString)),path,<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//将ctframe绘制到context里面</span></div><div class="line">    <span class="built_in">CTFrameDraw</span>(ctframe,context);</div><div class="line">    </div><div class="line">    <span class="comment">//因为不是对象类型，需要释放</span></div><div class="line">    <span class="built_in">CGPathRelease</span>(path);</div><div class="line">    <span class="built_in">CFRelease</span>(font1);</div><div class="line">    <span class="built_in">CFRelease</span>(framesetter);</div><div class="line">    <span class="built_in">CFRelease</span>(ctframe);</div><div class="line">    [[attributedStr mutableString] setString:<span class="string">@""</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//恢复context坐标系统</span></div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>, height);</div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，作者根据文字的起点，颜色，字体大小和行高，使用Core Text，将文字绘制在了传入的context上面。</p>
<h3 id="3-5-异步绘制UILabel"><a href="#3-5-异步绘制UILabel" class="headerlink" title="3.5 异步绘制UILabel"></a>3.5 异步绘制UILabel</h3><p>而对于<code>UILabel</code>里面的绘制，作者也采取了类似的方法：</p>
<p>首先看一下在cell实现文件里，关于绘制label文字方法的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将文本内容绘制到图片上，也是异步绘制</span></div><div class="line">- (<span class="keyword">void</span>)drawText&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果发现label或detailLabel不存在，则重新add一次</span></div><div class="line">    <span class="keyword">if</span> (label==<span class="literal">nil</span>||detailLabel==<span class="literal">nil</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> addLabel];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//传入frame</span></div><div class="line">    label.frame = [_data[<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">    <span class="comment">//异步绘制text</span></div><div class="line">    [label setText:_data[<span class="string">@"text"</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">//如果存在原帖</span></div><div class="line">    <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">        </div><div class="line">        detailLabel.frame = [[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">        <span class="comment">//异步绘制text</span></div><div class="line">        [detailLabel setText:[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"text"</span>]];</div><div class="line">        detailLabel.hidden = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，对于帖子而言，是否存在原贴（当前贴是否是转发贴）是不固定的，所以需要在判断之后，用<code>hidden</code>属性来控制相应控件的隐藏和显示，而不是用<code>addSubView</code>的方法。</p>
<p>这里的label是作者自己封装的<code>VVeboLabel</code>。它具有高亮显示点击，利用正则表达式区分不同类型的特殊文字（话题名，用户名，网址，emoji）的功能。</p>
<p>简单介绍一下这个封装好的label：</p>
<ul>
<li>继承于<code>UIView</code>,可以响应用户点击，在初始化之后，<code>_textAlignment</code>,<code>_textColor</code>,<code>_font</code>,<code>_lienSpace</code>属性都会被初始化。</li>
<li>使用Core Text绘制文字。</li>
<li>持有两种UIImageView，用来显示默认状态和高亮状态的图片（将字符串绘制成图片）。</li>
<li>保存了四种特殊文字的颜色，用正则表达式识别以后，给其着色。</li>
</ul>
<p>这里讲一下这个label的<code>setText:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用coretext将文本绘制到图片。</span></div><div class="line">- (<span class="keyword">void</span>)setText:(<span class="built_in">NSString</span> *)text&#123;</div><div class="line">   </div><div class="line">    <span class="comment">//labelImageView 普通状态时的imageview</span></div><div class="line">    <span class="comment">//highlightImageView 高亮状态时的iamgeview</span></div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//绘制标记，初始化时赋一个随机值；clear之后更新一个随机值</span></div><div class="line">    <span class="built_in">NSInteger</span> flag = drawFlag;</div><div class="line">    </div><div class="line">    <span class="comment">//是否正在高亮（在点击label的时候设置为yes，松开的时候设置为NO）</span></div><div class="line">    <span class="built_in">BOOL</span> isHighlight = highlighting;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSString</span> *temp = text;</div><div class="line">        _text = text;</div><div class="line">        <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.frame.size;</div><div class="line">        size.height += <span class="number">10</span>;</div><div class="line">       </div><div class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, ![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]], <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="keyword">if</span> (context==<span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]]) &#123;</div><div class="line">            [<span class="keyword">self</span>.backgroundColor set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">        <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</div><div class="line">        <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//Determine default text color</span></div><div class="line">        <span class="built_in">UIColor</span>* textColor = <span class="keyword">self</span>.textColor;</div><div class="line">        </div><div class="line">        <span class="comment">//Set line height, font, color and break mode</span></div><div class="line">        <span class="built_in">CGFloat</span> minimumLineHeight = <span class="keyword">self</span>.font.pointSize,maximumLineHeight = minimumLineHeight, linespace = <span class="keyword">self</span>.lineSpace;</div><div class="line">        </div><div class="line">        <span class="built_in">CTFontRef</span> font = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)<span class="keyword">self</span>.font.fontName, <span class="keyword">self</span>.font.pointSize,<span class="literal">NULL</span>);</div><div class="line">        <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByWordWrapping;</div><div class="line">        <span class="built_in">CTTextAlignment</span> alignment = <span class="built_in">CTTextAlignmentFromUITextAlignment</span>(<span class="keyword">self</span>.textAlignment);</div><div class="line">        <span class="comment">//Apply paragraph settings</span></div><div class="line">        <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</div><div class="line">            &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</div><div class="line">        &#125;,<span class="number">6</span>);</div><div class="line">    </div><div class="line">        <span class="comment">//属性字典</span></div><div class="line">        <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:(__bridge <span class="keyword">id</span>)font,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</div><div class="line">                                    textColor.CGColor,kCTForegroundColorAttributeName,</div><div class="line">                                    style,kCTParagraphStyleAttributeName,</div><div class="line">                                    <span class="literal">nil</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//拿到CFAttributedStringRef</span></div><div class="line">        <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:text attributes:attributes];</div><div class="line">        <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)[<span class="keyword">self</span> highlightText:attributedStr];</div><div class="line">        </div><div class="line">        <span class="comment">//根据attributedStringRef 获取CTFramesetterRef</span></div><div class="line">        <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</div><div class="line">        </div><div class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">5</span>,(size.width),(size.height<span class="number">-5</span>));</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//根据 framesetter 和 attributedString 绘制text</span></div><div class="line">            [<span class="keyword">self</span> drawFramesetter:framesetter attributedString:attributedStr textRange:<span class="built_in">CFRangeMake</span>(<span class="number">0</span>, text.length) inRect:rect context:context];</div><div class="line">            </div><div class="line">            <span class="comment">//恢复context</span></div><div class="line">            <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">            <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</div><div class="line">            <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">            </div><div class="line">            <span class="comment">//截取当前图片</span></div><div class="line">            <span class="built_in">UIImage</span> *screenShotimage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">            <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                </div><div class="line">                <span class="built_in">CFRelease</span>(font);</div><div class="line">                <span class="built_in">CFRelease</span>(framesetter);</div><div class="line">                [[attributedStr mutableString] setString:<span class="string">@""</span>];</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (drawFlag==flag) &#123;</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (isHighlight) &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//高亮状态：把图片付给highlightImageView</span></div><div class="line">                        <span class="keyword">if</span> (highlighting) &#123;</div><div class="line">                            highlightImageView.image = <span class="literal">nil</span>;</div><div class="line">                            <span class="keyword">if</span> (highlightImageView.width!=screenShotimage.size.width) &#123;</div><div class="line">                                highlightImageView.width = screenShotimage.size.width;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (highlightImageView.height!=screenShotimage.size.height) &#123;</div><div class="line">                                highlightImageView.height = screenShotimage.size.height;</div><div class="line">                            &#125;</div><div class="line">                            highlightImageView.image = screenShotimage;</div><div class="line">                        &#125;</div><div class="line">                    </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//非高亮状态，把图片付给labelImageView</span></div><div class="line">                        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</div><div class="line">                            <span class="keyword">if</span> (labelImageView.width!=screenShotimage.size.width) &#123;</div><div class="line">                                labelImageView.width = screenShotimage.size.width;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (labelImageView.height!=screenShotimage.size.height) &#123;</div><div class="line">                                labelImageView.height = screenShotimage.size.height;</div><div class="line">                            &#125;</div><div class="line">                            highlightImageView.image = <span class="literal">nil</span>;</div><div class="line">                            labelImageView.image = <span class="literal">nil</span>;</div><div class="line">                            labelImageView.image = screenShotimage;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"><span class="comment">//                    [self debugDraw];//绘制可触摸区域</span></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个被作者封装好的Label里面还有很多其他的方法，比如用正则表达式高亮显示特殊字符串等等。</p>
<p>关于tableView的优化，作者做了很多处理，使得这种显示内容比较丰富的cell在4s真机上好不卡顿，非常值得学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次分享一个关于性能优化的源码。&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;UITabelView&lt;/code&gt;在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，&lt;code&gt;UITabelView&lt;/code&gt;的性能将直接影响这个app的性能。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;UITabelView&lt;/code&gt;里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。&lt;/p&gt;
&lt;p&gt;但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。&lt;/p&gt;
&lt;p&gt;最近在看一些iOS性能优化的文章，我找到了&lt;a href=&quot;https://github.com/johnil/VVeboTableViewDemo&quot;&gt;VVeboTableView&lt;/a&gt;这个框架。严格来说这个不属于框架，而是作者用自己的方式优化&lt;code&gt;UITableView&lt;/code&gt;的一个实现。&lt;/p&gt;
&lt;p&gt;作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;看了源码之后，我把作者的思路整理了出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png&quot; alt=&quot;优化思路图&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PNChart源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/09/PNChart%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/09/PNChart源码解析/</id>
    <published>2017-02-09T03:33:20.000Z</published>
    <updated>2017-03-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一. 框架介绍"></a>一. 框架介绍</h2><p><a href="https://github.com/kevinzhow/PNChart">PNChart</a>是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。</p>
<p>该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类<code>PNGenericChart</code>,第二层就是所有类型的图表。提供一张图来直观感受一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png" alt="层级图"></p>
<blockquote>
<p>在这张图里，需要注意以下几点：</p>
<ol>
<li>带箭头的线和不带箭头的线的区别。</li>
<li><code>Data</code>类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有<code>Data</code>类，因为饼状图没有多组数据，而折线图<code>LineChart</code>是支持多组数据的，所以有<code>Data</code>类。</li>
<li><code>Item</code>类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。</li>
<li><code>BarChart</code>类里面的每一根柱子都是<code>PNBar</code>的实例（该类型的图表不在本篇讲解的范围之内）。</li>
</ol>
</blockquote>
<a id="more"></a>
<p>今天就来介绍一下该框架里的折线图的源码。上文提到过，该框架的折线图是支持多组数据的，也就是在同一张图表上显示多条折线。先带大家看一下效果图：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_2.png" alt="折线图"></p>
<p>折线图在效果上还是很简洁美观的，如果现在的你还不知道如何使用<code>CAShapeLayer</code>和<code>UIBezierPath</code>画图并附加动画效果，那么本篇源码解析非常适合你。</p>
<p>阅读本文之后，你可以掌握有关图形绘制的相关知识，也可以掌握自定义各种图形（<code>UIView</code>）的方法，而且你也应该有能力作出这样的图表，甚至更好！</p>
<p>在开始讲解之前，我先粗略介绍一下利用<code>CAShapeLayer</code>画图的过程。这个过程有三个大前提：</p>
<ul>
<li>因为<code>UIView</code>是对<code>CALayer</code>的封装，所以我们可以通过改变<code>UIView</code>所持有的<code>layer</code>属性来直接改变<code>UIView</code>的显示效果。</li>
<li><code>CAShapeLayer</code>是<code>CALayer</code>的子类。</li>
<li><code>CAShapeLayer</code>的使用是依赖于<code>UIBezierPath</code>的。<code>UIBezierPath</code>就是“路径”，可以理解为形状。不难理解，想象一下，如果我们想画一个图形，那么这个图形的形状（包括颜色）是必不可少的，而这个角色，就需要<code>UIBezierPath</code>来充当。</li>
</ul>
<p>那么了这三个大前提，我们就可以知道如何画图了：</p>
<ol>
<li>实例化一个<code>UIBezierPath</code>，并赋给<code>CAShapeLayer</code>实例的<code>path</code>属性。</li>
<li>将这个<code>CAShapeLayer</code>的实例添加到<code>UIView</code>的<code>layer</code>上。</li>
</ol>
<p>简单的代码演示上述过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">...自定义path...</div><div class="line"><span class="built_in">CAShapeLayer</span> *shapLayer = [<span class="built_in">CAShapeLayer</span> alloc] init];</div><div class="line">shapLayer.path = path;</div><div class="line">[<span class="keyword">self</span>.view.layer addSubLayer:shapeLayer];</div></pre></td></tr></table></figure></p>
<p>现在大致了解了画图的过程，我们来看一下该框架的作者是如何实现一个折线图的吧！</p>
<h2 id="二-源码解析"><a href="#二-源码解析" class="headerlink" title="二. 源码解析"></a>二. 源码解析</h2><p>首先看一下整个绘制折线图的步骤：</p>
<ol>
<li>图表的初始化。</li>
<li>获取横轴和纵轴的数据。</li>
<li>计算折线上所有拐点的x，y值。</li>
<li>计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）。</li>
<li>生成每个拐点上面的Label（可有可无）。</li>
<li>计算每条线段的贝塞尔曲线（UIBezierPath）。</li>
<li>将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</li>
<li>绘制所有折线（所有线段+所有圆圈）。</li>
<li>添加动画(可有可无)。</li>
<li>绘制x，y坐标轴。</li>
</ol>
<p>在集合代码具体讲解之前，我们要清楚三点（非常非常重要）：</p>
<ol>
<li>此折线图框架是可以设置拐点的样式的:可以设置为没有样式，也可以设置有样式：圆圈，方块，三角形。<ul>
<li>如果没有样式，则是简单的线段与线段的连接，在拐点处没有任何其他控件。</li>
<li>如果是有样式的，那么这条折线里的每条线段（在本篇文章里统一说成线段）之间是<strong>分离的</strong>，因为线段中间有一个拐点控件。本篇文章介绍的是圆圈样式（如上图所示，拐点控件是一个圆圈）。</li>
</ul>
</li>
<li>上文提到过，该折线图框架可以在一张图表里同时显示多条折线，也就是可以设置多组数据（一条折线对应一组数据）。因此，上面的3，4，5，6，7项都是用各自不同的一个数组保存的，数组里的每一个元素对应一条折线的数据。</li>
<li>既然同一个张图表可以显示多条折线：<ul>
<li>那么有些属性就是这些折线共有的，比如横坐标的value，这些属性保存在<code>PNLineChart</code>的实例里面。</li>
<li>有些属性是每条折线私有的，比如每条折线的颜色，纵坐标value等等，这些属性保存在<code>PNLineChartData</code>里面。每一条折线对应一个<code>PNLineChartData</code>实例。这些实例汇总到一个数组里面，这个数组由<code>PNLineChart</code>的实例管理。</li>
</ul>
</li>
</ol>
<p>在充分了解了这三点之后，我们结合一下代码来看一下具体的实现：</p>
<h3 id="1-图表的初始化"><a href="#1-图表的初始化" class="headerlink" title="1. 图表的初始化"></a>1. 图表的初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> setupDefaultValues];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setupDefaultValues &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> setupDefaultValues];</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//四个内边距</span></div><div class="line">    _chartMarginLeft = <span class="number">25.0</span>;</div><div class="line">    _chartMarginRight = <span class="number">25.0</span>;</div><div class="line">    _chartMarginTop = <span class="number">25.0</span>;</div><div class="line">    _chartMarginBottom = <span class="number">25.0</span>;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//真正绘制图表的画布（CavanWidth）的宽高</span></div><div class="line">    _chartCavanWidth = <span class="keyword">self</span>.frame.size.width - _chartMarginLeft - _chartMarginRight;</div><div class="line">    _chartCavanHeight = <span class="keyword">self</span>.frame.size.height - _chartMarginBottom - _chartMarginTop;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>上面这段代码我刻意省去了其他一些基本的设置，突出了图表布局的设置。</p>
<p>布局的设置是图表绘制的前提，因为在最开始的时候，就应该计算出“画布”，也就是图表内容（不包括坐标轴和坐标label）的具体大小和位置（内边距以内的部分）。</p>
<p>在这里，我们需要获取真正绘制图表的画布的宽高(<code>_chartCavanWidth</code>和<code>_chartCavanHeight</code>)。而且，要留意的是<code>_chartMarginLeft</code>在将来是要用作y轴Label的宽度，而<code>_chartMarginBottom</code>在将来是要用作x轴Label的高度的。</p>
</blockquote>
<p>用一张图直观看一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_4.png" alt="整个控件的大小和画布的大小"></p>
<h3 id="2-获取横轴和纵轴的数据"><a href="#2-获取横轴和纵轴的数据" class="headerlink" title="2. 获取横轴和纵轴的数据"></a>2. 获取横轴和纵轴的数据</h3><p>现在画布的位置和大小确定了，我们可以来看一下折线图是怎么画的了。<br>整个图表的绘制都基于三组数据（也可以是两组，为什么是两组，我稍后会给出解释），在讲解该框架是如何利用这些数据之前，我们来看一下这些数据是如何传进图表的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//设置x轴的数据</span></div><div class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</div><div class="line"><span class="comment">//设置y轴的数据</span></div><div class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</div><div class="line">                             <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</div><div class="line">                             ]</div><div class="line"> ];</div><div class="line"><span class="comment">// Line Chart</span></div><div class="line"><span class="comment">//设置每个点的y值</span></div><div class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</div><div class="line">PNLineChartData *data = [PNLineChartData new];</div><div class="line">data.pointLabelColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">data.color = PNTwitterColor;</div><div class="line">data.alpha = <span class="number">0.5</span>f;</div><div class="line">data.itemCount = dataArray.count;</div><div class="line">data.inflexionPointStyle = PNLineChartPointStyleCircle;</div><div class="line"><span class="comment">//这个block的作用是将上面的dataArray里的每一个值传给line chart。</span></div><div class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</div><div class="line">    <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</div><div class="line">    <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</div><div class="line">&#125;;</div><div class="line"><span class="comment">//因为只有一条折线，所以只有一组数据</span></div><div class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</div><div class="line"><span class="comment">//绘制图表</span></div><div class="line">[<span class="keyword">self</span>.lineChart strokeChart];</div><div class="line"><span class="comment">//设置代理，响应点击</span></div><div class="line"><span class="keyword">self</span>.lineChart.delegate = <span class="keyword">self</span>;</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.lineChart];</div></pre></td></tr></table></figure>
<p>上面的代码我可以略去了很多多余的设置，目的是突出图表数据的设置。</p>
<p>不难看出，这里有三个数据传给了lineChart：</p>
<p>1.x轴的数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码调用之后，实现了：</p>
<ol>
<li>根据传入的xLabel数组里元素的数量，内容宽度(<code>_chartCavanWidth</code>)和下边距（<code>_chartMarginBottom</code>），计算每个xlabel的size。</li>
<li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的xLabel（包括内容，位置）并显示出来，最后保存在<code>_xChartLabels</code>里面。</li>
</ol>
</blockquote>
<p>2.y轴的数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</div><div class="line">                <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</div><div class="line">                ]</div><div class="line">    ];</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码调用之后，实现了：</p>
<ol>
<li>根据传入的yLabel数组里元素的数量，内容高度(<code>_chartCavanHeight</code>)和左边距(<code>_chartMarginLeft</code>)，计算出每个ylabel的size。</li>
<li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的yLabel（包括内容，位置）并显示出来，最后保存在<code>_yChartLabels</code>里面。</li>
</ol>
</blockquote>
<p>3.一条折线上每个点的实际值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</div><div class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</div><div class="line">        <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</div><div class="line">        <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</div><div class="line">    &#125;;</div><div class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</div></pre></td></tr></table></figure>
<blockquote>
<p>着重讲一下block：为什么不直接把这个数组(<code>dataArray</code>)作为line chart的属性传进去呢？我认为作者是想提供一个接口给用户一个自己转化y值的机会。</p>
<p>像上文所说的，这里1，2是属于<code>lineChart</code>的数据，它适用于这张图表上所有的折线的。而3是属于某一条折线的。</p>
<p>现在回答一下为什么可以只传入两组数据：因为y轴数据可以由每个点的实际值数组得出。可以简单想一下，我们可以获取这些真实值里面的最大值，然后将它n等分，就自然得到了y轴数据了。</p>
</blockquote>
<p>我们已经布局了x轴和y轴的所有label，现在开始真正计算图表的数据了。</p>
<blockquote>
<p>注意：下面要介绍的3，4，5，6项都是在同一方法中计算出来，为了避免代码过长，我将每个部分分解开来做出解释。因为在同一方法里，所以这些涉及到for循环的语句是一致的。</p>
<p>整个图表的绘制都是依赖于数据的处理，所以3，4，5，6项也是理解该框架的一个关键！</p>
</blockquote>
<p>首先，我们需要计算每个数据点（拐点）的准确位置：</p>
<h3 id="3-计算折线上所有拐点的x，y值。"><a href="#3-计算折线上所有拐点的x，y值。" class="headerlink" title="3. 计算折线上所有拐点的x，y值。"></a>3. 计算折线上所有拐点的x，y值。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="comment">//还记得chartData属性么？它是用来保存多组折线的数据的，在这里只有一个折线，所以这个循环只循环一次）</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">   <span class="comment">//保存每条折线上的所有点的CGPoint  </span></div><div class="line">   <span class="built_in">NSMutableArray</span> *linePointsArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    <span class="comment">//遍历每条折线里的每个点    </span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//传入index，获取y值(调用的是上文提到的block)</span></div><div class="line">        yValue = chartData.getData(i).y;</div><div class="line">        <span class="comment">//当前点的x： _chartMarginLeft + _xLabelWidth / 2.0为0坐标，每多一个点就多一个_xLabelWidth</span></div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) (i * _xLabelWidth + _chartMarginLeft + _xLabelWidth / <span class="number">2.0</span>);</div><div class="line">            </div><div class="line">        <span class="comment">//当前点的y：根据当前点的值和当前点所在的数组里的最大值的比例 以及 图表的总高度，算出当前点在图表里的y坐标</span></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>)[<span class="keyword">self</span> yValuePositionInLineChart:yValue];</div><div class="line">        <span class="comment">//保存所有拐点的坐标</span></div><div class="line">        [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//保存多条折线的CGPoint（这里只有一条折线，所以该数组只有一个元素）</span></div><div class="line">  [pathPoints addObject:[linePointsArray <span class="keyword">copy</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里需要注意两点：</p>
<ol>
<li>这里的<code>pathPoints</code>对应的是<code>lineChart</code>的<code>_pathPoints</code>属性。它是一个二维数组，保存每条折线上所有点的<code>CGPoint</code>。</li>
<li>y值的计算：是需要从y的真实值转化为这个拐点在图表里的y坐标，转化方法的实现(仔细看几遍就懂了)：</li>
</ol>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)yValuePositionInLineChart:(<span class="built_in">CGFloat</span>)y &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> innerGrade;<span class="comment">//真实的最大值与最小值的差 与 当前点与最小值的差 的比值</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!(_yValueMax - _yValueMin)) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//特殊情况：当_yValueMax和_yValueMin相等的时候</span></div><div class="line">        innerGrade = <span class="number">0.5</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        innerGrade = ((<span class="built_in">CGFloat</span>) y - _yValueMin) / (_yValueMax - _yValueMin);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//innerGrade 与画布的高度（_chartCavanHeight）相乘，就能得出在画布中的高度</span></div><div class="line">    <span class="keyword">return</span> _chartCavanHeight - (innerGrade * _chartCavanHeight) - (_yLabelHeight / <span class="number">2</span>) + _chartMarginTop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"><a href="#4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）" class="headerlink" title="4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"></a>4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    <span class="comment">//每条折线所有圆圈的贝塞尔曲线</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *pointPath = [<span class="built_in">UIBezierPath</span> bezierPath];    </div><div class="line">    <span class="comment">//inflexionWidth默认是6,是两个线段中间的距离（因为中间有一个圈圈，所以需要定一个距离）</span></div><div class="line">    <span class="built_in">CGFloat</span> inflexionWidth = chartData.inflexionPointWidth;</div><div class="line">    <span class="comment">//遍历每条折线里的每个点</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;  </div><div class="line">        <span class="comment">//1. 计算圆圈的rect：已当前点为中心，以inflexionWidth为半径</span></div><div class="line">        <span class="built_in">CGRect</span> circleRect = <span class="built_in">CGRectMake</span>(x - inflexionWidth / <span class="number">2</span>, y - inflexionWidth / <span class="number">2</span>, inflexionWidth, inflexionWidth);    </div><div class="line">        <span class="comment">//2. 计算圆圈的中心：由圆圈的x，y和inflexionWidth算出</span></div><div class="line">        <span class="built_in">CGPoint</span> circleCenter = <span class="built_in">CGPointMake</span>(circleRect.origin.x + (circleRect.size.width / <span class="number">2</span>), circleRect.origin.y + (circleRect.size.height / <span class="number">2</span>));</div><div class="line">        <span class="comment">//3.1 移动到圆圈的右中部</span></div><div class="line">        [pointPath moveToPoint:<span class="built_in">CGPointMake</span>(circleCenter.x + (inflexionWidth / <span class="number">2</span>), circleCenter.y)];        </div><div class="line">        <span class="comment">//3.2 画线（圆形）</span></div><div class="line">        [pointPath addArcWithCenter:circleCenter radius:inflexionWidth / <span class="number">2</span> startAngle:<span class="number">0</span> endAngle:(<span class="built_in">CGFloat</span>) (<span class="number">2</span> * M_PI) clockwise:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//保存到pointsPath数组里</span></div><div class="line">    [pointsPath insertObject:pointPath atIndex:lineIndex];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>pointsPath</code>对应的是<code>lineChart</code>的<code>_pointsPath</code>属性。它是一个一维数组，保存每条折线上的圆圈贝塞尔曲线（UIBezierPath）。</p>
</blockquote>
<h3 id="5-生成每个拐点上面的Label（可有可无）"><a href="#5-生成每个拐点上面的Label（可有可无）" class="headerlink" title="5. 生成每个拐点上面的Label（可有可无）"></a>5. 生成每个拐点上面的Label（可有可无）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    <span class="comment">//遍历每条折线里的每一段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> (chartData.showPointLabel) &#123;</div><div class="line">            [gradePathArray addObject:[<span class="keyword">self</span> createPointLabelFor:chartData.getData(i).rawY pointCenter:circleCenter width:inflexionWidth withChartData:chartData]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，在这里，这些label的实现是通过一个<code>CATextLayer</code>实现的，并不是生成一个个<code>Label</code>放在数组里保存，具体实现方法如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CATextLayer</span> *)createPointLabelFor:(<span class="built_in">CGFloat</span>)grade pointCenter:(<span class="built_in">CGPoint</span>)pointCenter width:(<span class="built_in">CGFloat</span>)width withChartData:(PNLineChartData *)chartData &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//grade：提供textLayer显示的数值</span></div><div class="line">    <span class="comment">//pointCenter：根据pointCenter算出textLayer的x，y</span></div><div class="line">    <span class="comment">//width：根据width得到textLayer的总宽度</span></div><div class="line">    <span class="comment">//chartData：获取chartData里保存的textLayer上应该保存的字体大小和颜色</span></div><div class="line">    </div><div class="line">    <span class="built_in">CATextLayer</span> *textLayer = [[<span class="built_in">CATextLayer</span> alloc] init];</div><div class="line">    [textLayer setAlignmentMode:kCAAlignmentCenter];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的背景色</span></div><div class="line">    [textLayer setForegroundColor:[chartData.pointLabelColor <span class="built_in">CGColor</span>]];</div><div class="line">    [textLayer setBackgroundColor:<span class="keyword">self</span>.backgroundColor.CGColor];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的字体大小和颜色</span></div><div class="line">    <span class="keyword">if</span> (chartData.pointLabelFont != <span class="literal">nil</span>) &#123;</div><div class="line">        [textLayer setFont:(__bridge <span class="built_in">CFTypeRef</span>) (chartData.pointLabelFont)];</div><div class="line">        textLayer.fontSize = [chartData.pointLabelFont pointSize];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的高度</span></div><div class="line">    <span class="built_in">CGFloat</span> textHeight = (<span class="built_in">CGFloat</span>) (textLayer.fontSize * <span class="number">1.1</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> textWidth = width * <span class="number">8</span>;</div><div class="line">    <span class="built_in">CGFloat</span> textStartPosY;</div><div class="line">    </div><div class="line">    textStartPosY = pointCenter.y - textLayer.fontSize;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.layer addSublayer:textLayer];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的文字显示格式</span></div><div class="line">    <span class="keyword">if</span> (chartData.pointLabelFormat != <span class="literal">nil</span>) &#123;</div><div class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:chartData.pointLabelFormat, grade]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:_yLabelFormat, grade]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的位置和scale（1x，2x，3x）</span></div><div class="line">    [textLayer setFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, textWidth, textHeight)];</div><div class="line">    [textLayer setPosition:<span class="built_in">CGPointMake</span>(pointCenter.x, textStartPosY)];</div><div class="line">    textLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> textLayer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-计算每条线段的贝塞尔曲线（UIBezierPath）"><a href="#6-计算每条线段的贝塞尔曲线（UIBezierPath）" class="headerlink" title="6. 计算每条线段的贝塞尔曲线（UIBezierPath）"></a>6. 计算每条线段的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//每一条线段的贝塞尔曲线（UIBezierPath），用数组装起来</span></div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    </div><div class="line">    <span class="comment">//chartPath（二维数组）：保存所有折线上所有线段的贝塞尔曲线。现在只有一条折线，所以只有一个元素</span></div><div class="line">    [chartPath insertObject:progressLines atIndex:lineIndex];</div><div class="line">    </div><div class="line">    <span class="comment">//progressLinePaths的每个元素是一个字典，字典里存放每一条线段的端点（from，to）</span></div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *&gt; *progressLinePaths = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> last_x = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last_y = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//遍历每条折线里的每一段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//x，y的算法参考上文第三项</span></div><div class="line">            <span class="comment">// 计算index为0以后的点的位置</span></div><div class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) sqrt(pow(x - last_x, <span class="number">2</span>) + pow(y - last_y, <span class="number">2</span>));</div><div class="line">            <span class="keyword">float</span> last_x1 = last_x + (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</div><div class="line">            <span class="keyword">float</span> last_y1 = last_y + (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</div><div class="line">            <span class="keyword">float</span> x1 = x - (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</div><div class="line">            <span class="keyword">float</span> y1 = y - (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</div><div class="line">            </div><div class="line">            <span class="comment">//当前线段的端点</span></div><div class="line">            from = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(last_x1, last_y1)];</div><div class="line">            to = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x1, y1)];</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(from != <span class="literal">nil</span> &amp;&amp; to != <span class="literal">nil</span>) &#123;</div><div class="line">                <span class="comment">//保存每一段的端点</span></div><div class="line">                [progressLinePaths addObject:@&#123;<span class="string">@"from"</span>: from,  <span class="string">@"to"</span>:to&#125;];</div><div class="line">                <span class="comment">//保存所有的端点</span></div><div class="line">                [lineStartEndPointsArray addObject:from];</div><div class="line">                [lineStartEndPointsArray addObject:to];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//保存所有折点的坐标</span></div><div class="line">            [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</div><div class="line">            <span class="comment">//将当前的x转化为下一个点的last_x（y也一样）</span></div><div class="line">            last_x = x;</div><div class="line">            last_y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//pointsOfPath：保存所有折线里的所有线段两端的端点</span></div><div class="line">    [pointsOfPath addObject:[lineStartEndPointsArray <span class="keyword">copy</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">//根据每一条线段的两个端点，成生每条线段的贝塞尔曲线</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *calculatedRanges =</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">            [currentProgressLine moveToPoint:[range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>]];</div><div class="line">            [currentProgressLine addLineToPoint:[range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>]];</div><div class="line">            [progressLines addObject:currentProgressLine];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"><a href="#7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。" class="headerlink" title="7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"></a>7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</h3><h4 id="7-1-所有线段的layer："><a href="#7-1-所有线段的layer：" class="headerlink" title="7.1 所有线段的layer："></a>7.1 所有线段的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)populateChartLines &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//遍历每条线段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = <span class="keyword">self</span>.chartPath[lineIndex];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">//_chartLineArray:二维数组，装载每个chartData对应的一个数组。这个数组的元素是这一条折线上所有线段对应的CAShapeLayer</span></div><div class="line">        [<span class="keyword">self</span>.chartLineArray[lineIndex] removeAllObjects];</div><div class="line">        </div><div class="line">        <span class="built_in">NSUInteger</span> progressLineIndex = <span class="number">0</span>;;</div><div class="line">        </div><div class="line">        <span class="comment">//遍历含有UIBezierPath对象元素的数组。在每个循环里新建一个CAShapeLayer对象，将UIBezierPath赋给它。</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *progressLinePath <span class="keyword">in</span> progressLines) &#123;</div><div class="line">            </div><div class="line">            PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</div><div class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">            </div><div class="line">            ...</div><div class="line">            </div><div class="line">            <span class="comment">//将当前线段的UIBezierPath赋给当前线段的CAShapeLayer</span></div><div class="line">            chartLine.path = progressLinePath.CGPath;</div><div class="line">            </div><div class="line">            <span class="comment">//添加layer</span></div><div class="line">            [<span class="keyword">self</span>.layer addSublayer:chartLine];</div><div class="line">            </div><div class="line">            <span class="comment">//保存当前线段的layer</span></div><div class="line">            [<span class="keyword">self</span>.chartLineArray[lineIndex] addObject:chartLine];</div><div class="line">            progressLineIndex++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-2-所有圆圈的layer："><a href="#7-2-所有圆圈的layer：" class="headerlink" title="7.2 所有圆圈的layer："></a>7.2 所有圆圈的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)recreatePointLayers &#123;</div><div class="line">- </div><div class="line">    <span class="keyword">for</span> (PNLineChartData *chartData <span class="keyword">in</span> _chartData) &#123;</div><div class="line">    </div><div class="line">        <span class="comment">// create as many chart line layers as there are data-lines</span></div><div class="line">        [<span class="keyword">self</span>.chartLineArray addObject:[<span class="built_in">NSMutableArray</span> new]];</div><div class="line"></div><div class="line">        <span class="comment">// create point</span></div><div class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">        pointLayer.strokeColor = [[chartData.color colorWithAlphaComponent:chartData.alpha] <span class="built_in">CGColor</span>];</div><div class="line">        pointLayer.lineCap = kCALineCapRound;</div><div class="line">        pointLayer.lineJoin = kCALineJoinBevel;</div><div class="line">        pointLayer.fillColor = <span class="literal">nil</span>;</div><div class="line">        pointLayer.lineWidth = chartData.lineWidth;</div><div class="line">        [<span class="keyword">self</span>.layer addSublayer:pointLayer];</div><div class="line">        [<span class="keyword">self</span>.chartPointArray addObject:pointLayer];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里并没有将所有圆圈的<code>UIBezierPath</code>赋给对应的<code>layer</code>，而是在下一步，绘图的时候做的。</p>
</blockquote>
<h3 id="8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画"><a href="#8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画" class="headerlink" title="8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画"></a>8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)strokeChart &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 绘制所有折线（所有线段+所有圆圈）</span></div><div class="line">    <span class="comment">// 遍历所有折线</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">       </div><div class="line">        PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有线段的CAShapeLayer</span></div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">CAShapeLayer</span> *&gt; *chartLines =<span class="keyword">self</span>.chartLineArray[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有圆圈的CAShapeLayer</span></div><div class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = (<span class="built_in">CAShapeLayer</span> *) <span class="keyword">self</span>.chartPointArray[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//开始绘制折线</span></div><div class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="keyword">self</span>.frame.size);</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有线段的UIBezierPath</span></div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = _chartPath[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有圆圈的UIBezierPath</span></div><div class="line">        <span class="built_in">UIBezierPath</span> *pointPath = _pointPath[lineIndex];</div><div class="line"></div><div class="line">        <span class="comment">//7.2将圆圈的UIBezierPath赋给了圆圈的CAShapeLayer</span></div><div class="line">        pointLayer.path = pointPath.CGPath;</div><div class="line"></div><div class="line">        <span class="comment">//添加动画</span></div><div class="line">        [<span class="built_in">CATransaction</span> begin];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; progressLines.count; index++) &#123;</div><div class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = chartLines[index];</div><div class="line">            <span class="comment">//chartLine strokeColor is already set. no need to override here</span></div><div class="line">            [chartLine addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</div><div class="line">            chartLine.strokeEnd = <span class="number">1.0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// if you want cancel the point animation, comment this code, the point will show immediately</span></div><div class="line">        <span class="keyword">if</span> (chartData.inflexionPointStyle != PNLineChartPointStyleNone) &#123;</div><div class="line">            [pointLayer addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//提交动画</span></div><div class="line">        [<span class="built_in">CATransaction</span> commit];</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">        <span class="comment">//绘制完毕</span></div><div class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要注意两点：</p>
<blockquote>
<p>1.如果想给layer添加动画，只需要实例化一个animation（在这里是<code>CABasicAnimation</code>）并调用layer的<code>addAnimation:</code>方法即可。我们看一下关于<code>CABasicAnimation</code>的实例化代码：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CABasicAnimation</span> *)pathAnimation &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.displayAnimated &amp;&amp; !_pathAnimation) &#123;</div><div class="line">        _pathAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</div><div class="line">        <span class="comment">//持续时间</span></div><div class="line">        _pathAnimation.duration = <span class="number">1.0</span>;</div><div class="line">         <span class="comment">//类型</span></div><div class="line">        _pathAnimation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">        _pathAnimation.fromValue = @<span class="number">0.0</span>f;</div><div class="line">        _pathAnimation.toValue = @<span class="number">1.0</span>f;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">self</span>.displayAnimated) &#123;</div><div class="line">        _pathAnimation = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _pathAnimation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2.在这里调用了<code>setNeedsDisplay</code>方法之后，会调用<code>drawRect：</code>方法，在这个方法里，完成了x，y坐标轴的绘制：</p>
</blockquote>
<h3 id="10-绘制x，y坐标轴"><a href="#10-绘制x，y坐标轴" class="headerlink" title="10.绘制x，y坐标轴"></a>10.绘制x，y坐标轴</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制坐标轴和背景竖线</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isShowCoordinateAxis) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> yAxisOffset = <span class="number">10.</span>f;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsPopContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsPushContext</span>(ctx);</div><div class="line">        <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="keyword">self</span>.axisWidth);</div><div class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="keyword">self</span>.axisColor <span class="built_in">CGColor</span>]);</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> xAxisWidth = <span class="built_in">CGRectGetWidth</span>(rect) - (_chartMarginLeft + _chartMarginRight) / <span class="number">2</span>;</div><div class="line">        <span class="built_in">CGFloat</span> yAxisHeight = _chartMarginBottom + _chartCavanHeight;</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制xy轴</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制y轴的箭头</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset - <span class="number">3</span>, <span class="number">6</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset + <span class="number">3</span>, <span class="number">6</span>);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制x轴的箭头</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight - <span class="number">3</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight + <span class="number">3</span>);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">//绘制x轴和y轴的label</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.showLabel) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 绘制x轴的小分割线</span></div><div class="line">            <span class="built_in">CGPoint</span> point;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</div><div class="line">                point = <span class="built_in">CGPointMake</span>(<span class="number">2</span> * _chartMarginLeft + (i * _xLabelWidth), _chartMarginBottom + _chartCavanHeight);</div><div class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y - <span class="number">2</span>);</div><div class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x, point.y);</div><div class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 绘制y轴的小分割线</span></div><div class="line">            <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</div><div class="line">                point = <span class="built_in">CGPointMake</span>(_chartMarginBottom + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</div><div class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</div><div class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x + <span class="number">2</span>, point.y);</div><div class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">11</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制y轴单位</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.yUnit length]) &#123;</div><div class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.yUnit withWidth:<span class="number">30.</span>f font:font].height;</div><div class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(_chartMarginLeft + <span class="number">10</span> + <span class="number">5</span>, <span class="number">0</span>, <span class="number">30.</span>f, height);</div><div class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.yUnit inRect:drawRect font:font color:<span class="keyword">self</span>.yLabelColor];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制x轴的单位</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.xUnit length]) &#123;</div><div class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.xUnit withWidth:<span class="number">30.</span>f font:font].height;</div><div class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, _chartMarginBottom + _chartCavanHeight - height / <span class="number">2</span>, <span class="number">25.</span>f, height);</div><div class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.xUnit inRect:drawRect font:font color:<span class="keyword">self</span>.xLabelColor];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制竖线</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.showYGridLines) &#123;</div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">CGFloat</span> yAxisOffset = _showLabel ? <span class="number">10.</span>f : <span class="number">0.0</span>f;</div><div class="line">        <span class="built_in">CGPoint</span> point;</div><div class="line">        </div><div class="line">        <span class="comment">//每一条竖线的跨度</span></div><div class="line">        <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</div><div class="line">        </div><div class="line">        <span class="comment">//颜色</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.yGridLinesColor) &#123;</div><div class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, <span class="keyword">self</span>.yGridLinesColor.CGColor);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> lightGrayColor].CGColor);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//绘制每一条竖线</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; _yLabelNum; i++) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//拿到起点</span></div><div class="line">            point = <span class="built_in">CGPointMake</span>(_chartMarginLeft + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</div><div class="line">            </div><div class="line">            <span class="comment">//将画笔移动到起点</span></div><div class="line">            <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</div><div class="line">            </div><div class="line">            <span class="comment">//设置线的属性</span></div><div class="line">            <span class="built_in">CGFloat</span> dash[] = &#123;<span class="number">6</span>, <span class="number">5</span>&#125;;</div><div class="line">            <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">0.5</span>);</div><div class="line">            <span class="built_in">CGContextSetLineCap</span>(ctx, kCGLineCapRound);</div><div class="line">            <span class="built_in">CGContextSetLineDash</span>(ctx, <span class="number">0.0</span>, dash, <span class="number">2</span>);</div><div class="line">            </div><div class="line">            <span class="comment">//设置这条线的终点</span></div><div class="line">            <span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, point.y);</div><div class="line">            </div><div class="line">            <span class="comment">//画线</span></div><div class="line">            <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> drawRect:rect];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，一张完整的图表就可以画出来了。但是当前绘制的图表的折线都是直线，在上面还展示了一张曲线图。那么如果想绘制带有曲线的折线图应该怎么做呢？对，就是在贝塞尔曲线上下功夫。</p>
<p>当我们获取了所有线段的端点数组后，我们可以通过他们绘制弯曲的贝塞尔曲线（注意：该方法是对应上面对第6项的下半部分:生成每一个线段对贝塞尔曲线）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//_showSmoothLines是用来控制是否绘制曲线折线的开关属性</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.showSmoothLines &amp;&amp; chartData.itemCount &gt;= <span class="number">4</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">            <span class="built_in">CGPoint</span> segmentP1 = [range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> segmentP2 = [range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            [currentProgressLine moveToPoint:segmentP1];</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> midPoint = [PNLineChart midPointBetweenPoint1:segmentP1 andPoint2:segmentP2];</div><div class="line">            </div><div class="line">            <span class="comment">//以每条线段以中间点为分割点，分成两组。每一组形成柔和的外凸曲线，而不是内凹</span></div><div class="line">            [currentProgressLine addQuadCurveToPoint:midPoint</div><div class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP1]];</div><div class="line">            </div><div class="line">            [currentProgressLine addQuadCurveToPoint:segmentP2</div><div class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP2]];</div><div class="line">            </div><div class="line">            [progressLines addObject:currentProgressLine];</div><div class="line">            [progressLineColors addObject:range[<span class="string">@"color"</span>]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下生成弯曲的贝塞尔曲线的方法：<code>controlPointBetweenPoint1:andPoint2</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回的点的x：是两点的中间；返回的点的y：与第二个点保持一致</span></div><div class="line">+ (<span class="built_in">CGPoint</span>)controlPointBetweenPoint1:(<span class="built_in">CGPoint</span>)point1 andPoint2:(<span class="built_in">CGPoint</span>)point2 &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//线段两端的中间点</span></div><div class="line">    <span class="built_in">CGPoint</span> controlPoint = [<span class="keyword">self</span> midPointBetweenPoint1:point1 andPoint2:point2];</div><div class="line">    </div><div class="line">    <span class="comment">//末端点 和  中间点y的差</span></div><div class="line">    <span class="built_in">CGFloat</span> diffY = abs((<span class="keyword">int</span>) (point2.y - controlPoint.y));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (point1.y &lt; point2.y)</div><div class="line">    <span class="comment">//如果前端点更高</span></div><div class="line">        controlPoint.y += diffY;</div><div class="line">    </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (point1.y &gt; point2.y)</div><div class="line">    <span class="comment">//如果后端点更高</span></div><div class="line">        controlPoint.y -= diffY;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> controlPoint;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，这样一来，直线的曲线图还有曲线的曲线图就大概掌握了。不过还差一个东西，就是图表对点击的响应。</p>
<p>我们需要思考一下：既然一张图表里可以显示多条折线，所以，当手指点击图表上的点以后，应该同时返回两个数据：</p>
<ol>
<li>点击了哪条折线上的这个点。</li>
<li>点击了这条折线上的哪个点。</li>
</ol>
<p>该框架的作者很好地完成了这两个任务，我们来看一下他是如何实现的：</p>
<h3 id="响应点击的代理方法"><a href="#响应点击的代理方法" class="headerlink" title="响应点击的代理方法"></a>响应点击的代理方法</h3><h4 id="点击了哪条折线的判断"><a href="#点击了哪条折线的判断" class="headerlink" title="点击了哪条折线的判断"></a>点击了哪条折线的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="comment">// Get the point user touched</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span> *linePointsArray = _endPointsOfPath[p];</div><div class="line">        </div><div class="line">        <span class="comment">//遍历每个端点</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// Closest distance from point to line</span></div><div class="line">            <span class="comment">//触摸点到线段的距离</span></div><div class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) fabs(((p2.x - p1.x) * (touchPoint.y - p1.y)) - ((p1.x - touchPoint.x) * (p1.y - p2.y)));</div><div class="line">            distance /= hypot(p2.x - p1.x, p1.y - p2.y);</div><div class="line">            </div><div class="line">            <span class="comment">//如果距离小于5，则判断为“点击了当前的线段”，剩下的工作是判断具体点击了哪一条线段</span></div><div class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">5.0</span>) &#123;</div><div class="line">                <span class="comment">// Conform to delegate parameters, figure out what bezier path this CGPoint belongs to.</span></div><div class="line">                <span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *paths <span class="keyword">in</span> _chartPath) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *path <span class="keyword">in</span> paths) &#123;</div><div class="line">                        <span class="comment">//如果当前点处于UIBezierPath曲线上</span></div><div class="line">                        <span class="built_in">BOOL</span> pointContainsPath = <span class="built_in">CGPathContainsPoint</span>(path.CGPath, <span class="literal">NULL</span>, p1, <span class="literal">NO</span>);</div><div class="line">                        <span class="keyword">if</span> (pointContainsPath) &#123;</div><div class="line">                            <span class="comment">//点击了某一条折线</span></div><div class="line">                            [_delegate userClickedOnLinePoint:touchPoint lineIndex:lineIndex];</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    lineIndex++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="点击了哪个点的判断"><a href="#点击了哪个点的判断" class="headerlink" title="点击了哪个点的判断"></a>点击了哪个点的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchKeyPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="comment">// Get the point user touched</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *linePointsArray = _pathPoints[p];</div><div class="line">        </div><div class="line">        <span class="comment">//遍历所有的点</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            <span class="comment">//获取到前一点的距离和后一点的距离</span></div><div class="line">            <span class="keyword">float</span> distanceToP1 = (<span class="keyword">float</span>) fabs(hypot(touchPoint.x - p1.x, touchPoint.y - p1.y));</div><div class="line">            <span class="keyword">float</span> distanceToP2 = (<span class="keyword">float</span>) hypot(touchPoint.x - p2.x, touchPoint.y - p2.y);</div><div class="line">            </div><div class="line">            <span class="keyword">float</span> distance = MIN(distanceToP1, distanceToP2);</div><div class="line">            </div><div class="line">            <span class="comment">//如果较小的距离小于10，则判定为点击了某个点</span></div><div class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">10.0</span>) &#123;</div><div class="line">                <span class="comment">//点击了某一条折线上的某个点</span></div><div class="line">                [_delegate userClickedOnLineKeyPoint:touchPoint</div><div class="line">                                           lineIndex:p</div><div class="line">                                          pointIndex:(distance == distanceToP2 ? i + <span class="number">1</span> : i)];</div><div class="line">                </div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这下就完整了，一个带有响应功能的图表就做好啦！</p>
<h3 id="关于自定义UIView"><a href="#关于自定义UIView" class="headerlink" title="关于自定义UIView"></a>关于自定义UIView</h3><p>这里只是将图表的<code>layer</code>加在了<code>UIView</code>的layer上，那如果想完全自定义view的话，只需将图表的<code>layer</code>完全赋给<code>UIView</code>的layer即可，这样一来，想要画出任意形状的<code>UIView</code>都可以。</p>
<hr>
<h2 id="三-最后的话"><a href="#三-最后的话" class="headerlink" title="三. 最后的话"></a>三. 最后的话</h2><p>关于图表的绘制，相对贝塞尔曲线与<code>CALayer</code>来说，数据的处理是一个比较麻烦的点。但是一旦学会了折线图的绘制，了解了绘图原理，那么其他类型的图表就可以触类旁通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-框架介绍&quot;&gt;&lt;a href=&quot;#一-框架介绍&quot; class=&quot;headerlink&quot; title=&quot;一. 框架介绍&quot;&gt;&lt;/a&gt;一. 框架介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kevinzhow/PNChart&quot;&gt;PNChart&lt;/a&gt;是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。&lt;/p&gt;
&lt;p&gt;该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类&lt;code&gt;PNGenericChart&lt;/code&gt;,第二层就是所有类型的图表。提供一张图来直观感受一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png&quot; alt=&quot;层级图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这张图里，需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带箭头的线和不带箭头的线的区别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data&lt;/code&gt;类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有&lt;code&gt;Data&lt;/code&gt;类，因为饼状图没有多组数据，而折线图&lt;code&gt;LineChart&lt;/code&gt;是支持多组数据的，所以有&lt;code&gt;Data&lt;/code&gt;类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Item&lt;/code&gt;类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BarChart&lt;/code&gt;类里面的每一根柱子都是&lt;code&gt;PNBar&lt;/code&gt;的实例（该类型的图表不在本篇讲解的范围之内）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MJRefresh源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/04/MJRefresh%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/04/MJRefresh 源码解析/</id>
    <published>2017-02-04T01:30:17.000Z</published>
    <updated>2017-03-20T07:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a>是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。</p>
<p>该框架的结构设计得很清晰，使用一个基类<code>MJRefreshComponent</code>来做一些基本的设定，然后通过继承的方式，让<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png" alt="框架组织结构图"></p>
<a id="more"></a>
<p>首先来看一下该控件的基类：MJRefreshComponent：</p>
<h2 id="MJRefreshComponent"><a href="#MJRefreshComponent" class="headerlink" title="MJRefreshComponent"></a>MJRefreshComponent</h2><p>这个类作为该控件几类，涵盖了基类所具备的成份：状态，回调block等，大致分成下面这5种职能：</p>
<h3 id="有哪些职能"><a href="#有哪些职能" class="headerlink" title="有哪些职能?"></a>有哪些职能?</h3><ol>
<li>声明控件的所有状态。</li>
<li>声明控件的回调函数。</li>
<li>添加监听。</li>
<li>提供刷新，停止刷新接口。</li>
<li>提供子类需要实现的方法。</li>
</ol>
<h3 id="职能如何实现？"><a href="#职能如何实现？" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><h4 id="1-声明控件的所有状态"><a href="#1-声明控件的所有状态" class="headerlink" title="1. 声明控件的所有状态"></a>1. 声明控件的所有状态</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 刷新控件的状态 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, MJRefreshState) &#123;</div><div class="line">    <span class="comment">/** 普通闲置状态 */</span></div><div class="line">    MJRefreshStateIdle = <span class="number">1</span>,</div><div class="line">    <span class="comment">/** 松开就可以进行刷新的状态 */</span></div><div class="line">    MJRefreshStatePulling,</div><div class="line">    <span class="comment">/** 正在刷新中的状态 */</span></div><div class="line">    MJRefreshStateRefreshing,</div><div class="line">    <span class="comment">/** 即将刷新的状态 */</span></div><div class="line">    MJRefreshStateWillRefresh,</div><div class="line">    <span class="comment">/** 所有数据加载完毕，没有更多的数据了 */</span></div><div class="line">    MJRefreshStateNoMoreData</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="2-声明控件的回调函数"><a href="#2-声明控件的回调函数" class="headerlink" title="2. 声明控件的回调函数"></a>2. 声明控件的回调函数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 进入刷新状态的回调 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentRefreshingBlock)();</div><div class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentbeginRefreshingCompletionBlock)();</div><div class="line"><span class="comment">/** 结束刷新后的回调 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentEndRefreshingCompletionBlock)();</div></pre></td></tr></table></figure>
<h4 id="3-添加监听"><a href="#3-添加监听" class="headerlink" title="3. 添加监听"></a>3. 添加监听</h4><p>监听的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObservers</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</div><div class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset options:options context:<span class="literal">nil</span>];<span class="comment">//contentOffset属性</span></div><div class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize options:options context:<span class="literal">nil</span>];<span class="comment">//contentSize属性</span></div><div class="line">    <span class="keyword">self</span>.pan = <span class="keyword">self</span>.scrollView.panGestureRecognizer;</div><div class="line">    [<span class="keyword">self</span>.pan addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState options:options context:<span class="literal">nil</span>];<span class="comment">//UIPanGestureRecognizer 的state属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于监听的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 遇到这些情况就直接返回</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 这个就算看不见也需要处理</span></div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewContentSizeDidChange:change];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 看不见</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewContentOffsetDidChange:change];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewPanStateDidChange:change];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-提供刷新，停止刷新接口"><a href="#4-提供刷新，停止刷新接口" class="headerlink" title="4. 提供刷新，停止刷新接口"></a>4. 提供刷新，停止刷新接口</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark 进入刷新状态</span></div><div class="line">- (<span class="keyword">void</span>)beginRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.beginRefreshingCompletionBlock = completionBlock;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> beginRefreshing];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)beginRefreshing</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        <span class="keyword">self</span>.alpha = <span class="number">1.0</span>;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.pullingPercent = <span class="number">1.0</span>;</div><div class="line">    <span class="comment">// 只要正在刷新，就完全显示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.window) &#123;</div><div class="line">        <span class="comment">//将状态切换为正在刷新</span></div><div class="line">        <span class="keyword">self</span>.state = MJRefreshStateRefreshing;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 预防正在刷新中时，调用本方法使得header inset回置失败</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateRefreshing) &#123;</div><div class="line">            <span class="comment">//将状态切换为即将刷新</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStateWillRefresh;</div><div class="line">            <span class="comment">// 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</span></div><div class="line">            [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark 结束刷新状态</span></div><div class="line">- (<span class="keyword">void</span>)endRefreshing</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.state = MJRefreshStateIdle;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)endRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.endRefreshingCompletionBlock = completionBlock;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> endRefreshing];</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark 是否正在刷新</span></div><div class="line">- (<span class="built_in">BOOL</span>)isRefreshing</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == MJRefreshStateRefreshing || <span class="keyword">self</span>.state == MJRefreshStateWillRefresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>交给子类实现的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 摆放子控件frame */</span></div><div class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div></pre></td></tr></table></figure>
<h4 id="5-提供子类需要实现的方法"><a href="#5-提供子类需要实现的方法" class="headerlink" title="5. 提供子类需要实现的方法"></a>5. 提供子类需要实现的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 交给子类们去实现</span></div><div class="line"><span class="comment">/** 初始化 */</span></div><div class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 摆放子控件frame */</span></div><div class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div></pre></td></tr></table></figure>
<p>从上面等结构图可以看出，紧接着这个基类，下面分为<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>,这里顺着<code>MJRefreshHeader</code>这个分支向下展开：</p>
<h2 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h2><p><code>MJRefreshHeader</code>继承于<code>MJRefreshComponent</code>，它做了这几件事：</p>
<h3 id="有哪些职能？"><a href="#有哪些职能？" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol>
<li>初始化。</li>
<li>设置header高度。</li>
<li>重新调整y值。</li>
<li>根据<code>contentOffset</code>的变化，来切换状态（默认状态，可以刷新的状态，正在刷新的状态），实现方法是：<code>scrollViewContentOffsetDidChange:</code>。</li>
<li>在切换状态时，执行相应的操作。实现方法是：<code>setState:</code>。</li>
</ol>
<h3 id="职能如何实现？-1"><a href="#职能如何实现？-1" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化</p>
<p>初始化有两种方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock</div><div class="line">&#123;</div><div class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="comment">//传入block</span></div><div class="line">    cmp.refreshingBlock = refreshingBlock;</div><div class="line">    <span class="keyword">return</span> cmp;</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingTarget:(<span class="keyword">id</span>)target refreshingAction:(SEL)action</div><div class="line">&#123;</div><div class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="comment">//设置self.refreshingTarget 和 self.refreshingAction</span></div><div class="line">    [cmp setRefreshingTarget:target refreshingAction:action];</div><div class="line">    <span class="keyword">return</span> cmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-设置header高度"><a href="#2-设置header高度" class="headerlink" title="2. 设置header高度"></a>2. 设置header高度</h4><p>通过重写<code>prepare</code>方法来设置header的高度：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置用于在NSUserDefaults里存储时间的key</span></div><div class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</div><div class="line">    </div><div class="line">    <span class="comment">// 设置header的高度</span></div><div class="line">    <span class="keyword">self</span>.mj_h = MJRefreshHeaderHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-重新调整y值"><a href="#3-重新调整y值" class="headerlink" title="3. 重新调整y值"></a>3. 重新调整y值</h4><p>通过重写<code>placeSubviews</code>方法来重新调整y值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)</span></div><div class="line">    <span class="keyword">self</span>.mj_y = - <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.ignoredScrollViewContentInsetTop;</div><div class="line">    <span class="comment">//self.ignoredScrollViewContentInsetTop 如果是10，那么就向上移动10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-状态切换的代码："><a href="#4-状态切换的代码：" class="headerlink" title="4. 状态切换的代码："></a>4. 状态切换的代码：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> scrollViewContentOffsetDidChange:change];</div><div class="line">    <span class="comment">// 正在刷新的状态</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.window == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//- self.scrollView.mj_offsetY：-（-54-64）= 118 ： 刷新的时候，偏移量是不动的。偏移量 = 状态栏 + 导航栏 + header的高度</span></div><div class="line">        <span class="comment">//_scrollViewOriginalInset.top：64 （状态栏 + 导航栏）</span></div><div class="line">        <span class="comment">//insetT 取二者之间大的那一个</span></div><div class="line">        <span class="built_in">CGFloat</span> insetT = - <span class="keyword">self</span>.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - <span class="keyword">self</span>.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</div><div class="line">       </div><div class="line">        <span class="comment">//118</span></div><div class="line">        insetT = insetT &gt; <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top ? <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top : insetT;</div><div class="line">        </div><div class="line">        <span class="comment">//设置contentInset</span></div><div class="line">        <span class="keyword">self</span>.scrollView.mj_insetT = insetT;</div><div class="line">        </div><div class="line">        <span class="comment">// 记录刷新的时候的偏移量 -54 = 64 - 118</span></div><div class="line">        <span class="keyword">self</span>.insetTDelta = _scrollViewOriginalInset.top - insetT;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 跳转到下一个控制器时，contentInset可能会变</span></div><div class="line">     _scrollViewOriginalInset = <span class="keyword">self</span>.scrollView.contentInset;</div><div class="line">    </div><div class="line">    <span class="comment">// 记录当前的contentOffset</span></div><div class="line">    <span class="built_in">CGFloat</span> offsetY = <span class="keyword">self</span>.scrollView.mj_offsetY;</div><div class="line"></div><div class="line">    <span class="comment">// 头部控件刚好全部出现的offsetY,默认是-64（20 + 44）</span></div><div class="line">    <span class="built_in">CGFloat</span> happenOffsetY = - <span class="keyword">self</span>.scrollViewOriginalInset.top;</div><div class="line">    </div><div class="line">    <span class="comment">// 向上滚动，直接返回</span></div><div class="line">    <span class="keyword">if</span> (offsetY &gt; happenOffsetY) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 从普通 到 即将刷新 的临界距离</span></div><div class="line">    <span class="built_in">CGFloat</span> normal2pullingOffsetY = happenOffsetY - <span class="keyword">self</span>.mj_h;<span class="comment">// -64 - 54 = -118</span></div><div class="line">    </div><div class="line">    <span class="comment">//下拉的百分比：下拉的距离与header高度的比值</span></div><div class="line">    <span class="built_in">CGFloat</span> pullingPercent = (happenOffsetY - offsetY) / <span class="keyword">self</span>.mj_h;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollView.isDragging) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//记录当前下拉的百分比</span></div><div class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</div><div class="line">            <span class="comment">// 如果当前为默认状态 &amp;&amp; 下拉的距离大于临界距离（将tableview下拉得很低），则将状态切换为可以刷新</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStatePulling;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</div><div class="line">            <span class="comment">// 如果当前状态为可以刷新 &amp;&amp; 下拉的距离小于临界距离，则将状态切换为默认</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStateIdle;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling) &#123;<span class="comment">// 即将刷新 &amp;&amp; 手松开</span></div><div class="line">        <span class="comment">// 手松开 &amp;&amp; 状态为可以刷新（MJRefreshStatePulling）时 开始刷新</span></div><div class="line">        [<span class="keyword">self</span> beginRefreshing];        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pullingPercent &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//手松开后，默认状态时，恢复self.pullingPercent</span></div><div class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意三点：</p>
<ol>
<li>这里的状态有三种：默认状态（MJRefreshStateIdle），可以刷新的状态（MJRefreshStatePulling）以及正在刷新的状态（MJRefreshStateRefreshing）。</li>
<li>状态切换的因素有两个：一个是下拉的距离是否超过临界值，另一个是 手指是否离开屏幕。</li>
<li>注意:<strong>可以刷新的状态</strong>和<strong>正在刷新的状态</strong>是不同的。因为在手指还贴在屏幕的时候是不能进行刷新的。所以即使在下拉的距离超过了临界距离（状态栏 + 导航栏 + header高度），如果手指没有离开屏幕，那么也不能马上进行刷新，而是将状态切换为：可以刷新。一旦手指离开了屏幕，马上将状态切换为正在刷新。 </li>
</ol>
</blockquote>
<p>这里提供一张图来体现三个状态的不同：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_2.png" alt="三个状态"></p>
<h4 id="5-状态切换时的相应操作："><a href="#5-状态切换时的相应操作：" class="headerlink" title="5. 状态切换时的相应操作："></a>5. 状态切换时的相应操作：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">   </div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//============== 设置状态为默认状态 =============//</span></div><div class="line">        </div><div class="line">        <span class="comment">//如果当前不是正在刷新就返回，因为这个方法主要针对从正在刷新状态（oldstate）到默认状态</span></div><div class="line">        <span class="keyword">if</span> (oldState != MJRefreshStateRefreshing) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//刷新完成后，保存刷新完成的时间</span></div><div class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:[<span class="built_in">NSDate</span> date] forKey:<span class="keyword">self</span>.lastUpdatedTimeKey];</div><div class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</div><div class="line">        </div><div class="line">        <span class="comment">// 恢复inset和offset</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">            </div><div class="line">            <span class="comment">//118 -&gt; 64（剪去了header的高度）</span></div><div class="line">            <span class="keyword">self</span>.scrollView.mj_insetT += <span class="keyword">self</span>.insetTDelta;</div><div class="line">            </div><div class="line">            <span class="comment">// 自动调整透明度</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.isAutomaticallyChangeAlpha) <span class="keyword">self</span>.alpha = <span class="number">0.0</span>;</div><div class="line">            </div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.pullingPercent = <span class="number">0.0</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.endRefreshingCompletionBlock) &#123;</div><div class="line">                <span class="comment">//调用刷新完成的block</span></div><div class="line">                <span class="keyword">self</span>.endRefreshingCompletionBlock();</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">         <span class="comment">//============== 设置状态为正在刷新状态 =============//</span></div><div class="line">         <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            </div><div class="line">             [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">               </div><div class="line">                <span class="built_in">CGFloat</span> top = <span class="keyword">self</span>.scrollViewOriginalInset.top + <span class="keyword">self</span>.mj_h;<span class="comment">//64 + 54 (都是默认的高度)</span></div><div class="line">                <span class="comment">// 重新设置contentInset，top = 118</span></div><div class="line">                <span class="keyword">self</span>.scrollView.mj_insetT = top;</div><div class="line">                <span class="comment">// 设置滚动位置</span></div><div class="line">                [<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, -top) animated:<span class="literal">NO</span>];</div><div class="line">                 </div><div class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                <span class="comment">//调用进行刷新的block</span></div><div class="line">                [<span class="keyword">self</span> executeRefreshingCallback];</div><div class="line">            &#125;];</div><div class="line">         &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意两点：</p>
<ol>
<li>这里状态的切换，主要围绕着两种：默认状态和正在刷新状态。也就是针对<strong>开始刷新</strong>和<strong>结束刷新</strong>这两个切换点。</li>
<li>从正在刷新状态状态切换为默认状态时（结束刷新），需要记录刷新结束的时间。因为header里面有一个默认的label是用来显示上次刷新的时间的。</li>
</ol>
</blockquote>
<h2 id="MJRefreshStateHeader"><a href="#MJRefreshStateHeader" class="headerlink" title="MJRefreshStateHeader"></a>MJRefreshStateHeader</h2><p>这个类是<code>MJRefreshHeader</code>类的子类，它做了两件事：</p>
<h3 id="有哪些职能？-1"><a href="#有哪些职能？-1" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol>
<li>简单布局了<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>。</li>
<li>根据控件状态的切换（默认状态，正在刷新状态），实现了这两个label显示的文字的切换。</li>
</ol>
<p>给一张图，让大家直观感受一下这两个控件：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_3.png" alt="两个Label"></p>
<h3 id="职能如何实现？-2"><a href="#职能如何实现？-2" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>这个类通过覆盖父类三个方法来实现上述两个实现：</p>
<h4 id="方法1：prepare方法"><a href="#方法1：prepare方法" class="headerlink" title="方法1：prepare方法"></a>方法1：prepare方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化间距</span></div><div class="line">    <span class="keyword">self</span>.labelLeftInset = MJRefreshLabelLeftInset;</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化文字</span></div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];</div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];</div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，将每一个状态对应的提示文字放入一个字典里面,key是状态的NSNumber形式</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (title == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">self</span>.stateTitles[@(state)] = title;</div><div class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(<span class="keyword">self</span>.state)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：placeSubviews方法"><a href="#方法2：placeSubviews方法" class="headerlink" title="方法2：placeSubviews方法"></a>方法2：placeSubviews方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> noConstrainsOnStatusLabel = <span class="keyword">self</span>.stateLabel.constraints.count == <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果更新时间label是隐藏的，则让状态label撑满整个header</span></div><div class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) <span class="keyword">self</span>.stateLabel.frame = <span class="keyword">self</span>.bounds;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果更新时间label不是隐藏的，根据约束设置更新时间label和状态label（高度各占一半）</span></div><div class="line">        <span class="built_in">CGFloat</span> stateLabelH = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) &#123;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_x = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_y = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_w = <span class="keyword">self</span>.mj_w;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_h = stateLabelH;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 更新时间label</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_x = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y = stateLabelH;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_w = <span class="keyword">self</span>.mj_w;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_h = <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里主要是对<code>lastUpdatedTimeLabel</code>和<code>stateLabel</code>进行布局。要注意<code>lastUpdatedTimeLabel</code>隐藏的情况。</p>
</blockquote>
<h4 id="方法3-setState-方法"><a href="#方法3-setState-方法" class="headerlink" title="方法3: setState:方法"></a>方法3: setState:方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="comment">// 设置状态文字</span></div><div class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(state)];</div><div class="line">    </div><div class="line">    <span class="comment">// 重新设置key（重新显示时间）</span></div><div class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = <span class="keyword">self</span>.lastUpdatedTimeKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，根据传入的state的不同，在<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>里切换相应的文字。</p>
<ul>
<li><code>stateLabel</code>里的文字直接从<code>stateTitles</code>字典里取出即可。</li>
<li><code>lastUpdatedTimeLabel</code>里的文字需要通过一个方法来取出即可：</li>
</ul>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setLastUpdatedTimeKey:(<span class="built_in">NSString</span> *)lastUpdatedTimeKey</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> setLastUpdatedTimeKey:lastUpdatedTimeKey];</div><div class="line">    </div><div class="line">    <span class="comment">// 如果label隐藏了，就不用再处理</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//根据key，从NSUserDefaults获取对应的NSData型时间</span></div><div class="line">    <span class="built_in">NSDate</span> *lastUpdatedTime = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:lastUpdatedTimeKey];</div><div class="line">    </div><div class="line">    <span class="comment">// 如果有block，从block里拿来时间，这应该是用户自定义显示时间格式的渠道</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeText) &#123;</div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = <span class="keyword">self</span>.lastUpdatedTimeText(lastUpdatedTime);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果没有block，就按照下面的默认方法显示时间格式</span></div><div class="line">    <span class="keyword">if</span> (lastUpdatedTime) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 获得了上次更新时间</span></div><div class="line">        <span class="comment">// 1.获得年月日</span></div><div class="line">        <span class="built_in">NSCalendar</span> *calendar = [<span class="keyword">self</span> currentCalendar];</div><div class="line">        <span class="built_in">NSUInteger</span> unitFlags = <span class="built_in">NSCalendarUnitYear</span>| <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitDay</span> |<span class="built_in">NSCalendarUnitHour</span> |<span class="built_in">NSCalendarUnitMinute</span>;</div><div class="line">        <span class="built_in">NSDateComponents</span> *cmp1 = [calendar components:unitFlags fromDate:lastUpdatedTime];</div><div class="line">        <span class="built_in">NSDateComponents</span> *cmp2 = [calendar components:unitFlags fromDate:[<span class="built_in">NSDate</span> date]];</div><div class="line">        </div><div class="line">        <span class="comment">// 2.格式化日期</span></div><div class="line">        <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">        <span class="built_in">BOOL</span> isToday = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> ([cmp1 day] == [cmp2 day]) &#123;</div><div class="line">            <span class="comment">//今天，省去年月日</span></div><div class="line">            formatter.dateFormat = <span class="string">@" HH:mm"</span>;</div><div class="line">            isToday = <span class="literal">YES</span>;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([cmp1 year] == [cmp2 year]) &#123; <span class="comment">// 今年</span></div><div class="line">            <span class="comment">//今年，省去年，显示月日</span></div><div class="line">            formatter.dateFormat = <span class="string">@"MM-dd HH:mm"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//其他，年月日都显示</span></div><div class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSString</span> *time = [formatter stringFromDate:lastUpdatedTime];</div><div class="line">        </div><div class="line">        <span class="comment">// 3.显示日期</span></div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@%@"</span>,</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</div><div class="line">                                          isToday ? [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderDateTodayText] : <span class="string">@""</span>,</div><div class="line">                                          time];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有获得上次更新时间（应该是第一次更新或者多次更新，之前的更新都失败了）</span></div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>,</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderNoneLastDateText]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里注意两点：</p>
<ol>
<li>作者通过使用block来让用户自己定义日期现实的格式，如果用户没有自定义，就使用作者提供的默认格式。</li>
<li>在默认格式的设置里，判断了是否是今日，是否是今年的情况。在以后设计显示时间的labe的时候可以借鉴一下。</li>
</ol>
</blockquote>
<h2 id="MJRefreshNormalHeader"><a href="#MJRefreshNormalHeader" class="headerlink" title="MJRefreshNormalHeader"></a>MJRefreshNormalHeader</h2><h3 id="有哪些职能？-2"><a href="#有哪些职能？-2" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>MJRefreshNormalHeader 继承于 MJRefreshStateHeader，它主要做了两件事：</p>
<ol>
<li>它在MJRefreshStateHeader上添加了<code>_arrowView</code>和<code>loadingView</code>。</li>
<li>布局了这两个view并在Refresh控件的状态切换的时候改变这两个view的样式。</li>
</ol>
<p>还是给一张图来直观感受一下这两个view：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_4.png" alt="两个view"></p>
<h3 id="职能如何实现？-3"><a href="#职能如何实现？-3" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>同MJRefreshStateHeader一样，也是重写了父类的三个方法：</p>
<h4 id="方法1：prepare"><a href="#方法1：prepare" class="headerlink" title="方法1：prepare"></a>方法1：prepare</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.activityIndicatorViewStyle = <span class="built_in">UIActivityIndicatorViewStyleGray</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：placeSubviews"><a href="#方法2：placeSubviews" class="headerlink" title="方法2：placeSubviews"></a>方法2：placeSubviews</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">// 首先将箭头的中心点x设为header宽度的一半</span></div><div class="line">    <span class="built_in">CGFloat</span> arrowCenterX = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.stateLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</div><div class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//在stateLabel里的文字宽度和更新时间里的文字宽度里取较宽的</span></div><div class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</div><div class="line">        <span class="comment">//根据self.labelLeftInset和textWidth向左移动中心点x</span></div><div class="line">        arrowCenterX -= textWidth / <span class="number">2</span> + <span class="keyword">self</span>.labelLeftInset;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//中心点y永远设置为header的高度的一半</span></div><div class="line">    <span class="built_in">CGFloat</span> arrowCenterY = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//获得了最终的center，而这个center同时适用于arrowView和loadingView，因为二者是不共存的。</span></div><div class="line">    <span class="built_in">CGPoint</span> arrowCenter = <span class="built_in">CGPointMake</span>(arrowCenterX, arrowCenterY);</div><div class="line">    </div><div class="line">    <span class="comment">// 箭头</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.arrowView.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//控件大小等于图片大小</span></div><div class="line">        <span class="keyword">self</span>.arrowView.mj_size = <span class="keyword">self</span>.arrowView.image.size;</div><div class="line">        <span class="keyword">self</span>.arrowView.center = arrowCenter;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">// 菊花</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.loadingView.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.loadingView.center = arrowCenter;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//arrowView的色调与stateLabel的字体颜色一致</span></div><div class="line">    <span class="keyword">self</span>.arrowView.tintColor = <span class="keyword">self</span>.stateLabel.textColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里注意一点：因为<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>是上下并排分布的，而<code>arrowView</code>或<code>loadingView</code>是在这二者的左边，所以为了避免这两组重合，在计算<code>arrowView</code>或<code>loadingView</code>的center的时候，需要获取<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>两个控件的宽度并比较大小，将较大的一个作为两个label的‘最宽距离’，再计算center，这样一来就不会重合了。<br>而对于如何计算宽度，作者给出了一个方案，大家可以在以后的实践中使用：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)mj_textWith &#123;</div><div class="line">    <span class="built_in">CGFloat</span> stringWidth = <span class="number">0</span>;</div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.text.length &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="meta">#if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span></div><div class="line">        stringWidth =[<span class="keyword">self</span>.text</div><div class="line">                      boundingRectWithSize:size</div><div class="line">                      options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></div><div class="line">                      attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:<span class="keyword">self</span>.font&#125;</div><div class="line">                      context:<span class="literal">nil</span>].size.width;</div><div class="line"><span class="meta">#else</span></div><div class="line">        </div><div class="line">        stringWidth = [<span class="keyword">self</span>.text sizeWithFont:<span class="keyword">self</span>.font</div><div class="line">                             constrainedToSize:size</div><div class="line">                                 lineBreakMode:<span class="built_in">NSLineBreakByCharWrapping</span>].width;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stringWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法3-setState"><a href="#方法3-setState" class="headerlink" title="方法3: setState:"></a>方法3: setState:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="comment">// 根据状态更新arrowView和loadingView的显示</span></div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//1. 设置为默认状态</span></div><div class="line">        <span class="keyword">if</span> (oldState == MJRefreshStateRefreshing) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//1.1 从正在刷新状态中切换过来</span></div><div class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            </div><div class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">                <span class="comment">//隐藏菊花</span></div><div class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">0.0</span>;</div><div class="line">                </div><div class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// 如果执行完动画发现不是idle状态，就直接返回，进入其他状态</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateIdle) <span class="keyword">return</span>;</div><div class="line">                <span class="comment">//菊花停止旋转</span></div><div class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>;</div><div class="line">                [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">                <span class="comment">//显示箭头</span></div><div class="line">                <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//1.2 从其他状态中切换过来</span></div><div class="line">            [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">            <span class="comment">//显示箭头并设置为初始状态</span></div><div class="line">            <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">                <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStatePulling) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//2. 设置为可以刷新状态</span></div><div class="line">        [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">            <span class="comment">//箭头倒立</span></div><div class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformMakeRotation</span>(<span class="number">0.000001</span> - M_PI);</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//3. 设置为正在刷新状态</span></div><div class="line">        <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>; <span class="comment">// 防止refreshing -&gt; idle的动画完毕动作没有被执行</span></div><div class="line">        <span class="comment">//菊花旋转</span></div><div class="line">        [<span class="keyword">self</span>.loadingView startAnimating];</div><div class="line">        <span class="comment">//隐藏arrowView</span></div><div class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此为止，我们已经从<code>MJRefreshComponent</code>到<code>MJRefreshNormalHeader</code>的实现过程看了一遍。可以看出，作者将<code>prepare</code>,<code>placeSubviews</code>以及<code>setState：</code>方法作为基类的方法，让下面的子类去一层一层实现。</p>
<p>而每一层的子类，根据自身的职责，分别按照自己的方式来实现这三个方法：</p>
<ul>
<li><code>MJRefreshHeader</code>: 负责header的高度和调整header自身在外部的位置。</li>
<li><code>MJRefreshStateHeader</code>:负责header内部的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>的布局和不同状态下内部文字的显示。</li>
<li><code>MJRefreshNormalHeader</code>:负责header内部的<code>loadingView</code>以及<code>arrowView</code>的布局和不同状态下的显示。</li>
</ul>
<p>这样做的好处是，如果想要增加某种类型的header，只要在某一层上做文章即可。例如该框架里的<code>MJRefreshGifHeader</code>,它和<code>MJRefreshNormalHeader</code>属于同一级，都是继承于<code>MJRefreshStateHeader</code>。因为二者都具有相同形式的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>，唯一不同的就是左侧的部分：</p>
<ul>
<li><code>MJRefreshNormalHeader</code>的左侧是箭头。</li>
<li><code>MJRefreshGifHeader</code>的左侧则是一个gif动画。</li>
</ul>
<p>还是提供一张图来直观感受一下：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_5.png" alt="normalHeader 与 gifHeader"></p>
<p>下面我们来看一下的实现：</p>
<h2 id="MJRefreshGifHeader"><a href="#MJRefreshGifHeader" class="headerlink" title="MJRefreshGifHeader"></a>MJRefreshGifHeader</h2><p>它提供了两个接口，是用来设置不同状态下使用的图片数组的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images duration:(<span class="built_in">NSTimeInterval</span>)duration forState:(MJRefreshState)state </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span> (images == <span class="literal">nil</span>) <span class="keyword">return</span>; </div><div class="line">    </div><div class="line">    <span class="comment">//设置不同状态下的图片组和持续时间</span></div><div class="line">    <span class="keyword">self</span>.stateImages[@(state)] = images; </div><div class="line">    <span class="keyword">self</span>.stateDurations[@(state)] = @(duration); </div><div class="line">    </div><div class="line">    <span class="comment">/* 根据图片设置控件的高度 */</span> </div><div class="line">    <span class="built_in">UIImage</span> *image = [images firstObject]; </div><div class="line">    <span class="keyword">if</span> (image.size.height &gt; <span class="keyword">self</span>.mj_h) &#123; </div><div class="line">        <span class="keyword">self</span>.mj_h = image.size.height; </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images forState:(MJRefreshState)state </div><div class="line">&#123; </div><div class="line">   <span class="comment">//如果没有传入duration，则根据图片的多少来计算</span></div><div class="line">    [<span class="keyword">self</span> setImages:images duration:images.count * <span class="number">0.1</span> forState:state]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="有哪些职能？-3"><a href="#有哪些职能？-3" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>然后，和<code>MJRefreshNormalHeader</code>一样，它也重写了基类提供的三个方法来实现显示gif图片的职能。</p>
<h3 id="职能如何实现？-4"><a href="#职能如何实现？-4" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化和label的间距<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化间距</span></div><div class="line">    <span class="keyword">self</span>.labelLeftInset = <span class="number">20</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####2. 根据label的宽度和存在与否设置gif的位置<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">//如果约束存在，就立即返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.gifView.constraints.count) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.gifView.frame = <span class="keyword">self</span>.bounds;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden &amp;&amp; <span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel都在隐藏状态，将gif剧中显示</span></div><div class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeCenter</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel中至少一个存在，则根据label的宽度设置gif的位置</span></div><div class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeRight</span>;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</div><div class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</div><div class="line">        <span class="keyword">self</span>.gifView.mj_w = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span> - textWidth * <span class="number">0.5</span> - <span class="keyword">self</span>.labelLeftInset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-根据传入状态的不同来设置动画"><a href="#3-根据传入状态的不同来设置动画" class="headerlink" title="3. 根据传入状态的不同来设置动画"></a>3. 根据传入状态的不同来设置动画</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//1. 如果传进来的状态是可以刷新和正在刷新</span></div><div class="line">        <span class="built_in">NSArray</span> *images = <span class="keyword">self</span>.stateImages[@(state)];</div><div class="line">        <span class="keyword">if</span> (images.count == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (images.count == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">//1.1 单张图片</span></div><div class="line">            <span class="keyword">self</span>.gifView.image = [images lastObject];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//1.2 多张图片</span></div><div class="line">            <span class="keyword">self</span>.gifView.animationImages = images;</div><div class="line">            <span class="keyword">self</span>.gifView.animationDuration = [<span class="keyword">self</span>.stateDurations[@(state)] doubleValue];</div><div class="line">            [<span class="keyword">self</span>.gifView startAnimating];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">        <span class="comment">//2.如果传进来的状态是默认状态</span></div><div class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>Footer类是用来处理上拉加载的，实现原理和下拉刷新很类似，在这里先不介绍了～</p>
<p>总的来说，该框架设计得非常工整：通过一个基类来定义一些状态和一些需要子类实现的接口。通过一层一层地继承，让每一层的子类各司其职，只完成真正属于自己的任务，提高了框架的可定制性，而且对于功能的扩展和bug的追踪也很有帮助，非常值得我们参考与借鉴。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot;&gt;MJRefresh&lt;/a&gt;是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。&lt;/p&gt;
&lt;p&gt;该框架的结构设计得很清晰，使用一个基类&lt;code&gt;MJRefreshComponent&lt;/code&gt;来做一些基本的设定，然后通过继承的方式，让&lt;code&gt;MJRefreshHeader&lt;/code&gt;和&lt;code&gt;MJRefreshFooter&lt;/code&gt;分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png&quot; alt=&quot;框架组织结构图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/04/SDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/04/SDWebImage源码解析/</id>
    <published>2017-02-04T01:24:37.000Z</published>
    <updated>2017-03-20T07:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信对于广大的iOS开发者，对<a href="https://github.com/rs/SDWebImage">SDWebImage</a>并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。</p>
<p>在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>] placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>] completed:^(<span class="built_in">UIImage</span> * _Nullable image, <span class="built_in">NSError</span> * _Nullable error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> * _Nullable imageURL) &#123;</div><div class="line">        </div><div class="line">        imageview.image = image;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图片加载完成"</span>);</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//图片下载完成后直接显示下载后的图片</span></div><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>]];</div></pre></td></tr></table></figure>
<p>在最开始先简单介绍这个框架：</p>
<p>这个框架的核心类是<code>SDWebImageManger</code>，在外部有<code>UIImageView+WebCache</code> 和 <code>UIButton+WebCache</code> 为下载图片的操作提供接口。内部有<code>SDWebImageManger</code>负责处理和协调 <code>SDWebImageDownloader</code> 和 <code>SDWebImageCache</code>：<code>SDWebImageDownloader</code>负责具体的下载任务，<code>SDWebImageCache</code>负责关于缓存的工作：添加，删除，查询缓存。</p>
<p>首先我们大致看一下这个框架的调用流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage"></p>
<p>从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。</p>
<p>OK～基本流程大概清楚了，我们看一下每个层具体实现吧～</p>
<a id="more"></a>
<hr>
<p>##UIKit层</p>
<p>该框架最外层的类是<code>UIImageView +WebCache</code>，我们将图片的URL，占位图片直接给这个类。下面是这个类的公共接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  UIImageView + WebCache.h ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>可以看出，这个类提供的接口非常灵活，可以根据我们自己的需求来调用其中某一个方法，而这些方法到最后都会走到：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>而这个方法里面，调用的是<code>UIView+WebCache</code>分类的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</div><div class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么不是UIImageView+WebCache而要上一层到UIView的分类里呢？<br>因为SDWebImage框架也支持UIButton的下载图片等方法，所以需要在它们的父类：UIView里面统一一个下载方法。</p>
</blockquote>
<p>简单看一下这个方法的实现（省略的代码用…代替）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line"></div><div class="line">   <span class="comment">//valid key：UIImageView || UIButton</span></div><div class="line">   <span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</div><div class="line">   <span class="comment">//UIView+WebCacheOperation 的 operationDictionary</span></div><div class="line">   <span class="comment">//下面这行代码是保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突</span></div><div class="line">   [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</div><div class="line">   </div><div class="line"></div><div class="line">   <span class="comment">//添加临时的占位图（在不延迟添加占位图的option下）</span></div><div class="line">   <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">       &#125;);</div><div class="line">   &#125;    </div><div class="line">   <span class="comment">//如果url存在</span></div><div class="line">   <span class="keyword">if</span> (url) &#123;     </div><div class="line">      ...</div><div class="line">       __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">      <span class="comment">//SDWebImageManager下载图片</span></div><div class="line">       <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">         </div><div class="line">           ...</div><div class="line">           <span class="comment">//dispatch_main_sync_safe : 保证block能在主线程进行</span></div><div class="line">           dispatch_main_async_safe(^&#123;</div><div class="line">               </div><div class="line">               <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;               </div><div class="line">               <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">                    <span class="comment">//image，而且不自动替换 placeholder image</span></div><div class="line">                   completedBlock(image, error, cacheType, url);</div><div class="line">                   <span class="keyword">return</span>;                    </div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                   <span class="comment">//存在image，需要马上替换 placeholder image</span></div><div class="line">                   [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                   [sself sd_setNeedsLayout];                </div><div class="line">               &#125; <span class="keyword">else</span> &#123;                    </div><div class="line">                   <span class="comment">//没有image，在图片下载完之后显示 placeholder image</span></div><div class="line">                   <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                       [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                       [sself sd_setNeedsLayout];</div><div class="line">                   &#125;</div><div class="line">               &#125;                </div><div class="line">               <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                   completedBlock(image, error, cacheType, url);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;];</div><div class="line">       </div><div class="line">       <span class="comment">//在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行</span></div><div class="line">       [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];        </div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">//如果url不存在，就在completedBlock里传入error（url为空）</span></div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           [<span class="keyword">self</span> sd_removeActivityIndicator];</div><div class="line">           <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">               <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">               completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，在这一层，使用一个字典<code>operationDictionary</code>专门用作存储操作的缓存，随时添加，删除操作任务。<br>而这个字典是<code>UIView+WebCacheOperation</code>分类的关联对象，它的存取方法使用运行时来操作：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  UIView+WebCacheOperation.m ============== //</span></div><div class="line"> <span class="comment">//获取关联对象：operations（用来存放操作的字典）</span></div><div class="line">- (SDOperationsDictionary *)operationDictionary &#123;</div><div class="line">    SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line">    <span class="comment">//存放操作的字典</span></div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">return</span> operations;</div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//如果没有，就新建一个</span></div><div class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];    </div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    <span class="keyword">return</span> operations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么不直接在<code>UIImageView+WebCache</code>里直接关联这个对象呢？我觉得这里作者应该是遵从面向对象的<strong>单一职责原则（SRP：Single responsibility principle）</strong>，就连类都要履行这个职责，何况分类呢？这里作者专门创造一个分类<code>UIView+WebCacheOperation</code>来管理操作缓存（字典）。</p>
</blockquote>
<p>到这里，<code>UIKit</code>层上面的东西都讲完了，现在开始正式讲解工具层。</p>
<h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>上文提到过，<code>SDWebImageManager</code>同时管理<code>SDImageCache</code>和<code>SDWebImageDownloader</code>两个类，它是这一层的<strong>老大哥</strong>。在下载任务开始的时候，<code>SDWebImageManager</code>首先访问<code>SDImageCache</code>来查询是否存在缓存，如果有缓存，直接返回缓存的图片。如果没有缓存，就命令<code>SDWebImageDownloader</code>来下载图片，下载成功后，存入缓存，显示图片。以上是<code>SDWebImageManager</code>大致的工作流程。</p>
<p>在详细讲解<code>SDWebImageManager</code>是如何下载图片之前，我们先看一下这个类的几个重要的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageManager.h ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDImageCache *imageCache;<span class="comment">//管理缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDWebImageDownloader <span class="comment">//下载器*imageDownloader;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSURL</span> *&gt; *failedURLs;<span class="comment">//记录失效url的名单</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDWebImageCombinedOperation *&gt; *runningOperations;<span class="comment">//记录当前正在执行的操作</span></div></pre></td></tr></table></figure>
<p><code>SDWebImageManager</code>下载图片的方法只有一个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SDWebImageManager.sharedManager loadImageWithURL:options:progress:completed:]</div></pre></td></tr></table></figure>
<p>看一下这个方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageManager.m ============== //</span></div><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">     ...                             </div><div class="line">    <span class="comment">//在SDImageCache里查询是否存在缓存的图片</span></div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;        </div><div class="line">        ...</div><div class="line">        <span class="comment">//（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片） || （代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片）</span></div><div class="line">        <span class="keyword">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;            </div><div class="line">            <span class="comment">//1. 存在缓存图片 &amp;&amp; 即使有缓存图片也要下载更新图片</span></div><div class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 2. 如果不存在缓存图片</span></div><div class="line">            ...            </div><div class="line">            <span class="comment">//开启下载器下载</span></div><div class="line">            <span class="comment">//subOperationToken 用来标记当前的下载任务，便于被取消</span></div><div class="line">            SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// 1. 如果任务被取消，则什么都不做，避免和其他的completedBlock重复</span></div><div class="line">                </div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//2. 如果有错误</span></div><div class="line">                    <span class="comment">//2.1 在completedBlock里传入error</span></div><div class="line">                    [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url];</div><div class="line"></div><div class="line">							<span class="comment">//2.2 在错误url名单中添加当前的url</span></div><div class="line">                    <span class="keyword">if</span> (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</div><div class="line">                        </div><div class="line">                       <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs addObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//3. 下载成功</span></div><div class="line">                    <span class="comment">//3.1 如果需要下载失败后重新下载，则将当前url从失败url名单里移除</span></div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="comment">//3.2 进行缓存</span></div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);                   </div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                    </div><div class="line">                        <span class="comment">//（即使缓存存在，也要刷新图片） &amp;&amp; 缓存图片 &amp;&amp; 不存在下载后的图片：不做操作</span></div><div class="line">                                           </div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        </div><div class="line">          <span class="comment">//（下载图片成功 &amp;&amp; （没有动图||处理动图） &amp;&amp; （下载之后，缓存之前处理图片）               dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span></div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">                                <span class="comment">//缓存图片</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//将图片传入completedBlock</span></div><div class="line">                            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                        &#125;);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//(图片下载成功并结束)</span></div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">					 <span class="comment">//如果完成，从当前运行的操作列表里移除当前操作</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">            <span class="comment">//取消的block</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">            </div><div class="line">                <span class="comment">//取消当前的token</span></div><div class="line">                [<span class="keyword">self</span>.imageDownloader cancel:subOperationToken];</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="comment">//从当前运行的操作列表里移除当前操作</span></div><div class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            &#125;;</div><div class="line">        </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//存在缓存图片</span></div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;            </div><div class="line">            <span class="comment">//调用完成的block</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];            </div><div class="line">            <span class="comment">//删去当前的的下载操作（线程安全）</span></div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];        </div><div class="line">        &#125; <span class="keyword">else</span> &#123;            </div><div class="line">            <span class="comment">//没有缓存的图片，而且下载被代理终止了</span></div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">           </div><div class="line">            <span class="comment">// 调用完成的block</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:<span class="literal">YES</span> url:url];            </div><div class="line">            <span class="comment">//删去当前的下载操作</span></div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;                                                             </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完了<code>SDWebImageManager</code>的回调处理，我们分别看一下<br><code>SDImageCache</code>和<code>SDWebImageDownloader</code>内部具体是如何工作的。首先看一下<code>SDImageCache</code>：</p>
<h3 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSCache</span> *memCache;<span class="comment">//内存缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;<span class="comment">//磁盘缓存路径</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;<span class="comment">//</span></div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> <span class="comment">//ioQueue唯一子线程;</span></div></pre></td></tr></table></figure>
<h4 id="核心方法：查询缓存"><a href="#核心方法：查询缓存" class="headerlink" title="核心方法：查询缓存"></a>核心方法：查询缓存</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;   </div><div class="line">    <span class="keyword">if</span> (!key) &#123;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;		</div><div class="line">    <span class="comment">//================查看内存的缓存=================//</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];    </div><div class="line">    <span class="comment">// 如果存在，直接调用block，将image，data，CaheType传进去</span></div><div class="line">    <span class="keyword">if</span> (image) &#123;    </div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;        </div><div class="line">        <span class="comment">//如果是gif，就拿到data，后面要传到doneBlock里。不是gif就传nil</span></div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;        </div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//因为图片有缓存可供使用，所以不用实例化NSOperation，直接范围nil</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//================查看磁盘的缓存=================//</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];    </div><div class="line">    <span class="comment">//唯一的子线程：self.ioQueue</span></div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;        </div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// 在用之前就判断operation是否被取消了，作者考虑的非常严谨</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;            </div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];            </div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                  <span class="comment">// cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。</span></div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);                </div><div class="line">                <span class="comment">//存入内存缓存中</span></div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;<span class="comment">//下载队列</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *lastAddedOperation;<span class="comment">//最后添加的下载操作</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) Class operationClass;<span class="comment">//操作类</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, SDWebImageDownloaderOperation *&gt; *URLOperations;<span class="comment">//操作数组</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDHTTPHeadersMutableDictionary *HTTPHeaders;<span class="comment">//HTTP请求头</span></div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;<span class="comment">//用来阻塞前面的下载线程（串行化）</span></div></pre></td></tr></table></figure>
<h4 id="核心方法：下载图片"><a href="#核心方法：下载图片" class="headerlink" title="核心方法：下载图片"></a>核心方法：下载图片</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        </div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">        </div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">        </div><div class="line">        <span class="comment">//创建下载请求</span></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//创建下载操作：SDWebImageDownloaderOperation用于请求网络资源的操作，它是一个 NSOperation 的子类</span></div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="comment">//url证书</span></div><div class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//优先级</span></div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//在下载队列里添加下载操作，执行下载操作</span></div><div class="line">        [sself.downloadQueue addOperation:operation];</div><div class="line">        </div><div class="line">        <span class="comment">//如果后进先出</span></div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            <span class="comment">//addDependency:参数opertaion倍添加到NSOperationQueue后，只有等该opertion结束后才能执行其他的operation，实现了后进先出</span></div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面还有一个<code>addProgressCallback: progressBlock: completedBlock: forURL: createCallback:</code>方法，用来保存<code>progressBlock</code>和<code>completedBlock</code>。我们看一下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123;</div><div class="line"></div><div class="line">    <span class="comment">// url 用来作为回调字典的key，如果为空，立即返回失败 </span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    __block SDWebImageDownloadToken *token = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">//串行化前面所有的操作</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;    </div><div class="line">        	<span class="comment">//当前下载操作中取出SDWebImageDownloaderOperation实例</span></div><div class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];        </div><div class="line">        <span class="keyword">if</span> (!operation) &#123;</div><div class="line">        <span class="comment">//如果没有，就初始化它</span></div><div class="line">            operation = createCallback();</div><div class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</div><div class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            </div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</div><div class="line">              <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</div><div class="line">                  [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">              &#125;;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">        <span class="comment">//这里 downloadOperationCancelToken 默认是一个字典，存放 progressBlock 和 completedBlock</span></div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里真正保存两个block的方法是<code>addHandlersForProgress: completed:</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    <span class="comment">//实例化一个SDCallbacksDictionary，存放一个progressBlock 和 completedBlock</span></div><div class="line">    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">    dispatch_barrier_async(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        <span class="comment">//添加到缓存中 self.callbackBlocks</span></div><div class="line">        [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里<code>SDWebImage</code>的核心方法都讲解完毕了，其他没有讲到的部分以后会慢慢添加上去。</p>
<h2 id="最后看一下一些比较零散的知识点："><a href="#最后看一下一些比较零散的知识点：" class="headerlink" title="最后看一下一些比较零散的知识点："></a>最后看一下一些比较零散的知识点：</h2><hr>
<h4 id="1-运行时存取关联对象："><a href="#1-运行时存取关联对象：" class="headerlink" title="1. 运行时存取关联对象："></a>1. 运行时存取关联对象：</h4><p><strong>存：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"><span class="comment">//将operations对象关联给self，地址为&amp;loadOperationKey，语义是OBJC_ASSOCIATION_RETAIN_NONATOMIC。</span></div></pre></td></tr></table></figure>
<p><strong>取：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line"><span class="comment">//将operations对象通过地址&amp;loadOperationKey从self里取出来</span></div></pre></td></tr></table></figure>
<h4 id="2-数组的写操作需要加锁（多线程访问，避免覆写）"><a href="#2-数组的写操作需要加锁（多线程访问，避免覆写）" class="headerlink" title="2. 数组的写操作需要加锁（多线程访问，避免覆写）"></a>2. 数组的写操作需要加锁（多线程访问，避免覆写）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给self.runningOperations加锁</span></div><div class="line"><span class="comment">//self.runningOperations数组的添加操作</span></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div><div class="line"><span class="comment">//self.runningOperations数组的删除操作</span></div><div class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        <span class="keyword">if</span> (operation) &#123;</div><div class="line">            [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-确保在主线程的宏："><a href="#3-确保在主线程的宏：" class="headerlink" title="3. 确保在主线程的宏："></a>3. 确保在主线程的宏：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_main_async_safe(^&#123;</div><div class="line"> 				 <span class="comment">//将下面这段代码放在主线程中</span></div><div class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line"><span class="comment">//宏定义：</span></div><div class="line"><span class="meta">#define dispatch_main_async_safe(block)\</span></div><div class="line">    <span class="keyword">if</span> (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == <span class="number">0</span>) &#123;\</div><div class="line">        block();\</div><div class="line">    &#125; <span class="keyword">else</span> &#123;\</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), block);\</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<h4 id="4-设置不能为nil的参数"><a href="#4-设置不能为nil的参数" class="headerlink" title="4. 设置不能为nil的参数"></a>4. 设置不能为nil的参数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        _imageCache = cache;</div><div class="line">        _imageDownloader = downloader;</div><div class="line">        _failedURLs = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">        _runningOperations = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果在参数里添加了nonnull关键字，那么编译器就可以检查传入的参数是否为nil，如果是，则编译器会有警告</p>
</blockquote>
<h4 id="5-容错，强制转换类型"><a href="#5-容错，强制转换类型" class="headerlink" title="5. 容错，强制转换类型"></a>5. 容错，强制转换类型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</div><div class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在传入的参数为NSString时（但是方法参数要求是NSURL），自动转换为NSURL</p>
</blockquote>
<hr>
<p>貌似还有图片解码等内容没有详细看，以后会逐渐补充哒～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信对于广大的iOS开发者，对&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。&lt;/p&gt;
&lt;p&gt;在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;] placeholderImage:[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;placeholder&quot;&lt;/span&gt;] completed:^(&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; * _Nullable image, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nullable error, SDImageCacheType cacheType, &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; * _Nullable imageURL) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        imageview.image = image;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;图片加载完成&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//图片下载完成后直接显示下载后的图片&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;]];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在最开始先简单介绍这个框架：&lt;/p&gt;
&lt;p&gt;这个框架的核心类是&lt;code&gt;SDWebImageManger&lt;/code&gt;，在外部有&lt;code&gt;UIImageView+WebCache&lt;/code&gt; 和 &lt;code&gt;UIButton+WebCache&lt;/code&gt; 为下载图片的操作提供接口。内部有&lt;code&gt;SDWebImageManger&lt;/code&gt;负责处理和协调 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 和 &lt;code&gt;SDWebImageCache&lt;/code&gt;：&lt;code&gt;SDWebImageDownloader&lt;/code&gt;负责具体的下载任务，&lt;code&gt;SDWebImageCache&lt;/code&gt;负责关于缓存的工作：添加，删除，查询缓存。&lt;/p&gt;
&lt;p&gt;首先我们大致看一下这个框架的调用流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SDWebImage&quot;&gt;&lt;/p&gt;
&lt;p&gt;从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。&lt;/p&gt;
&lt;p&gt;OK～基本流程大概清楚了，我们看一下每个层具体实现吧～&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MBProgressHUD源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/17/MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/17/MBProgressHUD源码解析/</id>
    <published>2017-01-17T09:02:54.000Z</published>
    <updated>2017-03-20T07:56:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的<strong>读好源码Project</strong>。</p>
<p>从哪个框架开始呢？我想到了<code>SDWebImage</code>，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～</p>
<p>找着找着就找到了<code>MBProgressHUD</code>，这个框架只有两个文件，一个头文件和一个实现文件，很适合我现在的水平（对于一个没怎么读过源码的选手），于是就撸起了袖子开始了。</p>
<p>连查知识点带记笔记一共花了大概3个小时（虽然文件很少，但是里面好多东西都不知道[捂脸]）。整体说来，收获还是比较大的，除了一些零碎的语法之外，框架作者对于代码结构的设计和各种情况的考虑还是很出色的，很值得学习，而且我在下文也有介绍。</p>
<p>这篇总结主要分三个部分来介绍这个框架：</p>
<ol>
<li>核心Public API</li>
<li>方法调用流程图</li>
<li>方法内部实现</li>
</ol>
<p>不多说了，开始吧～</p>
<a id="more"></a>
<h2 id="1-核心Public-API"><a href="#1-核心Public-API" class="headerlink" title="1. 核心Public API"></a>1. 核心Public API</h2><h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDMode mode;<span class="comment">//HUD的类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDAnimation animationType <span class="built_in">UI_APPEARANCE_SELECTOR</span>;<span class="comment">//动画类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> graceTime;<span class="comment">//show函数触发到显示HUD的时间段</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> minShowTime;<span class="comment">//HUD显示的最短时间</span></div></pre></td></tr></table></figure>
<h3 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在某个view上添加HUD并显示</div><div class="line"> *</div><div class="line"> * 注意：显示之前，先去掉在当前view上显示的HUD。这个做法很严谨，我们将这个方案抽象出来：如果一个模型是这样的：我们需要将A加入到B中，但是需求上B里面只允许只有一个A。那么每次将A添加到B之前，都要先判断当前的b里面是否有A，如果有，则移除。</div><div class="line"> */</div><div class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 找到某个view上最上层的HUD并隐藏它。</div><div class="line"> * 如果返回值是YES的话，就表明HUD被找到而且被移除了。</div><div class="line"> */</div><div class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 在某个view上找到最上层的HUD并返回它。</div><div class="line"> * 返回值可以是空，所以返回值的关键字为：nullable</div><div class="line"> */</div><div class="line">+ (<span class="keyword">nullable</span> MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view;</div></pre></td></tr></table></figure>
<h3 id="对象方法："><a href="#对象方法：" class="headerlink" title="对象方法："></a>对象方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个HUD的便利构造函数，用某个view来初始化HUD：这个view的bounds就是HUD的bounds</div><div class="line"> */</div><div class="line">- (<span class="keyword">instancetype</span>)initWithView:(<span class="built_in">UIView</span> *)view;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 显示HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 隐藏HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 在delay的时间过后隐藏HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</div></pre></td></tr></table></figure>
<p>看完了这些比较主要的API，我们看一下方法调用的流程图：</p>
<h2 id="2-方法调用流程图："><a href="#2-方法调用流程图：" class="headerlink" title="2. 方法调用流程图："></a>2. 方法调用流程图：</h2><p>总体来说，这个第三方框架的接口还是比较整齐的，可以大致上分为两类：显示（show）和隐藏（hide）。而且无论是调用显示方法还是隐藏方法，最终都会走到私有方法<code>animateIn:withType: completion:</code>里（前提是附加动画效果）。可以看一下方法调用的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-fe3f0f393bcc3b9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法调用流程图"></p>
<p>看完方法调用的结构之后，我们来具体看一下方法内部是如何实现的：</p>
<h2 id="3-方法内部实现："><a href="#3-方法内部实现：" class="headerlink" title="3. 方法内部实现："></a>3. 方法内部实现：</h2><p>在讲解API之前，有必要先介绍一下HUD使用的三个Timer。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *graceTimer; <span class="comment">//执行一次：在show方法触发后到HUD真正显示之前,前提是设定了graceTime，默认为0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *minShowTimer;<span class="comment">//执行一次：在HUD显示后到HUD被隐藏之前</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *hideDelayTimer;<span class="comment">//执行一次：在HUD被隐藏的方法触发后到真正隐藏之前</span></div></pre></td></tr></table></figure>
<ul>
<li>graceTimer：用来推迟HUD的显示。如果设定了graceTime，那么HUD会在<code>show</code>方法触发后的graceTime时间后显示。它的意义是：如果任务完成所消耗的时间非常短并且短于graceTime，则HUD就不会出现了，避免HUD一闪而过的差体验。</li>
<li>minShowTimer：如果设定了minShowTime，就会在<code>hide</code>方法触发后判断任务执行的时间是否短于minShowTime。因此即使任务在minShowTime之前完成了，HUD也不会立即消失，它会在走完minShowTime之后才消失，这应该也是避免HUD一闪而过的情况。</li>
<li>hideDelayTimer：用来推迟HUD的隐藏。如果设定了delayTime，那么在触发<code>hide</code>方法后HUD也不会立即隐藏，它会在走完delayTime之后才隐藏。</li>
</ul>
<p>这三者的关系可以由下面这张图来体现（并没有包含所有的情况）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c9f49bfcec64dd0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三种timer"></p>
<p>下面开始分别讲解<code>show</code>系列的方法和<code>hide</code>系列的方法。</p>
<h3 id="show系列方法"><a href="#show系列方法" class="headerlink" title="show系列方法"></a>show系列方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBProgressHUD *hud = [[<span class="keyword">self</span> alloc] initWithView:view];<span class="comment">// 接着调用 [self initWithFrame:view.bounds]：根据传进来的view的frame来设定自己的frame</span></div><div class="line">    hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;<span class="comment">//removeFromSuperViewOnHide 应该是一个标记，表明HUD自己处于“应该被移除的状态”</span></div><div class="line">    [view addSubview:hud];<span class="comment">//在view上将自己的实例添加上去</span></div><div class="line">    [hud showAnimated:animated];</div><div class="line">    <span class="keyword">return</span> hud;</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用showAnimated：</span></div><div class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBMainThreadAssert();</div><div class="line">    [<span class="keyword">self</span>.minShowTimer invalidate];<span class="comment">//取消当前的minShowTimer</span></div><div class="line">     <span class="keyword">self</span>.useAnimation = animated;<span class="comment">//设置animated状态</span></div><div class="line">     <span class="keyword">self</span>.finished = <span class="literal">NO</span>;<span class="comment">//添加标记：表明当前任务仍在进行</span></div><div class="line">    <span class="comment">// 如果设定了graceTime，就要推迟HUD的显示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.graceTime &gt; <span class="number">0.0</span>) &#123;</div><div class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.graceTime target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleGraceTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line">        <span class="keyword">self</span>.graceTimer = timer;</div><div class="line">    &#125; </div><div class="line">    <span class="comment">// ... otherwise show the HUD immediately</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//self.graceTimer触发的方法</span></div><div class="line">- (<span class="keyword">void</span>)handleGraceTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</div><div class="line">    <span class="comment">// Show the HUD only if the task is still running</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.hasFinished) &#123;</div><div class="line">        [<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//所有的show方法最终都会走到这个方法</span></div><div class="line">- (<span class="keyword">void</span>)showUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    <span class="comment">// Cancel any previous animations : 移走所有的动画</span></div><div class="line">    [<span class="keyword">self</span>.bezelView.layer removeAllAnimations];</div><div class="line">    [<span class="keyword">self</span>.backgroundView.layer removeAllAnimations];</div><div class="line">    <span class="comment">// Cancel any scheduled hideDelayed: calls :取消delay的timer</span></div><div class="line">    [<span class="keyword">self</span>.hideDelayTimer invalidate];</div><div class="line">    <span class="comment">//记忆开始的时间</span></div><div class="line">    <span class="keyword">self</span>.showStarted = [<span class="built_in">NSDate</span> date];</div><div class="line">    <span class="keyword">self</span>.alpha = <span class="number">1.</span>f;</div><div class="line">    <span class="comment">// Needed in case we hide and re-show with the same NSProgress object attached.</span></div><div class="line">    [<span class="keyword">self</span> setNSProgressDisplayLinkEnabled:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">if</span> (animated) &#123;        </div><div class="line">        [<span class="keyword">self</span> animateIn:<span class="literal">YES</span> withType:<span class="keyword">self</span>.animationType completion:<span class="literal">NULL</span>];   </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//方法弃用警告</span></div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">        <span class="keyword">self</span>.bezelView.alpha = <span class="keyword">self</span>.opacity;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，无论是类方法的show方法，还是对象方法的show方法，而且无论是触发了<code>graceTimer</code>还是没有触发，最后都会走到<code>showUsingAnimation:</code>方法来让HUD显示出来。</p>
</blockquote>
<p>这里补充讲解一下NSProgress的监听方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setNSProgressDisplayLinkEnabled:(<span class="built_in">BOOL</span>)enabled &#123;</div><div class="line">    <span class="comment">// 这里使用 CADisplayLink 来刷新progress的变化。因为如果使用kvo机制来监听的话可能会非常消耗主线程（因为频率可能非常快）。</span></div><div class="line">    <span class="keyword">if</span> (enabled &amp;&amp; <span class="keyword">self</span>.progressObject) &#123;</div><div class="line">        <span class="comment">// Only create if not already active.</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.progressObjectDisplayLink) &#123;</div><div class="line">            <span class="keyword">self</span>.progressObjectDisplayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateProgressFromProgressObject)];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//不刷新</span></div><div class="line">        <span class="keyword">self</span>.progressObjectDisplayLink = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。 CADisplayLink以特定模式注册到runloop后， 每当屏幕显示内容刷新结束的时候，runloop就会向 CADisplayLink指定的target发送一次指定的selector消息，  CADisplayLink类对应的selector就会被调用一次。<br>参考文章：<a href="http://www.tuicool.com/articles/meMVR3" target="_blank" rel="external">Core Animation系列之CADisplayLink</a></p>
</blockquote>
<h3 id="hide系列方法"><a href="#hide系列方法" class="headerlink" title="hide系列方法"></a>hide系列方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBProgressHUD *hud = [<span class="keyword">self</span> HUDForView:view];<span class="comment">//获取当前view的最前为止的HUD</span></div><div class="line">    <span class="keyword">if</span> (hud != <span class="literal">nil</span>) &#123;</div><div class="line">        hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;</div><div class="line">        [hud hideAnimated:animated];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line">+ (MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view &#123;   </div><div class="line">    <span class="built_in">NSEnumerator</span> *subviewsEnum = [view.subviews reverseObjectEnumerator]; <span class="comment">//倒叙排序</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> subviewsEnum) &#123;</div><div class="line">        <span class="keyword">if</span> ([subview isKindOfClass:<span class="keyword">self</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> (MBProgressHUD *)subview;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBMainThreadAssert();</div><div class="line">    [<span class="keyword">self</span>.graceTimer invalidate];</div><div class="line">     <span class="keyword">self</span>.useAnimation = animated;</div><div class="line">     <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">     <span class="comment">//如果设定了HUD最小显示时间，那就需要判断最小显示时间和已经经过的时间的大小</span></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</div><div class="line">        <span class="built_in">NSTimeInterval</span> interv = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:<span class="keyword">self</span>.showStarted];</div><div class="line">        </div><div class="line">        <span class="comment">//如果最小显示时间比较大，则暂时不触发HUD的隐藏，而是启动一个timer，再经过二者的时间差的时间之后再触发隐藏</span></div><div class="line">        <span class="keyword">if</span> (interv &lt; <span class="keyword">self</span>.minShowTime) &#123;</div><div class="line">            <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:(<span class="keyword">self</span>.minShowTime - interv) target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleMinShowTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line">            <span class="keyword">self</span>.minShowTimer = timer;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; </div><div class="line">     &#125;</div><div class="line">    <span class="comment">//如果最小显示时间比较小，则立即将HUD隐藏</span></div><div class="line">    [<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">&#125;</div><div class="line"><span class="comment">//self.minShowTimer触发的方法</span></div><div class="line">- (<span class="keyword">void</span>)handleMinShowTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</div><div class="line">    [<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)hideUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    <span class="keyword">if</span> (animated &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</div><div class="line">        <span class="comment">//隐藏时，将showStarted设为nil</span></div><div class="line">        <span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</div><div class="line">        [<span class="keyword">self</span> animateIn:<span class="literal">NO</span> withType:<span class="keyword">self</span>.animationType completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            [<span class="keyword">self</span> done];</div><div class="line">        &#125;];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">self</span>.bezelView.alpha = <span class="number">0.</span>f;</div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，无论是类方法的<code>hide</code>方法，还是对象方法的<code>hide</code>方法，而且无论是触发还是没有触发<code>minShowTimer</code>,最终都会走到<code>hideUsingAnimation</code>这个方法里。</p>
</blockquote>
<p>而无论是<code>show</code>方法，还是<code>hide</code>方法，在设定animated属性为YES的前提下，最终都会走到<code>animateIn: withType: completion:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)animateIn:(<span class="built_in">BOOL</span>)animatingIn withType:(MBProgressHUDAnimation)type completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completion &#123;</div><div class="line">    <span class="comment">// Automatically determine the correct zoom animation type</span></div><div class="line">    <span class="keyword">if</span> (type == MBProgressHUDAnimationZoom) &#123;</div><div class="line">        type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//()内代表x和y方向缩放倍数</span></div><div class="line">    <span class="built_in">CGAffineTransform</span> small = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</div><div class="line">    <span class="built_in">CGAffineTransform</span> large = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.5</span>f, <span class="number">1.5</span>f);</div><div class="line">    <span class="comment">// 设定初始状态</span></div><div class="line">    <span class="built_in">UIView</span> *bezelView = <span class="keyword">self</span>.bezelView;</div><div class="line">    <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</div><div class="line">        bezelView.transform = small;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</div><div class="line">        bezelView.transform = large;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建动画任务</span></div><div class="line">    dispatch_block_t animations = ^&#123;</div><div class="line">        <span class="keyword">if</span> (animatingIn) &#123;</div><div class="line">            bezelView.transform = <span class="built_in">CGAffineTransformIdentity</span>;<span class="comment">//重置</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</div><div class="line">            bezelView.transform = large;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</div><div class="line">            bezelView.transform = small;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">        bezelView.alpha = animatingIn ? <span class="keyword">self</span>.opacity : <span class="number">0.</span>f;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">       <span class="comment">//如果animatingIn是true，就是show方法，否则是hide方法</span></div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = animatingIn ? <span class="number">1.</span>f : <span class="number">0.</span>f;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// Spring animations are nicer, but only available on iOS 7+</span></div><div class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV</span></div><div class="line">    <span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;</div><div class="line">        <span class="comment">//执行动画 &gt;= iOS7</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> usingSpringWithDamping:<span class="number">1.</span>f initialSpringVelocity:<span class="number">0.</span>f options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>除了一些细节上的语法之外，我觉得该框架有几个地方值得我们借鉴：</p>
<ol>
<li>暴露出来的API最终都会走到同一个私有方法里。</li>
<li>将真正显示的时间的前后加上缓冲的时间（graceTimer 和 hideDelayTimer），可以提高可定制性和稳定性。</li>
<li>如果有两个方法是矛盾的，并且可以同时调用，就需要在全局设置一个属性来判断当前的状态（removeFromSuperViewOnHide属性，finished属性）</li>
<li>使用CADisplayLink来刷新更新频率可能很高的view。</li>
<li>使用NSAssert来捕获各种异常。</li>
</ol>
<p>就这样大致写完了，没有怎么读过第三方框架的源码，所以第一次可能显得稍许不足。有不好的地方还希望多多指点哈～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的&lt;strong&gt;读好源码Project&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从哪个框架开始呢？我想到了&lt;code&gt;SDWebImage&lt;/code&gt;，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～&lt;/p&gt;
&lt;p&gt;找着找着就找到了&lt;code&gt;MBProgressHUD&lt;/code&gt;，这个框架只有两个文件，一个头文件和一个实现文件，很适合我现在的水平（对于一个没怎么读过源码的选手），于是就撸起了袖子开始了。&lt;/p&gt;
&lt;p&gt;连查知识点带记笔记一共花了大概3个小时（虽然文件很少，但是里面好多东西都不知道[捂脸]）。整体说来，收获还是比较大的，除了一些零碎的语法之外，框架作者对于代码结构的设计和各种情况的考虑还是很出色的，很值得学习，而且我在下文也有介绍。&lt;/p&gt;
&lt;p&gt;这篇总结主要分三个部分来介绍这个框架：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;核心Public API&lt;/li&gt;
&lt;li&gt;方法调用流程图&lt;/li&gt;
&lt;li&gt;方法内部实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不多说了，开始吧～&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>2016年终总结 | 善于总结，把握方向</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%20%7C%20%E5%96%84%E4%BA%8E%E6%80%BB%E7%BB%93%EF%BC%8C%E6%8A%8A%E6%8F%A1%E6%96%B9%E5%90%91/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/2016年终总结 | 善于总结，把握方向/</id>
    <published>2017-01-13T05:55:17.000Z</published>
    <updated>2017-03-20T07:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得去年这个时候看到很多同行写了年终总结，当时只工作了1个月的我觉得很是高大上。转眼一年过去了，从第一家公司来到现在的这家公司，无论技术上还是思想上都成熟了一些，巧的是简书在这个时候给我们这个平台来写年终总结。贵在参与，也为了自己，写一篇吧～</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-88a964d0151cb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GoodBye 2016，Welcome 2017"></p>
<p>2016年，是我事业起步的第一年，现在回头看去，这一年大致分为五个时期：</p>
<ol>
<li><strong>技术基础建设期（1月～5月）</strong>：从iOS小白的小白到独立上线app。</li>
<li><strong>技术快速成长期（6月～9月）</strong>：简书更新30篇文章，粉丝达到1000+。</li>
<li><strong>写简历找工作期（10月）</strong>：8家面试，3个offer。</li>
<li><strong>适应新的公司期（11月）</strong>：新项目1个月内上架。</li>
<li><strong>明年方向定位期（12月）</strong>：决定研究Hybrid app开发。</li>
</ol>
<p>下面开始按时间顺序分别总结一下每个时期里我的所做所思。</p>
<a id="more"></a>
<h2 id="基础形成期：2016年1月～5月"><a href="#基础形成期：2016年1月～5月" class="headerlink" title="基础形成期：2016年1月～5月"></a>基础形成期：2016年1月～5月</h2><hr>
<p>我的第一份工作就是iOS开发，从2015年11月入职，熟悉了一段时间的项目代码，在12月份又接了一段时间的测试工作，所以真正开始做iOS的时间应该是今年的1月份。</p>
<p>从开始接手简单的需求到独立负责完成前公司第二个项目上线一共经历了5个月的时间，在这个阶段里，我从一个连UITableView的代理都不怎么会用的小白中的小白逐渐成长为一个独立负责app上线的小白。</p>
<p>由于开始的时候基础太差，每天都累得不行，因为当时的我，就算一个特别小的问题都要去问谷哥或者度娘，所以几乎每天都去无止境地在浏览器里输入问题，搜索问题的答案，几乎每天都有记录下来的代码段，几乎每天都有需要改的bug（因为自己之前代码写的不好需要重写）。</p>
<p>我记得当时为了赶上进度，不给大家拖后腿，每天经常是2点之后睡觉，觉得代码可以了就在家里上传代码。而且因为用眼过度+用脑过度，有时会眼睛疼，头疼，甚至偶尔在睡觉之前眼睛看东西的时候出现了散光的情况。</p>
<p>在前公司的主项目在渡过了两次迭代之后，也就是今年3月份的时候，紧接着要上线一个新的小项目，而iOS端开发的任务就落在我的头上。虽然伴随着各种懵逼，各种恐惧，但我还是欣然接受的，因为像这种突破舒适区的事情还是接下来为好，我心里还是知道这是一个难得的锻炼自己的机会。</p>
<p>可能也是因为这个项目还是比较简单，而且一些功能集成了第三方的SDK，在开发的时候渐渐没有显得那么吃力了。但我仍然记得很清楚地记得有好几个夜晚是自己最后从公司走出去的，因为当时安卓那边是有两个人一起做这个项目，而且接口也比较简单，后端的童鞋也比较轻松。</p>
<p>到最后结果还是不错的，我这里结束得没有比计划晚，而且比安卓提早开发完毕了。当时看着app store里自己开发的app上线了，心里还是很开心的，毕竟对于一个工作刚半年的人来说，这个机会挺难得的，而且我把握的还算不错。</p>
<blockquote>
<p>这个时期应该是我成长得最痛苦的时期，因为在这个阶段里，我经历了iOS开发的“从0到1”的阶段，也可以理解为骑自行车的“第一蹬”。也就是，我“上路”了。</p>
</blockquote>
<h2 id="快速成长期：2016年6月～9月"><a href="#快速成长期：2016年6月～9月" class="headerlink" title="快速成长期：2016年6月～9月"></a>快速成长期：2016年6月～9月</h2><hr>
<p>虽然说程序员需要自学，但是以我之前的水平，只是搞懂公司现有的代码，完成项目需求就已经耗尽了我所有的休息时间，几乎没有其他的时间用来学习。</p>
<p>但是经过了近半年的历练，对公司业务的驾轻就熟了。在开发公司项目后，余下的自己的时间越来越多了，于是就找一些资料进行学习。在这段时间里，我的学习成果主要包括两个：</p>
<h4 id="1-第一个成果：简书博客"><a href="#1-第一个成果：简书博客" class="headerlink" title="1. 第一个成果：简书博客"></a>1. 第一个成果：简书博客</h4><p>我的学习方式是采取以：<strong>“面向博客学习”</strong>的学习方法。</p>
<ul>
<li>具体说来就是：将学习到的东西进行反复总结，能达到让任何人看懂的水准。</li>
<li>它的核心思想：能让其他人理解了自己才算是理解。</li>
<li>最后总结一句就是：笔记即博客（笔记总结完了就直接能到发布博客的水准）。</li>
</ul>
<p>除了能更好地理解知识，我认为分享技术的好处还有：</p>
<ol>
<li>认识一些优秀的同行（神交的基友）：<a href="http://www.jianshu.com/users/e39da354ce50/latest_articles" target="_blank" rel="external">神经骚栋</a> | <a href="http://www.jianshu.com/users/c68741efc396/latest_articles" target="_blank" rel="external">熊皮皮</a> | <a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a> | <a href="http://www.jianshu.com/users/a54931de4c9b/latest_articles" target="_blank" rel="external">阿拉斯加的狗</a> |<a href="http://www.jianshu.com/users/bfb3a06ce1cd/latest_articles" target="_blank" rel="external">小菜一碟321</a> 。</li>
<li>有时会有人指出博客里的错误或者提出一些更好的建议。</li>
</ol>
<p><strong>以下是我分享的其中三个专题：</strong></p>
<ul>
<li><p><a href="http://www.jianshu.com/notebooks/4747753/latest" target="_blank" rel="external">斯坦福公开课（18节课的所有课程的总结和Demo）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/notebooks/6074358/latest" target="_blank" rel="external">《Effective Objective-C》 超级干货三部曲（重整全书的精华部分）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/notebooks/3482176/latest" target="_blank" rel="external">读书笔记 - 程序员素养（《高效能程序员的修炼》等书的读书总结）</a></p>
</li>
</ul>
<p><strong>还有几篇质量不是很低的文章：</strong></p>
<ul>
<li><a href="http://www.jianshu.com/p/7702f58be845" target="_blank" rel="external">高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息</a></li>
<li><a href="http://www.jianshu.com/p/bf5c0e462119" target="_blank" rel="external">详解 iOS 多图下载的缓存机制</a></li>
<li><a href="http://www.jianshu.com/p/6e74f5438f2c" target="_blank" rel="external">最浅显易懂的iOS多线程技术 - GCD的教程</a></li>
</ul>
<h4 id="2-第二个成果：开源库"><a href="#2-第二个成果：开源库" class="headerlink" title="2. 第二个成果：开源库"></a>2. 第二个成果：开源库</h4><p>哎呀，说出来都不好意思，因为这个库很简单的。但是因为是写总结嘛，就要面面俱到，虽然贴出来大家能看，但是总结毕竟还是给自己写的。</p>
<p>这个开源框架主要封装了一下iOS的FMDB框架，用来操作本地数据库的。因为之前公司的需求总是和多用户的用户信息离不开，所以就想写一个可以随时增删改查多个用户信息的数据库，我记得当时想法出来以后，从写代码到上传到Github，连续写了10个小时，天都亮了，额。</p>
<p>最后还是附上传送门：<a href="https://github.com/knightsj/SJUserInfoManager">GitHub:SJUserInfoManager</a></p>
<blockquote>
<p>这个阶段是我成长得最快的时期，基本完成了从菜鸟到新手的升级。更让人欣慰的是，我的成长历程留在了简书博客里，它是可见的，也为我下阶段换公司打下了基础（因为都体现在了简历里，为我的求职添加了砝码）。</p>
</blockquote>
<h2 id="3-找工作期：10月。"><a href="#3-找工作期：10月。" class="headerlink" title="3. 找工作期：10月。"></a>3. 找工作期：10月。</h2><hr>
<p>由于上家公司前景不是很理想，渐渐地，很多人都离开了，而且项目需求也渐渐变成修边幅的那种，于是我也为自己打算，准备换一家公司。</p>
<p>准备简历和找工作的经历就不赘述了，大家可以看我上一篇文章，详细地介绍了10月份找工作的心路历程：<br><a href="http://www.jianshu.com/p/087027dcc942" target="_blank" rel="external">2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer</a></p>
<p>这篇文章可能由于标题起的还不错，而且我写的也比较实在，阅读量已经4000+了，我记得当时一个上午不到3个小时就已经超过2000了，而且留言也有很多，我也逐一认真回复，因为我真心很想帮助那些有疑问的同行，让他们少走弯路。</p>
<blockquote>
<p>如果还是要在这里总结一下这段经历的感受的话，我想说的是：<strong>人要凭做出来的东西说话，其余的都是虚的。如果有，该出手时就出手；如果没有，低着头，沉住气，把它做出来</strong>。</p>
</blockquote>
<h2 id="4-适应新公司期：11月"><a href="#4-适应新公司期：11月" class="headerlink" title="4. 适应新公司期：11月"></a>4. 适应新公司期：11月</h2><hr>
<p>工作找了一个月之后，在11月来到了新公司，这里的规模比上一家大一些，技术团队60+人，仅iOS端就有10个人，除了我之外几乎都是2年以上工作经验的（是的，我很幸运），而且其中也有会PHP的，会Java的，会Javascript的iOS，感觉自己只会做iOS好low啊～～</p>
<p>刚进入公司后，就和另外一名新进来的iOS开发者联手负责了一个新项目，这个新项目需求还是比较简单的，开发3个星期就结束了，第4个星期已经在app store审核通过了，非常顺利。</p>
<p>在这次开发中，我学会的全新技术点是：</p>
<ol>
<li>MVVM框架的实际运用，并体会到了MVC框架的不足。</li>
<li>iOS图表的实现（使用CAShapeLayer和贝塞尔曲线绘图）。</li>
</ol>
<p>而且在写代码之外，通过积极地沟通，逐渐认识了一些负责设计，负责接口，安卓那边的小伙伴，以及产品经理，建立了很友好的合作关系，反正一切都很顺就是啦～～</p>
<blockquote>
<p>新公司不乏各路高手，在这60多人的技术团队里，有做技术20年+的技术经理，也有清华高材生，也有美国，英国留学生，也有一些朝气蓬勃刚入职场的小伙伴，感觉以后可以向他们学习的东西蛮多的。</p>
</blockquote>
<h2 id="5-下阶段方向抉择期：12月"><a href="#5-下阶段方向抉择期：12月" class="headerlink" title="5. 下阶段方向抉择期：12月"></a>5. 下阶段方向抉择期：12月</h2><hr>
<p>在项目的第一版成功上架后有一段时间是比较闲的，除了研究下一版要使用的图表以外，我有时间去思考下一步要去学什么。</p>
<p>为什么我在思考这个问题呢？因为iOS这一行业开发者突然增多的客观情况的存在，我们心里都很明白今后如果只会iOS开发已经不够了，况且程序员这一行业本来就变化很快，每一年最好要接触一个新的语言。而且我自己心里也很明白：现在到了该选择的时候了：<strong>我该学哪门语言呢？</strong></p>
<h3 id="Python？"><a href="#Python？" class="headerlink" title="Python？"></a>Python？</h3><p>新公司的技术团队里，有20+的人是python开发，接口就是用python写的。而且新认识的小伙伴也有做python的，随便聊两句就能指点我一二。再说，如果会写脚本，爬虫啥的，岂不是感觉屌屌的？而且机器学习，大数据什么的也可以做的。</p>
<h3 id="PHP？"><a href="#PHP？" class="headerlink" title="PHP？"></a>PHP？</h3><p>PHP7的性能提升了很多，而且部署能力强，很多公司的后端都用PHP，所以它的需求很大。况且我已经学会了iOS，如果再学会PHP，岂不是等于全栈了？</p>
<h3 id="Java？"><a href="#Java？" class="headerlink" title="Java？"></a>Java？</h3><p>如果学会了java，那么搞定安卓开发也就是时间问题了。再说java也可以写后台，所以是不是学会了java就真的移动端和后台自己全能包了？</p>
<h3 id="Javascript！"><a href="#Javascript！" class="headerlink" title="Javascript！"></a>Javascript！</h3><p>在我今年面试新公司的时候，跟我交流过的公司一共有10个左右，这其中，问我会不会混合开发（hybrid app develop：native app develop + web app develop）的就有5个。而且我也有问过之前的同事，他们的公司也几乎都有混合开发。于是我觉得这是个趋势，甚至可能已经开始了。就好比很多商城应用，很多界面都是通过H5来实现的，只是在本地做了js与OC的交互。</p>
<p>有的时候人就需要现实一点：对我来说，与其去学跨度很大的后端语言，为什么不用相同的时间学习混合开发呢？而且对于混合开发来说，我已经了解了native app 开发了不是么？</p>
<p>所以，我暂时放弃了能写脚本的Python，需求仅次于Java的PHP，能写安卓的Java，果断选择了Javascript（当然还有Html5和Css）！</p>
<p>而就在前几天，在公司项目第二版开发完成后，马上报名了优达学诚的前端工程师纳米学位的课程：<a href="https://cn.udacity.com/course/front-end-web-developer-nanodegree--nd001" target="_blank" rel="external">优达学诚 前端工程师纳米学位</a></p>
<p>昨天已经提交了第二个作业：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f60daa7f617b7ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前端工程师纳米学位 Project2"></p>
<p>励志在明年成为一个独当一面的hybrid app developer～哇咔咔</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><hr>
<p>在这一年里，我不断成熟了自己的iOS开发技术，也定下来了下一年的学习方向。当然，iOS开发还是既需要深入的，因为毕竟native app的一些实现能力，短时间用web技术还是很难超越，比如CPU和GPU密集型的任务还有就是底层的优化，与C，C++混编等等。但是毕竟现在native 与web的界限变得越来越模糊，有必要去学习web的一些东西，以备不时之需。</p>
<p>最后点个题：</p>
<p>学习提升的前提是总结，没有总结，就很难一步一个脚印，踏踏实实地走下去。就好比航海，如果不经常看星座，一步步总结之前犯下的错误，找方向，调整路线，是很难达到最终的目的地的。</p>
<p>而对于大多数人来说，提高生活质量的唯一途径就是通过工作。但是，如果工作本身对这个社会的价值不是很大，那么就很难拿到可观的薪水，就算该领域的高手，可能也不如那些工资高的行业的新手。</p>
<p>所以，现实一点来说，就像选择一个高薪的工作一样，选择一个需求比较大，前景可观的编程语言还是比较正确的。我很实在，说的都是些实实在在的话，当你想转一个跨度比较大的行业，一定要量力而行，而且好好做做研究，研究一下这个行业是不是在走下坡路，毕竟你不是一个人，你背后有养你的父母，有朋友伙伴，可能还有你的人生伴侣，把握好方向很重要。</p>
<p>可能你会说：</p>
<ul>
<li>我年轻，想做什么就做什么；</li>
<li>语言只是工具，学什么都行；</li>
</ul>
<p>但是我会告诉你：</p>
<ul>
<li>人生的每一个选择都很重要，你现在的生活取决于你曾经的选择；你今后的生活取决于你现在的选择。</li>
<li>人的精力有限，领域跨度过大的时候一定要仔细考虑，这个社会需要的是T型人才，而这个T的根基是这根竖！</li>
</ul>
<p>人最危险的就是不知道自己不知道，所以嘛，没事多想想，没有坏处。</p>
<hr>
<p>最后感谢在身后支持我转行的父母和陪伴我的女朋友，么么哒～</p>
<p>最后的最后附上本次互动的链接：<a href="http://www.jianshu.com/p/20707def779a" target="_blank" rel="external">程序员专题征文活动|GoodBye 2016,Welcome 2017
</a><br>请大家多多参与啊～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得去年这个时候看到很多同行写了年终总结，当时只工作了1个月的我觉得很是高大上。转眼一年过去了，从第一家公司来到现在的这家公司，无论技术上还是思想上都成熟了一些，巧的是简书在这个时候给我们这个平台来写年终总结。贵在参与，也为了自己，写一篇吧～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-88a964d0151cb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;GoodBye 2016，Welcome 2017&quot;&gt;&lt;/p&gt;
&lt;p&gt;2016年，是我事业起步的第一年，现在回头看去，这一年大致分为五个时期：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;技术基础建设期（1月～5月）&lt;/strong&gt;：从iOS小白的小白到独立上线app。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术快速成长期（6月～9月）&lt;/strong&gt;：简书更新30篇文章，粉丝达到1000+。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写简历找工作期（10月）&lt;/strong&gt;：8家面试，3个offer。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适应新的公司期（11月）&lt;/strong&gt;：新项目1个月内上架。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;明年方向定位期（12月）&lt;/strong&gt;：决定研究Hybrid app开发。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面开始按时间顺序分别总结一下每个时期里我的所做所思。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>2016年10月求职记 | iOS工作经验不到1年，在1个月内拿到了3个offer</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/2016%E5%B9%B410%E6%9C%88%E6%B1%82%E8%81%8C%E8%AE%B0%EF%BC%9AiOS%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E4%B8%8D%E5%88%B01%E5%B9%B4%EF%BC%8C%E5%9C%A81%E4%B8%AA%E6%9C%88%E5%86%85%E6%8B%BF%E5%88%B0%E4%BA%863%E4%B8%AAoffer/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer/</id>
    <published>2017-01-13T05:54:44.000Z</published>
    <updated>2017-03-20T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>真的是非常非常感谢我的新东家，在我最需要新工作的时候给我抛来橄榄枝~</p>
<p>新东家的知名度很高，但并不是做互联网起家的，是一家有自己线下产业的大公司，创立时间也比较久，新项目（互联网）的技术团队组成非常优秀，所以虽然给我的待遇并没有很多，但还是毫不犹豫选择了这一家。为此还谢绝了后面的面试邀请（因为要准备一些入职材料和入职之前的相关学习）。</p>
<p>笔者在国庆节期间准备简历，在国庆节后开始投递简历。从最开始投递简历到拿到最后一个offer历时3周多。因为在这段求职时间里感触很多，所以想专门写一篇博客来讲述一下自己的求职心得，希望能给各位年底求职的小伙伴，特别是做iOS的同行一些值得借鉴的东西。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-23f60ab52ef7bafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
<a id="more"></a>
<h3 id="1-总求职数据："><a href="#1-总求职数据：" class="headerlink" title="1. 总求职数据："></a>1. 总求职数据：</h3><hr>
<ol>
<li>从写简历到拿到最后一个offer历时26天。</li>
<li>总面试通知数：11个</li>
<li>总面试次数：8次</li>
<li>总offer数：3个</li>
</ol>
<h4 id="有趣的3个点："><a href="#有趣的3个点：" class="headerlink" title="有趣的3个点："></a>有趣的3个点：</h4><ol>
<li>简历的最初稿的完成历时2天并开始投递，在第10天才最终定稿。</li>
<li>在简历开始投递后的第一个星期里没有收到任何面试通知。</li>
<li>在3个offer里，只有一家是小公司（不到50人），其他两个都是具有相当规模的大公司。</li>
</ol>
<p>下面写一下整个求职过程的心得：</p>
<h3 id="1-简历需要持续更新"><a href="#1-简历需要持续更新" class="headerlink" title="1. 简历需要持续更新"></a>1. 简历需要持续更新</h3><hr>
<p>虽然开始简历的初版完成的挺快的，但是后来却不断发现有很多不妥的地方：</p>
<ol>
<li>不应该添加我自己的证件照：其实除了美女，是不建议有自己的证明照的。</li>
<li>不应该添加项目的icon：导致排版显得很乱，应该去掉。</li>
<li>项目经验的技术点不够具体，而且主次没有顺序：最好将技术亮点放在最前面，而且要细致一点。</li>
<li>技能清单太过俗套，不够具体：比如不能只写“熟悉RunLoop的使用”，建议这么写：“熟悉RunLoop的机制，创建常驻线程执行任务”，也就是将具体的技术点和具体的应用结合起来写一下会好一些。</li>
<li>个人优势不突出：因为项目经验少而且比较简单，所以相对来说博客和开源项目就是我的优势，而这些 优势我甚至没有在初版简历中写明，后来在更新简历的时候才写出来放在偏后的位置。但是再后来，<a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a>大大建议我开源项目的地址和优秀博客文章最好放在显著位置，我才鼓起勇气将它们放在个人信息的下面，也就是简历的第二项。</li>
<li>除了简历的撰写技巧之外，笔者也在不断自学来增添简历上的技术点：在学习前两天在简历上添加要学习的技术点，保证将来面试的时候可以用上。</li>
</ol>
<blockquote>
<p>在简历的初版完成之后就开始投递了，之后也在不断更新自己的简历，直到10天后更新才趋于稳定。</p>
</blockquote>
<h3 id="2-简历要突出个人优势"><a href="#2-简历要突出个人优势" class="headerlink" title="2. 简历要突出个人优势"></a>2. 简历要突出个人优势</h3><hr>
<p>之前提到过，在第一个星期里，我没有收到任何面试通知，直到第二个星期的星期三我才收到了第一个面试通知。而这个时间点，也正是简历最终定稿之后的2，3天。而且后来，面试通知就“源源不断”了：两周里有11个面试通知，而且越到后面越多。</p>
<p>虽然可能不是很准确，但我个人觉得：将我的博客优秀文章链接和开源项目地址放（并加上简单介绍）在简历的前面之后，我的简历变得“招人喜欢了”。</p>
<blockquote>
<p>因此，在写简历的时候，就要想：到底自己的优势点在哪里？哪个最有亮点，就毫不犹豫地写在最前面吧！</p>
<ul>
<li>如果你的优势是公司项目里的某个功能模块（不能太简单），就把这个模块写出来好好描述一下。</li>
<li>如果你在github上有星星，就把它放在简历前面，多啰嗦几句。</li>
<li>如果你的文章很热，或者被知名网站转载过，也把它放在简历前面，多啰嗦几句。</li>
<li>如果你上面三点都没有，就将你研究过或者参与过的开源框架拿出来，写一写你都从中学到了什么。</li>
</ul>
</blockquote>
<h3 id="3-大公司和小公司的用人侧重点不一样"><a href="#3-大公司和小公司的用人侧重点不一样" class="headerlink" title="3. 大公司和小公司的用人侧重点不一样"></a>3. 大公司和小公司的用人侧重点不一样</h3><hr>
<p>简历写得再好，它的性质也只是面试的敲门砖，真正考验你的还是面试。这段时间我的面试次数是8次，但是只拿到了2个offer，成绩很一般。</p>
<p>我分析了一下自己的优势和劣势：</p>
<h4 id="我的优势："><a href="#我的优势：" class="headerlink" title="我的优势："></a>我的优势：</h4><ol>
<li>学历高：海外硕士（非科班）。</li>
<li>自学能力强：iOS完全自学，而且持续更新博客，有开源项目（很渣）。入职四个月后独立负责一个新项目。</li>
</ol>
<h4 id="我的劣势："><a href="#我的劣势：" class="headerlink" title="我的劣势："></a>我的劣势：</h4><ol>
<li>工作经验少：严格来讲只有10个月。</li>
<li>项目经验少：而且项目技术点难度偏低。</li>
</ol>
<p>整体来说就是：经验少一些，潜力大一点。</p>
<p>有意思的是，这8家面试我的公司里有3家是有相当规模的大公司，而其中2家都给了我offer。而且在我面试的过程中，明显觉得自己比较受大公司青睐，而小公司却反差比较大。</p>
<h4 id="结合我的特点和面试结果有一个结论："><a href="#结合我的特点和面试结果有一个结论：" class="headerlink" title="结合我的特点和面试结果有一个结论："></a>结合我的特点和面试结果有一个结论：</h4><p>大公司招人大多还是以<strong>培养</strong>为目的。<br>小公司招人大多是以<strong>上手</strong>为目的。</p>
<blockquote>
<p>因此，<br>如果你觉得你技术很牛，能独当一面的话，大公司和小公司都可以尝试；<br>如果你经验少，但是潜力相对大一点，小公司还是相对不适合的。<br>如果你经验少，潜力也不是很大，不建议马上跳槽，把前两点的某一点或者其中一点强化再说。</p>
</blockquote>
<h3 id="4-面试题的准备有点虐心"><a href="#4-面试题的准备有点虐心" class="headerlink" title="4. 面试题的准备有点虐心"></a>4. 面试题的准备有点虐心</h3><hr>
<p>笔者在第一第二星期的时间里一直在刷网上的iOS面试题，不断地查缺补漏。在2个星期的时间里，笔记数量增加了100+条，都是记录面试题和相关基础知识的，后来实在是看不下去了，已经看吐了。</p>
<p>不过可笑的是：<br>在面试小公司的时候，问的问题及其刁钻以至于我的“iOS面试题库”几乎形同虚设，网上看的iOS面试题已经应付不了了。<br>而面试大公司的时候，几乎都没有问太多iOS相关的问题，而且问题都不难。</p>
<blockquote>
<p>虽然我最终要去的公司面试我的时候没有问我几个iOS的面试题，不过面试题还是需要准备的。这段时间总结的100多条笔记虽然一方面是为了在面试的时候发挥，另一方面也巩固了自己的基础知识，而且效果很好。</p>
</blockquote>
<h3 id="5-要么做，要么走"><a href="#5-要么做，要么走" class="headerlink" title="5. 要么做，要么走"></a>5. 要么做，要么走</h3><hr>
<p>在求职的过程中看到过这么一句话：“不是互联网不行，而是你不行”。<br>随后我就自行脑补：“不是iOS形势不行，而是你不行”。<br>那么是否可以通用一下呢：“不是<em>__</em>形势不行，而是你不行”？</p>
<p>难道互联网资本寒冬，互联网从业者就一定会失业么？<br>难道iOS形势不好，iOS开发者就一定很难找到工作或者跳槽么？</p>
<p>不要听到一些“什么什么形势不好”就给自己找不到工作找借口，给自己受伤的心灵抹上一点自欺欺人的糖。</p>
<p>为什么简历石沉大海？<br>为什么面试屡屡不中？</p>
<p>挺起胸膛解决问题好么？！</p>
<p>不要去抱怨，你抱怨的时候，可能有人在默默刷题，默默刷开源框架。对自己要求不高，必定会被淘汰。</p>
<p>认清现实吧！以前iOS这边“会拉个线就能月薪过万”的时代已经一去不复返了，如今正是淘汰浑水摸鱼的人的阶段。但这是一个好现象，说明这个行业终于走上正轨了。</p>
<p>如果觉得做不下去了，最好尽早离开；<br>如果决定坚持做下去，就要拿出你的本事让人家看看。</p>
<p>怎么看？当然不是靠说的，而是靠你做过什么。</p>
<p>现在这个时代知识的共享太容易了，绝大多数科目的入门资料在网上都能轻而易举地看到。很多人看得多了，会说了，就以为自己懂了。因此这个时代也过于浮躁，尤其是有一些会上网的年轻人。</p>
<p>但是，技术领域，对一个人的认可并不是靠说的，而是你做过了什么，或是能拿出什么能证明你以后能做什么。</p>
<p>举两个三国武将的例子：<br>从什么时候人们觉得关羽厉害？- 温酒斩华雄<br>从什么时候人们觉得吕布厉害？- 三英战吕布</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b6810305d1803032.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关二爷"></p>
<p>看出问题了么？<br>看谁牛不牛，是围绕着“事件”说的，而不是围绕花里胡哨的<strong>青龙偃月刀</strong>和<strong>方天画戟</strong>这些表面上的东西说的（虽然能舞得动这些的也能算是不弱）。</p>
<p>觉得舞刀弄枪离自己太远？举两个程序员界的例子：<br>Python的作者求职谷歌的时候只在简历上写了三个词：“I wrote Python.”<br>在iOS界家喻户晓的网络请求第三方框架AFNetworking的作者听说已经被苹果收编了。<br>（我也是听别人说的，真的假的不知道，但我就是要说，不喜欢来打我呀）</p>
<p>很现实的问题：<br>武将厉不厉害，拿战功说事儿；<br>技术工作者厉不厉害，拿作品说事儿。你的作品，反映了你的水平，也能反映你的潜力</p>
<p>所以，对于iOS程序员来说，如果想在这盘淘汰赛中不被抛弃，现在就着手构思真正属于自己的项目。或者用博客记录一下自己的学习历程，勾勒出自己的成长轨迹：“让别人知道你知道”很重要。</p>
<p>如果没有思路，没有关系，看一些已经开源的好的app和框架，相信我，不久你就会有自己的想法。因为创造无非就是拼凑，你懂得多了，自然就会“拼”了（此处双关[掩面]）。</p>
<h3 id="6-心得写完了，以后要怎么做呢？"><a href="#6-心得写完了，以后要怎么做呢？" class="headerlink" title="6. 心得写完了，以后要怎么做呢？"></a>6. 心得写完了，以后要怎么做呢？</h3><hr>
<p>上面说过，我个人感觉这次面试成功率不是很高，而原因也暴露的很明显：项目经验不足。</p>
<p>因此，笔者打算今后在不影响工作质量的情况下好好研究一些比较好的开源app和第三方框架，仔细阅读源码，从中抽取出值得学习的地方，不断提高自己的技术水平，而不仅仅停留在公司项目中。</p>
<p>目的并不是为了下次跳槽，而是为了不断搭建自己的技术壁垒，取各家之所长，借此来打造一个无法取代的自己：</p>
<p>就好比段誉：只会六脉神剑或者凌波微步还不足以独步武林，但是将二者结合在一起就能与萧大侠抗衡了。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><hr>
<p>整个求职过程中心情还是有低落的时候的，特别是第一个星期，面试通知丝毫没有动静。不过还好有一些“道上”的朋友给我鼓励和支持。在这里特别感谢在简书上认识的同行<a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a>， <a href="http://www.jianshu.com/users/a54931de4c9b/latest_articles" target="_blank" rel="external">阿拉斯加的狗</a>，<a href="http://www.jianshu.com/users/e39da354ce50/latest_articles" target="_blank" rel="external">神经骚栋</a>，<a href="http://www.jianshu.com/users/c68741efc396/latest_articles" target="_blank" rel="external">熊皮皮</a>的支持和鼓励，他们都是很优秀的iOS开发者，而且很有潜力，有很多我需要学习的地方。</p>
<p>如果有小伙伴有问题想问我，评论本文，发简信，加我微信（简书主页有我的微信二维码）都可以。<br>不过因为新东家的知名度比较高，具体新东家是谁就不方便说啦，请谅解~</p>
<p>最后还是祝愿在最近找工作的小伙伴们马到功成~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-784af8ebfba85366.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的是非常非常感谢我的新东家，在我最需要新工作的时候给我抛来橄榄枝~&lt;/p&gt;
&lt;p&gt;新东家的知名度很高，但并不是做互联网起家的，是一家有自己线下产业的大公司，创立时间也比较久，新项目（互联网）的技术团队组成非常优秀，所以虽然给我的待遇并没有很多，但还是毫不犹豫选择了这一家。为此还谢绝了后面的面试邀请（因为要准备一些入职材料和入职之前的相关学习）。&lt;/p&gt;
&lt;p&gt;笔者在国庆节期间准备简历，在国庆节后开始投递简历。从最开始投递简历到拿到最后一个offer历时3周多。因为在这段求职时间里感触很多，所以想专门写一篇博客来讲述一下自己的求职心得，希望能给各位年底求职的小伙伴，特别是做iOS的同行一些值得借鉴的东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-23f60ab52ef7bafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片来自：pixabay.com&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E9%AB%98%E5%BA%A6%E5%B0%81%E8%A3%85FMDB%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%90%84%E7%94%A8%E4%B8%80%E5%8F%A5%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%EF%BC%88%E6%B7%BB%E5%8A%A0&amp;%E4%BF%AE%E6%94%B9%EF%BC%89%EF%BC%8C%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息/</id>
    <published>2017-01-13T05:54:08.000Z</published>
    <updated>2017-03-20T07:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在移动开发中，有时不得不在客户端本地保存一些数据。在iOS端，我们可以使用plist，属性列表等技术来存储数据，而相比而下更高端一点的，我们也可以使用<strong>数据库</strong>来存储数据。</p>
<p>有趣的是，很多iOS开发者没有去选择使用苹果自家的Core Data技术来操作数据库，而是选择了<a href="[https://github.com/ccgus/fmdb](https://github.com/ccgus/fmdb">FMDB</a>)这个第三方框架。</p>
<p>该框架很好地封装了操作繁琐的SQLite语句，让数据库的操作更加面向对象，而且上手快，门槛低，不用学习数据库的相关知识就可以使用自如。如此优秀流行的框架是值得学习的，于是笔者这两天研究了一下FMDB。研究后，略有所思，将它封装了一下，写了一个<code>Manager</code>类，最后结合了一个Demo演示如何使用这个类。</p>
<p>该博客分为两个部分:第一个部分讲解笔者封装的这个<code>Manager</code>类；第二部分结合Demo来体现该类的实用性。</p>
<a id="more"></a>
<h1 id="1-封装FMDB"><a href="#1-封装FMDB" class="headerlink" title="1. 封装FMDB"></a>1. 封装FMDB</h1><hr>
<h2 id="1-1-封装类的功能"><a href="#1-1-封装类的功能" class="headerlink" title="1.1 封装类的功能"></a>1.1 封装类的功能</h2><p>首先看一下这个类的大名：SJUserInfoManager</p>
<ul>
<li>SJ：笔者的名字缩写，作为前缀，都懂得。</li>
<li>UserInfo:说明这个类用于操作用户信息。</li>
<li>Manager:这个类只具有工厂方法，省内存，而且方便使用。</li>
</ul>
<p><strong>这个类的功能是：它可以创建一个关于用户信息的表（数据库），可以保存，修改，读取，删除用户信息</strong>。</p>
<blockquote>
<p>现在几乎每个app都有登录功能，有登录就意味着有用户信息。有的时候，我们需要将一些用户信息存储到本地，方便今后的读取和操作。</p>
<p>而对于用户信息，几乎永远不变的一项就是用户id，因为用户可以改自己的名字，自己的注册手机号，用户签名等等，然而用户id是唯一一成不变的，后端查找用户信息一般都通过用户id来查找，这不难理解。</p>
</blockquote>
<p>因此，这个封装类基于用户id（user_id），让使用者可以自主添加<strong>一项</strong>自定义的用户信息（可以是用户名，用户签名，用户性别等等），从而形成一个只具有两个纵行的表（第一个纵行是默认的字段：user_id,第二个纵行是自定义字段，可以是user_name等等）。</p>
<p>这样一来，我们就可以生成很多基于用户id的表：可以是用户姓名的表，可以是用户出生日期的表，可以是用户手机号的表等等。</p>
<h2 id="1-2-API介绍"><a href="#1-2-API介绍" class="headerlink" title="1.2 API介绍"></a>1.2 API介绍</h2><p>该封装类的API一共有五个，分别是：</p>
<ol>
<li>创建表格</li>
<li>更新用户信息（添加&amp;修改）</li>
<li>查询某个用户的信息</li>
<li>查询全部用户的信息</li>
<li>删除某个用户的信息</li>
</ol>
<p>下面开始一一讲解：</p>
<h4 id="1-创建表格"><a href="#1-创建表格" class="headerlink" title="1. 创建表格"></a>1. 创建表格</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** Create table with tableName and fieldName **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userInfoField   fieldNameString（自定义字段名）</div><div class="line"> *</div><div class="line"> * @return  if the table is successfully created</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">BOOL</span>)createDataBaseWithName:(<span class="built_in">NSString</span> *)dataBaseName andUserInfoField:(<span class="built_in">NSString</span> *)userInfoField;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个方法的意图很明显，只要传进去表的名字和自定义字段的名字就能创造一个表。</p>
<ul>
<li>创建成功，返回YES；</li>
<li>创建失败，返回NO。</li>
</ul>
<p>而且这个表有一个默认的字段：user_id。因为通过这个类创建用户信息的表是基于用户id来操作的，前面已有说明。</p>
</blockquote>
<h4 id="2-更新用户信息（添加-amp-修改）"><a href="#2-更新用户信息（添加-amp-修改）" class="headerlink" title="2. 更新用户信息（添加&amp;修改）"></a>2. 更新用户信息（添加&amp;修改）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** update specific userInfo with specific userID and userInfoField and userInfoValue **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userID          userIDString（用户id的值）</div><div class="line"> * @param   userInfoField   fieldNameString（自定义字段名）</div><div class="line"> * @param   userInfoValue   userInfoValueString（字段对应的值）</div><div class="line"> *</div><div class="line"> * @return  the result of updating specific userInfo </div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSString</span> *)updateUserInfoIntoDataBase:(<span class="built_in">NSString</span> *)dataBaseName withUserID:(<span class="built_in">NSString</span> *)userID andUserInfoField:(<span class="built_in">NSString</span> *)userInfoField andUserInfoValue:(<span class="built_in">NSString</span> *)userInfoValue;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个方法用于更新用户信息，传入表的名字，用户id，自定义字段名，和自定义字段对应的值。</p>
<ul>
<li>如果输入的表不存在，则返回相应的错误信息。</li>
<li>如果输入的用户id已经存在，就更新对应的用户信息。</li>
<li>如果输入的用户id不存在，就添加这个用户的信息。</li>
</ul>
</blockquote>
<h4 id="3-查询某个用户的信息"><a href="#3-查询某个用户的信息" class="headerlink" title="3. 查询某个用户的信息"></a>3. 查询某个用户的信息</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** Query specific userInfoValue with tableName and userID and userInfoField **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userID          userIDString（用户id的值）</div><div class="line"> * @param   userInfoField   fieldNameString（自定义字段名）</div><div class="line"> *</div><div class="line"> * @return  specific userInfoValue （表内某用户id对应的用户信息）</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSString</span> *)queryUserInfoInDataBase:(<span class="built_in">NSString</span> *)dataBaseName WithUserID:(<span class="built_in">NSString</span> *)userId andUserInfoField:(<span class="built_in">NSString</span> *)userInfoField;</div></pre></td></tr></table></figure>
<blockquote>
<p>该方法用于查询某个用户的信息，传入表的名字，用户id和自定义字段名。</p>
<ul>
<li>如果输入的表不存在，则返回相应的错误信息。</li>
<li>如果输入的用户id存在，则返回对应的信息。</li>
<li>如果输入的用户id不存在，则返回相应的错误信息。</li>
</ul>
</blockquote>
<h4 id="4-查询全部用户的信息"><a href="#4-查询全部用户的信息" class="headerlink" title="4. 查询全部用户的信息"></a>4. 查询全部用户的信息</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** Query all userInfos in this table with userInfoField **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userInfoField   fieldNameString（自定义字段名）</div><div class="line"> *</div><div class="line"> * @return  all the userInfos in this table （表内所有的用户信息）</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSDictionary</span> *)queryUserInfosInDataBase:(<span class="built_in">NSString</span> *)dataBaseName andUserInfoField:(<span class="built_in">NSString</span> *)userInfoField;</div></pre></td></tr></table></figure>
<blockquote>
<p>该方法用户获取某个表内的所有用户信息，传入表的名字和自定义字段名即可。<br>返回的字典里包含一个数组，数组元素为表的每一行的信息。每一行的信息是一个字典：</p>
<ul>
<li>其中一个key为默认的字段名：user_id，它的值为对应的user_id的值。</li>
<li>另一个key为添加的自定义字段名，它对应的值为该字段对应的值。</li>
</ul>
</blockquote>
<h4 id="5-删除某个用户的信息"><a href="#5-删除某个用户的信息" class="headerlink" title="5. 删除某个用户的信息"></a>5. 删除某个用户的信息</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** Delete specific userInfo with specific userID **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userId          userIDString（用户id的值）</div><div class="line"> *</div><div class="line"> * @return  the result of deleting specific userInfo （删除的结果）</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSString</span> *)deleteUserInfoInDataBase:(<span class="built_in">NSString</span> *)dataBaseName WithUserID:(<span class="built_in">NSString</span> *)userId;</div></pre></td></tr></table></figure>
<blockquote>
<p>该方法用于删除表里的某个用户信息，只要传入表的名字和用户id即可，可以删除表中对应的一整行信息。同样地，如果输入的表不存在，则返回相应的错误信息。</p>
</blockquote>
<p>如果觉得有点抽象的话，可以看下面这个Demo，可以看到该封装类的具体使用方法。</p>
<h1 id="2-Demo演示"><a href="#2-Demo演示" class="headerlink" title="2. Demo演示"></a>2. Demo演示</h1><hr>
<p>在这个Demo中，我们要在表里添加的自定义字段名(fieldNameString)为：“user_name”。也就是说这个表将保存用户id和用户名信息。</p>
<h2 id="2-1-需求"><a href="#2-1-需求" class="headerlink" title="2.1 需求"></a>2.1 需求</h2><ol>
<li>在插入板块中插入用户信息（用户id和用户名）。</li>
<li>在查询板块中，根据输入的用户id，可以显示对应的用户名。如果没有对应的用户id，则显示“没有对应id”。</li>
<li>在删除板块中，根据输入的用户id，可以删除对应的用户信息（包括用户id和用户名，也就是删除了表的一整行）。如果没有对应的用户id，则显示“没有对应id”。</li>
<li>点击导航栏右侧的按钮，进入“用户信息列表页”。在这一页显示当前表里的全部用户的信息（在cell的textLabel里显示用户名；在cell的detailTextLabel里显示用户id）。</li>
</ol>
<h2 id="2-2-效果图"><a href="#2-2-效果图" class="headerlink" title="2.2 效果图"></a>2.2 效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-404e4004af3b981a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左图：数据库操作页面（插入，查询，删除板块）| 右图：数据库全部用户信息"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f32a934c4eb45af6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地沙盒中sqlite表文件内容"></p>
<h3 id="2-3-代码讲解"><a href="#2-3-代码讲解" class="headerlink" title="2.3 代码讲解"></a>2.3 代码讲解</h3><p><strong>1. 最先导入这个封装类和FMDB框架：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"SJUserInfoManager.h"</span></span></div></pre></td></tr></table></figure>
<p><strong>2. 因为表的名字和自定义字段是固定的，所以就以宏来定义了：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define DATABASENAME  @<span class="meta-string">"userInfoTable"</span> //表的名字</span></div><div class="line"><span class="meta">#define USERINFOFIELD @<span class="meta-string">"user_name"</span>     //自定义字段的名字</span></div></pre></td></tr></table></figure>
<p><strong>3. 添加几个输入框的属性，获取输入框的内容；和查询结果显示</strong>Label：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *insertUserIdTextfield;       <span class="comment">//插入输入框：输入用户id</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *insertUserInfoValueTextfiled;<span class="comment">//插入收入框：输入用户名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *queryUserIdTextfield;        <span class="comment">//查询输入框：输入用户id</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *queryUserInfoValueLabel;         <span class="comment">//查询结果显示Label:显示用户id对应的用户名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *deleteUserIdTextField;       <span class="comment">//删除输入框：输入用户id</span></div></pre></td></tr></table></figure>
<p><strong>4. 下面看一下封装的增改&amp;查&amp;删的代码：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//插入用户信息</span></div><div class="line">- (<span class="keyword">IBAction</span>)insertAction:(<span class="keyword">id</span>)sender &#123;</div><div class="line">   </div><div class="line">    <span class="built_in">NSString</span> *result = <span class="string">@""</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.insertUserInfoValueTextfiled.text.length == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">         result = <span class="string">@"Please Input UserID!"</span>;<span class="comment">//没有输入用户id就点击了插入按钮</span></div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">         result = [SJUserInfoManager updateUserInfoIntoDataBase:DATABASENAME withUserID:<span class="keyword">self</span>.insertUserIdTextfield.text andUserInfoField:USERINFOFIELD andUserInfoValue:<span class="keyword">self</span>.insertUserInfoValueTextfiled.text];</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">   [<span class="keyword">self</span> showAlertWithTitle:result];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="comment">//查询用户信息</span></div><div class="line">- (<span class="keyword">IBAction</span>)queryUserInfoValue:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *result = <span class="string">@""</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.queryUserIdTextfield.text.length == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        result = <span class="string">@"Please Input UserID!"</span>;<span class="comment">//没有输入用户id就点击了查询按钮</span></div><div class="line">        <span class="keyword">self</span>.queryUserInfoValueLabel.text = <span class="string">@""</span>;<span class="comment">//重置查询输入框</span></div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        result =  [SJUserInfoManager queryUserInfoInDataBase:DATABASENAME WithUserID:<span class="keyword">self</span>.queryUserIdTextfield.text andUserInfoField:USERINFOFIELD];</div><div class="line">        <span class="keyword">self</span>.queryUserInfoValueLabel.text = result;</div><div class="line">        [<span class="keyword">self</span> showAlertWithTitle:result];</div><div class="line">        </div><div class="line">    &#125;    </div><div class="line">    [<span class="keyword">self</span> showAlertWithTitle:result];</div><div class="line">&#125;</div><div class="line"><span class="comment">//删除用户信息</span></div><div class="line">- (<span class="keyword">IBAction</span>)deleteUserInfoWithUserID:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *result = <span class="string">@""</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.deleteUserIdTextField.text.length == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        result = <span class="string">@"Please Input UserID!"</span>;</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        result =  [SJUserInfoManager deleteUserInfoInDataBase:DATABASENAME WithUserID:<span class="keyword">self</span>.deleteUserIdTextField.text];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> showAlertWithTitle:result];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其实不难看出，除了处理错误信息的代码以外，数据库的操作代码是非常简洁的:都是一行结束，而且返回一个结果字符串或者布尔值。</p>
</blockquote>
<p><strong>5. 在进入第二页之前，需要查询表内所有的用户信息并传递给第二个页面的VC：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([segue.destinationViewController isKindOfClass:[DataListTableViewController <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> ([segue.identifier isEqualToString:<span class="string">@"userInfosList"</span>]) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">NSDictionary</span> *userInfosDict = [SJUserInfoManager queryUserInfosInDataBase:DATABASENAME andUserInfoField:USERINFOFIELD];</div><div class="line">            DataListTableViewController *dataListVc = (DataListTableViewController *)segue.destinationViewController;</div><div class="line">            dataListVc.userInfosDict = userInfosDict;</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6. 在第二页的viewDidLoad方法里获取用户信息列表，并刷新表格将其显示出来：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *alertTitle = [<span class="keyword">self</span>.userInfosDict objectForKey:<span class="string">@"result"</span>];</div><div class="line">    [<span class="keyword">self</span> showAlertWithTitle:alertTitle];</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *userInfosArray = [<span class="keyword">self</span>.userInfosDict objectForKey:<span class="string">@"userInfosArray"</span>];</div><div class="line">    <span class="keyword">if</span> ([userInfosArray count] != <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">self</span>.userInfosArray = userInfosArray;</div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想知道Demo是如何实现的么？</p>
<p>Demo传送门：<a href="https://github.com/Shijie0111/SJUserInfoManager">SJUserInfoManager - GitHub</a></p>
<p>如果可以给星星，或者给笔者提意见，那就再好不过啦~</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>说来惭愧，笔者封装的这个类的功能还是很有局限性的：</p>
<ol>
<li>操作表格前必须创建一次表格（一次就可以）。</li>
<li>只支持NSString类型的值。</li>
<li>除user_id字段以外只支持一个自定义字段。</li>
<li>不同的自定义字段必须对应不同的表格名，也就是说不同的自定义字段不能对应同一个表格名。</li>
<li>数据库操作API的返回值还不够完善，最好以枚举类型返回，有待改进。</li>
<li>没有使用FMDB的队列API。</li>
</ol>
<p>虽然这个封装很简单，但是笔者始终赞同<strong>学习的最终目的在于应用和创造</strong>这句话。如果只是用眼睛看FMDB框架的API或是复制粘贴一些别人写好的FMDB的应用代码，那么其实是意义不大的。</p>
<p>如果在学习后，可以融会贯通，将学到的知识可以按照自己的意图加以改进和运用的话，那么相对于“搬运工”式学习来说，显然收获更大。</p>
<p>这是笔者第一个开源项目，虽然简单，算上优化和改bug只写了大概3个小时，但是毕竟是开源的第一步，对自己的鼓励还是蛮大的，以后还会封装优化更多的库，加油~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在移动开发中，有时不得不在客户端本地保存一些数据。在iOS端，我们可以使用plist，属性列表等技术来存储数据，而相比而下更高端一点的，我们也可以使用&lt;strong&gt;数据库&lt;/strong&gt;来存储数据。&lt;/p&gt;
&lt;p&gt;有趣的是，很多iOS开发者没有去选择使用苹果自家的Core Data技术来操作数据库，而是选择了&lt;a href=&quot;[https://github.com/ccgus/fmdb](https://github.com/ccgus/fmdb&quot;&gt;FMDB&lt;/a&gt;)这个第三方框架。&lt;/p&gt;
&lt;p&gt;该框架很好地封装了操作繁琐的SQLite语句，让数据库的操作更加面向对象，而且上手快，门槛低，不用学习数据库的相关知识就可以使用自如。如此优秀流行的框架是值得学习的，于是笔者这两天研究了一下FMDB。研究后，略有所思，将它封装了一下，写了一个&lt;code&gt;Manager&lt;/code&gt;类，最后结合了一个Demo演示如何使用这个类。&lt;/p&gt;
&lt;p&gt;该博客分为两个部分:第一个部分讲解笔者封装的这个&lt;code&gt;Manager&lt;/code&gt;类；第二部分结合Demo来体现该类的实用性。&lt;/p&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>

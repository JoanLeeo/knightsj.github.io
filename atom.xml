<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J_Knight</title>
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/knightsj/knightsj.github.io/"/>
  <updated>2017-01-13T06:10:18.000Z</updated>
  <id>https://github.com/knightsj/knightsj.github.io/</id>
  
  <author>
    <name>Knight_SJ</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2016年终总结 | 善于总结，把握方向</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%20%7C%20%E5%96%84%E4%BA%8E%E6%80%BB%E7%BB%93%EF%BC%8C%E6%8A%8A%E6%8F%A1%E6%96%B9%E5%90%91/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/2016年终总结 | 善于总结，把握方向/</id>
    <published>2017-01-13T05:55:17.000Z</published>
    <updated>2017-01-13T06:10:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得去年这个时候看到很多同行写了年终总结，当时只工作了1个月的我觉得很是高大上。转眼一年过去了，从第一家公司来到现在的这家公司，无论技术上还是思想上都成熟了一些，巧的是简书在这个时候给我们这个平台来写年终总结。贵在参与，也为了自己，写一篇吧～</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-88a964d0151cb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GoodBye 2016，Welcome 2017"></p>
<p>2016年，是我事业起步的第一年，现在回头看去，这一年大致分为五个时期：</p>
<ol>
<li><strong>技术基础建设期（1月～5月）</strong>：从iOS小白的小白到独立上线app。</li>
<li><strong>技术快速成长期（6月～9月）</strong>：简书更新30篇文章，粉丝达到1000+。</li>
<li><strong>写简历找工作期（10月）</strong>：8家面试，3个offer。</li>
<li><strong>适应新的公司期（11月）</strong>：新项目1个月内上架。</li>
<li><strong>明年方向定位期（12月）</strong>：决定研究Hybrid app开发。</li>
</ol>
<p>下面开始按时间顺序分别总结一下每个时期里我的所做所思。</p>
<h2 id="基础形成期：2016年1月～5月"><a href="#基础形成期：2016年1月～5月" class="headerlink" title="基础形成期：2016年1月～5月"></a>基础形成期：2016年1月～5月</h2><hr>
<p>我的第一份工作就是iOS开发，从2015年11月入职，熟悉了一段时间的项目代码，在12月份又接了一段时间的测试工作，所以真正开始做iOS的时间应该是今年的1月份。</p>
<p>从开始接手简单的需求到独立负责完成前公司第二个项目上线一共经历了5个月的时间，在这个阶段里，我从一个连UITableView的代理都不怎么会用的小白中的小白逐渐成长为一个独立负责app上线的小白。</p>
<p>由于开始的时候基础太差，每天都累得不行，因为当时的我，就算一个特别小的问题都要去问谷哥或者度娘，所以几乎每天都去无止境地在浏览器里输入问题，搜索问题的答案，几乎每天都有记录下来的代码段，几乎每天都有需要改的bug（因为自己之前代码写的不好需要重写）。</p>
<p>我记得当时为了赶上进度，不给大家拖后腿，每天经常是2点之后睡觉，觉得代码可以了就在家里上传代码。而且因为用眼过度+用脑过度，有时会眼睛疼，头疼，甚至偶尔在睡觉之前眼睛看东西的时候出现了散光的情况。</p>
<p>在前公司的主项目在渡过了两次迭代之后，也就是今年3月份的时候，紧接着要上线一个新的小项目，而iOS端开发的任务就落在我的头上。虽然伴随着各种懵逼，各种恐惧，但我还是欣然接受的，因为像这种突破舒适区的事情还是接下来为好，我心里还是知道这是一个难得的锻炼自己的机会。</p>
<p>可能也是因为这个项目还是比较简单，而且一些功能集成了第三方的SDK，在开发的时候渐渐没有显得那么吃力了。但我仍然记得很清楚地记得有好几个夜晚是自己最后从公司走出去的，因为当时安卓那边是有两个人一起做这个项目，而且接口也比较简单，后端的童鞋也比较轻松。</p>
<p>到最后结果还是不错的，我这里结束得没有比计划晚，而且比安卓提早开发完毕了。当时看着app store里自己开发的app上线了，心里还是很开心的，毕竟对于一个工作刚半年的人来说，这个机会挺难得的，而且我把握的还算不错。</p>
<blockquote>
<p>这个时期应该是我成长得最痛苦的时期，因为在这个阶段里，我经历了iOS开发的“从0到1”的阶段，也可以理解为骑自行车的“第一蹬”。也就是，我“上路”了。</p>
</blockquote>
<h2 id="快速成长期：2016年6月～9月"><a href="#快速成长期：2016年6月～9月" class="headerlink" title="快速成长期：2016年6月～9月"></a>快速成长期：2016年6月～9月</h2><hr>
<p>虽然说程序员需要自学，但是以我之前的水平，只是搞懂公司现有的代码，完成项目需求就已经耗尽了我所有的休息时间，几乎没有其他的时间用来学习。</p>
<p>但是经过了近半年的历练，对公司业务的驾轻就熟了。在开发公司项目后，余下的自己的时间越来越多了，于是就找一些资料进行学习。在这段时间里，我的学习成果主要包括两个：</p>
<h4 id="1-第一个成果：简书博客"><a href="#1-第一个成果：简书博客" class="headerlink" title="1. 第一个成果：简书博客"></a>1. 第一个成果：简书博客</h4><p>我的学习方式是采取以：<strong>“面向博客学习”</strong>的学习方法。</p>
<ul>
<li>具体说来就是：将学习到的东西进行反复总结，能达到让任何人看懂的水准。</li>
<li>它的核心思想：能让其他人理解了自己才算是理解。</li>
<li>最后总结一句就是：笔记即博客（笔记总结完了就直接能到发布博客的水准）。</li>
</ul>
<p>除了能更好地理解知识，我认为分享技术的好处还有：</p>
<ol>
<li>认识一些优秀的同行（神交的基友）：<a href="http://www.jianshu.com/users/e39da354ce50/latest_articles" target="_blank" rel="external">神经骚栋</a> | <a href="http://www.jianshu.com/users/c68741efc396/latest_articles" target="_blank" rel="external">熊皮皮</a> | <a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a> | <a href="http://www.jianshu.com/users/a54931de4c9b/latest_articles" target="_blank" rel="external">阿拉斯加的狗</a> |<a href="http://www.jianshu.com/users/bfb3a06ce1cd/latest_articles" target="_blank" rel="external">小菜一碟321</a> 。</li>
<li>有时会有人指出博客里的错误或者提出一些更好的建议。</li>
</ol>
<p><strong>以下是我分享的其中三个专题：</strong></p>
<ul>
<li><p><a href="http://www.jianshu.com/notebooks/4747753/latest" target="_blank" rel="external">斯坦福公开课（18节课的所有课程的总结和Demo）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/notebooks/6074358/latest" target="_blank" rel="external">《Effective Objective-C》 超级干货三部曲（重整全书的精华部分）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/notebooks/3482176/latest" target="_blank" rel="external">读书笔记 - 程序员素养（《高效能程序员的修炼》等书的读书总结）</a></p>
</li>
</ul>
<p><strong>还有几篇质量不是很低的文章：</strong></p>
<ul>
<li><a href="http://www.jianshu.com/p/7702f58be845" target="_blank" rel="external">高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息</a></li>
<li><a href="http://www.jianshu.com/p/bf5c0e462119" target="_blank" rel="external">详解 iOS 多图下载的缓存机制</a></li>
<li><a href="http://www.jianshu.com/p/6e74f5438f2c" target="_blank" rel="external">最浅显易懂的iOS多线程技术 - GCD的教程</a></li>
</ul>
<h4 id="2-第二个成果：开源库"><a href="#2-第二个成果：开源库" class="headerlink" title="2. 第二个成果：开源库"></a>2. 第二个成果：开源库</h4><p>哎呀，说出来都不好意思，因为这个库很简单的。但是因为是写总结嘛，就要面面俱到，虽然贴出来大家能看，但是总结毕竟还是给自己写的。</p>
<p>这个开源框架主要封装了一下iOS的FMDB框架，用来操作本地数据库的。因为之前公司的需求总是和多用户的用户信息离不开，所以就想写一个可以随时增删改查多个用户信息的数据库，我记得当时想法出来以后，从写代码到上传到Github，连续写了10个小时，天都亮了，额。</p>
<p>最后还是附上传送门：<a href="https://github.com/knightsj/SJUserInfoManager">GitHub:SJUserInfoManager</a></p>
<blockquote>
<p>这个阶段是我成长得最快的时期，基本完成了从菜鸟到新手的升级。更让人欣慰的是，我的成长历程留在了简书博客里，它是可见的，也为我下阶段换公司打下了基础（因为都体现在了简历里，为我的求职添加了砝码）。</p>
</blockquote>
<h2 id="3-找工作期：10月。"><a href="#3-找工作期：10月。" class="headerlink" title="3. 找工作期：10月。"></a>3. 找工作期：10月。</h2><hr>
<p>由于上家公司前景不是很理想，渐渐地，很多人都离开了，而且项目需求也渐渐变成修边幅的那种，于是我也为自己打算，准备换一家公司。</p>
<p>准备简历和找工作的经历就不赘述了，大家可以看我上一篇文章，详细地介绍了10月份找工作的心路历程：<br><a href="http://www.jianshu.com/p/087027dcc942" target="_blank" rel="external">2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer</a></p>
<p>这篇文章可能由于标题起的还不错，而且我写的也比较实在，阅读量已经4000+了，我记得当时一个上午不到3个小时就已经超过2000了，而且留言也有很多，我也逐一认真回复，因为我真心很想帮助那些有疑问的同行，让他们少走弯路。</p>
<blockquote>
<p>如果还是要在这里总结一下这段经历的感受的话，我想说的是：<strong>人要凭做出来的东西说话，其余的都是虚的。如果有，该出手时就出手；如果没有，低着头，沉住气，把它做出来</strong>。</p>
</blockquote>
<h2 id="4-适应新公司期：11月"><a href="#4-适应新公司期：11月" class="headerlink" title="4. 适应新公司期：11月"></a>4. 适应新公司期：11月</h2><hr>
<p>工作找了一个月之后，在11月来到了新公司，这里的规模比上一家大一些，技术团队60+人，仅iOS端就有10个人，除了我之外几乎都是2年以上工作经验的（是的，我很幸运），而且其中也有会PHP的，会Java的，会Javascript的iOS，感觉自己只会做iOS好low啊～～</p>
<p>刚进入公司后，就和另外一名新进来的iOS开发者联手负责了一个新项目，这个新项目需求还是比较简单的，开发3个星期就结束了，第4个星期已经在app store审核通过了，非常顺利。</p>
<p>在这次开发中，我学会的全新技术点是：</p>
<ol>
<li>MVVM框架的实际运用，并体会到了MVC框架的不足。</li>
<li>iOS图表的实现（使用CAShapeLayer和贝塞尔曲线绘图）。</li>
</ol>
<p>而且在写代码之外，通过积极地沟通，逐渐认识了一些负责设计，负责接口，安卓那边的小伙伴，以及产品经理，建立了很友好的合作关系，反正一切都很顺就是啦～～</p>
<blockquote>
<p>新公司不乏各路高手，在这60多人的技术团队里，有做技术20年+的技术经理，也有清华高材生，也有美国，英国留学生，也有一些朝气蓬勃刚入职场的小伙伴，感觉以后可以向他们学习的东西蛮多的。</p>
</blockquote>
<h2 id="5-下阶段方向抉择期：12月"><a href="#5-下阶段方向抉择期：12月" class="headerlink" title="5. 下阶段方向抉择期：12月"></a>5. 下阶段方向抉择期：12月</h2><hr>
<p>在项目的第一版成功上架后有一段时间是比较闲的，除了研究下一版要使用的图表以外，我有时间去思考下一步要去学什么。</p>
<p>为什么我在思考这个问题呢？因为iOS这一行业开发者突然增多的客观情况的存在，我们心里都很明白今后如果只会iOS开发已经不够了，况且程序员这一行业本来就变化很快，每一年最好要接触一个新的语言。而且我自己心里也很明白：现在到了该选择的时候了：<strong>我该学哪门语言呢？</strong></p>
<h3 id="Python？"><a href="#Python？" class="headerlink" title="Python？"></a>Python？</h3><p>新公司的技术团队里，有20+的人是python开发，接口就是用python写的。而且新认识的小伙伴也有做python的，随便聊两句就能指点我一二。再说，如果会写脚本，爬虫啥的，岂不是感觉屌屌的？而且机器学习，大数据什么的也可以做的。</p>
<h3 id="PHP？"><a href="#PHP？" class="headerlink" title="PHP？"></a>PHP？</h3><p>PHP7的性能提升了很多，而且部署能力强，很多公司的后端都用PHP，所以它的需求很大。况且我已经学会了iOS，如果再学会PHP，岂不是等于全栈了？</p>
<h3 id="Java？"><a href="#Java？" class="headerlink" title="Java？"></a>Java？</h3><p>如果学会了java，那么搞定安卓开发也就是时间问题了。再说java也可以写后台，所以是不是学会了java就真的移动端和后台自己全能包了？</p>
<h3 id="Javascript！"><a href="#Javascript！" class="headerlink" title="Javascript！"></a>Javascript！</h3><p>在我今年面试新公司的时候，跟我交流过的公司一共有10个左右，这其中，问我会不会混合开发（hybrid app develop：native app develop + web app develop）的就有5个。而且我也有问过之前的同事，他们的公司也几乎都有混合开发。于是我觉得这是个趋势，甚至可能已经开始了。就好比很多商城应用，很多界面都是通过H5来实现的，只是在本地做了js与OC的交互。</p>
<p>有的时候人就需要现实一点：对我来说，与其去学跨度很大的后端语言，为什么不用相同的时间学习混合开发呢？而且对于混合开发来说，我已经了解了native app 开发了不是么？</p>
<p>所以，我暂时放弃了能写脚本的Python，需求仅次于Java的PHP，能写安卓的Java，果断选择了Javascript（当然还有Html5和Css）！</p>
<p>而就在前几天，在公司项目第二版开发完成后，马上报名了优达学诚的前端工程师纳米学位的课程：<a href="https://cn.udacity.com/course/front-end-web-developer-nanodegree--nd001" target="_blank" rel="external">优达学诚 前端工程师纳米学位</a></p>
<p>昨天已经提交了第二个作业：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f60daa7f617b7ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前端工程师纳米学位 Project2"></p>
<p>励志在明年成为一个独当一面的hybrid app developer～哇咔咔</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><hr>
<p>在这一年里，我不断成熟了自己的iOS开发技术，也定下来了下一年的学习方向。当然，iOS开发还是既需要深入的，因为毕竟native app的一些实现能力，短时间用web技术还是很难超越，比如CPU和GPU密集型的任务还有就是底层的优化，与C，C++混编等等。但是毕竟现在native 与web的界限变得越来越模糊，有必要去学习web的一些东西，以备不时之需。</p>
<p>最后点个题：</p>
<p>学习提升的前提是总结，没有总结，就很难一步一个脚印，踏踏实实地走下去。就好比航海，如果不经常看星座，一步步总结之前犯下的错误，找方向，调整路线，是很难达到最终的目的地的。</p>
<p>而对于大多数人来说，提高生活质量的唯一途径就是通过工作。但是，如果工作本身对这个社会的价值不是很大，那么就很难拿到可观的薪水，就算该领域的高手，可能也不如那些工资高的行业的新手。</p>
<p>所以，现实一点来说，就像选择一个高薪的工作一样，选择一个需求比较大，前景可观的编程语言还是比较正确的。我很实在，说的都是些实实在在的话，当你想转一个跨度比较大的行业，一定要量力而行，而且好好做做研究，研究一下这个行业是不是在走下坡路，毕竟你不是一个人，你背后有养你的父母，有朋友伙伴，可能还有你的人生伴侣，把握好方向很重要。</p>
<p>可能你会说：</p>
<ul>
<li>我年轻，想做什么就做什么；</li>
<li>语言只是工具，学什么都行；</li>
</ul>
<p>但是我会告诉你：</p>
<ul>
<li>人生的每一个选择都很重要，你现在的生活取决于你曾经的选择；你今后的生活取决于你现在的选择。</li>
<li>人的精力有限，领域跨度过大的时候一定要仔细考虑，这个社会需要的是T型人才，而这个T的根基是这根竖！</li>
</ul>
<p>人最危险的就是不知道自己不知道，所以嘛，没事多想想，没有坏处。</p>
<hr>
<p>最后感谢在身后支持我转行的父母和陪伴我的女朋友，么么哒～</p>
<p>最后的最后附上本次互动的链接：<a href="http://www.jianshu.com/p/20707def779a" target="_blank" rel="external">程序员专题征文活动|GoodBye 2016,Welcome 2017
</a><br>请大家多多参与啊～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得去年这个时候看到很多同行写了年终总结，当时只工作了1个月的我觉得很是高大上。转眼一年过去了，从第一家公司来到现在的这家公司，无论技术上还是思想上都成熟了一些，巧的是简书在这个时候给我们这个平台来写年终总结。贵在参与，也为了自己，写一篇吧～&lt;/p&gt;
&lt;p&gt;&lt;img src
    
    </summary>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>2016年10月求职记 | iOS工作经验不到1年，在1个月内拿到了3个offer</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/2016%E5%B9%B410%E6%9C%88%E6%B1%82%E8%81%8C%E8%AE%B0%EF%BC%9AiOS%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E4%B8%8D%E5%88%B01%E5%B9%B4%EF%BC%8C%E5%9C%A81%E4%B8%AA%E6%9C%88%E5%86%85%E6%8B%BF%E5%88%B0%E4%BA%863%E4%B8%AAoffer/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer/</id>
    <published>2017-01-13T05:54:44.000Z</published>
    <updated>2017-01-13T05:54:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>真的是非常非常感谢我的新东家，在我最需要新工作的时候给我抛来橄榄枝~</p>
<p>新东家的知名度很高，但并不是做互联网起家的，是一家有自己线下产业的大公司，创立时间也比较久，新项目（互联网）的技术团队组成非常优秀，所以虽然给我的待遇并没有很多，但还是毫不犹豫选择了这一家。为此还谢绝了后面的面试邀请（因为要准备一些入职材料和入职之前的相关学习）。</p>
<p>笔者在国庆节期间准备简历，在国庆节后开始投递简历。从最开始投递简历到拿到最后一个offer历时3周多。因为在这段求职时间里感触很多，所以想专门写一篇博客来讲述一下自己的求职心得，希望能给各位年底求职的小伙伴，特别是做iOS的同行一些值得借鉴的东西。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-23f60ab52ef7bafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
<h3 id="1-总求职数据："><a href="#1-总求职数据：" class="headerlink" title="1. 总求职数据："></a>1. 总求职数据：</h3><hr>
<ol>
<li>从写简历到拿到最后一个offer历时26天。</li>
<li>总面试通知数：11个</li>
<li>总面试次数：8次</li>
<li>总offer数：3个</li>
</ol>
<h4 id="有趣的3个点："><a href="#有趣的3个点：" class="headerlink" title="有趣的3个点："></a>有趣的3个点：</h4><ol>
<li>简历的最初稿的完成历时2天并开始投递，在第10天才最终定稿。</li>
<li>在简历开始投递后的第一个星期里没有收到任何面试通知。</li>
<li>在3个offer里，只有一家是小公司（不到50人），其他两个都是具有相当规模的大公司。</li>
</ol>
<p>下面写一下整个求职过程的心得：</p>
<h3 id="1-简历需要持续更新"><a href="#1-简历需要持续更新" class="headerlink" title="1. 简历需要持续更新"></a>1. 简历需要持续更新</h3><hr>
<p>虽然开始简历的初版完成的挺快的，但是后来却不断发现有很多不妥的地方：</p>
<ol>
<li>不应该添加我自己的证件照：其实除了美女，是不建议有自己的证明照的。</li>
<li>不应该添加项目的icon：导致排版显得很乱，应该去掉。</li>
<li>项目经验的技术点不够具体，而且主次没有顺序：最好将技术亮点放在最前面，而且要细致一点。</li>
<li>技能清单太过俗套，不够具体：比如不能只写“熟悉RunLoop的使用”，建议这么写：“熟悉RunLoop的机制，创建常驻线程执行任务”，也就是将具体的技术点和具体的应用结合起来写一下会好一些。</li>
<li>个人优势不突出：因为项目经验少而且比较简单，所以相对来说博客和开源项目就是我的优势，而这些 优势我甚至没有在初版简历中写明，后来在更新简历的时候才写出来放在偏后的位置。但是再后来，<a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a>大大建议我开源项目的地址和优秀博客文章最好放在显著位置，我才鼓起勇气将它们放在个人信息的下面，也就是简历的第二项。</li>
<li>除了简历的撰写技巧之外，笔者也在不断自学来增添简历上的技术点：在学习前两天在简历上添加要学习的技术点，保证将来面试的时候可以用上。</li>
</ol>
<blockquote>
<p>在简历的初版完成之后就开始投递了，之后也在不断更新自己的简历，直到10天后更新才趋于稳定。</p>
</blockquote>
<h3 id="2-简历要突出个人优势"><a href="#2-简历要突出个人优势" class="headerlink" title="2. 简历要突出个人优势"></a>2. 简历要突出个人优势</h3><hr>
<p>之前提到过，在第一个星期里，我没有收到任何面试通知，直到第二个星期的星期三我才收到了第一个面试通知。而这个时间点，也正是简历最终定稿之后的2，3天。而且后来，面试通知就“源源不断”了：两周里有11个面试通知，而且越到后面越多。</p>
<p>虽然可能不是很准确，但我个人觉得：将我的博客优秀文章链接和开源项目地址放（并加上简单介绍）在简历的前面之后，我的简历变得“招人喜欢了”。</p>
<blockquote>
<p>因此，在写简历的时候，就要想：到底自己的优势点在哪里？哪个最有亮点，就毫不犹豫地写在最前面吧！</p>
<ul>
<li>如果你的优势是公司项目里的某个功能模块（不能太简单），就把这个模块写出来好好描述一下。</li>
<li>如果你在github上有星星，就把它放在简历前面，多啰嗦几句。</li>
<li>如果你的文章很热，或者被知名网站转载过，也把它放在简历前面，多啰嗦几句。</li>
<li>如果你上面三点都没有，就将你研究过或者参与过的开源框架拿出来，写一写你都从中学到了什么。</li>
</ul>
</blockquote>
<h3 id="3-大公司和小公司的用人侧重点不一样"><a href="#3-大公司和小公司的用人侧重点不一样" class="headerlink" title="3. 大公司和小公司的用人侧重点不一样"></a>3. 大公司和小公司的用人侧重点不一样</h3><hr>
<p>简历写得再好，它的性质也只是面试的敲门砖，真正考验你的还是面试。这段时间我的面试次数是8次，但是只拿到了2个offer，成绩很一般。</p>
<p>我分析了一下自己的优势和劣势：</p>
<h4 id="我的优势："><a href="#我的优势：" class="headerlink" title="我的优势："></a>我的优势：</h4><ol>
<li>学历高：海外硕士（非科班）。</li>
<li>自学能力强：iOS完全自学，而且持续更新博客，有开源项目（很渣）。入职四个月后独立负责一个新项目。</li>
</ol>
<h4 id="我的劣势："><a href="#我的劣势：" class="headerlink" title="我的劣势："></a>我的劣势：</h4><ol>
<li>工作经验少：严格来讲只有10个月。</li>
<li>项目经验少：而且项目技术点难度偏低。</li>
</ol>
<p>整体来说就是：经验少一些，潜力大一点。</p>
<p>有意思的是，这8家面试我的公司里有3家是有相当规模的大公司，而其中2家都给了我offer。而且在我面试的过程中，明显觉得自己比较受大公司青睐，而小公司却反差比较大。</p>
<h4 id="结合我的特点和面试结果有一个结论："><a href="#结合我的特点和面试结果有一个结论：" class="headerlink" title="结合我的特点和面试结果有一个结论："></a>结合我的特点和面试结果有一个结论：</h4><p>大公司招人大多还是以<strong>培养</strong>为目的。<br>小公司招人大多是以<strong>上手</strong>为目的。</p>
<blockquote>
<p>因此，<br>如果你觉得你技术很牛，能独当一面的话，大公司和小公司都可以尝试；<br>如果你经验少，但是潜力相对大一点，小公司还是相对不适合的。<br>如果你经验少，潜力也不是很大，不建议马上跳槽，把前两点的某一点或者其中一点强化再说。</p>
</blockquote>
<h3 id="4-面试题的准备有点虐心"><a href="#4-面试题的准备有点虐心" class="headerlink" title="4. 面试题的准备有点虐心"></a>4. 面试题的准备有点虐心</h3><hr>
<p>笔者在第一第二星期的时间里一直在刷网上的iOS面试题，不断地查缺补漏。在2个星期的时间里，笔记数量增加了100+条，都是记录面试题和相关基础知识的，后来实在是看不下去了，已经看吐了。</p>
<p>不过可笑的是：<br>在面试小公司的时候，问的问题及其刁钻以至于我的“iOS面试题库”几乎形同虚设，网上看的iOS面试题已经应付不了了。<br>而面试大公司的时候，几乎都没有问太多iOS相关的问题，而且问题都不难。</p>
<blockquote>
<p>虽然我最终要去的公司面试我的时候没有问我几个iOS的面试题，不过面试题还是需要准备的。这段时间总结的100多条笔记虽然一方面是为了在面试的时候发挥，另一方面也巩固了自己的基础知识，而且效果很好。</p>
</blockquote>
<h3 id="5-要么做，要么走"><a href="#5-要么做，要么走" class="headerlink" title="5. 要么做，要么走"></a>5. 要么做，要么走</h3><hr>
<p>在求职的过程中看到过这么一句话：“不是互联网不行，而是你不行”。<br>随后我就自行脑补：“不是iOS形势不行，而是你不行”。<br>那么是否可以通用一下呢：“不是<em>__</em>形势不行，而是你不行”？</p>
<p>难道互联网资本寒冬，互联网从业者就一定会失业么？<br>难道iOS形势不好，iOS开发者就一定很难找到工作或者跳槽么？</p>
<p>不要听到一些“什么什么形势不好”就给自己找不到工作找借口，给自己受伤的心灵抹上一点自欺欺人的糖。</p>
<p>为什么简历石沉大海？<br>为什么面试屡屡不中？</p>
<p>挺起胸膛解决问题好么？！</p>
<p>不要去抱怨，你抱怨的时候，可能有人在默默刷题，默默刷开源框架。对自己要求不高，必定会被淘汰。</p>
<p>认清现实吧！以前iOS这边“会拉个线就能月薪过万”的时代已经一去不复返了，如今正是淘汰浑水摸鱼的人的阶段。但这是一个好现象，说明这个行业终于走上正轨了。</p>
<p>如果觉得做不下去了，最好尽早离开；<br>如果决定坚持做下去，就要拿出你的本事让人家看看。</p>
<p>怎么看？当然不是靠说的，而是靠你做过什么。</p>
<p>现在这个时代知识的共享太容易了，绝大多数科目的入门资料在网上都能轻而易举地看到。很多人看得多了，会说了，就以为自己懂了。因此这个时代也过于浮躁，尤其是有一些会上网的年轻人。</p>
<p>但是，技术领域，对一个人的认可并不是靠说的，而是你做过了什么，或是能拿出什么能证明你以后能做什么。</p>
<p>举两个三国武将的例子：<br>从什么时候人们觉得关羽厉害？- 温酒斩华雄<br>从什么时候人们觉得吕布厉害？- 三英战吕布</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b6810305d1803032.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关二爷"></p>
<p>看出问题了么？<br>看谁牛不牛，是围绕着“事件”说的，而不是围绕花里胡哨的<strong>青龙偃月刀</strong>和<strong>方天画戟</strong>这些表面上的东西说的（虽然能舞得动这些的也能算是不弱）。</p>
<p>觉得舞刀弄枪离自己太远？举两个程序员界的例子：<br>Python的作者求职谷歌的时候只在简历上写了三个词：“I wrote Python.”<br>在iOS界家喻户晓的网络请求第三方框架AFNetworking的作者听说已经被苹果收编了。<br>（我也是听别人说的，真的假的不知道，但我就是要说，不喜欢来打我呀）</p>
<p>很现实的问题：<br>武将厉不厉害，拿战功说事儿；<br>技术工作者厉不厉害，拿作品说事儿。你的作品，反映了你的水平，也能反映你的潜力</p>
<p>所以，对于iOS程序员来说，如果想在这盘淘汰赛中不被抛弃，现在就着手构思真正属于自己的项目。或者用博客记录一下自己的学习历程，勾勒出自己的成长轨迹：“让别人知道你知道”很重要。</p>
<p>如果没有思路，没有关系，看一些已经开源的好的app和框架，相信我，不久你就会有自己的想法。因为创造无非就是拼凑，你懂得多了，自然就会“拼”了（此处双关[掩面]）。</p>
<h3 id="6-心得写完了，以后要怎么做呢？"><a href="#6-心得写完了，以后要怎么做呢？" class="headerlink" title="6. 心得写完了，以后要怎么做呢？"></a>6. 心得写完了，以后要怎么做呢？</h3><hr>
<p>上面说过，我个人感觉这次面试成功率不是很高，而原因也暴露的很明显：项目经验不足。</p>
<p>因此，笔者打算今后在不影响工作质量的情况下好好研究一些比较好的开源app和第三方框架，仔细阅读源码，从中抽取出值得学习的地方，不断提高自己的技术水平，而不仅仅停留在公司项目中。</p>
<p>目的并不是为了下次跳槽，而是为了不断搭建自己的技术壁垒，取各家之所长，借此来打造一个无法取代的自己：</p>
<p>就好比段誉：只会六脉神剑或者凌波微步还不足以独步武林，但是将二者结合在一起就能与萧大侠抗衡了。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><hr>
<p>整个求职过程中心情还是有低落的时候的，特别是第一个星期，面试通知丝毫没有动静。不过还好有一些“道上”的朋友给我鼓励和支持。在这里特别感谢在简书上认识的同行<a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a>， <a href="http://www.jianshu.com/users/a54931de4c9b/latest_articles" target="_blank" rel="external">阿拉斯加的狗</a>，<a href="http://www.jianshu.com/users/e39da354ce50/latest_articles" target="_blank" rel="external">神经骚栋</a>，<a href="http://www.jianshu.com/users/c68741efc396/latest_articles" target="_blank" rel="external">熊皮皮</a>的支持和鼓励，他们都是很优秀的iOS开发者，而且很有潜力，有很多我需要学习的地方。</p>
<p>如果有小伙伴有问题想问我，评论本文，发简信，加我微信（简书主页有我的微信二维码）都可以。<br>不过因为新东家的知名度比较高，具体新东家是谁就不方便说啦，请谅解~</p>
<p>最后还是祝愿在最近找工作的小伙伴们马到功成~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-784af8ebfba85366.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的是非常非常感谢我的新东家，在我最需要新工作的时候给我抛来橄榄枝~&lt;/p&gt;
&lt;p&gt;新东家的知名度很高，但并不是做互联网起家的，是一家有自己线下产业的大公司，创立时间也比较久，新项目（互联网）的技术团队组成非常优秀，所以虽然给我的待遇并没有很多，但还是毫不犹豫选择了这一家。
    
    </summary>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E9%AB%98%E5%BA%A6%E5%B0%81%E8%A3%85FMDB%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%90%84%E7%94%A8%E4%B8%80%E5%8F%A5%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%EF%BC%88%E6%B7%BB%E5%8A%A0&amp;%E4%BF%AE%E6%94%B9%EF%BC%89%EF%BC%8C%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息/</id>
    <published>2017-01-13T05:54:08.000Z</published>
    <updated>2017-01-16T04:42:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在移动开发中，有时不得不在客户端本地保存一些数据。在iOS端，我们可以使用plist，属性列表等技术来存储数据，而相比而下更高端一点的，我们也可以使用<strong>数据库</strong>来存储数据。</p>
<p>有趣的是，很多iOS开发者没有去选择使用苹果自家的Core Data技术来操作数据库，而是选择了<a href="[https://github.com/ccgus/fmdb](https://github.com/ccgus/fmdb">FMDB</a>)这个第三方框架。</p>
<p>该框架很好地封装了操作繁琐的SQLite语句，让数据库的操作更加面向对象，而且上手快，门槛低，不用学习数据库的相关知识就可以使用自如。如此优秀流行的框架是值得学习的，于是笔者这两天研究了一下FMDB。研究后，略有所思，将它封装了一下，写了一个<code>Manager</code>类，最后结合了一个Demo演示如何使用这个类。</p>
<p>该博客分为两个部分:第一个部分讲解笔者封装的这个<code>Manager</code>类；第二部分结合Demo来体现该类的实用性。</p>
<h1 id="1-封装FMDB"><a href="#1-封装FMDB" class="headerlink" title="1. 封装FMDB"></a>1. 封装FMDB</h1><hr>
<h2 id="1-1-封装类的功能"><a href="#1-1-封装类的功能" class="headerlink" title="1.1 封装类的功能"></a>1.1 封装类的功能</h2><p>首先看一下这个类的大名：SJUserInfoManager</p>
<ul>
<li>SJ：笔者的名字缩写，作为前缀，都懂得。</li>
<li>UserInfo:说明这个类用于操作用户信息。</li>
<li>Manager:这个类只具有工厂方法，省内存，而且方便使用。</li>
</ul>
<p><strong>这个类的功能是：它可以创建一个关于用户信息的表（数据库），可以保存，修改，读取，删除用户信息</strong>。</p>
<blockquote>
<p>现在几乎每个app都有登录功能，有登录就意味着有用户信息。有的时候，我们需要将一些用户信息存储到本地，方便今后的读取和操作。</p>
<p>而对于用户信息，几乎永远不变的一项就是用户id，因为用户可以改自己的名字，自己的注册手机号，用户签名等等，然而用户id是唯一一成不变的，后端查找用户信息一般都通过用户id来查找，这不难理解。</p>
</blockquote>
<p>因此，这个封装类基于用户id（user_id），让使用者可以自主添加<strong>一项</strong>自定义的用户信息（可以是用户名，用户签名，用户性别等等），从而形成一个只具有两个纵行的表（第一个纵行是默认的字段：user_id,第二个纵行是自定义字段，可以是user_name等等）。</p>
<p>这样一来，我们就可以生成很多基于用户id的表：可以是用户姓名的表，可以是用户出生日期的表，可以是用户手机号的表等等。</p>
<h2 id="1-2-API介绍"><a href="#1-2-API介绍" class="headerlink" title="1.2 API介绍"></a>1.2 API介绍</h2><p>该封装类的API一共有五个，分别是：</p>
<ol>
<li>创建表格</li>
<li>更新用户信息（添加&amp;修改）</li>
<li>查询某个用户的信息</li>
<li>查询全部用户的信息</li>
<li>删除某个用户的信息</li>
</ol>
<p>下面开始一一讲解：</p>
<h4 id="1-创建表格"><a href="#1-创建表格" class="headerlink" title="1. 创建表格"></a>1. 创建表格</h4><pre><code class="objc">/*
 ********** Create table with tableName and fieldName **********
 *
 * @param   dataBaseName    tableNameString (表的名字)
 * @param   userInfoField   fieldNameString（自定义字段名）
 *
 * @return  if the table is successfully created
 *
 */
+ (BOOL)createDataBaseWithName:(NSString *)dataBaseName andUserInfoField:(NSString *)userInfoField;
</code></pre>
<blockquote>
<p>这个方法的意图很明显，只要传进去表的名字和自定义字段的名字就能创造一个表。</p>
<ul>
<li>创建成功，返回YES；</li>
<li>创建失败，返回NO。</li>
</ul>
<p>而且这个表有一个默认的字段：user_id。因为通过这个类创建用户信息的表是基于用户id来操作的，前面已有说明。</p>
</blockquote>
<h4 id="2-更新用户信息（添加-amp-修改）"><a href="#2-更新用户信息（添加-amp-修改）" class="headerlink" title="2. 更新用户信息（添加&amp;修改）"></a>2. 更新用户信息（添加&amp;修改）</h4><pre><code class="objc">/*
 ********** update specific userInfo with specific userID and userInfoField and userInfoValue **********
 *
 * @param   dataBaseName    tableNameString (表的名字)
 * @param   userID          userIDString（用户id的值）
 * @param   userInfoField   fieldNameString（自定义字段名）
 * @param   userInfoValue   userInfoValueString（字段对应的值）
 *
 * @return  the result of updating specific userInfo 
 *
 */
+ (NSString *)updateUserInfoIntoDataBase:(NSString *)dataBaseName withUserID:(NSString *)userID andUserInfoField:(NSString *)userInfoField andUserInfoValue:(NSString *)userInfoValue;
</code></pre>
<blockquote>
<p>这个方法用于更新用户信息，传入表的名字，用户id，自定义字段名，和自定义字段对应的值。</p>
<ul>
<li>如果输入的表不存在，则返回相应的错误信息。</li>
<li>如果输入的用户id已经存在，就更新对应的用户信息。</li>
<li>如果输入的用户id不存在，就添加这个用户的信息。</li>
</ul>
</blockquote>
<h4 id="3-查询某个用户的信息"><a href="#3-查询某个用户的信息" class="headerlink" title="3. 查询某个用户的信息"></a>3. 查询某个用户的信息</h4><pre><code class="objc">/*
 ********** Query specific userInfoValue with tableName and userID and userInfoField **********
 *
 * @param   dataBaseName    tableNameString (表的名字)
 * @param   userID          userIDString（用户id的值）
 * @param   userInfoField   fieldNameString（自定义字段名）
 *
 * @return  specific userInfoValue （表内某用户id对应的用户信息）
 *
 */
+ (NSString *)queryUserInfoInDataBase:(NSString *)dataBaseName WithUserID:(NSString *)userId andUserInfoField:(NSString *)userInfoField;
</code></pre>
<blockquote>
<p>该方法用于查询某个用户的信息，传入表的名字，用户id和自定义字段名。</p>
<ul>
<li>如果输入的表不存在，则返回相应的错误信息。</li>
<li>如果输入的用户id存在，则返回对应的信息。</li>
<li>如果输入的用户id不存在，则返回相应的错误信息。</li>
</ul>
</blockquote>
<h4 id="4-查询全部用户的信息"><a href="#4-查询全部用户的信息" class="headerlink" title="4. 查询全部用户的信息"></a>4. 查询全部用户的信息</h4><pre><code class="objc">/*
 ********** Query all userInfos in this table with userInfoField **********
 *
 * @param   dataBaseName    tableNameString (表的名字)
 * @param   userInfoField   fieldNameString（自定义字段名）
 *
 * @return  all the userInfos in this table （表内所有的用户信息）
 *
 */
+ (NSDictionary *)queryUserInfosInDataBase:(NSString *)dataBaseName andUserInfoField:(NSString *)userInfoField;
</code></pre>
<blockquote>
<p>该方法用户获取某个表内的所有用户信息，传入表的名字和自定义字段名即可。<br>返回的字典里包含一个数组，数组元素为表的每一行的信息。每一行的信息是一个字典：</p>
<ul>
<li>其中一个key为默认的字段名：user_id，它的值为对应的user_id的值。</li>
<li>另一个key为添加的自定义字段名，它对应的值为该字段对应的值。</li>
</ul>
</blockquote>
<h4 id="5-删除某个用户的信息"><a href="#5-删除某个用户的信息" class="headerlink" title="5. 删除某个用户的信息"></a>5. 删除某个用户的信息</h4><pre><code class="objc">/*
 ********** Delete specific userInfo with specific userID **********
 *
 * @param   dataBaseName    tableNameString (表的名字)
 * @param   userId          userIDString（用户id的值）
 *
 * @return  the result of deleting specific userInfo （删除的结果）
 *
 */
+ (NSString *)deleteUserInfoInDataBase:(NSString *)dataBaseName WithUserID:(NSString *)userId;
</code></pre>
<blockquote>
<p>该方法用于删除表里的某个用户信息，只要传入表的名字和用户id即可，可以删除表中对应的一整行信息。同样地，如果输入的表不存在，则返回相应的错误信息。</p>
</blockquote>
<p>如果觉得有点抽象的话，可以看下面这个Demo，可以看到该封装类的具体使用方法。</p>
<h1 id="2-Demo演示"><a href="#2-Demo演示" class="headerlink" title="2. Demo演示"></a>2. Demo演示</h1><hr>
<p>在这个Demo中，我们要在表里添加的自定义字段名(fieldNameString)为：“user_name”。也就是说这个表将保存用户id和用户名信息。</p>
<h2 id="2-1-需求"><a href="#2-1-需求" class="headerlink" title="2.1 需求"></a>2.1 需求</h2><ol>
<li>在插入板块中插入用户信息（用户id和用户名）。</li>
<li>在查询板块中，根据输入的用户id，可以显示对应的用户名。如果没有对应的用户id，则显示“没有对应id”。</li>
<li>在删除板块中，根据输入的用户id，可以删除对应的用户信息（包括用户id和用户名，也就是删除了表的一整行）。如果没有对应的用户id，则显示“没有对应id”。</li>
<li>点击导航栏右侧的按钮，进入“用户信息列表页”。在这一页显示当前表里的全部用户的信息（在cell的textLabel里显示用户名；在cell的detailTextLabel里显示用户id）。</li>
</ol>
<h2 id="2-2-效果图"><a href="#2-2-效果图" class="headerlink" title="2.2 效果图"></a>2.2 效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-404e4004af3b981a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左图：数据库操作页面（插入，查询，删除板块）| 右图：数据库全部用户信息"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f32a934c4eb45af6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地沙盒中sqlite表文件内容"></p>
<h3 id="2-3-代码讲解"><a href="#2-3-代码讲解" class="headerlink" title="2.3 代码讲解"></a>2.3 代码讲解</h3><p><strong>1. 最先导入这个封装类和FMDB框架：</strong></p>
<pre><code class="objc">#import &quot;SJUserInfoManager.h&quot;
</code></pre>
<p><strong>2. 因为表的名字和自定义字段是固定的，所以就以宏来定义了：</strong></p>
<pre><code class="objc">#define DATABASENAME  @&quot;userInfoTable&quot; //表的名字
#define USERINFOFIELD @&quot;user_name&quot;     //自定义字段的名字
</code></pre>
<p><strong>3. 添加几个输入框的属性，获取输入框的内容；和查询结果显示</strong>Label：</p>
<pre><code class="objc">@property (strong, nonatomic) IBOutlet UITextField *insertUserIdTextfield;       //插入输入框：输入用户id
@property (strong, nonatomic) IBOutlet UITextField *insertUserInfoValueTextfiled;//插入收入框：输入用户名

@property (strong, nonatomic) IBOutlet UITextField *queryUserIdTextfield;        //查询输入框：输入用户id
@property (strong, nonatomic) IBOutlet UILabel *queryUserInfoValueLabel;         //查询结果显示Label:显示用户id对应的用户名

@property (strong, nonatomic) IBOutlet UITextField *deleteUserIdTextField;       //删除输入框：输入用户id
</code></pre>
<p><strong>4. 下面看一下封装的增改&amp;查&amp;删的代码：</strong></p>
<pre><code class="objc">//插入用户信息
- (IBAction)insertAction:(id)sender {

    NSString *result = @&quot;&quot;;

    if (self.insertUserInfoValueTextfiled.text.length == 0) {

         result = @&quot;Please Input UserID!&quot;;//没有输入用户id就点击了插入按钮

    }else{

         result = [SJUserInfoManager updateUserInfoIntoDataBase:DATABASENAME withUserID:self.insertUserIdTextfield.text andUserInfoField:USERINFOFIELD andUserInfoValue:self.insertUserInfoValueTextfiled.text];
    }

   [self showAlertWithTitle:result];

}

//查询用户信息
- (IBAction)queryUserInfoValue:(UIButton *)sender {

    NSString *result = @&quot;&quot;;

    if (self.queryUserIdTextfield.text.length == 0) {

        result = @&quot;Please Input UserID!&quot;;//没有输入用户id就点击了查询按钮
        self.queryUserInfoValueLabel.text = @&quot;&quot;;//重置查询输入框

    }else{

        result =  [SJUserInfoManager queryUserInfoInDataBase:DATABASENAME WithUserID:self.queryUserIdTextfield.text andUserInfoField:USERINFOFIELD];
        self.queryUserInfoValueLabel.text = result;
        [self showAlertWithTitle:result];

    }

    [self showAlertWithTitle:result];
}

//删除用户信息
- (IBAction)deleteUserInfoWithUserID:(UIButton *)sender {

    NSString *result = @&quot;&quot;;

    if (self.deleteUserIdTextField.text.length == 0) {

        result = @&quot;Please Input UserID!&quot;;

    }else{

        result =  [SJUserInfoManager deleteUserInfoInDataBase:DATABASENAME WithUserID:self.deleteUserIdTextField.text];
    }

    [self showAlertWithTitle:result];

}
</code></pre>
<blockquote>
<p>其实不难看出，除了处理错误信息的代码以外，数据库的操作代码是非常简洁的:都是一行结束，而且返回一个结果字符串或者布尔值。</p>
</blockquote>
<p><strong>5. 在进入第二页之前，需要查询表内所有的用户信息并传递给第二个页面的VC：</strong></p>
<pre><code class="objc">-(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    if ([segue.destinationViewController isKindOfClass:[DataListTableViewController class]]) {
        if ([segue.identifier isEqualToString:@&quot;userInfosList&quot;]) {

            NSDictionary *userInfosDict = [SJUserInfoManager queryUserInfosInDataBase:DATABASENAME andUserInfoField:USERINFOFIELD];
            DataListTableViewController *dataListVc = (DataListTableViewController *)segue.destinationViewController;
            dataListVc.userInfosDict = userInfosDict;
        }
    }    
}
</code></pre>
<p><strong>6. 在第二页的viewDidLoad方法里获取用户信息列表，并刷新表格将其显示出来：</strong></p>
<pre><code class="objc">- (void)viewDidLoad {

    [super viewDidLoad];

    NSString *alertTitle = [self.userInfosDict objectForKey:@&quot;result&quot;];
    [self showAlertWithTitle:alertTitle];

    NSArray *userInfosArray = [self.userInfosDict objectForKey:@&quot;userInfosArray&quot;];
    if ([userInfosArray count] != 0) {
         self.userInfosArray = userInfosArray;
        [self.tableView reloadData];
    }

}
</code></pre>
<p>想知道Demo是如何实现的么？</p>
<p>Demo传送门：<a href="https://github.com/Shijie0111/SJUserInfoManager">SJUserInfoManager - GitHub</a></p>
<p>如果可以给星星，或者给笔者提意见，那就再好不过啦~</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>说来惭愧，笔者封装的这个类的功能还是很有局限性的：</p>
<ol>
<li>操作表格前必须创建一次表格（一次就可以）。</li>
<li>只支持NSString类型的值。</li>
<li>除user_id字段以外只支持一个自定义字段。</li>
<li>不同的自定义字段必须对应不同的表格名，也就是说不同的自定义字段不能对应同一个表格名。</li>
<li>数据库操作API的返回值还不够完善，最好以枚举类型返回，有待改进。</li>
<li>没有使用FMDB的队列API。</li>
</ol>
<p>虽然这个封装很简单，但是笔者始终赞同<strong>学习的最终目的在于应用和创造</strong>这句话。如果只是用眼睛看FMDB框架的API或是复制粘贴一些别人写好的FMDB的应用代码，那么其实是意义不大的。</p>
<p>如果在学习后，可以融会贯通，将学到的知识可以按照自己的意图加以改进和运用的话，那么相对于“搬运工”式学习来说，显然收获更大。</p>
<p>这是笔者第一个开源项目，虽然简单，算上优化和改bug只写了大概3个小时，但是毕竟是开源的第一步，对自己的鼓励还是蛮大的，以后还会封装优化更多的库，加油~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在移动开发中，有时不得不在客户端本地保存一些数据。在iOS端，我们可以使用plist，属性列表等技术来存储数据，而相比而下更高端一点的，我们也可以使用&lt;strong&gt;数据库&lt;/strong&gt;来存储数据。&lt;/p&gt;
&lt;p&gt;有趣的是，很多iOS开发者没有去选择使用苹果自家的Cor
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C》超级干货三部曲（三）：技巧篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E3%80%8AEffective%20Objective-C%E3%80%8B%E8%B6%85%E7%BA%A7%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%8A%80%E5%B7%A7%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（三）：技巧篇/</id>
    <published>2017-01-13T05:52:57.000Z</published>
    <updated>2017-01-13T05:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>《Effective Objective-C 》超级干货三部曲系列迎来了最后一篇：技巧篇，这一篇总结汇总了这本书中一些用来解决问题的偏向“设计模式”的知识点。</p>
<p>不知道笔者所谓的三部曲的童鞋们可以看一下这张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0599d987732d932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<p>前两篇传送门：<br><a href="http://www.jianshu.com/p/9c93c7ab734d" target="_blank" rel="external">《Effective Objective-C 》超级干货三部曲（一）：概念篇</a><br><a href="http://www.jianshu.com/p/0b895e39eca1" target="_blank" rel="external">《Effective Objective-C 》超级干货三部曲（二）：规范篇</a></p>
<h1 id="第9条-以“类族模式“隐藏实现细节"><a href="#第9条-以“类族模式“隐藏实现细节" class="headerlink" title="第9条 以“类族模式“隐藏实现细节"></a>第9条 以“类族模式“隐藏实现细节</h1><hr>
<p>在iOS开发中，我们也会使用“类族”(class cluster)这一设计模式，通过“抽象基类”来实例化不同的实体子类。</p>
<p>举个🌰 ：</p>
<pre><code class="objc">+ (UIButton *)buttonWithType:(UIButtonType)type;
</code></pre>
<blockquote>
<p>在这里，我们只需要输入不同的按钮类型(UIButtonType)就可以得到不同的UIButton的子类。在OC框架中普遍使用这一设计模式。</p>
</blockquote>
<h4 id="为什么要这么做呢"><a href="#为什么要这么做呢" class="headerlink" title="为什么要这么做呢?"></a>为什么要这么做呢?</h4><p>笔者认为这么做的原因是为了“弱化”子类的具体类型，让开发者无需关心创建出来的子类具体属于哪个类。（这里觉得还有点什么，但是还没有想到，欢迎补充！）</p>
<p>我们可以看一个具体的例子：<br>对于“员工”这个类，可以有各种不同的“子类型”：开发员工，设计员工和财政员工。这些“实体类”可以由“员工”这个抽象基类来获得：</p>
<h4 id="1-抽象基类"><a href="#1-抽象基类" class="headerlink" title="1. 抽象基类"></a>1. 抽象基类</h4><pre><code class="objc">//EOCEmployee.h

typedef NS_ENUM(NSUInteger, EOCEmployeeType) {
    EOCEmployeeTypeDeveloper,
    EOCEmployeeTypeDesigner,
    EOCEmployeeTypeFinance,
};

@interface EOCEmployee : NSObject

@property (copy) NSString *name;
@property NSUInteger salary;


// Helper for creating Employee objects
+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;

// Make Employees do their respective day&#39;s work
- (void)doADaysWork;

@end
</code></pre>
<pre><code>//EOCEmployee.m

@implementation EOCEmployee

+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type {
     switch (type) {
         case EOCEmployeeTypeDeveloper:
            return [EOCEmployeeDeveloper new];
         break; 

        case EOCEmployeeTypeDesigner:
             return [EOCEmployeeDesigner new];
         break;

        case EOCEmployeeTypeFinance:
             return [EOCEmployeeFinance new];
         break;
    }
}

- (void)doADaysWork {
 // 需要子类来实现
}



@end
</code></pre><blockquote>
<p>我们可以看到，将EOCEmployee作为抽象基类，这个抽象基类有一个初始化方法，通过这个方法，我们可以得到多种基于这个抽象基类的实体子类:</p>
</blockquote>
<h4 id="2-实体子类（concrete-subclass）"><a href="#2-实体子类（concrete-subclass）" class="headerlink" title="2. 实体子类（concrete subclass）:"></a>2. 实体子类（concrete subclass）:</h4><pre><code>
@interface EOCEmployeeDeveloper : EOCEmployee
@end

@implementation EOCEmployeeDeveloper

- (void)doADaysWork {
    [self writeCode];
}

@end
</code></pre><blockquote>
<p><strong>注意：</strong><br>如果对象所属的类位于某个类族中，那么在查询类型信息时就要小心。因为类族中的实体子类并不与其基类属于同一个类。</p>
</blockquote>
<h1 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h1><hr>
<p>我们可以通“关联对象”机制来把两个对象连接起来。这样我们就可以从某个对象中获取相应的关联对象的值。</p>
<p>先看一下关联对象的语法：</p>
<h4 id="1-为某个对象设置关联对象的值："><a href="#1-为某个对象设置关联对象的值：" class="headerlink" title="1. 为某个对象设置关联对象的值："></a>1. 为某个对象设置关联对象的值：</h4><p><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code></p>
<blockquote>
<p>这里，第一个参数是主对象，第二个参数是键，第三个参数是关联的对象，第四个参数是存储策略:是枚举，定义了内存管理语义。</p>
</blockquote>
<h4 id="2-根据给定的键从某对象中获取相应的关联对象值："><a href="#2-根据给定的键从某对象中获取相应的关联对象值：" class="headerlink" title="2. 根据给定的键从某对象中获取相应的关联对象值："></a>2. 根据给定的键从某对象中获取相应的关联对象值：</h4><p><code>id objc_getAssociatedObject(id object, void *key)</code></p>
<h4 id="3-移除指定对象的关联对象："><a href="#3-移除指定对象的关联对象：" class="headerlink" title="3. 移除指定对象的关联对象："></a>3. 移除指定对象的关联对象：</h4><p><code>void objc_removeAssociatedObjects(id object)</code></p>
<p>举个例子：</p>
<pre><code>#import &lt;objc/runtime.h&gt;

static void *EOCMyAlertViewKey = &quot;EOCMyAlertViewKey&quot;;


- (void)askUserAQuestion {

         UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@&quot;Question&quot;
                                                         message:@&quot;What do you want to do?&quot;
                                                        delegate:self
                                               cancelButtonTitle:@&quot;Cancel&quot;
                                               otherButtonTitles:@&quot;Continue&quot;, nil];

         void (^block)(NSInteger) = ^(NSInteger buttonIndex){

                     if (buttonIndex == 0) {
                            [self doCancel];
                     } else {
                            [self doContinue];
                    }
         };

         //将alert和block关联在了一起
         objc_setAssociatedObject(alert,EOCMyAlertViewKey,block, OBJC_ASSOCIATION_COPY);
         [alert show];
}

// UIAlertViewDelegate protocol method
- (void)alertView:(UIAlertView*)alertView clickedButtonAtIndex:(NSInteger)buttonIndex
{
     //alert取出关联的block
      void (^block)(NSInteger) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey)
     //给block传入index值
      block(buttonIndex);
}
</code></pre><h1 id="第13条：用“方法调配技术”调试“黑盒方法”"><a href="#第13条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第13条：用“方法调配技术”调试“黑盒方法”"></a>第13条：用“方法调配技术”调试“黑盒方法”</h1><hr>
<p>与选择子名称相对应的方法是可以在运行期被改变的，所以，我们可以不用通过继承类并覆写方法就能改变这个类本身的功能。</p>
<p>那么如何在运行期改变选择子对应的方法呢？<br>答：通过操纵类的方法列表的IMP指针</p>
<p>什么是类方法表？什么是IMP指针呢？</p>
<blockquote>
<p>类的方法列表会把<strong>选择子</strong>的名称映射到相关的方法实现上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这些指针叫做IMP。例如NSString类的选择子列表：</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c58274453996f2c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类方法表的映射"></p>
<p>有了这张表，OC的运行期系统提供的几个方法就能操纵它。开发者可以向其中增加选择子，也可以改变某选择子对应的方法实现，也可以交换两个选择子所映射到的指针以达到交换方法实现的目的。</p>
<p>举个 ：交换<code>lowercaseString</code>和<code>uppercaseString</code>方法的实现：</p>
<pre><code>Method originalMethod = class_getInstanceMethod([NSString class], @selector(lowercaseString));
Method swappedMethod = class_getInstanceMethod([NSString class],@selector(uppercaseString));

method_exchangeImplementations(originalMethod, swappedMethod);
</code></pre><blockquote>
<p>这样一来，类方法表的映射关系就变成了下图：</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-10ddc4e1634625b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交换两个方法"></p>
<blockquote>
<p>这时，如果我们调用lowercaseString方法就会实际调用uppercaseString的方法，反之亦然。</p>
</blockquote>
<p><strong>然而！</strong><br>在实际应用中，只交换已经存在的两个方法是没有太大意义的。我们应该利用这个特性来给既有的方法添加新功能（听上去吊吊的）：</p>
<p>它的实现原理是：先通过分类增加一个新方法，然后将这个新方法和要增加功能的旧方法替换（旧方法名 对应新方法的实现），这样一来，如果我们调用了旧方法，就会实现新方法了。</p>
<p>不知道这么说是否抽象。还是举个 ：</p>
<p><strong>需求：</strong>我们要在原有的lowercaseString方法中添加一条输出语句。</p>
<h4 id="步骤一：我们先将新方法写在NSString的分类里："><a href="#步骤一：我们先将新方法写在NSString的分类里：" class="headerlink" title="步骤一：我们先将新方法写在NSString的分类里："></a>步骤一：我们先将新方法写在NSString的分类里：</h4><pre><code>@interface NSString (EOCMyAdditions)
- (NSString*)eoc_myLowercaseString;
@end


@implementation NSString (EOCMyAdditions)

- (NSString*)eoc_myLowercaseString {
     NSString *lowercase = [self eoc_myLowercaseString];//eoc_myLowercaseString方法会在将来方法调换后执行lowercaseString的方法
     NSLog(@&quot;%@ =&gt; %@&quot;, self, lowercase);//输出语句，便于调试
     return lowercase;
}
@end
</code></pre><h4 id="步骤二：交换两个方法的实现（操纵调换IMP指针）"><a href="#步骤二：交换两个方法的实现（操纵调换IMP指针）" class="headerlink" title="步骤二：交换两个方法的实现（操纵调换IMP指针）"></a>步骤二：交换两个方法的实现（操纵调换IMP指针）</h4><pre><code>Method originalMethod =
 class_getInstanceMethod([NSString class],
 @selector(lowercaseString));
Method swappedMethod =
 class_getInstanceMethod([NSString class],
 @selector(eoc_myLowercaseString));

method_exchangeImplementations(originalMethod, swappedMethod);
</code></pre><p>这样一来，我们如果交换了<code>lowercaseString</code>和<code>eoc_myLowercaseString</code>的方法实现，那么在调用原来的<code>lowercaseString</code>方法后就可以输出新增的语句了。</p>
<p><code>“NSString *string = @&quot;ThIs iS tHe StRiNg&quot;;
NSString *lowercaseString = [string lowercaseString];
// Output: ThIs iS tHe StRiNg =&gt; this is the string”</code></p>
<h1 id="第16条：提供”全能初始化方法”"><a href="#第16条：提供”全能初始化方法”" class="headerlink" title="第16条：提供”全能初始化方法”"></a>第16条：提供”全能初始化方法”</h1><hr>
<p>有时，由于要实现各种设计需求，一个类可以有多个创建实例的初始化方法。我们应该<strong>选定其中一个</strong>作为<strong>全能初始化方法</strong>，令其他初始化方法都来调用它。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>只有在这个全能初始化方法里面才能存储内部数据。这样一来，当底层数据存储机制改变时，只需修改此方法的代码就好，无需改动其他初始化方法。</li>
<li>全能初始化方法是所有初始化方法里参数最多的一个，因为它使用了尽可能多的初始化所需要的参数，以便其他的方法来调用自己。</li>
<li>在我们拥有了一个全能初始化方法后，最好还是要覆写init方法来设置默认值。</li>
</ul>
</blockquote>
<pre><code>//全能初始化方法
- (id)initWithWidth:(float)width andHeight:(float)height
{
     if ((self = [super init])) {
        _width = width;
        _height = height;
    }
    return self;
}

//init方法也调用了全能初始化方法
- (id)init {
     return [self initWithWidth:5.0f andHeight:10.0f];
}
</code></pre><p>现在，我们要创造一个squre类继承这上面这个ractangle类,它有自己的全能初始化方法：</p>
<pre><code>- (id)initWithDimension: (float)dimension{
    return [super initWithWidth:dimension andHeight:dimension];
}
</code></pre><h4 id="这里有问题！"><a href="#这里有问题！" class="headerlink" title="这里有问题！"></a>这里有问题！</h4><p>然而，因为square类是rectangle类的子类，那么它也可以使用<code>initWithWidth: andHeight:</code>方法，更可以使用<code>init</code>方法。那么这两种情况下，显然是无法确保初始化的图形是正方形。</p>
<p>因此，我们需要在这里覆写square的父类rectangle的全能初始化方法：</p>
<pre><code>- (id)initWithWidth:(float)width andHeight:(float)height
{
    float dimension = MAX(width, height);
    return [self initWithDimension:dimension];
}
</code></pre><p>这样一来，当square用<code>initWithWidth: andHeight:</code>方法初始化时，就会得到一个正方形。</p>
<p>并且，如果用<code>init</code>方法来初始化square的话，我们也可以得到一个默认的正方形。因为在rectangle类里覆写了init方法，而这个init方法又调用了<code>initWithWidth: andHeight:</code>方法，并且square类又覆写了<code>initWithWidth: andHeight:</code>方法，所以我们仍然可以得到一个正方形。</p>
<p>而且，为了让square的init方法得到一个默认的正方形，我们也可以覆写它自己的初始化方法：</p>
<pre><code>- (id)init{
    return [self initWithDimension:5.0f];
}
</code></pre><p>我们做个总结：</p>
<p>因为子类的全能初始化方法（initWithDimension:）和其父类的初始化方法并不同，所以我们需要在子类里覆写<code>initWithWidth: andHeight:</code>方法。</p>
<h4 id="还差一点：initWithCoder-的初始化"><a href="#还差一点：initWithCoder-的初始化" class="headerlink" title="还差一点：initWithCoder:的初始化"></a>还差一点：initWithCoder:的初始化</h4><p>有时，需要定义两种全能初始化方法，因为对象有可能有两种完全不同的创建方式，例如<code>initWithCoder:</code>方法。</p>
<p>我们仍然需要调用超类的初始化方法：</p>
<p>在rectangle类：</p>
<pre><code>// Initializer from NSCoding
- (id)initWithCoder:(NSCoder*)decoder {

     // Call through to super&#39;s designated initializer
         if ((self = [super init])) {
            _width = [decoder decodeFloatForKey:@&quot;width&quot;];
            _height = [decoder decodeFloatForKey:@&quot;height&quot;];
        }
     return self;
}
</code></pre><p>在square类：</p>
<pre><code>// Initializer from NSCoding
- (id)initWithCoder:(NSCoder*)decoder {

 // Call through to super&#39;s designated initializer
      if ((self = [super initWithCoder:decoder])) {
     // EOCSquare&#39;s specific initializer
    }
     return self;
}
</code></pre><p>每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上。在调用了超类的初始化方法后，再执行与本类相关的方法。</p>
<h1 id="第17条：实现description方法"><a href="#第17条：实现description方法" class="headerlink" title="第17条：实现description方法"></a>第17条：实现description方法</h1><hr>
<p>在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：</p>
<pre><code>object = &lt;EOCPerson: 0x7fd9a1600600&gt;
</code></pre><blockquote>
<p>这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。</p>
</blockquote>
<p><strong>但是！</strong>如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。</p>
<p>例如：</p>
<pre><code>
- (NSString*)description {
     return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@ %@&gt;&quot;, [self class], self, firstName, lastName];
}
</code></pre><p>在这里，显示了内存地址，还有该类的所有属性。</p>
<p>而且，如果我们将这些属性值放在字典里打印，则更具有可读性：</p>
<pre><code>- (NSString*)description {

     return [NSString stringWithFormat:@&quot;&lt;%@: %p, %@&gt;&quot;,[self class],self,

    @{    @&quot;title&quot;:_title,
       @&quot;latitude&quot;:@(_latitude),
      @&quot;longitude&quot;:@(_longitude)}
    ];
}
</code></pre><p>输出结果：</p>
<pre><code>location = &lt;EOCLocation: 0x7f98f2e01d20, {

    latitude = &quot;51.506&quot;;
   longitude = 0;
       title = London;
}&gt;
</code></pre><blockquote>
<p>我们可以看到，通过重写<code>description</code>方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。</p>
</blockquote>
<h1 id="第28条-通过协议提供匿名对象"><a href="#第28条-通过协议提供匿名对象" class="headerlink" title="第28条:通过协议提供匿名对象"></a>第28条:通过协议提供匿名对象</h1><hr>
<p>匿名对象（Annonymous object），可以理解为“没有名字的对象”。有时我们用协议来提供匿名对象，目的在于说明它仅仅表示“遵从某个协议的对象”，而不是“属于某个类的对象”。</p>
<p>它的表示方法为：<code>id&lt;protocol&gt;</code>。<br>通过协议提供匿名对象的主要使用场景有两个：</p>
<ul>
<li>作为属性</li>
<li>作为方法参数</li>
</ul>
<h4 id="1-匿名对象作为属性"><a href="#1-匿名对象作为属性" class="headerlink" title="1. 匿名对象作为属性"></a>1. 匿名对象作为属性</h4><p>在设定某个类为自己的代理属性时，可以不声明代理的类，而是用id<protocol>，因为<strong>成为</strong>代理的终点并不是<strong>某个类的实例</strong>，而是<strong>遵循了某个协议</strong>。</protocol></p>
<p>举个 ：</p>
<pre><code>@property (nonatomic, weak) id &lt;EOCDelegate&gt; delegate;
</code></pre><p>在这里使用匿名对象的原因有两个：</p>
<ol>
<li>将来可能会有很多不同类的实例对象作为该类的代理。</li>
<li>我们不想指明具体要使用哪个类来作为这个类的代理。</li>
</ol>
<p>也就是说，能作为该类的代理的条件只有一个：它遵从了 <eocdelegate>协议。</eocdelegate></p>
<h4 id="2-匿名对象作为方法参数"><a href="#2-匿名对象作为方法参数" class="headerlink" title="2. 匿名对象作为方法参数"></a>2. 匿名对象作为方法参数</h4><p>有时，我们不会在意方法里某个参数的具体类型，而是遵循了某种协议，这个时候就可以使用匿名对象来作为方法参数。</p>
<p>举个 ：</p>
<pre><code>- (void)setObject:(id)object forKey:(id&lt;NSCopying&gt;)key;
</code></pre><p>这个方法是NSDictionary的设值方法，它的参数只要遵从了<nscopying>协议，就可以作为参数传进去,作为NSDictionary的键。</nscopying></p>
<h1 id="第32条：编写“异常安全代码”时留意内存管理问题"><a href="#第32条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第32条：编写“异常安全代码”时留意内存管理问题"></a>第32条：编写“异常安全代码”时留意内存管理问题</h1><hr>
<p>在发生异常时的内存管理需要仔细考虑内存管理的问题：</p>
<blockquote>
<p>在try块中，如果先保留了某个对象，然后在释放它之前又抛出了异常，那么除非在catch块中能处理此问题，否则对象所占内存就将泄漏。</p>
</blockquote>
<h4 id="在MRC环境下："><a href="#在MRC环境下：" class="headerlink" title="在MRC环境下："></a>在MRC环境下：</h4><pre><code>@try {
     EOCSomeClass *object = [[EOCSomeClass alloc] init];
      [object doSomethingThatMayThrow];
      [object release];

}


@catch (...) {
         NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);
}
</code></pre><p>这里，我们用release方法释放了try中的对象，但是这样做仍然有问题：如果在<code>doSomthingThatMayThrow</code>方法中抛出了异常了呢？</p>
<p>这样就无法执行<code>release</code>方法了。</p>
<p>解决办法是使用@finnaly块，无论是否抛出异常，其中的代码都能运行：</p>
<p>```EOCSomeClass *object;<br>@try {<br>    object = [[EOCSomeClass alloc] init];<br>    [object doSomethingThatMayThrow];<br>}</p>
<p>@catch (…) {<br>     NSLog(@”Whoops, there was an error. Oh well…”);<br>}</p>
<p>@finally {<br>    [object release];<br>}```</p>
<p>####在ARC环境下呢？</p>
<pre><code>@try {
     EOCSomeClass *object = [[EOCSomeClass alloc] init];
     [object doSomethingThatMayThrow];
}



@catch (...) {
 NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);
}
</code></pre><p>这时，我们无法手动使用<code>release</code>方法了，解决办法是使用：-fobjc-arc-exceptions 标志来加入清理代码，不过会导致应用程序变大，而且会降低运行效率。</p>
<h1 id="第33条：以弱引用避免保留环"><a href="#第33条：以弱引用避免保留环" class="headerlink" title="第33条：以弱引用避免保留环"></a>第33条：以弱引用避免保留环</h1><hr>
<p>对象之间都用强指针引用对方的话会造成保留环。</p>
<h4 id="两个对象的保留环："><a href="#两个对象的保留环：" class="headerlink" title="两个对象的保留环："></a>两个对象的保留环：</h4><p>两个对象都有一个对方的实例来作为自己的属性：</p>
<pre><code>@interface EOCClassA : NSObject
@property (nonatomic, strong) EOCClassB *other;
@end


@interface EOCClassB : NSObject
@property (nonatomic, strong) EOCClassA *other;
@end
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/859001-4e1aa0647dee51fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个对象的保留环"></p>
<p>两个对象都有指向对方的强指针，这样会导致这两个属性里的对象无法被释放掉。</p>
<h4 id="多个对象的保留环："><a href="#多个对象的保留环：" class="headerlink" title="多个对象的保留环："></a>多个对象的保留环：</h4><p>如果保留环连接了多个对象，而这里其中一个对象被外界引用，那么当这个引用被移除后，整个保留环就泄漏了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d99033df1cf5e1ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多个对象的保留环：孤岛"></p>
<p>解决方案是使用弱引用：</p>
<pre><code>//EOCClassB.m
//第一种弱引用：unsafe_unretained
@property (nonatomic, unsafe_unretained) EOCClassA *other;


//第二种弱引用：weak
@property (nonatomic, weak) EOCClassA *other;
</code></pre><p>这两种弱引用有什么区别呢？</p>
<p>unsafe_unretained:当指向EOCClassA实例的引用移除后，unsafe_unretained属性仍然指向那个已经回收的实例，</p>
<p>而weak指向nil：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-afc3b538527f93da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unsafe_unretained 和 weak的区别"></p>
<p>显然，用weak字段应该是更安全的，因为不再使用的对象按理说应该设置为nil,而不应该产生依赖。</p>
<h1 id="第34条：以“自动释放池快”降低内存峰值"><a href="#第34条：以“自动释放池快”降低内存峰值" class="headerlink" title="第34条：以“自动释放池快”降低内存峰值"></a>第34条：以“自动释放池快”降低内存峰值</h1><hr>
<p>释放对象的两种方式：</p>
<ul>
<li>调用release:保留计数递减</li>
<li>调用autorelease将其加入自动释放池中。在将来清空自动释放池时，系统会向其中的对象发送release消息。</li>
</ul>
<p>内存峰值（high-memory waterline）是指应用程序在某个限定时段内的最大内存用量（highest memory footprint）。新增的自动释放池块可以减少这个峰值：</p>
<p>不用自动释放池减少峰值：</p>
<pre><code>
for (int i = 0; i &lt; 100000; i++) {

      [self doSomethingWithInt:i];

}
</code></pre><p>在这里，<code>doSomethingWithInt:</code>方法可能会创建临时对象。随着循环次数的增加，临时对象的数量也会飙升，而只有在整个for循环结束后，这些临时对象才会得意释放。</p>
<p>这种情况是不理想的，尤其在我们无法控制循环长度的情况下，我们会不断占用内存并突然释放掉它们。</p>
<p>因此，我们需要用自动释放池来降低这种突兀的变化：</p>
<pre><code>
NSArray *databaseRecords = /* ... */;
NSMutableArray *people = [NSMutableArray new];
for (NSDictionary *record in databaseRecords) {
     @autoreleasepool {
             EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];
            [people addObject:person];
      }
}
</code></pre><blockquote>
<p>这样一来，每次循环结束，我们都会将临时对象放在这个池里面，而不是线程的主池里面。</p>
</blockquote>
<h1 id="第35条：用“僵尸对象”调试内存管理问题"><a href="#第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第35条：用“僵尸对象”调试内存管理问题"></a>第35条：用“僵尸对象”调试内存管理问题</h1><hr>
<p>某个对象被回收后，再向它发送消息是不安全的，这并不一定会引起程序崩溃。</p>
<p>如果程序没有崩溃，可能是因为：</p>
<ul>
<li>该内存的部分原数据没有被覆写。</li>
<li>该内存恰好被另一个对象占据，而这个对象可以应答这个方法。</li>
</ul>
<p>如果被回收的对象占用的原内存被新的对象占据，那么收到消息的对象就不会是我们预想的那个对象。在这样的情况下，如果这个对象无法响应那个方法的话，程序依旧会崩溃。</p>
<p>因此，我们希望可以通过一种方法捕捉到<strong>对象被释放后收到消息的情况</strong>。</p>
<p>这种方法就是<strong>利用僵尸对象！</strong></p>
<p>Cocoa提供了“僵尸对象”的功能。如果开启了这个功能，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”（通过修改isa指针，令其指向特殊的僵尸类），而不会真正回收它们，而且它们所占据的核心内存将无法被重用，这样也就避免了覆写的情况。</p>
<p>在僵尸对象收到消息后，会抛出异常，它会说明发送过来的消息，也会描述回收之前的那个对象。</p>
<h1 id="第38条：为常用的块类型创建typedef"><a href="#第38条：为常用的块类型创建typedef" class="headerlink" title="第38条：为常用的块类型创建typedef"></a>第38条：为常用的块类型创建typedef</h1><hr>
<p>如果我们需要重复创建某种块（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型</p>
<p>例如：</p>
<pre><code>int (^variableName)(BOOL flag, int value) =^(BOOL flag, int value){
     // Implementation
     return someInt;
}
</code></pre><p>这个块有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型：</p>
<p><code>typedef int(^EOCSomeBlock)(BOOL flag, int value);</code></p>
<p>再次定义的时候，就可以通过简单的赋值来实现：</p>
<pre><code>EOCSomeBlock block = ^(BOOL flag, int value){
     // Implementation
};
</code></pre><p>定义作为参数的块：</p>
<pre><code>- (void)startWithCompletionHandler: (void(^)(NSData *data, NSError *error))completion;
</code></pre><p>这里的块有一个NSData参数，一个NSError参数并没有返回值</p>
<pre><code>typedef void(^EOCCompletionHandler)(NSData *data, NSError *error);
- (void)startWithCompletionHandler:(EOCCompletionHandler)completion;”
</code></pre><p>通过typedef定义块签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。</p>
<h1 id="第39条：用handler块降低代码分散程度"><a href="#第39条：用handler块降低代码分散程度" class="headerlink" title="第39条：用handler块降低代码分散程度"></a>第39条：用handler块降低代码分散程度</h1><hr>
<p>下载网络数据时，如果使用代理方法，会使得代码分布不紧凑，而且如果有多个下载任务的话，还要在回调的代理中判断当前请求的类型。但是如果使用block的话，就可以让网络下载的代码和回调处理的代码写在一起，这样就可以同时解决上面的两个问题：</p>
<h4 id="用代理下载："><a href="#用代理下载：" class="headerlink" title="用代理下载："></a>用代理下载：</h4><pre><code>- (void)fetchFooData {

     NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;];
    _fooFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    _fooFetcher.delegate = self;
    [_fooFetcher start];

}

- (void)fetchBarData {

     NSURL *url = [[NSURL alloc] initWithString: @&quot;http://www.example.com/bar.dat&quot;];
    _barFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];
    _barFetcher.delegate = self;
    [_barFetcher start];

}

- (void)networkFetcher:(EOCNetworkFetcher*)networkFetcher didFinishWithData:(NSData*)data
{   //判断下载器类型
     if (networkFetcher == _fooFetcher) {
        _fetchedFooData = data;
        _fooFetcher = nil;

    } else if (networkFetcher == _barFetcher) {
        _fetchedBarData = data;
        _barFetcher = nil;
    }
}
</code></pre><h4 id="用块下载："><a href="#用块下载：" class="headerlink" title="用块下载："></a>用块下载：</h4><pre><code>
- (void)fetchFooData {

     NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/foo.dat&quot;];
     EOCNetworkFetcher *fetcher =
     [[EOCNetworkFetcher alloc] initWithURL:url];
     [fetcher startWithCompletionHandler:^(NSData *data){
            _fetchedFooData = data;
   }];

}

- (void)fetchBarData {

     NSURL *url = [[NSURL alloc] initWithString: @&quot;http://www.example.com/bar.dat&quot;];
     EOCNetworkFetcher *fetcher =[[EOCNetworkFetcher alloc] initWithURL:url];
    [fetcher startWithCompletionHandler:^(NSData *data){
            _fetchedBarData = data;
    }];

}
</code></pre><p>还可以将处理成功的代码放在一个块里，处理失败的代码放在另一个块中：</p>
<pre><code>
“#import &lt;Foundation/Foundation.h&gt;

@class EOCNetworkFetcher;
typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);
typedef void(^EOCNetworkFetcherErrorHandler)(NSError *error);


@interface EOCNetworkFetcher : NSObject

- (id)initWithURL:(NSURL*)url;
- (void)startWithCompletionHandler: (EOCNetworkFetcherCompletionHandler)completion failureHandler: (EOCNetworkFetcherErrorHandler)failure;

@end



EOCNetworkFetcher *fetcher =[[EOCNetworkFetcher alloc] initWithURL:url];
[fetcher startWithCompletionHander:^(NSData *data){
     // Handle success
}

 failureHandler:^(NSError *error){
 // Handle failure
}];
</code></pre><blockquote>
<p>这样写的好处是，我们可以将处理成功和失败的代码分开来写，看上去更加清晰。</p>
</blockquote>
<p>我们还可以将 成功和失败的代码都放在同一个块里：</p>
<pre><code>
“#import &lt;Foundation/Foundation.h&gt;


@class EOCNetworkFetcher;
typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data, NSError *error);

@interface EOCNetworkFetcher : NSObject

- (id)initWithURL:(NSURL*)url;
- (void)startWithCompletionHandler:

(EOCNetworkFetcherCompletionHandler)completion;

@end



EOCNetworkFetcher *fetcher =[[EOCNetworkFetcher alloc] initWithURL:url];

[fetcher startWithCompletionHander:

^(NSData *data, NSError *error){

if (error) {

     // Handle failure

} else {

     // Handle success

}
}];
</code></pre><blockquote>
<p>这样做的好处是，如果及时下载失败或中断了，我们仍然可以取到当前所下载的data。而且，如果在需求上指出：下载成功后得到的数据很少，也视为失败，那么单一块的写法就很适用，因为它可以取得数据后（成功）再判断其是否是下载成功的。</p>
</blockquote>
<h1 id="第40条：用块引用其所属对象时不要出现保留环"><a href="#第40条：用块引用其所属对象时不要出现保留环" class="headerlink" title="第40条：用块引用其所属对象时不要出现保留环"></a>第40条：用块引用其所属对象时不要出现保留环</h1><hr>
<p>如果块捕获的对象直接或间接地保留了块本身，那么就需要小心保留环问题:</p>
<pre><code>@implementation EOCClass {

     EOCNetworkFetcher *_networkFetcher;
     NSData *_fetchedData;

}


- (void)downloadData {

     NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/something.dat&quot;];
    _networkFetcher =[[EOCNetworkFetcher alloc] initWithURL:url];

    [_networkFetcher startWithCompletionHandler:^(NSData *data){

             NSLog(@&quot;Request URL %@ finished&quot;, _networkFetcher.url);
            _fetchedData = data;

    }];

}
</code></pre><p>在这里出现了保留环：块要设置_fetchedData变量，就需要捕获self变量。而self（EOCClass实例）通过实例变量保留了获取器_networkFetcher，而_networkFetcher又保留了块。</p>
<p>解决方案是：在块中取得了data后，将_networkFetcher设为nil。</p>
<pre><code>
- (void)downloadData {

     NSURL *url = [[NSURL alloc] initWithString:@&quot;http://www.example.com/something.dat&quot;];
    _networkFetcher =[[EOCNetworkFetcher alloc] initWithURL:url];
    [_networkFetcher startWithCompletionHandler:^(NSData *data){

             NSLog(@&quot;Request URL %@ finished&quot;, _networkFetcher.url);
            _fetchedData = data;
            _networkFetcher = nil;

    }];

}
</code></pre><h1 id="第41条：多用派发队列，少用同步锁"><a href="#第41条：多用派发队列，少用同步锁" class="headerlink" title="第41条：多用派发队列，少用同步锁"></a>第41条：多用派发队列，少用同步锁</h1><hr>
<p>多个线程执行同一份代码时，很可能会造成数据不同步。作者建议使用GCD来为代码加锁的方式解决这个问题。</p>
<h4 id="方案一：使用串行同步队列来将读写操作都安排到同一个队列里："><a href="#方案一：使用串行同步队列来将读写操作都安排到同一个队列里：" class="headerlink" title="方案一：使用串行同步队列来将读写操作都安排到同一个队列里："></a>方案一：使用串行同步队列来将读写操作都安排到同一个队列里：</h4><pre><code>_syncQueue = dispatch_queue_create(&quot;com.effectiveobjectivec.syncQueue&quot;, NULL);

//读取字符串
- (NSString*)someString {

         __block NSString *localSomeString;
         dispatch_sync(_syncQueue, ^{
            localSomeString = _someString;
        });
         return localSomeString;

}

//设置字符串
- (void)setSomeString:(NSString*)someString {

     dispatch_sync(_syncQueue, ^{
        _someString = someString;
    });
}
</code></pre><p>这样一来，读写操作都在串行队列进行，就不容易出错。</p>
<p>但是，还有一种方法可以让性能更高：</p>
<h4 id="方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"><a href="#方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。" class="headerlink" title="方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"></a>方案二：将<strong>写操作</strong>放入栅栏快中，让他们单独执行；将<strong>读取操作</strong>并发执行。</h4><pre><code>_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);

//读取字符串
- (NSString*)someString {

     __block NSString *localSomeString;
     dispatch_sync(_syncQueue, ^{
        localSomeString = _someString;
    });
     return localSomeString;
}
</code></pre><pre><code>//设置字符串
- (void)setSomeString:(NSString*)someString {

     dispatch_barrier_async(_syncQueue, ^{
        _someString = someString;
    });

}
</code></pre><blockquote>
<p>显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。</p>
<p>这里的<code>dispatch_barrier_async</code>方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。</p>
</blockquote>
<h1 id="第42条：多用GCD，少用performSelector系列方法"><a href="#第42条：多用GCD，少用performSelector系列方法" class="headerlink" title="第42条：多用GCD，少用performSelector系列方法"></a>第42条：多用GCD，少用performSelector系列方法</h1><hr>
<p>在iOS开发中，有时会使用performSelector来执行某个方法，但是performSelector系列的方法能处理的选择子很局限：</p>
<ul>
<li>它无法处理带有多个参数的选择子。</li>
<li>返回值只能是void或者对象类型。</li>
</ul>
<p>但是如果将方法放在块中，通过GCD来操作就能很好地解决这些问题。尤其是我们如果想要让一个任务在另一个线程上执行，最好应该将任务放到块里，交给GCD来实现，而不是通过performSelector方法。</p>
<p>举几个 来比较这两种方案：</p>
<h4 id="1-延后执行某个任务的方法："><a href="#1-延后执行某个任务的方法：" class="headerlink" title="1. 延后执行某个任务的方法："></a>1. 延后执行某个任务的方法：</h4><pre><code>
// 使用 performSelector:withObject:afterDelay:
[self performSelector:@selector(doSomething) withObject:nil afterDelay:5.0];


// 使用 dispatch_after
dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5.0 * NSEC_PER_SEC));
dispatch_after(time, dispatch_get_main_queue(), ^(void){
    [self doSomething];
});
</code></pre><h4 id="2-将任务放在主线程执行："><a href="#2-将任务放在主线程执行：" class="headerlink" title="2. 将任务放在主线程执行："></a>2. 将任务放在主线程执行：</h4><pre><code>// 使用 performSelectorOnMainThread:withObject:waitUntilDone:
[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntilDone:NO];


// 使用 dispatch_async
// (or if waitUntilDone is YES, then dispatch_sync)
dispatch_async(dispatch_get_main_queue(), ^{
        [self doSomething];
});
</code></pre><blockquote>
<p>注意：<br>如果waitUntilDone的参数是Yes，那么就对应GCD的dispatch_sync方法。<br>我们可以看到，使用GCD的方式可以将线程操作代码和方法调用代码写在同一处，一目了然；而且完全不受调用方法的选择子和方法参数个数的限制。</p>
</blockquote>
<h1 id="第43条：掌握GCD及操作队列的使用时机"><a href="#第43条：掌握GCD及操作队列的使用时机" class="headerlink" title="第43条：掌握GCD及操作队列的使用时机"></a>第43条：掌握GCD及操作队列的使用时机</h1><hr>
<p>除了GCD，操作队列（NSOperationQueue）也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用GCD好些，有时则是使用操作队列更加合理。</p>
<p>使用NSOperation和NSOperationQueue的优点：</p>
<ol>
<li>可以取消操作：在运行任务前，可以在NSOperation对象调用cancel方法，标明此任务不需要执行。但是GCD队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。</li>
<li>可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。</li>
<li>监控NSOperation对象的属性：可以通过KVO来监听NSOperation的属性：可以通过isCancelled属性来判断任务是否已取消；通过isFinished属性来判断任务是否已经完成。</li>
<li>可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。</li>
</ol>
<h1 id="第44条：通过Dispath-Group机制，根据系统资源状况来执行任务"><a href="#第44条：通过Dispath-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第44条：通过Dispath Group机制，根据系统资源状况来执行任务"></a>第44条：通过Dispath Group机制，根据系统资源状况来执行任务</h1><hr>
<p>有时需要<strong>等待</strong>多个并行任务结束的那一刻执行某个任务，这个时候就可以使用dispath group函数来实现这个需求：</p>
<p>通过dispath group函数，可以把并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。</p>
<pre><code>
//一个优先级低的并发队列
dispatch_queue_t lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0);

//一个优先级高的并发队列
dispatch_queue_t highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0);

//创建dispatch_group
dispatch_group_t dispatchGroup = dispatch_group_create();

//将优先级低的队列放入dispatch_group
for (id object in lowPriorityObjects) {
 dispatch_group_async(dispatchGroup,lowPriorityQueue,^{ [object performTask]; });
}

//将优先级高的队列放入dispatch_group
for (id object in highPriorityObjects) {
 dispatch_group_async(dispatchGroup,highPriorityQueue,^{ [object performTask]; });
}

//dispatch_group里的任务都结束后调用块中的代码
dispatch_queue_t notifyQueue = dispatch_get_main_queue();
dispatch_group_notify(dispatchGroup,notifyQueue,^{
     // Continue processing after completing tasks
});
</code></pre><h1 id="第45条：使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#第45条：使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="第45条：使用dispatch_once来执行只需运行一次的线程安全代码"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h1><hr>
<p>有时我们可能只需要将某段代码执行一次，这时可以通过dispatch_once函数来解决。</p>
<p>dispatch_once函数比较重要的使用例子是单例模式：<br>我们在创建单例模式的实例时，可以使用dispatch_once函数来令初始化代码只执行一次，并且内部是线程安全的。</p>
<p>而且，对于执行一次的block来说，每次调用函数时传入的标记都必须完全相同，通常标记变量声明在static或global作用域里。</p>
<pre><code>+ (id)sharedInstance {

     static EOCClass *sharedInstance = nil;
     static dispatch_once_t onceToken;
     dispatch_once(&amp;onceToken, ^{
﻿            sharedInstance = [[self alloc] init];
    });
     return sharedInstance;
}
</code></pre><blockquote>
<p>我们可以这么理解：在dispatch_once块中的代码在程序启动到终止的过程里，只要运行了一次后，就给自己加上了注释符号，不再存在了。</p>
</blockquote>
<h1 id="第49条：对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条：对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条：对自定义其内存管理语义的collection使用无缝桥接"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h1><hr>
<p>通过无缝桥接技术，可以再Foundation框架中的OC对象和CoreFoundation框架中的C语言数据结构之间来回转换。</p>
<p>创建CoreFoundation中的collection时，可以指定如何处理其中的元素。然后利用无缝桥接技术，可以将其转换为OCcollection。</p>
<p>简单的无缝桥接演示：</p>
<pre><code>NSArray *anNSArray = @[@1, @2, @3, @4, @5];
CFArrayRef aCFArray = (__bridge CFArrayRef)anNSArray;
NSLog(@&quot;Size of array = %li&quot;, CFArrayGetCount(aCFArray));
</code></pre><p>这里，<code>__bridge</code>表示ARC仍然具备这个OC对象的所有权。<code>CFArrayGetCount</code>用来获取数组的长高度。</p>
<p>为什么要使用无缝桥接技术呢？因为有些OC对象的特性是其对应的CF数据结构不具备的，反之亦然。因此我们需要通过无缝桥接技术来让这两者进行功能上的“互补”。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>终于总结完了，还是有个别知识点理解得不是很透彻，需要反复阅读和理解消化。希望各位小伙伴多多提出宝贵意见，交流学习~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C》超级干货三部曲（二）：规范篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E3%80%8AEffective%20Objective-C%E3%80%8B%E8%B6%85%E7%BA%A7%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%A7%84%E8%8C%83%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（二）：规范篇/</id>
    <published>2017-01-13T05:52:04.000Z</published>
    <updated>2017-01-13T05:52:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>继上一篇<a href="http://www.jianshu.com/p/9c93c7ab734d" target="_blank" rel="external">《Effective Objective-C 》超级干货三部曲（一）：概念篇</a>之后，本篇即是三部曲的第二篇：规范篇。<br>没看过三部曲第一篇的小伙伴可能不知道我在说神马，在这里还是先啰嗦一下三部曲是咋回事：笔者将《Effective Objective-C 》这本书的52个知识点分为三大类进行了归类整理：</p>
<ul>
<li>概念类：讲解了一些概念性知识。</li>
<li>规范类：讲解了一些为了避免一些问题或者为后续开发提供便利所需要遵循的规范性知识。</li>
<li>技巧类：讲解了一些为了解决某些特定问题而需要用到的技巧性知识。</li>
</ul>
<p>然后用思维导图整理了一下：<br><img src="http://upload-images.jianshu.io/upload_images/859001-0599d987732d932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<p>作为三部曲的第二篇，本篇总结抽取了《Effective Objective-C 》这本书中讲解规范性知识的部分：这些知识点都是为了避免在开发过程中出现问题或给开发提供便利的规范性知识点。掌握这些知识有助于形成科学地写OC代码的习惯，使得代码更加容易维护和扩展，学习这类知识是iOS初学者进阶的必经之路。</p>
<p>好吧，不费话了，开始了！</p>
<h1 id="第2条：-在类的头文件中尽量少引用其他头文件"><a href="#第2条：-在类的头文件中尽量少引用其他头文件" class="headerlink" title="第2条： 在类的头文件中尽量少引用其他头文件"></a>第2条： 在类的头文件中尽量少引用其他头文件</h1><hr>
<p>有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。</p>
<pre><code>// EOCPerson.h
#import &lt;Foundation/Foundation.h&gt;
@class EOCEmployer;

@interface EOCPerson : NSObject
@property (nonatomic, copy) NSString *firstName;
@property (nonatomic, copy) NSString *lastName;
@property (nonatomic, strong) EOCEmployer *employer;//将EOCEmployer作为属性

@end

// EOCPerson.m
#import &quot;EOCEmployer.h&quot;
</code></pre><p>这样做有什么优点呢：</p>
<blockquote>
<ul>
<li>不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。</li>
<li>可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。</li>
</ul>
</blockquote>
<p>但是个别的时候，必须在头文件中引入其他类的头文件:</p>
<blockquote>
<p>主要有两种情况：</p>
<ol>
<li>该类继承于某个类，则应该引入父类的头文件。</li>
<li>该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。</li>
</ol>
</blockquote>
<h1 id="第3条：多用字面量语法，少用与之等价的方法"><a href="#第3条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第3条：多用字面量语法，少用与之等价的方法"></a>第3条：多用字面量语法，少用与之等价的方法</h1><hr>
<h2 id="1-声明时的字面量语法："><a href="#1-声明时的字面量语法：" class="headerlink" title="1. 声明时的字面量语法："></a>1. 声明时的字面量语法：</h2><p>在声明NSNumber，NSArray，NSDictionary时，应该尽量使用简洁字面量语法。</p>
<pre><code>NSNumber *intNumber = @1;
NSNumber *floatNumber = @2.5f;
</code></pre><pre><code>NSArray *animals =[NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;,@&quot;mouse&quot;, @&quot;badger&quot;, nil];
Dictionary *dict = @{@&quot;animal&quot;:@&quot;tiger&quot;,@&quot;phone&quot;:@&quot;iPhone 6&quot;};
</code></pre><h2 id="2-集合类取下标的字面量语法："><a href="#2-集合类取下标的字面量语法：" class="headerlink" title="2. 集合类取下标的字面量语法："></a>2. 集合类取下标的字面量语法：</h2><p>NSArray，NSDictionary，NSMutableArray，NSMutableDictionary 的取下标操作也应该尽量使用字面量语法。</p>
<pre><code>NSString *cat = animals[0];
NSString *iphone = dict[@&quot;phone&quot;];
</code></pre><blockquote>
<p>使用字面量语法的优点：</p>
<ol>
<li>代码看起来更加简洁。</li>
<li>如果存在nil值，则会立即抛出异常。如果在不用字面量语法定义数组的情况下，如果数组内部存在nil，则系统会将其设为数组最后一个元素并终止。所以当这个nil不是最后一个元素的话，就会出现难以排查的错误。</li>
</ol>
<p><strong>注意</strong>:<br>字面量语法创建出来的字符串，数组，字典对象都是不可变的。</p>
</blockquote>
<h1 id="第4条：多用类型常量，少用-define预处理命令"><a href="#第4条：多用类型常量，少用-define预处理命令" class="headerlink" title="第4条：多用类型常量，少用#define预处理命令"></a>第4条：多用类型常量，少用#define预处理命令</h1><hr>
<p>在OC中，定义常量通常使用预处理命令，但是并不建议使用它，而是使用类型常量的方法。<br>首先比较一下这两种方法的区别：</p>
<ul>
<li>预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。</li>
<li>类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。</li>
</ul>
<p>我们可以看出来，使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的：不具备类型 + 可以被任意修改，总之给人一种不安全的感觉。</p>
<p>知道了它们的长短处，我们再来简单看一下它们的具体使用方法：</p>
<h4 id="预处理命令："><a href="#预处理命令：" class="headerlink" title="预处理命令："></a>预处理命令：</h4><p><code>#define W_LABEL (W_SCREEN - 2*GAP)</code></p>
<blockquote>
<p>这里，(W_SCREEN - 2*GAP)替换了W_LABEL，它不具备W_LABEL的类型信息。而且要注意一下：如果替换式中存在运算符号，以笔者的经验最好用括号括起来，不然容易出现错误（有体会）。</p>
</blockquote>
<h4 id="类型常量："><a href="#类型常量：" class="headerlink" title="类型常量："></a>类型常量：</h4><p><code>static const NSTimeIntervalDuration = 0.3;</code></p>
<blockquote>
<p>这里:<br>const 将其设置为常量，不可更改。<br>static意味着该变量仅仅在定义此变量的编译单元中可见。如果不声明static,编译器会为它创建一个外部符号（external symbol）。我们来看一下对外公开的常量的声明方法：</p>
</blockquote>
<h4 id="对外公开某个常量："><a href="#对外公开某个常量：" class="headerlink" title="对外公开某个常量："></a>对外公开某个常量：</h4><p>如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串，那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。</p>
<pre><code>//header file
extern NSString *const NotificationString;

//implementation file
NSString *const  NotificationString = @&quot;Finish Download&quot;;
</code></pre><blockquote>
<p>这里NSString *const NotificationString是指针常量。<br>extern关键字告诉编译器，在全局符号表中将会有一个名叫NotificationString的符号。</p>
</blockquote>
<p>我们通常在头文件声明常量，在其实现文件里定义该常量。由实现文件生成目标文件时，编译器会在“数据段”为字符串分配存储空间。</p>
<p>最后注意一下公开和非公开的常量的命名规范：</p>
<blockquote>
<p>公开的常量：常量的名字最好用与之相关的类名做前缀。<br>非公开的常量：局限于某个编译单元（tanslation unit，实现文件 implementation file）内，在签名加上字母k。</p>
</blockquote>
<h1 id="第5条：用枚举表示状态，选项，状态码"><a href="#第5条：用枚举表示状态，选项，状态码" class="headerlink" title="第5条：用枚举表示状态，选项，状态码"></a>第5条：用枚举表示状态，选项，状态码</h1><hr>
<p>我们经常需要给类定义几个状态，这些状态码可以用枚举来管理。下面是关于网络连接状态的状态码枚举：</p>
<pre><code>typedef NS_ENUM(NSUInteger, EOCConnectionState) {
  EOCConnectionStateDisconnected,
  EOCConnectionStateConnecting,
  EOCConnectionStateConnected,
};
</code></pre><p>需要注意的一点是：<br>在枚举类型的switch语句中不要实现default分支。它的好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch语句并未处理所有的枚举。对此，笔者有个教训，又一次在switch语句中将“默认分支”设置为枚举中的第一项，自以为这样写可以让程序更健壮，结果后来导致了严重的崩溃。</p>
<h1 id="第7条：-在对象内部尽量直接访问实例变量"><a href="#第7条：-在对象内部尽量直接访问实例变量" class="headerlink" title="第7条： 在对象内部尽量直接访问实例变量"></a>第7条： 在对象内部尽量直接访问实例变量</h1><hr>
<p>关于实例变量的访问，可以直接访问，也可以通过属性的方式(点语法)来访问。书中作者建议在读取实例变量时采用直接访问的形式，而在设置实例变量的时候通过属性来做。</p>
<h4 id="直接访问属性的特点："><a href="#直接访问属性的特点：" class="headerlink" title="直接访问属性的特点："></a>直接访问属性的特点：</h4><ul>
<li>绕过set，get语义，速度快；</li>
</ul>
<h4 id="通过属性访问属性的特点："><a href="#通过属性访问属性的特点：" class="headerlink" title="通过属性访问属性的特点："></a>通过属性访问属性的特点：</h4><ul>
<li>不会绕过属性定义的内存管理语义</li>
<li>有助于打断点排查错误</li>
<li>可以触发KVO</li>
</ul>
<p>因此，有个关于折中的方案：</p>
<blockquote>
<p>设置属性：通过属性<br>读取属性：直接访问</p>
</blockquote>
<p>不过有两个特例：</p>
<ol>
<li>初始化方法和dealloc方法中，需要直接访问实例变量来进行设置属性操作。因为如果在这里没有绕过set方法，就有可能触发其他不必要的操作。</li>
<li>惰性初始化（lazy initialization）的属性，必须通过属性来读取数据。因为惰性初始化是通过重写get方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。</li>
</ol>
<h1 id="第15条：用前缀-避免命名空间冲突"><a href="#第15条：用前缀-避免命名空间冲突" class="headerlink" title="第15条：用前缀 避免命名空间冲突"></a>第15条：用前缀 避免命名空间冲突</h1><hr>
<p>Apple宣称其保留使用所有”两字母前缀”的权利，所以我们选用的前缀应该是三个字母的。<br>而且，如果自己开发的程序使用到了第三方库，也应该加上前缀。</p>
<h1 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h1><hr>
<p>书中作者建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是：</p>
<p>在头文件中，设置对象属性为<code>readonly</code>，在实现文件中设置为<code>readwrite</code>。这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。</p>
<p>而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。</p>
<p>如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。这样一来，当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本,例如：</p>
<p>在公共API中：</p>
<pre><code>@interface EOCPerson : NSObject

@property (nonatomic, copy, readonly) NSString *firstName;
@property (nonatomic, copy, readonly) NSString *lastName;
@property (nonatomic, strong, readonly) NSSet *friends //向外公开的不可变集合

- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;
- (void)addFriend:(EOCPerson*)person;
- (void)removeFriend:(EOCPerson*)person;

@end
</code></pre><blockquote>
<p>在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。</p>
</blockquote>
<p>在实现文件里：</p>
<pre><code>@interface EOCPerson ()

@property (nonatomic, copy, readwrite) NSString *firstName;
@property (nonatomic, copy, readwrite) NSString *lastName;

@end

@implementation EOCPerson {
     NSMutableSet *_internalFriends;  //实现文件里的可变集合
}

- (NSSet*)friends {
     return [_internalFriends copy]; //get方法返回的永远是可变set的不可变型
}

- (void)addFriend:(EOCPerson*)person {
    [_internalFriends addObject:person]; //在外部增加集合元素的操作
    //do something when add element
}

- (void)removeFriend:(EOCPerson*)person {
    [_internalFriends removeObject:person]; //在外部移除元素的操作
    //do something when remove element
}

- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName {

     if ((self = [super init])) {
        _firstName = firstName;
        _lastName = lastName;
        _internalFriends = [NSMutableSet new];
    }
 return self;
}
</code></pre><p>我们可以看到，在实现文件里，保存一个可变set来记录外部的增删操作。</p>
<p>这里最重要的代码是：</p>
<pre><code>- (NSSet*)friends {
 return [_internalFriends copy];
}
</code></pre><blockquote>
<p>这个是friends属性的获取方法：它将当前保存的可变set复制了一不可变的set并返回。因此，外部读取到的set都将是不可变的版本。</p>
</blockquote>
<h4 id="等一下，有个疑问：在公共接口设置不可变set-和-将增删的代码放在公共接口中是否矛盾的？"><a href="#等一下，有个疑问：在公共接口设置不可变set-和-将增删的代码放在公共接口中是否矛盾的？" class="headerlink" title="等一下，有个疑问：在公共接口设置不可变set 和 将增删的代码放在公共接口中是否矛盾的？"></a>等一下，有个疑问：在公共接口设置不可变set 和 将增删的代码放在公共接口中是否矛盾的？</h4><h4 id="答案：并不矛盾"><a href="#答案：并不矛盾" class="headerlink" title="答案：并不矛盾!"></a>答案：<strong>并不矛盾!</strong></h4><p>因为如果将friends属性设置为可变的，那么外部就可以随便更改set集合里的数据，这里的更改，仅仅是底层数据的更改，并不伴随其他任何操作。<br>然而有时，我们需要在更改set数据的同时<strong>要执行隐秘在实现文件里的其他工作</strong>，那么如果在外部随意更改这个属性的话，显然是达不到这种需求的。</p>
<p>因此，我们需要提供给外界<strong>我们定制的</strong>增删的方法，并不让外部”自行“增删。</p>
<h1 id="第19条：使用清晰而协调的命名方式"><a href="#第19条：使用清晰而协调的命名方式" class="headerlink" title="第19条：使用清晰而协调的命名方式"></a>第19条：使用清晰而协调的命名方式</h1><hr>
<p>在给OC的方法取名字的时候要充分利用OC方法的命名优势，取一个<strong>语义清晰</strong>的方法名！什么叫语义清晰呢?就是说读起来像是一句话一样。</p>
<p>我们看一个例子：</p>
<p>先看名字取得不好的：</p>
<pre><code>//方法定义
- (id)initWithSize:(float)width :(float)height;

//方法调用
EOCRectangle *aRectangle =[[EOCRectangle alloc] initWithSize:5.0f :10.0f];
</code></pre><blockquote>
<p>这里定义了Rectangle的初始化方法。虽然直观上可以知道这个方法通过传入的两个参数来组成矩形的size，但是我们并不知道哪个是矩形的宽，哪个是矩形的高。<br>来看一下正确的🌰 ：</p>
</blockquote>
<pre><code>//方法定义
- (id)initWithWidth:(float)width andHeight:(float)height;

//方法调用
EOCRectangle *aRectangle =[[EOCRectangle alloc] initWithWidth:5.0f andHeight:10.0f];
</code></pre><blockquote>
<p>这个方法名就很好的诠释了该方法的意图：这个类的初始化是需要宽度和高度的。而且，哪个参数是高度，哪个参数是宽度，看得人一清二楚。永远要记得：<strong>代码是给人看的</strong>。</p>
</blockquote>
<p>笔者自己总结的方法命名规则：</p>
<blockquote>
<p>每个冒号左边的方法部分最好与右边的参数名一致。</p>
</blockquote>
<p>对于返回值是布尔值的方法，我们也要注意命名的规范：</p>
<ul>
<li>获取”是否“的布尔值，应该增加“is”前缀：</li>
</ul>
<pre><code>- hasPrefix:
</code></pre><p>获取“是否有”的布尔值，应该增加“has”前缀：</p>
<pre><code>- isEqualToString:
</code></pre><h1 id="第20条：为私有方法名加前缀"><a href="#第20条：为私有方法名加前缀" class="headerlink" title="第20条：为私有方法名加前缀"></a>第20条：为私有方法名加前缀</h1><hr>
<p>建议在实现文件里将非公开的方法都加上前缀，便于调试，而且这样一来也很容易区分哪些是公共方法，哪些是私有方法。因为往往公共方法是不便于任意修改的。</p>
<p>在这里，作者举了个例子：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;
@interface EOCObject : NSObject
- (void)publicMethod;
@end


@implementation EOCObject

- (void)publicMethod {
 /* ... */
}

- (void)p_privateMethod {
 /* ... */
}

@end
</code></pre><blockquote>
<p><strong>注意</strong>：<br>不要用下划线来区分私有方法和公共方法，因为会和苹果公司的API重复。</p>
</blockquote>
<h1 id="第23条：通过委托与数据源协议进行对象间通信"><a href="#第23条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条：通过委托与数据源协议进行对象间通信"></a>第23条：通过委托与数据源协议进行对象间通信</h1><hr>
<p>如果给委托对象发送消息，那么必须提前判断该委托对象是否实现了该消息：</p>
<pre><code>NSData *data = /* data obtained from network */;

if ([_delegate respondsToSelector: @selector(networkFetcher:didReceiveData:)])
{
        [_delegate networkFetcher:self didReceiveData:data];
}
</code></pre><p>而且，最好再加上一个判断：判断委托对象是否存在</p>
<pre><code>NSData *data = /* data obtained from network */;

if ( (_delegate) &amp;&amp; ([_delegate respondsToSelector: @selector(networkFetcher:didReceiveData:)]))
{
        [_delegate networkFetcher:self didReceiveData:data];
}
</code></pre><p>对于代理模式，在iOS中分为两种：</p>
<ul>
<li>普通的委托模式:信息从类流向委托者</li>
<li>信息源模式:信息从数据源流向类</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d9349b44ab6fba52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="普通的委托 | 信息源"></p>
<blockquote>
<p>就好比tableview告诉它的代理（delegate）“我被点击了”；而它的数据源（data Source）告诉它“你有这些数据”。仔细回味一下，这两个信息的传递方向是相反的。</p>
</blockquote>
<h1 id="第24条：将类的实现代码分散到便于管理的数个分类中"><a href="#第24条：将类的实现代码分散到便于管理的数个分类中" class="headerlink" title="第24条：将类的实现代码分散到便于管理的数个分类中"></a>第24条：将类的实现代码分散到便于管理的数个分类中</h1><hr>
<p>通常一个类会有很多方法，而这些方法往往可以用某种特有的逻辑来分组。我们可以利用OC的分类机制，将类的这些方法按一定的逻辑划入几个分区中。</p>
<p>例子：</p>
<p>无分类的类：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface EOCPerson : NSObject

@property (nonatomic, copy, readonly) NSString *firstName;
@property (nonatomic, copy, readonly) NSString *lastName;
@property (nonatomic, strong, readonly) NSArray *friends;

- (id)initWithFirstName:(NSString*)firstName andLastName:(NSString*)lastName;

/* Friendship methods */
- (void)addFriend:(EOCPerson*)person;
- (void)removeFriend:(EOCPerson*)person;
- (BOOL)isFriendsWith:(EOCPerson*)person;

/* Work methods */
- (void)performDaysWork;
- (void)takeVacationFromWork;

/* Play methods */
- (void)goToTheCinema;
- (void)goToSportsGame;

@end
</code></pre><p>分类之后：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface EOCPerson : NSObject

@property (nonatomic, copy, readonly) NSString *firstName;
@property (nonatomic, copy, readonly) NSString *lastName;
@property (nonatomic, strong, readonly) NSArray *friends;



- (id)initWithFirstName:(NSString*)firstName
andLastName:(NSString*)lastName;

@end

@interface EOCPerson (Friendship)

- (void)addFriend:(EOCPerson*)person;
- (void)removeFriend:(EOCPerson*)person;
- (BOOL)isFriendsWith:(EOCPerson*)person;
@end


@interface EOCPerson (Work)
- (void)performDaysWork;
- (void)takeVacationFromWork;

@end

@interface EOCPerson (Play)
- (void)goToTheCinema;
- (void)goToSportsGame;
@end
</code></pre><p>其中，FriendShip分类的实现代码可以这么写：</p>
<pre><code>// EOCPerson+Friendship.h
#import &quot;EOCPerson.h&quot;


@interface EOCPerson (Friendship)

- (void)addFriend:(EOCPerson*)person;
- (void)removeFriend:(EOCPerson*)person;
- (BOOL)isFriendsWith:(EOCPerson*)person;

@end


// EOCPerson+Friendship.m
#import &quot;EOCPerson+Friendship.h&quot;


@implementation EOCPerson (Friendship)

- (void)addFriend:(EOCPerson*)person {
 /* ... */
}

- (void)removeFriend:(EOCPerson*)person {
 /* ... */
}

- (BOOL)isFriendsWith:(EOCPerson*)person {
 /* ... */
}

@end
</code></pre><blockquote>
<p>注意：在新建分类文件时，一定要引入被分类的类文件。</p>
</blockquote>
<p>通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。</p>
<p>利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。</p>
<h1 id="第25条：总是为第三方类的分类名称加前缀"><a href="#第25条：总是为第三方类的分类名称加前缀" class="headerlink" title="第25条：总是为第三方类的分类名称加前缀"></a>第25条：总是为第三方类的分类名称加前缀</h1><hr>
<p>分类机制虽然强大，但是如果分类里的方法与原来的方法名称一致，那么分类的方法就会覆盖掉原来的方法，而且总是以最后一次被覆盖为基准。</p>
<p>因此，我们应该以命名空间来区别各个分类的名称与其中定义的方法。在OC里的做法就是给这些方法加上某个共用的前缀。例如：</p>
<pre><code>@interface NSString (ABC_HTTP)

// Encode a string with URL encoding
- (NSString*)abc_urlEncodedString;

// Decode a URL encoded string
- (NSString*)abc_urlDecodedString;

@end
</code></pre><p>因此，如果我们想给第三方库或者iOS框架里的类添加分类时，最好将分类名和方法名加上前缀。</p>
<h1 id="第26条-勿在分类中声明属性"><a href="#第26条-勿在分类中声明属性" class="headerlink" title="第26条:勿在分类中声明属性"></a>第26条:勿在分类中声明属性</h1><hr>
<p>除了实现文件里的class-continuation分类中可以声明属性外，其他分类无法向类中新增实例变量。</p>
<p>因此，类所封装的全部数据都应该定义在主接口中，这里是唯一能够定义实例变量的地方。</p>
<p>关于分类，需要强调一点：</p>
<blockquote>
<p>分类机制，目标在于扩展类的功能，而不是封装数据。</p>
</blockquote>
<h2 id="第27条：使用class-continuation分类-隐藏实现细节"><a href="#第27条：使用class-continuation分类-隐藏实现细节" class="headerlink" title="#第27条：使用class-continuation分类 隐藏实现细节"></a>#第27条：使用class-continuation分类 隐藏实现细节</h2><p>通常，我们需要减少在公共接口中向外暴露的部分(包括属性和方法)，而因此带给我们的局限性可以利用class-continuation分类的特性来补偿：</p>
<ul>
<li>可以在class-continuation分类中增加实例变量。</li>
<li>可以在class-continuation分类中将公共接口的只读属性设置为读写。</li>
<li>可以在class-continuation分类中遵循协议，使其不为人知。</li>
</ul>
<h1 id="第31条：在dealloc方法中只释放引用并解除监听"><a href="#第31条：在dealloc方法中只释放引用并解除监听" class="headerlink" title="第31条：在dealloc方法中只释放引用并解除监听"></a>第31条：在dealloc方法中只释放引用并解除监听</h1><hr>
<p>永远不要自己调用dealloc方法，运行期系统会在适当的时候调用它。根据性能需求我们有时需要在dealloc方法中做一些操作。那么我们可以在dealloc方法里做什么呢？</p>
<ul>
<li>释放对象所拥有的所有引用，不过ARC会自动添加这些释放代码，可以不必操心。</li>
<li>而且对象拥有的其他非OC对象也要释放（CoreFoundation对象就必须手动释放）</li>
<li>释放原来的观测行为：注销通知。如果没有及时注销，就会向其发送通知，使得程序崩溃。</li>
</ul>
<p>举个简单的🌰 ：</p>
<pre><code>
- (void)dealloc {

     CFRelease(coreFoundationObject);
    [[NSNotificationCenter defaultCenter] removeObserver:self];

}
</code></pre><blockquote>
<p><strong>尤其注意</strong>：在dealloc方法中不应该调用其他的方法，因为如果这些方法是异步的，并且回调中还要使用当前对象，那么很有可能当前对象已经被释放了，会导致崩溃。</p>
<p>并且在dealloc方法中也不能调用属性的存取方法，因为很有可能在这些方法里还有其他操作。而且这个属性还有可能处于键值观察状态，该属性的观察者可能会在属性改变时保留或者使用这个即将回收的对象。</p>
</blockquote>
<h1 id="第36条：不要使用retainCount"><a href="#第36条：不要使用retainCount" class="headerlink" title="第36条：不要使用retainCount"></a>第36条：不要使用retainCount</h1><hr>
<p>在非ARC得环境下使用retainCount可以返回当前对象的引用计数，但是在ARC环境下调用会报错，因为该方法已经被废弃了 。</p>
<p>它被废弃的原因是因为它所返回的引用计数只能反映对象某一时刻的引用计数，而无法“预知”对象将来引用计数的变化（比如对象当前处于自动释放池中，那么将来就会自动递减引用计数）。</p>
<h1 id="第46条：不要使用dispatch-get-current-queue"><a href="#第46条：不要使用dispatch-get-current-queue" class="headerlink" title="第46条：不要使用dispatch_get_current_queue"></a>第46条：不要使用dispatch_get_current_queue</h1><hr>
<p>我们无法用某个队列来描述“当前队列”这一属性，因为派发队列是按照层级来组织的。</p>
<p>那么什么是队列的层级呢?</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-e880be58b75c49c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="队列的层及分布"></p>
<p>安排在某条队列中的快，会在其上层队列中执行，而层级地位最高的那个队列总是全局并发队列。</p>
<p>在这里，B，C中的块会在A里执行。但是D中的块，可能与A里的块并行，因为A和D的目标队列是并发队列。</p>
<p>正因为有了这种层级关系，所以检查当前队列是并发的还是非并发的就不会总是很准确。</p>
<h1 id="第48条：多用块枚举，少用for循环"><a href="#第48条：多用块枚举，少用for循环" class="headerlink" title="第48条：多用块枚举，少用for循环"></a>第48条：多用块枚举，少用for循环</h1><hr>
<p>当遍历集合元素时，建议使用块枚举，因为相对于传统的for循环，它更加高效，而且简洁,还能获取到用传统的for循环无法提供的值：</p>
<p>我们首先看一下传统的遍历：</p>
<h4 id="传统的for遍历"><a href="#传统的for遍历" class="headerlink" title="传统的for遍历"></a>传统的for遍历</h4><pre><code>NSArray *anArray = /* ... */;
for (int i = 0; i &lt; anArray.count; i++) {
   id object = anArray[i];
   // Do something with &#39;object&#39;
}

// Dictionary
NSDictionary *aDictionary = /* ... */;
NSArray *keys = [aDictionary allKeys];
for (int i = 0; i &lt; keys.count; i++) {
   id key = keys[i];
   id value = aDictionary[key];
   // Do something with &#39;key&#39; and &#39;value&#39;
}

// Set
NSSet *aSet = /* ... */;
NSArray *objects = [aSet allObjects];
for (int i = 0; i &lt; objects.count; i++) {
   id object = objects[i];
   // Do something with &#39;object&#39;
}
</code></pre><p>我们可以看到，在遍历NSDictionary,和NSet时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。</p>
<h4 id="利用快速遍历："><a href="#利用快速遍历：" class="headerlink" title="利用快速遍历："></a>利用快速遍历：</h4><pre><code>NSArray *anArray = /* ... */;
for (id object in anArray) {
 // Do something with &#39;object&#39;
}

// Dictionary
NSDictionary *aDictionary = /* ... */;
for (id key in aDictionary) {
 id value = aDictionary[key];
 // Do something with &#39;key&#39; and &#39;value&#39;

}


NSSet *aSet = /* ... */;
for (id object in aSet) {
 // Do something with &#39;object&#39;
}
</code></pre><p>这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。</p>
<h4 id="利用基于块（block）的遍历："><a href="#利用基于块（block）的遍历：" class="headerlink" title="利用基于块（block）的遍历："></a>利用基于块（block）的遍历：</h4><pre><code>NSArray *anArray = /* ... */;
[anArray enumerateObjectsUsingBlock:^(id object, NSUInteger idx, BOOL *stop){

   // Do something with &#39;object&#39;
   if (shouldStop) {
      *stop = YES; //使迭代停止
  }

}];


“// Dictionary
NSDictionary *aDictionary = /* ... */;
[aDictionary enumerateKeysAndObjectsUsingBlock:^(id key, id object, BOOL *stop){
     // Do something with &#39;key&#39; and &#39;object&#39;
     if (shouldStop) {
        *stop = YES;
    }
}];


// Set
NSSet *aSet = /* ... */;
[aSet enumerateObjectsUsingBlock:^(id object, BOOL *stop){
     // Do something with &#39;object&#39;
     if (shouldStop) {
        *stop = YES;
    }
</code></pre><p>我们可以看到，在使用块进行快速枚举的时候，我们可以不创建临时数组。虽然语法上没有快速枚举简洁，但是我们可以获得数组元素对应的序号，字典元素对应的键值，而且，我们还可以随时令遍历终止。</p>
<p>利用快速枚举和块的枚举还有一个优点：能够修改块的方法签名</p>
<p><code>for (NSString *key in aDictionary) {
         NSString *object = (NSString*)aDictionary[key];
        // Do something with &#39;key&#39; and &#39;object&#39;
}</code></p>
<pre><code>
NSDictionary *aDictionary = /* ... */;

    [aDictionary enumerateKeysAndObjectsUsingBlock:^(NSString *key, NSString *obj, BOOL *stop){

             // Do something with &#39;key&#39; and &#39;obj&#39;

}];
</code></pre><p>如果我们可以知道集合里的元素类型，就可以修改签名。这样做的好处是：可以让编译期检查该元素是否可以实现我们想调用的方法，如果不能实现，就做另外的处理。这样一来，程序就能变得更加安全。</p>
<h1 id="第50条：构建缓存时选用NSCache-而非NSDictionary"><a href="#第50条：构建缓存时选用NSCache-而非NSDictionary" class="headerlink" title="第50条：构建缓存时选用NSCache 而非NSDictionary"></a>第50条：构建缓存时选用NSCache 而非NSDictionary</h1><hr>
<p>如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。</p>
<p>在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。</p>
<h4 id="NSCache优于NSDictionary的几点："><a href="#NSCache优于NSDictionary的几点：" class="headerlink" title="NSCache优于NSDictionary的几点："></a>NSCache优于NSDictionary的几点：</h4><ul>
<li>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。</li>
<li>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。</li>
<li>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</li>
</ul>
<h4 id="关于操控NSCache删减内容的时机"><a href="#关于操控NSCache删减内容的时机" class="headerlink" title="关于操控NSCache删减内容的时机"></a>关于操控NSCache删减内容的时机</h4><p>开发者可以通过两个尺度来调整这个时机：</p>
<ul>
<li>缓存中的对象总数.</li>
<li>将对象加入缓存时，为其指定开销值。</li>
</ul>
<p>对于开销值，只有在能很快计算出开销值的情况下，才应该考虑采用这个尺度，不然反而会加大系统的开销。</p>
<p>下面我们来看一下缓存的用法：缓存网络下载的数据</p>
<pre><code>// Network fetcher class
typedef void(^EOCNetworkFetcherCompletionHandler)(NSData *data);

@interface EOCNetworkFetcher : NSObject

- (id)initWithURL:(NSURL*)url;
- (void)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;

@end

// Class that uses the network fetcher and caches results
@interface EOCClass : NSObject
@end

@implementation EOCClass {
     NSCache *_cache;
}

- (id)init {

     if ((self = [super init])) {
    _cache = [NSCache new];

     // Cache a maximum of 100 URLs
    _cache.countLimit = 100;


     /**
     * The size in bytes of data is used as the cost,
     * so this sets a cost limit of 5MB.
     */
    _cache.totalCostLimit = 5 * 1024 * 1024;
    }
 return self;
}



- (void)downloadDataForURL:(NSURL*)url { 

     NSData *cachedData = [_cache objectForKey:url];

     if (cachedData) {

         // Cache hit：存在缓存，读取
        [self useData:cachedData];

    } else {

         // Cache miss：没有缓存，下载
         EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];      

        [fetcher startWithCompletionHandler:^(NSData *data){
         [_cache setObject:data forKey:url cost:data.length];    
        [self useData:data];
        }];
    }
}
@end
</code></pre><p>在这里，我们使用URL作为缓存的key，将总对象数目设置为100，将开销值设置为5MB。</p>
<h2 id="NSPurgeableData"><a href="#NSPurgeableData" class="headerlink" title="NSPurgeableData"></a>NSPurgeableData</h2><p>NSPurgeableData是NSMutableData的子类，把它和NSCache配合使用效果很好。</p>
<p>因为当系统资源紧张时，可以把保存NSPurgeableData的那块内存释放掉。</p>
<p>如果需要访问某个NSPurgeableData对象，可以调用<code>beginContentAccess</code>方发，告诉它现在还不应该丢弃自己所占据的内存。</p>
<p>在使用完之后，调用<code>endContentAccess</code>方法，告诉系统在必要时可以丢弃自己所占据的内存。</p>
<blockquote>
<p>上面这两个方法类似于“引用计数”递增递减的操作，也就是说，只有当“引用计数”为0的时候，才可以在将来删去它所占的内存。</p>
</blockquote>
<pre><code>- (void)downloadDataForURL:(NSURL*)url { 

      NSPurgeableData *cachedData = [_cache objectForKey:url];

      if (cachedData) {         

            // 如果存在缓存，需要调用beginContentAccess方法
            [cacheData beginContentAccess];

             // Use the cached data
            [self useData:cachedData];

             // 使用后，调用endContentAccess
            [cacheData endContentAccess];


        } else {

                 //没有缓存
                 EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];    

                  [fetcher startWithCompletionHandler:^(NSData *data){

                         NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data];
                         [_cache setObject:purgeableData forKey:url cost:purgeableData.length];

                          // Don&#39;t need to beginContentAccess as it begins            
                          // with access already marked
                           // Use the retrieved data
                            [self useData:data];

                             // Mark that the data may be purged now
                            [purgeableData endContentAccess];

            }];
      }
}
</code></pre><blockquote>
<p>注意：</p>
</blockquote>
<p>在我们可以直接拿到purgeableData的情况下需要执行<code>beginContentAccess</code>方法。然而，在创建purgeableData的情况下，是不需要执行beginContentAccess，因为在创建了purgeableData之后，其引用计数会自动+1；</p>
<h1 id="第51条-精简initialize-与-load的实现代码"><a href="#第51条-精简initialize-与-load的实现代码" class="headerlink" title="第51条: 精简initialize 与 load的实现代码"></a>第51条: 精简initialize 与 load的实现代码</h1><hr>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><p><code>+(void)load;</code><br>每个类和分类在加入运行期系统时，都会调用<code>load</code>方法，而且仅仅调用一次，可能有些小伙伴习惯在这里调用一些方法，但是作者建议尽量不要在这个方法里调用其他方法，尤其是使用其他的类。原因是每个类载入程序库的时机是不同的，如果该类调用了还未载入程序库的类，就会很危险。</p>
<h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="initialize方法"></a>initialize方法</h2><p><code>+(void)initialize;</code></p>
<p>这个方法与<code>load</code>方法类似，区别是这个方法会在程序<strong>首次</strong>调用这个类的时候调用（惰性调用），而且只调用一次（绝对不能主动使用代码调用）。</p>
<p>值得注意的一点是，如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码：这个情况往往很容易让人忽视。</p>
<p>看一下🌰 ：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface EOCBaseClass : NSObject
@end

@implementation EOCBaseClass
+ (void)initialize {
 NSLog(@&quot;%@ initialize&quot;, self);
}
@end

@interface EOCSubClass : EOCBaseClass
@end

@implementation EOCSubClass
@end
</code></pre><p>当使用EOCSubClass类时，控制台会输出两次打印方法：<br><code>EOCBaseClass initialize
EOCSubClass initialize</code></p>
<p>因为子类EOCSubClass并没有覆写<code>initialize</code>方法，那么自然会调用其父类EOCBaseClass的方法。<br>解决方案是通过检测类的类型的方法：</p>
<p>``</p>
<ul>
<li>(void)initialize {<br> if (self == [EOCBaseClass class]) {<pre><code> NSLog(@&quot;%@ initialized&quot;, self);
</code></pre>  }<br>}<br>``</li>
</ul>
<p>这样一来，EOCBaseClass的子类EOCSubClass就无法再调用<code>initialize</code>方法了。<br>我们可以察觉到，如果在这个方法里执行过多的操作的话，会使得程序难以维护，也可能引起其他的bug。因此，在<code>initialize</code>方法里，最好只是设置内部的数据，不要调用其他的方法，因为将来可能会给这些方法添加其它的功能，那么会可能会引起难以排查的bug。</p>
<h1 id="第52条-别忘了NSTimer会保留其目标对象"><a href="#第52条-别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条: 别忘了NSTimer会保留其目标对象"></a>第52条: 别忘了NSTimer会保留其目标对象</h1><hr>
<p>在使用NSTimer的时候，NSTimer会生成指向其使用者的引用，而其使用者如果也引用了NSTimer，那么就会生成保留环。</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface EOCClass : NSObject
- (void)startPolling;
- (void)stopPolling;
@end


@implementation EOCClass {
     NSTimer *_pollTimer;
}


- (id)init {
     return [super init];
}


- (void)dealloc {
    [_pollTimer invalidate];
}


- (void)stopPolling {

    [_pollTimer invalidate];
    _pollTimer = nil;
}


- (void)startPolling {
   _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0
                                                 target:self
                                               selector:@selector(p_doPoll)
                                               userInfo:nil
                                                repeats:YES];
}

- (void)p_doPoll {
    // Poll the resource
}

@end
</code></pre><blockquote>
<p>在这里，在EOCClass和_pollTimer之间形成了保留环，如果不主动调用<code>stopPolling</code>方法就无法打破这个保留环。像这种通过主动调用方法来打破保留环的设计显然是不好的。</p>
</blockquote>
<p>而且，如果通过回收该类的方法来打破此保留环也是行不通的，因为会将该类和NSTimer孤立出来，形成“孤岛”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d60b4571e7709e46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="孤立了类和它的NSTimer"></p>
<p>这可能是一个极其危险的情况，因为NSTimer没有消失，它还有可能持续执行一些任务，不断消耗系统资源。而且，如果任务涉及到下载，那么可能会更糟。。</p>
<p>那么如何解决呢？ 通过“块”来解决！</p>
<p>通过给NSTimer增加一个分类就可以解决：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface NSTimer (EOCBlocksSupport)

+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval
                                         block:(void(^)())block
                                         repeats:(BOOL)repeats;
@end



@implementation NSTimer (EOCBlocksSupport)

+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval
                                         block:(void(^)())block
                                        repeats:(BOOL)repeats
{
             return [self scheduledTimerWithTimeInterval:interval
                                                  target:self
                                                selector:@selector(eoc_blockInvoke:)
                                                userInfo:[block copy]
                                                 repeats:repeats];

}


+ (void)eoc_blockInvoke:(NSTimer*)timer {
     void (^block)() = timer.userInfo;
         if (block) {
             block();
        }
}
@end
</code></pre><p>我们在NSTimer类里添加了方法，我们来看一下如何使用它：</p>
<pre><code>- (void)startPolling {

         __weak EOCClass *weakSelf = self;    
         _pollTimer = [NSTimer eoc_scheduledTimerWithTimeInterval:5.0 block:^{

               EOCClass *strongSelf = weakSelf;
               [strongSelf p_doPoll];
          }

                                                          repeats:YES];
}
</code></pre><p>﻿在这里，创建了一个self的弱引用，然后让块捕获了这个self变量，让其在执行期间存活。</p>
<p>一旦外界指向EOC类的最后一个引用消失，该类就会被释放，被释放的同时，也会向NSTimer发送invalidate消息（因为在该类的dealloc方法中向NSTimer发送了invalidate消息）。</p>
<p>而且，即使在dealloc方法里没有发送invalidate消息，因为块里的weakSelf会变成nil，所以NSTimer同样会失效。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>总的来说这一部分还是比较容易理解的，更多的只是教我们一些编写OC程序的规范，并没有深入讲解技术细节。</p>
<p>而三部曲的最后一篇：技巧篇则着重讲解了一些在编写OC代码的过程中可以使用的一些技巧。广义上来讲，这些技巧也可以被称为“规范”，例如“提供全能初始化方法”这一节，但是这些知识点更像是一些“设计模式”目的更偏向于在于解决一些实际问题，因此将这些知识点归类为“技巧类”。</p>
<p>因为第三篇的内容稍微难一点，所以笔者打算再好好消化几天，将第三篇的初稿再三润饰之后呈献给大家~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C》超级干货三部曲（一）：概念篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E3%80%8AEffective%20Objective-C%E3%80%8B%E8%B6%85%E7%BA%A7%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A6%82%E5%BF%B5%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（一）：概念篇/</id>
    <published>2017-01-13T05:50:51.000Z</published>
    <updated>2017-01-13T05:50:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>很多文章和大牛都在推荐这本书，说它讲授了很多编写Objective-C语言时所应该遵循的规范。刚好笔者前段时间因为产品刚开发完，有了一点空档期，于是用了3个星期的时间仔细研读和总结了这本书。</p>
<p>在学习过程中也看过很多总结这本书的博客和文章，但是发现多数只是将每节的总结部分抄了过来，讲得并不是很详细，于是笔者就想按照自己的方式对这本书进行总结，并以博客的形式展现出来：既能分享，同时又能对知识进行一下梳理和二次复习。</p>
<p>虽然本书的作者按照知识模块来将这本书分成七个章节，共52节，但是笔者在拜读的过程中发现本书介绍的知识点可以大致分为三类：概念类，规范类，和技巧类。笔者打算按照这三类来对这本书进行总结，形成三部曲：</p>
<ul>
<li>概念类：讲解了一些概念性知识。</li>
<li>规范类：讲解了一些为了避免一些问题或者为后续开发提供便利所需要遵循的规范性知识。</li>
<li>技巧类：讲解了一些为了解决某些特定问题而需要用到的技巧性知识。</li>
</ul>
<p>而且，笔者也按照自己的归类将这本书的结构用思维导图工具画了出来：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-539498fef0819472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<blockquote>
<p>从图中可以看到，笔者并没有打乱原来作者的标题顺序。本篇总结即是三部曲之一：概念篇，后续会呈上规范篇和技巧篇。<br>备注：本总结所有的代码和图片都来自原书。其中，代码会适当加上笔者的注释，便于各位看官理解。</p>
</blockquote>
<p>好了，不啰嗦了， 开始吧！</p>
<h1 id="第1条：了解Objective-C的起源"><a href="#第1条：了解Objective-C的起源" class="headerlink" title="第1条：了解Objective-C的起源"></a>第1条：了解Objective-C的起源</h1><hr>
<h2 id="1-运行期组件"><a href="#1-运行期组件" class="headerlink" title="1. 运行期组件"></a>1. 运行期组件</h2><p>对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由运行期组件完成（runtime component），使用Objective-C的面向对象特性所需的全部数据结构以及函数都在运行期组件里面。</p>
<p>运行期组件本质上是一种与开发者所编写的代码相链接的动态库（dynamic library），其代码能把开发者所编写的所有程序粘合起来，所以只要更新运行期组件，就可以提升应用程序性能。</p>
<p>内存：对象分配到堆空间,指针分配到栈空间。<br>分配在队中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。</p>
<p>不含*的变量，可能会使用栈空间。结构体保存非对象类型。</p>
<h1 id="第6条：理解“属性”这一概念"><a href="#第6条：理解“属性”这一概念" class="headerlink" title="第6条：理解“属性”这一概念"></a>第6条：理解“属性”这一概念</h1><hr>
<blockquote>
<p>属性用于封装对象中的数据。</p>
</blockquote>
<h2 id="1-存取方法"><a href="#1-存取方法" class="headerlink" title="1. 存取方法"></a>1. 存取方法</h2><p>在设置完属性后，编译器会自动写出一套存取方法，用于访问相应名称的变量：</p>
<pre><code>@interface EOCPerson : NSObject
@property NSString *firstName;
@property NSString *lastName;
@end

@interface EOCPerson : NSObject
- (NSString*)firstName;
- (void)setFirstName:(NSString*)firstName;
- (NSString*)lastName;
- (void)setLastName:(NSString*)lastName;
@end
</code></pre><p>访问属性，可以使用点语法。编译器会把点语法转换为对存取方法的调用：</p>
<pre><code>aPerson.firstName = @&quot;Bob&quot;; // Same as:
[aPerson setFirstName:@&quot;Bob&quot;];

NSString *lastName = aPerson.lastName; // Same as:
NSString *lastName = [aPerson lastName];
</code></pre><p>如果我们不希望编译器自动生成存取方法的话，需要设置@dynamic 字段：</p>
<pre><code>@interface EOCPerson : NSManagedObject
@property NSString *firstName;
@property NSString *lastName;
@end

@implementation EOCPerson
@dynamic firstName, lastName;
@end
</code></pre><h2 id="2-属相特质"><a href="#2-属相特质" class="headerlink" title="2. 属相特质"></a>2. 属相特质</h2><blockquote>
<p>定义属性的时候，通常会赋予它一些特性，来满足一些对类保存数据所要遵循的需求。</p>
</blockquote>
<h4 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h4><ul>
<li>nonatomic：不使用同步锁</li>
<li>atomic：加同步锁，确保其原子性</li>
</ul>
<h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><ul>
<li>readwrite:同时存在存取方法</li>
<li>readonly:只有获取方法</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>assign:纯量类型(scalar type)的简单赋值操作</li>
<li>strong:拥有关系保留新值，释放旧值，再设置新值</li>
<li>weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空</li>
<li>unsafe_unretained ：类似assign，适用于对象类型，非拥有关系，属性所指的对象遭到摧毁时，属性不会清空。</li>
<li>copy：不保留新值，而是将其拷贝</li>
</ul>
<h4 id="注意：遵循属性定义"><a href="#注意：遵循属性定义" class="headerlink" title="注意：遵循属性定义"></a>注意：遵循属性定义</h4><p>如果属性定义为copy，那么在非设置方法里设定属性的时候，也要遵循copy的语义</p>
<pre><code>- (id)initWithFirstName:(NSString*)firstName lastName:(NSString*)lastName
{
         if ((self = [super init])) {
            _firstName = [firstName copy];
            _lastName = [lastName copy];
        }
       return self;
}
</code></pre><h1 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h1><hr>
<h2 id="1-同等性判断"><a href="#1-同等性判断" class="headerlink" title="1. 同等性判断"></a>1. 同等性判断</h2><blockquote>
<p>==操作符比较的是指针值，也就是内存地址。</p>
</blockquote>
<p>然而有的时候我们只是想比较指针所指向的内容，在这个时候，就需要通过<code>isEqual:</code>方法来比较。</p>
<p>而且，如果已知两个对象是字符串，最好通过<code>isEqualToString:</code>方法来比较。<br>对于数组和字典，也有<code>isEqualToArray:</code>方法和<code>isEqualToDictionary:</code>方法。</p>
<p>另外，如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的<code>isEqual:</code>方法：</p>
<pre><code>- (BOOL)isEqualToPerson:(EOCPerson*)otherPerson {
     //先比较对象类型，然后比较每个属性
     if (self == object) return YES;
     if (![_firstName isEqualToString:otherPerson.firstName])
         return NO;
     if (![_lastName isEqualToString:otherPerson.lastName])
         return NO;
     if (_age != otherPerson.age)
         return NO;
     return YES;
}

- (BOOL)isEqual:(id)object {
    //如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法
     if ([self class] == [object class]) {    
         return [self isEqualToPerson:(EOCPerson*)object];
    } else {    
         return [super isEqual:object];
    }
}
</code></pre><h2 id="2-深度等同性判定"><a href="#2-深度等同性判定" class="headerlink" title="2. 深度等同性判定"></a>2. 深度等同性判定</h2><p>比较两个数组是否相等的话可以使用深度同等性判断方法：</p>
<blockquote>
<p>1.先比较数组的个数<br>2.再比较两个数组对应位置上的对象均相等。</p>
</blockquote>
<h1 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h1><hr>
<p>在OC中，如果向某对象传递信息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数.</p>
<p>然而对象收到 消息后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得OC成为一门真正的动态语言。</p>
<p>在OC中，给对象发送消息的语法是：</p>
<pre><code>id returnValue = [someObject messageName:parameter];
</code></pre><blockquote>
<p>这里，someObject叫做“接收者(receiver)”，messageName:叫做”选择子（selector）”,选择子和参数合起来称为“消息”。编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是消息传递机制中的核心函数叫做objc_msgSend，它的原型如下：</p>
</blockquote>
<pre><code>void objc_msgSend(id self, SEL cmd, ...)
</code></pre><blockquote>
<p>第一个参数代表接收者，第二个参数代表选择子，后续参数就是消息中的那些参数，数量是可变的，所以这个函数就是参数个数可变的函数。</p>
</blockquote>
<p>因此，上述以OC形式展现出来的函数就会转化成如下函数:</p>
<pre><code>id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);
</code></pre><blockquote>
<p>这个函数会在接收者所属的类中搜寻其“方法列表”，如果能找到与选择子名称相符的方法，就去实现代码，如果找不到就沿着继承体系继续向上查找。如果找到了就执行，如果最终还是找不到，就执行<strong>消息转发</strong>操作。</p>
<p><strong>注意</strong>：如果匹配成功的话，这种匹配的结果会缓存在“快速映射表”里面。每个类都有这样一块缓存。所以如果将来再次向该类发送形同的消息，执行速度就会更快了。</p>
</blockquote>
<h1 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h1><hr>
<p>如果对象所属类和其所有的父类都无法解读收到的消息，就会启动消息转发机制（message forwarding）。</p>
<p>尤其我们在编写自己的类时，可在消息转发过程中设置挂钩，用以执行预定的逻辑，而不应该使应用程序崩溃。</p>
<p>消息转发分为两个阶段:</p>
<ol>
<li><p>征询接受者，看它能否动态添加方法，以处理这个未知的选择子，这个过程叫做动态方法解析（dynamic method resolution）。</p>
</li>
<li><p>请接受者看看有没有其他对象能处理这条消息：</p>
<p>  2.1 如果有，则运行期系统会把消息转给那个对象。<br>  2.2 如果没有，则启动完整的消息转发机制（full forwarding mechanism），运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接受者最后一次机会，令其设法解决当前还未处理的这条消息。</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6619cbf33830ce3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Effective Objective-C 》"></p>
<p>类方法<code>+(BOOL)resolveInstanceMethod:(SEL)selector</code>:查看这个类是否能新增一个实例方法用以处理此选择子</p>
<p>实例方法<code>- (id)forwardTargetForSelector:(SEL)selector;</code>:询问是否能找到未知消息的备援接受者，如果能找到备援对象，就将其返回，如果不能，就返回nil。</p>
<p>实例方法<code>- (void)forwardInvocation:(NSInvocation*)invocation</code>:创建NSInvocation对象，将尚未处理的那条消息 有关的全部细节都封于其中，在触发NSInvocation对象时，“消息派发系统（message-dispatch system）”就会将消息派给目标对象。</p>
<p>下面来看一个关于动态方法解析的例子：</p>
<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface EOCAutoDictionary : NSObject
@property (nonatomic, strong) NSString *string;
@property (nonatomic, strong) NSNumber *number;
@property (nonatomic, strong) NSDate *date;
@property (nonatomic, strong) id opaqueObject;

@end

#import &quot;EOCAutoDictionary.h&quot;
#import &lt;objc/runtime.h&gt;


@interface EOCAutoDictionary ()
@property (nonatomic, strong) NSMutableDictionary *backingStore;
@end



@implementation EOCAutoDictionary
@dynamic string, number, date, opaqueObject;

- (id)init {
 if ((self = [super init])) {
    _backingStore = [NSMutableDictionary new];
}
   return self;
}

+ (BOOL)resolveInstanceMethod:(SEL)selector {

     NSString *selectorString = NSStringFromSelector(selector);
     if ([selectorString hasPrefix:@&quot;set&quot;]) {
         class_addMethod(self,selector,(IMP)autoDictionarySetter, &quot;v@:@&quot;);
     } else {
         class_addMethod(self,selector,(IMP)autoDictionaryGetter, &quot;@@:&quot;);
    }
     return YES;
}
</code></pre><blockquote>
<p>在本例中，EOCAutoDictionary类将属性设置为@dynamic，也就是说编译器无法自动为其属性生成set和get方法，因此我们需要动态给其添加set和get方法。</p>
<p>我们实现了<code>resolveInstanceMethod:</code>方法：首先将选择子转换为String，然后判断字符串是否含有set字段，如果有，则增加处理选择子的set方法；如果没有，则增加处理选择子的get方法。其中<code>class_addMethod</code>可以给类动态添加方法。</p>
</blockquote>
<p>实现增加处理选择子的get方法：</p>
<pre><code>id autoDictionaryGetter(id self, SEL _cmd) {

     // Get the backing store from the object
     EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;
     NSMutableDictionary *backingStore = typedSelf.backingStore;

     // The key is simply the selector name
     NSString *key = NSStringFromSelector(_cmd);

     // Return the value
     return [backingStore objectForKey:key];
}
</code></pre><blockquote>
<p>在这里，键的名字就等于方法名，所以在取出键对应的值之前，要将方法名转换为字符串。</p>
</blockquote>
<p>实现增加处理选择子的set方法：</p>
<pre><code>void autoDictionarySetter(id self, SEL _cmd, id value) {

     // Get the backing store from the object
     EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self;
     NSMutableDictionary *backingStore = typedSelf.backingStore;

     /** The selector will be for example, &quot;setOpaqueObject:&quot;.
     * We need to remove the &quot;set&quot;, &quot;:&quot; and lowercase the first
     * letter of the remainder.
     */
     NSString *selectorString = NSStringFromSelector(_cmd);
     NSMutableString *key = [selectorString mutableCopy];

     // Remove the &#39;:&#39; at the end
    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];

     // Remove the &#39;set&#39; prefix
    [key deleteCharactersInRange:NSMakeRange(0, 3)];

     // Lowercase the first character
     NSString *lowercaseFirstChar = [[key substringToIndex:1] lowercaseString];
    [key replaceCharactersInRange:NSMakeRange(0, 1) withString:lowercaseFirstChar];

     if (value) {
       [backingStore setObject:value forKey:key];
    } else {
        [backingStore removeObjectForKey:key];        
    }
}
</code></pre><blockquote>
<p>因为key的名字对应了属性名，也就是没有set，首字母小写，尾部没有：的字符串。然而，将set方法转换为字符串后，我们需要将set方法的这些“边角”都处理掉。最后得到了“纯净”的键后，再进行字典的赋值操作。</p>
</blockquote>
<h1 id="第14条：理解“类对象”的用意"><a href="#第14条：理解“类对象”的用意" class="headerlink" title="第14条：理解“类对象”的用意"></a>第14条：理解“类对象”的用意</h1><hr>
<p>在运行期程序库的头文件里定义了描述OC对象所用的数据结构：</p>
<pre><code>typedef struct objc_class *Class;
    struct objc_class {
         Class isa;
         Class super_class;
         const char *name;
         long version;
         long info;
         long instance_size;
         struct objc_ivar_list *ivars;
         struct objc_method_list **methodLists;
         struct objc_cache *cache;
         struct objc_protocol_list *protocols;
};
</code></pre><blockquote>
<p>在这里，isa指针指向了对象所属的类：元类（metaclass），它是整个结构体的第一个变量。super_class定义了本类的超类。</p>
</blockquote>
<p>我们也可以向对象发送特定的方法来检视类的继承体系：自身属于哪一类；自身继承与哪一类。</p>
<p>我们使用<code>isMemberOfClass:</code>能够判断出对象是否为某个特定类的实例；<br>而<code>isKindOfClass:</code>方法能够判断出对象是否为某类或其派生类的实例。</p>
<p>这两种方法都是利用了isa指针获取对象所属的类，然后通过super_class类在继承体系中查询。在OC语言中，必须使用这种查询类型信息的方法才能完全了解对象的真实类型。因为对象类型无法在编译期决定。</p>
<p>尤其注意在集合类里获取对象时，通常要查询类型信息因为这些对象不是强类型的（strongly typed），将它们从集合类中取出来的类型通常是id，也就是能响应任何消息（编译期）。</p>
<p>所以如果我们对这些对象的类型把握不好，那么就会有可能造成对象无法响应消息的情况。因此，在我们从集合里取出对象后，通常要进行类型判断：</p>
<pre><code>- (NSString*)commaSeparatedStringFromObjects:(NSArray*)array {

         NSMutableString *string = [NSMutableString new];

             for (id object in array) {
                    if ([object isKindOfClass:[NSString class]]) {
                            [string appendFormat:@&quot;%@,&quot;, object];
                    } else if ([object isKindOfClass:[NSNumber class]]) {
                            [string appendFormat:@&quot;%d,&quot;, [object intValue]];
                    } else if ([object isKindOfClass:[NSData class]]) {
                           NSString *base64Encoded = /* base64 encoded data */;
                            [string appendFormat:@&quot;%@,&quot;, base64Encoded];
                    } else {
                            // Type not supported
                    }
              }
             return string;
}
</code></pre><h1 id="第21条：理解Objective-C错误类型"><a href="#第21条：理解Objective-C错误类型" class="headerlink" title="第21条：理解Objective-C错误类型"></a>第21条：理解Objective-C错误类型</h1><hr>
<p>在OC中，我们可以用NSError描述错误。<br>使用NSError可以封装三种信息：</p>
<ul>
<li>Error domain:错误范围，类型是字符串</li>
<li>Error code :错误码，类型是整数</li>
<li>User info：用户信息，类型是字典</li>
</ul>
<h2 id="1-NSError的使用"><a href="#1-NSError的使用" class="headerlink" title="1. NSError的使用"></a>1. NSError的使用</h2><p>用法：</p>
<p>1.通过委托协议来传递NSError，告诉代理错误类型。</p>
<pre><code>- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
</code></pre><p>2.作为方法的“输出参数”返回给调用者</p>
<pre><code>- (BOOL)doSomething:(NSError**)error
</code></pre><p>使用范例：</p>
<pre><code>NSError *error = nil;
BOOL ret = [object doSomething:&amp;error];

if (error) {
    // There was an error
}
</code></pre><h2 id="2-自定义NSError"><a href="#2-自定义NSError" class="headerlink" title="2. 自定义NSError"></a>2. 自定义NSError</h2><p>我们可以设置属于我们自己程序的错误范围和错误码</p>
<ul>
<li>错误范围可以用全局常量字符串来定义。</li>
<li>错误码可以用枚举来定义。</li>
</ul>
<pre><code>
// EOCErrors.h
extern NSString *const EOCErrorDomain;

//定义错误码
typedef NS_ENUM(NSUInteger, EOCError) {

    EOCErrorUnknown = –1,
    EOCErrorInternalInconsistency = 100,
    EOCErrorGeneralFault = 105,
    EOCErrorBadInput = 500,
};
// EOCErrors.m
NSString *const EOCErrorDomain = @&quot;EOCErrorDomain&quot;; //定义错误范围
</code></pre><h1 id="第22条：理解NSCopying协议"><a href="#第22条：理解NSCopying协议" class="headerlink" title="第22条：理解NSCopying协议"></a>第22条：理解NSCopying协议</h1><hr>
<p>如果我们想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法：</p>
<pre><code>- (id)copyWithZone:(NSZone*)zone
</code></pre><p>作者举了个：</p>
<pre><code>- (id)copyWithZone:(NSZone*)zone {
     EOCPerson *copy = [[[self class] allocWithZone:zone] initWithFirstName:_firstName  andLastName:_lastName];
    copy-&gt;_friends = [_friends mutableCopy];
     return copy;
}
</code></pre><blockquote>
<p>之所以是copy-&gt;_friends，而不是copy.friends是因为friends并不是属性，而是一个内部使用的实例变量。</p>
</blockquote>
<h2 id="1-复制可变的版本："><a href="#1-复制可变的版本：" class="headerlink" title="1. 复制可变的版本："></a>1. 复制可变的版本：</h2><p>遵从<nsmutablecopying>协议</nsmutablecopying></p>
<p>而且要执行：</p>
<pre><code>- (id)mutableCopyWithZone:(NSZone*)zone；
</code></pre><blockquote>
<p>注意：拷贝可变型和不可变型发送的是<code>copy</code>和<code>mutableCopy</code>消息，而我们实现的却是<code>- (id)copyWithZone:(NSZone*)zone</code>和<code>- (id)mutableCopyWithZone:(NSZone*)zone</code> 方法。</p>
<p>而且，如果我们想获得某对象的不可变型，统一调用copy方法；获得某对象的可变型，统一调用mutableCopy方法。</p>
</blockquote>
<p>例如数组的拷贝：</p>
<pre><code>-[NSMutableArray copy] =&gt; NSArray
-[NSArray mutableCopy] =&gt; NSMutableArray
</code></pre><h2 id="2-浅拷贝和深拷贝"><a href="#2-浅拷贝和深拷贝" class="headerlink" title="2. 浅拷贝和深拷贝"></a>2. 浅拷贝和深拷贝</h2><p>Foundation框架中的集合类默认都执行浅拷贝：只拷贝容器对象本身，而不复制其中的数据。<br>而深拷贝的意思是连同对象本身和它的底层数据都要拷贝。</p>
<p>作者用一个图很形象地体现了浅拷贝和深拷贝的区别：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0fd10d82cbecd8d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Effective Objective-C》"></p>
<blockquote>
<p>浅拷贝后的内容和原始内容指向同一个对象<br>深拷贝后的内容所指的对象是原始内容对应对象的拷贝</p>
</blockquote>
<h2 id="3-如何深拷贝？"><a href="#3-如何深拷贝？" class="headerlink" title="3. 如何深拷贝？"></a>3. 如何深拷贝？</h2><p>我们需要自己编写深拷贝的方法：遍历每个元素并复制，然后将复制后的所有元素重新组成一个新的集合。</p>
<pre><code>- (id)initWithSet:(NSArray*)array copyItems:(BOOL)copyItems;
</code></pre><blockquote>
<p>在这里，我们自己提供了一个深拷贝的方法：该方法需要传入两个参数：需要拷贝的数组和是否拷贝元素（是否深拷贝）</p>
</blockquote>
<pre><code>
- (id)deepCopy {
       EOCPerson *copy = [[[self class] alloc] initWithFirstName:_firstName andLastName:_lastName];
        copy-&gt;_friends = [[NSMutableSet alloc] initWithSet:_friends copyItems:YES];
        return copy;
}
</code></pre><h1 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h1><hr>
<p>尽管在iOS系统已经支持了自动引用计数，但仍然需要开发者了解其内存管理机制。</p>
<h2 id="1-计数器的操作："><a href="#1-计数器的操作：" class="headerlink" title="1. 计数器的操作："></a>1. 计数器的操作：</h2><ol>
<li>retain：递增保留计数。</li>
<li>release：递减保留计数</li>
<li>autorelease ：待稍后清理“自动释放池时”，再递减保留计数。</li>
</ol>
<blockquote>
<p>注意：在对象初始化后，引用计数不一定是1，还有可能大于1。因为在初始化方法的实现中，或许还有其他的操作使得引用计数+1，例如其他的对象也保留了此对象。</p>
</blockquote>
<p>有时，我们无法确定在某个操作后引用计数的确切值，而只能判断这个操作是递增还是递减了保留计数。</p>
<h2 id="2-自动释放池："><a href="#2-自动释放池：" class="headerlink" title="2. 自动释放池："></a>2. 自动释放池：</h2><p>将对象放入自动释放池之后，不会马上使其引用计数-1，而是在当前线程的下一次事件循环时递减。</p>
<p>使用举例：如果我们想释放当前需要使用的方法返回值是，可以将其暂时放在自动释放池中：</p>
<pre><code>
- (NSString*)stringValue {
     NSString *str = [[NSString alloc] initWithFormat:@&quot;I am this: %@&quot;, self];
     return [str autorelease];
}
</code></pre><h2 id="3-保留环（retain-cycle）"><a href="#3-保留环（retain-cycle）" class="headerlink" title="3. 保留环（retain cycle）"></a>3. 保留环（retain cycle）</h2><p>对象之间相互用强引用指向对方，会使得全部都无法得以释放。解决方案是讲其中一端的引用改为弱引用（weak reference），在引用的同时不递增引用计数。</p>
<h1 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h1><hr>
<p>使用ARC，可以省略对于引用计数的操作，让开发者专注于开发本身：</p>
<pre><code>if ([self shouldLogMessage]) {
     NSString *message = [[NSString alloc] initWithFormat:@&quot;I am object, %p&quot;, self];
     NSLog(@&quot;message = %@&quot;, message);
      [message release]; ///&lt; Added by ARC
}
</code></pre><blockquote>
<p>显然这里我们不需要message对象了，那么ARC会自动为我们添加内存管理的语句。</p>
</blockquote>
<p>因此，在ARC环境下调用内存管理语句是非法的：</p>
<ul>
<li>retain</li>
<li>release</li>
<li>autorelease</li>
<li>dealloc</li>
</ul>
<blockquote>
<p>注意：ARC只负责管理OC对象的内存，CoreFoundation对象不归ARC管理</p>
</blockquote>
<h1 id="第37条：理解“块”这一概念"><a href="#第37条：理解“块”这一概念" class="headerlink" title="第37条：理解“块”这一概念"></a>第37条：理解“块”这一概念</h1><hr>
<p>对于“块”的基础知识就不再赘述了，这里强调一下块的种类。</p>
<p>块(Block)分为三类：</p>
<ul>
<li>栈块</li>
<li>堆块</li>
<li>全局块</li>
</ul>
<h2 id="1-栈块"><a href="#1-栈块" class="headerlink" title="1. 栈块"></a>1. 栈块</h2><p>定义块的时候，其所占内存区域是分配在栈中的，而且只在定义它的那个范围内有效：</p>
<pre><code>void (^block)();

if ( /* some condition */ ) {
    block = ^{
     NSLog(@&quot;Block A&quot;);
    };

} else {
    block = ^{
     NSLog(@&quot;Block B&quot;);
    };
}

block();
</code></pre><p>上面定义的两个块只在if else语句范围内有效，一旦离开了最后一个右括号，如果编译器覆写了分配给块的内存，那么就会造成程序崩溃。</p>
<h2 id="2-堆块"><a href="#2-堆块" class="headerlink" title="2. 堆块"></a>2. 堆块</h2><p>为了解决这个问题，我们可以给对象发送copy消息，复制一份到堆里，并自带引用计数：</p>
<pre><code>void (^block)();

if ( /* some condition */ ) {
    block = [^{
         NSLog(@&quot;Block A&quot;);
   } copy];
} else {
    block = [^{
         NSLog(@&quot;Block B&quot;);
    } copy];
}
block();
</code></pre><h2 id="3-全局块"><a href="#3-全局块" class="headerlink" title="3. 全局块"></a>3. 全局块</h2><p>全局块声明在全局内存里，而不需要在每次用到的时候于栈中创建。</p>
<pre><code>void (^block)() = ^{
     NSLog(@&quot;This is a block&quot;);
﻿};
</code></pre><h1 id="第47条：熟悉系统框架"><a href="#第47条：熟悉系统框架" class="headerlink" title="第47条：熟悉系统框架"></a>第47条：熟悉系统框架</h1><hr>
<p>如果我们使用了系统提供的现成的框架，那么用户在升级系统后，就可以直接享受系统升级所带来的改进。</p>
<p>主要的系统框架：</p>
<ul>
<li>Foundation:NSObject,NSArray,NSDictionary等</li>
<li>CFoundation框架：C语言API，Foundation框架中的许多功能，都可以在这里找到对应的C语言API</li>
<li>CFNetwork框架:C语言API，提供了C语言级别的网络通信能力</li>
<li>CoreAudio:C语言API，操作设备上的音频硬件</li>
<li>AVFoundation框架：提供的OC对象可以回放并录制音频和视频</li>
<li>CoreData框架：OC的API，将对象写入数据库</li>
<li>CoreText框架：C语言API，高效执行文字排版和渲染操作</li>
</ul>
<p>用C语言来实现API的好处：可以绕过OC的运行期系统，从而提升执行速度。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>像本文开头所说，本文是三部曲系列的第一篇：概念篇，笔者主要将本书讲解概念的知识点抽取出来合并而成，内容相对后两篇简单一些。笔者会在一周的时间里陆续推出第2篇（规范篇），第3篇（技巧篇）~<br>望各路大神和在大神路上的伙伴们多多交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; a
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>详解iOS多图下载的缓存机制</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E8%AF%A6%E8%A7%A3iOS%E5%A4%9A%E5%9B%BE%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/详解iOS多图下载的缓存机制/</id>
    <published>2017-01-13T05:33:55.000Z</published>
    <updated>2017-01-13T05:36:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>做iOS开发也有半年多了，想想自己对一些第三方库还只是停留在简单运用的阶段，感觉心慌慌的。于是决定用一个月的时间深入了解一些好的第三方库。</p>
<p>第一个想到了SDWebImage，这个库很不错，几乎每个iOS项目都会有它的影子，因为它很完美地解决了下载图片并显示的处理逻辑。那么深究它之前，笔者准备先了解一下多图下载的缓存机制，因为它和SDWebImage的方案类似。</p>
<p>有一个多图缓存机制的教程是来自李明杰小码哥的，笔者觉得讲得挺不错的，于是就花了2个小时好好学习了一下。</p>
<h1 id="1-需求点是什么？"><a href="#1-需求点是什么？" class="headerlink" title="1.需求点是什么？"></a>1.需求点是什么？</h1><hr>
<p>这里所说的<strong>多图下载</strong>，就是要在tableview的每一个cell里显示一张图片,而且这些图片都需要从网上下载。</p>
<h1 id="2-容易遇到的问题"><a href="#2-容易遇到的问题" class="headerlink" title="2.容易遇到的问题"></a>2.容易遇到的问题</h1><hr>
<p>如果不知道或不使用<strong>异步操作</strong>和<strong>缓存机制</strong>，那么写出来的代码很可能会是这样：</p>
<pre><code>cell.textLabel.text = app.name;
cell.detailTextLabel.text = app.download;
NSData *imageData = [NSData dataWithContentsOfURL:app.url];
cell.imageView.image = [UIImage imageWithData:imageData];
</code></pre><p>这样写有什么后果呢？</p>
<h4 id="后果1：不可避免的卡顿（因为没有异步下载操作）"><a href="#后果1：不可避免的卡顿（因为没有异步下载操作）" class="headerlink" title="后果1：不可避免的卡顿（因为没有异步下载操作）"></a>后果1：不可避免的卡顿（因为没有异步下载操作）</h4><blockquote>
<p>dataWithContentsOfURL：是耗时操作，将其放在主线程会造成卡顿。如果图片很多，图片很大，而且网络情况不好的话肯定会卡出翔！</p>
</blockquote>
<h4 id="后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）"><a href="#后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）" class="headerlink" title="后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）"></a>后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）</h4><blockquote>
<p>由于没有缓存机制，即使下载完成并显示了当前cell的图片，但是当该cell再一次需要显示的时候还是会下载它所对应的图片：耗费了下载流量，而且还导致重复操作。</p>
</blockquote>
<p>很显然，要达到Tableview滚动的<strong>如丝滑般的享受</strong>必须二者兼得才可以，具体怎么做呢？</p>
<h1 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h1><hr>
<h4 id="1-先看一下解决方案的流程图"><a href="#1-先看一下解决方案的流程图" class="headerlink" title="1.先看一下解决方案的流程图"></a>1.先看一下解决方案的流程图</h4><p>小码哥将他的解决方案在PPT里用流程图画了出来，笔者觉得很不错，但是颜值略低（毕竟人家是一心搞技术，没时间在意这些外在的东西），笔者理了理思路，自己重新画了一张（好看么？）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-addf3137097c3912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多图下载解决方案流程图"></p>
<p>要想快速看懂此图，需要先了解该流程所需的所有数据源：</p>
<p><strong>1. 图片的URL</strong>：因为每张图片对应的URL都是唯一的，所以我们可以通过它来建立<strong>图片缓存</strong>和<strong>下载操作的缓存</strong>的键，以及拼接<strong>沙盒缓存</strong>的路径字符串。<br><strong>2. 图片缓存（字典）</strong>：存放于内存中；键为图片的URL，值为UIImage对象。作用：读取速度快，直接使用UIImage对象。<br><strong>3. 下载操作缓存（字典）</strong>：存放与内存中，键为图片的URL，值为NSBlockOperation对象。作用：用来避免对于同一张图片还要开启多个下载线程。<br><strong>4. 沙盒缓存(文件路径对应NSData)</strong>：存放于磁盘中，位于Cache文件夹内，路径为“Cache/图片URL的最后的部分”，值为NSData对象（将UIImage转化为NSData才能写入磁盘里）。作用：程序断网，再次启动也可以直接在磁盘中拿到图片。</p>
<h4 id="2-再看一下解决方案的代码"><a href="#2-再看一下解决方案的代码" class="headerlink" title="2.再看一下解决方案的代码"></a>2.再看一下解决方案的代码</h4><p><strong>2.1图片缓存，下载操作缓存，沙盒缓存路径</strong></p>
<pre><code>/**
 *  存放所有下载完的图片
 */
@property (nonatomic, strong) NSMutableDictionary *images;

/**
 *  存放所有的下载操作（key是url，value是operation对象）
 */
@property (nonatomic, strong) NSMutableDictionary *operations;

/**
 *  拼接Cache文件夹的路径与url最后的部分，合并成唯一约定好的缓存路径
 */
#define CachedImageFile(url) [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:[url lastPathComponent]]
</code></pre><p><strong>2.2 图片下载之前的查询缓存部分</strong>：</p>
<pre><code>    // 先从images缓存中取出图片url对应的UIImage
    UIImage *image = self.images[app.icon];
    if (image) { 

        // 存在：说明图片已经下载成功，并缓存成功）
        cell.imageView.image = image;

    } else { 

         // 不存在：说明图片并未下载成功过，或者成功下载但是在images里缓存失败，需要在沙盒里寻找对于的图片

         // 获得url对于的沙盒缓存路径
        NSString *file = CachedImageFile(app.icon);

        // 先从沙盒中取出图片
        NSData *data = [NSData dataWithContentsOfFile:file];

        if (data) {

            //data不为空，说明沙盒中存在这个文件
            cell.imageView.image = [UIImage imageWithData:data];

        } else {

             // 反之沙盒中不存在这个文件
             // 在下载之前显示占位图片
            cell.imageView.image = [UIImage imageNamed:@&quot;placeholder&quot;];

            // 下载图片
            [self download:app.icon indexPath:indexPath];
        }
    }
</code></pre><p><strong>2.3 图片的下载部分</strong>：</p>
<pre><code>
/**
 *  下载图片
 *
 *  @param imageUrl 图片的url
 */
- (void)download:(NSString *)imageUrl indexPath:(NSIndexPath *)indexPath
{
    // 取出当前图片url对应的下载操作（operation对象）
    NSBlockOperation *operation = self.operations[imageUrl];
    if (operation) return;

    // 创建操作，下载图片
    __weak typeof(self) appsVc = self;
    operation = [NSBlockOperation blockOperationWithBlock:^{
        NSURL *url = [NSURL URLWithString:imageUrl];
        NSData *data = [NSData dataWithContentsOfURL:url]; // 下载
        UIImage *image = [UIImage imageWithData:data]; // NSData -&gt; UIImage

        // 回到主线程
        [[NSOperationQueue mainQueue] addOperationWithBlock:^{

            if (image) {
                // 如果存在图片（下载完成），存放图片到图片缓存字典中
                appsVc.images[imageUrl] = image;

                //将图片存入沙盒中
                //1. 先将图片转化为NSData
                NSData *data = UIImagePNGRepresentation(image);

                //2.  再生成缓存路径            
                [data writeToFile:CachedImageFile(imageUrl) atomically:YES];
            }

            // 从字典中移除下载操作 (保证下载失败后，能重新下载)
            [appsVc.operations removeObjectForKey:imageUrl];

            // 刷新当前表格，减少系统开销
            [appsVc.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationNone];
        }];
    }];

    // 添加下载操作到队列中
    [self.queue addOperation:operation];

    // 将当前下载操作添加到下载操作缓存中 (为了解决重复下载)
    self.operations[imageUrl] = operation;
}
</code></pre><h4 id="3-有哪些点是值得注意的？"><a href="#3-有哪些点是值得注意的？" class="headerlink" title="3. 有哪些点是值得注意的？"></a>3. 有哪些点是值得注意的？</h4><p>要说值得注意的地方，还是离不开对于缓存内容的添加和删除操作。</p>
<p><strong>3.1 关于图片缓存</strong>：<br>很简单，成功下载，拿到了图片，就将图片添加到图片缓存中；下载失败，什么都不做，反正没有图。在这种机制下，就没有删除缓存里某个图片项的情况，因为图片缓存永远不会出现重复添加多个相同图片的情况，缓存中只要有一张对应的图，就直接拿去用了，不会去再下载了。</p>
<p><strong>3.2 关于沙盒缓存</strong>：<br>同样地，对于沙盒缓存也是一个道理：有图就将其转化为NSData，写入磁盘，并对应唯一的路径，没有图就不写。所以即使是要下载相同的图片，因为当前url对应的沙盒路径已经存在文件了，所以直接拿就可以了，不会再下载。</p>
<p>但是！<br>下载操作缓存是不同的！</p>
<p><strong>3.3 关于下载操作缓存</strong><br>我们需要在下载回调完成后，立即将当前的下载操作从下载操作缓存中删去！<br>因为要避免下载失败后，无法再次下载的情况的发生！</p>
<p>为什么呢？<br>注意一下将下载操作加入到下载操作缓存的时机：<br>是在<strong>下载开始的那一刻</strong>而不是<strong>下载成功的那一刻</strong>！</p>
<p>如果在下载开始的那一刻加入到缓存中的话，这个缓存信息就包括两个情况：下载成功和下载失败：</p>
<ul>
<li><p>如果未来下载成功了，那么我们就不会来到判断当前下载操作是否在下载操作缓存这一步，在这之前直接就可以拿图去用了，下载操作是否存在下载操作缓存里并没有什么影响。</p>
</li>
<li><p>但是！如果未来下载失败了，那就肯定不会有对应的图片缓存和沙盒缓存，也就肯定会来到判断当前的下载操作是否在下载操作缓存里这一步。不幸的是，因为没有被删去，它是存在的。存在的话就不做任何其他操作，放任自流，导致曾经下载失败的图片永远不会再次下载。</p>
</li>
</ul>
<p>忘了那段代码了么？回看一下代码（看我多好）：</p>
<pre><code>NSBlockOperation *operation = self.operations[imageUrl];
 if (operation) return;//转身就走，毫不留情
</code></pre><p>因此，无论下载成功或是失败，在图片下载的回调里都要将当前的下载操作从下载操作队列中移走：用来保证如果下载失败了，就可以重新开启对应的下载操作进行下载，逻辑上更加严谨。</p>
<h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4.最后的话"></a>4.最后的话</h1><hr>
<p>异步+缓存这两个机制双剑合璧的话会对程序新能带来很大的改观。这应该app开发进阶的必经之路。</p>
<p>小码哥讲述的这套流程还算比较完整的了，更重要的还是学习其中的思想：</p>
<blockquote>
<ol>
<li><p>将缓存分级：内存缓存，沙盒缓存，下载操作缓存。</p>
</li>
<li><p>而且还要经常使用二分法，将我们的逻辑考虑得滴水不漏。<br>如果我们没有认识到将下载操作添加到下载操作缓存的时机是包含下载成功和下载失败两个情况，那么就不会考虑到即时要将下载操作从下载操作缓存中删去的操作，很容易引起bug。所以在以后的开发中，成功和失败两个情况都要考虑进去，也就是说有if一定要有else！</p>
</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做iOS开发也有半年多了，想想自己对一些第三方库还只是停留在简单运用的阶段，感觉心慌慌的。于是决定用一个月的时间深入了解一些好的第三方库。&lt;/p&gt;
&lt;p&gt;第一个想到了SDWebImage，这个库很不错，几乎每个iOS项目都会有它的影子，因为它很完美地解决了下载图片并显示的处
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>浅显易懂讲解iOS多线程技术-GCD</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%E8%AE%B2%E8%A7%A3%E7%9A%84iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF-GCD/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/浅显易懂讲解的iOS多线程技术-GCD/</id>
    <published>2017-01-13T05:26:33.000Z</published>
    <updated>2017-01-13T05:28:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>励志打造一篇浅显易懂地介绍iOS中GCD的文章！<br>笔者见过很多其他讲解GCD的博客，有些写得非常详细非常专业，几乎涵盖了GCD大大小小的全部知识，细致庞杂的内容容易让人摸不清主次，笔者觉得这类文章<strong>并不适合初学者学习</strong>，于是决定写一篇针对一些只是听过，但是对GCD还不了解的童鞋们。</p>
<p>本文排除了一些细枝末节，扰乱人头绪的东西，着重讲解了GCD中重要的知识点，并在最后展示了GCD中<strong>经常使用的函数</strong>并附上结果图和讲解，简单明了。</p>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><hr>
<p>在了解多线程之前，需要弄清进程和线程的概念和他们之间的区别。</p>
<h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>系统中正在运行的一个程序，进程之间是相互独立的，每个进程都有属于自己的内存空间。比如手机中的<strong>微信</strong>应用和<strong>印象笔记</strong>应用，他们都是iOS系统中独立的进程，有着自己的内存空间。</p>
<h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>进程内部执行任务所需要的执行路径。进程若想执行任务，则必须得在线程下执行。也就是说进程至少有一个线程才能执行任务。但是，我们使用软件的时候，很少有只让它做一件事的时候：</p>
<p>举个<strong>印象笔记</strong>的🌰 ： 当你正在编辑一则笔记的时候点击了同步按钮，那么编辑任务（线程）和同步任务（线程）一定是不能按照顺序执行的。因为同步任务的完成时间是不可控的，如果在同步的过程中无法进行别的任务（线程）那就太糟糕了！</p>
<p>因此，我们需要让一些任务可以同时进行。既然任务是在线程上执行的，那么多任务的执行就意味着需要多线程的开启和使用。</p>
<p>来一张图直观地展示一下内存，进程和线程的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-a1e6c65eda0d3aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存，进程和线程"></p>
<h1 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h1><hr>
<p>多线程的实现原理：虽然在同一时刻，CPU只能处理1条线程，但是CPU可以快速地在多条线程之间调度（切换），造成了多线程并发执行的假象。</p>
<h2 id="1-多线程的优点"><a href="#1-多线程的优点" class="headerlink" title="1. 多线程的优点"></a>1. 多线程的优点</h2><ul>
<li>能适当提高程序的执行效率。</li>
<li>能适当提高资源利用率（CPU、内存利用率）。</li>
</ul>
<h2 id="2-多线程的缺点"><a href="#2-多线程的缺点" class="headerlink" title="2. 多线程的缺点"></a>2. 多线程的缺点</h2><ul>
<li>创建线程是需要成本的：iOS下主要成本包括：在栈空间的子线程512KB、主线程1MB，创建线程大约需要90毫秒的创建时间。</li>
<li>线程越多，CPU在调度线程上的开销就越大。</li>
<li>线程越多，程序设计就越复杂：因为要考虑到线程之间的通信，多线程的数据共享。</li>
</ul>
<h1 id="多线程在iOS开发中的应"><a href="#多线程在iOS开发中的应" class="headerlink" title="多线程在iOS开发中的应"></a>多线程在iOS开发中的应</h1><hr>
<h2 id="1-iOS的主线程"><a href="#1-iOS的主线程" class="headerlink" title="1. iOS的主线程"></a>1. iOS的主线程</h2><p>一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</p>
<h4 id="主线程的作用"><a href="#主线程的作用" class="headerlink" title="主线程的作用:"></a>主线程的作用:</h4><ul>
<li>显示\刷新UI界面</li>
<li>处理UI事件（比如点击事件、滚动事件、拖拽事件等）</li>
</ul>
<blockquote>
<p>主线程的使用<strong>注意事项</strong>:<br>不能把比较耗时的操作放到主线程中，，严重影响UI的流畅度，给用户一种程序“卡顿”的体验。<br>因此，要将耗时的操作放在子线程中异步执行。这样一来，及时开始执行了耗时的操作，也不会影响主线程中UI交互的体验。</p>
</blockquote>
<h2 id="2-iOS的子线程"><a href="#2-iOS的子线程" class="headerlink" title="2. iOS的子线程"></a>2. iOS的子线程</h2><p>子线程是异步执行的，不影响主线程。在iOS开发中，我们需要将耗时的任务（网络请求，复杂的运算）放在子线程进行，不让其影响UI的交互体验。</p>
<h2 id="3-多线程安全"><a href="#3-多线程安全" class="headerlink" title="3. 多线程安全"></a>3. 多线程安全</h2><p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。就好比好几个人在同时修改同一个表格，造成数据的错乱。</p>
<h4 id="3-1-资源抢夺的解决方案"><a href="#3-1-资源抢夺的解决方案" class="headerlink" title="3.1 资源抢夺的解决方案"></a>3.1 资源抢夺的解决方案</h4><p>我们需要给数据添加<strong>互斥锁</strong>。也就是说，当某线程访问一个数据之前就要给数据加锁，让其不被其他的线程所修改。就好比一个人修改表格的时候给表格设置了密码，那么其他人就无法访问文件了。当他修改文件之后，再讲密码撤销，第二个人就可以访问该文件了。</p>
<blockquote>
<p><strong>注意</strong>：<br>这里的线程都为子线程，如果给数据加了锁，就等于将这些异步的子线程变成同步的了，这也叫做线程同步技术。</p>
</blockquote>
<h4 id="3-2-互斥锁使用："><a href="#3-2-互斥锁使用：" class="headerlink" title="3.2 互斥锁使用："></a>3.2 互斥锁使用：</h4><pre><code>@synchronized(锁对象) { // 需要锁定的代码  };
</code></pre><h4 id="3-3-互斥锁的优缺点"><a href="#3-3-互斥锁的优缺点" class="headerlink" title="3.3 互斥锁的优缺点"></a>3.3 互斥锁的优缺点</h4><p>优点：能有效防止因多线程抢夺资源造成的数据安全问题<br>缺点：需要消耗大量的CPU资源</p>
<p>互斥锁的使用前提：多条线程抢夺同一块资源的时候使用。</p>
<h4 id="3-4互斥锁在iOS开发中的使用"><a href="#3-4互斥锁在iOS开发中的使用" class="headerlink" title="3.4互斥锁在iOS开发中的使用"></a>3.4互斥锁在iOS开发中的使用</h4><p>OC在定义属性时有<code>nonatomic</code>和<code>atomic</code>两种选择</p>
<ul>
<li>atomic：原子属性，为setter方法加锁（默认就是atomic）</li>
<li>nonatomic：非原子属性，不会为setter方法加锁</li>
</ul>
<h4 id="3-5-nonatomic和atomic对比"><a href="#3-5-nonatomic和atomic对比" class="headerlink" title="3.5 nonatomic和atomic对比"></a>3.5 nonatomic和atomic对比</h4><p>atomic：线程安全，需要消耗大量的资源<br>nonatomic：非线程安全，适合内存小的移动设备</p>
<blockquote>
<p><strong>建议：</strong><br>所有属性都声明为nonatomic，尽量避免多线程抢夺同一块资源，将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力。</p>
</blockquote>
<h1 id="多线程在iOS中的应用：GCD"><a href="#多线程在iOS中的应用：GCD" class="headerlink" title="多线程在iOS中的应用：GCD"></a>多线程在iOS中的应用：GCD</h1><hr>
<p>GCD，全称为 Grand Central Dispatch ，是iOS用来管理线程的技术。 纯C语言，提供了非常多强大的函数。</p>
<h2 id="1-GCD的优势"><a href="#1-GCD的优势" class="headerlink" title="1. GCD的优势"></a>1. GCD的优势</h2><p>GCD会自动利用更多的CPU内核（比如双核、四核）。<br>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。<br>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码。</p>
<h2 id="2-为什么要用GCD？"><a href="#2-为什么要用GCD？" class="headerlink" title="2. 为什么要用GCD？"></a>2. 为什么要用GCD？</h2><p>为了要提高软件性能，应该异步执行耗时任务(加载图片)，以防止影响主线程任务的执行(UI相应)。</p>
<blockquote>
<p>举个🌰 ：<br>从网络加载一张图片，如果将此任务放到主线程，那么在下载完成的时间里，软件是无法相应用户的任何操作的。特别地，如果当前是在可以滚动的页面，就会造成无法滚动这种体验非常糟的情况。</p>
</blockquote>
<p>所以：应该将网络加载放在异步执行，执行成功后，再回到主线程显示加载后的图片(详细做法马上就会讲到)。</p>
<h2 id="3-GCD的使用步骤"><a href="#3-GCD的使用步骤" class="headerlink" title="3. GCD的使用步骤"></a>3. GCD的使用步骤</h2><ol>
<li>由开发者定制将要执行的任务。</li>
</ol>
<ul>
<li>将任务添加到队列中，GCD会自动将队列中的任务取出，放到对应的线程中执行。</li>
</ul>
<blockquote>
<p><strong>注意：</strong><br>任务的取出遵循队列的FIFO原则：先进先出，后进后出。</p>
</blockquote>
<h2 id="4-什么是队列？"><a href="#4-什么是队列？" class="headerlink" title="4. 什么是队列？"></a>4. 什么是队列？</h2><p>队列是用来存放任务的，由GCD将这些任务从队列中取出并放到相应的线程中执行。</p>
<h3 id="GCD的队列可以分为2大类型："><a href="#GCD的队列可以分为2大类型：" class="headerlink" title="GCD的队列可以分为2大类型："></a>GCD的队列可以分为2大类型：</h3><h4 id="1-并发队列（Concurrent-Dispatch-Queue）"><a href="#1-并发队列（Concurrent-Dispatch-Queue）" class="headerlink" title="1. 并发队列（Concurrent Dispatch Queue）"></a>1. 并发队列（Concurrent Dispatch Queue）</h4><p>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务），并发功能只有在异步（dispatch_async）函数下才有效</p>
<h4 id="2-串行队列（Serial-Dispatch-Queue）"><a href="#2-串行队列（Serial-Dispatch-Queue）" class="headerlink" title="2. 串行队列（Serial Dispatch Queue）"></a>2. 串行队列（Serial Dispatch Queue）</h4><p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）。</p>
<p>那么队列和线程又有什么区别？</p>
<p>简单来说，队列就是用来存放任务的“暂存区”，而线程是执行任务的路径，GCD将这些存在于队列的任务取出来放到相应的线程上去执行，而队列的性质决定了在其中的任务在哪种线程上执行。</p>
<p>下面由一张图来直观地展示任务，队列和线程的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6da601dd550b8390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="任务，队列和线程"></p>
<blockquote>
<p>在这里，我们可以看到，放入串行队列的任务会一个一个地执行。而放入并行队列的任务，会在多个线程并发地执行。</p>
</blockquote>
<h2 id="5-队列的创建"><a href="#5-队列的创建" class="headerlink" title="5. 队列的创建"></a>5. 队列的创建</h2><h3 id="5-1-串行队列的创建："><a href="#5-1-串行队列的创建：" class="headerlink" title="5.1 串行队列的创建："></a>5.1 串行队列的创建：</h3><p>GCD中获得串行有2种途径：</p>
<p>1.使用<code>dispatch_queue_create</code>函数创建串行队列</p>
<pre><code>// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）
dispatch_queue_t queue = dispatch_queue_create(&quot;serial_queue&quot;, NULL);
</code></pre><p>2.使用主队列（跟主线程相关联的队列）</p>
<p>主队列是GCD自带的一种特殊的串行队列：放在主队列中的任务，都会放到主线程中执行。<br>可以使用dispatch_get_main_queue()获得系统提供的主队列：</p>
<pre><code>dispatch_queue_t queue = dispatch_get_main_queue();
</code></pre><h3 id="5-2-并发队列的创建："><a href="#5-2-并发队列的创建：" class="headerlink" title="5.2 并发队列的创建："></a>5.2 并发队列的创建：</h3><p>1.使用<code>dispatch_queue_create</code>函数创建并发队列。</p>
<pre><code>dispatch_queue_t queue = dispatch_queue_create(&quot;concurrent.queue&quot;, DISPATCH_QUEUE_CONCURRENT);
</code></pre><p>2.使用<code>dispatch_get_global_queue</code>获得全局并发队列。</p>
<p>GCD默认已经提供了全局的并发队列，供整个应用使用，可以无需手动创建。</p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
</code></pre><h2 id="6-GCD的几种重要的应用"><a href="#6-GCD的几种重要的应用" class="headerlink" title="6. GCD的几种重要的应用"></a>6. GCD的几种重要的应用</h2><h3 id="6-1-子线程与主线程的通信"><a href="#6-1-子线程与主线程的通信" class="headerlink" title="6.1 子线程与主线程的通信"></a>6.1 子线程与主线程的通信</h3><p>需求点:我们有时需要在子线程处理一个耗时比较长的任务，而且此任务完成后，要在主线程执行另一个任务。<br>例子：从网络加载图片（在子线程），加载完成就更新UIView（在主线程）。</p>
<p>为了实现这个需求，我们需要首先拿到全局并发队列（或自己开启一个子线程）来执行耗时的操作，然后在其完成block中拿到全局串行队列来执行UI刷新的任务。</p>
<pre><code>  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

              //加载图片
              NSData *dataFromURL = [NSData dataWithContentsOfURL:imageURL];
              UIImage *imageFromData = [UIImage imageWithData:dataFromURL];

      dispatch_async(dispatch_get_main_queue(), ^{

              //加载完成更新view
              UIImageView *imageView = [[UIImageView alloc] initWithImage:imageFromData];          
      });      
  });
</code></pre><blockquote>
<p>以笔者的拙见，除了复杂的算法，网络请求以外，大多数<code>dataWithContentsOf。。。</code>函数可能也会比较耗时，所以以后遇到与NSData交互的操作时，尽量将其放在子线程执行。</p>
</blockquote>
<h4 id="6-2-dispatch-once"><a href="#6-2-dispatch-once" class="headerlink" title="6.2 dispatch_once"></a>6.2 dispatch_once</h4><p>需求点：用于在程序启动到终止，只执行一次的代码。此代码被执行后，相当于自身全部被加上了注释，不会再执行了。<br>为了实现这个需求，我们需要使用<code>dispatch_once</code>让代码在运行一次后即刻被“雪藏”。</p>
<pre><code>//使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次

static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    // 只执行1次的代码，这里默认是线程安全的：不会有其他线程可以访问到这里
});
</code></pre><h4 id="6-3-dispatch-group"><a href="#6-3-dispatch-group" class="headerlink" title="6.3 dispatch_group"></a>6.3 dispatch_group</h4><p>需求点：执行多个耗时的异步任务，但是只能等到这些任务都执行完毕后，才能在主线程执行某个任务。<br>为了实现这个需求，我们需要让将这些异步执行的操作放在<code>dispatch_group_async</code>函数中执行，最后再调用<code>dispatch_group_notify</code>来执行最后执行的任务。</p>
<pre><code>  dispatch_group_t group =  dispatch_group_create();
  dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
      // 执行1个耗时的异步操作
  });

  dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
      // 执行1个耗时的异步操作
  });

  dispatch_group_notify(group, dispatch_get_main_queue(), ^{
      // 等前面的异步操作都执行完毕后，回到主线程...
  });
</code></pre><p>让我们看一下示例代码和运行结果：</p>
<p>示例代码：</p>
<p>为了使对比明显，笔者多开了几条线程，这样更容易看清问题。</p>
<pre><code>    dispatch_group_t group =  dispatch_group_create();    
    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // 执行1个耗时的异步操作
        for (NSInteger index = 0; index &lt; 10000; index ++) {
        }
        NSLog(@&quot;完成了任务1&quot;);                
    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // 执行1个耗时的异步操作
        for (NSInteger index = 0; index &lt; 20000; index ++) {
        }
        NSLog(@&quot;完成了任务2&quot;);        
    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // 执行1个耗时的异步操作
        for (NSInteger index = 0; index &lt; 200000; index ++) {
        }
        NSLog(@&quot;完成了任务3&quot;);

    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // 执行1个耗时的异步操作
        for (NSInteger index = 0; index &lt; 400000; index ++) {
        }
        NSLog(@&quot;完成了任务4&quot;);

    });

    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

        // 执行1个耗时的异步操作
        for (NSInteger index = 0; index &lt; 1000000; index ++) {
        }
        NSLog(@&quot;完成了任务5&quot;);

    });

    dispatch_group_notify(group, dispatch_get_main_queue(), ^{

        // 等前面的异步操作都执行完毕后，回到主线程...
        NSLog(@&quot;都完成了&quot;);        
    });
</code></pre><p>运行结果:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-3c8d5886442ce7b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="  dispatch_group 的使用运行结果"></p>
<blockquote>
<p>从三次运行的结果来看:</p>
<ol>
<li><p>异步执行的任务1-5的最终完成时间是与其自身完成任务所需要的时间并无绝对关联。因为任务5是最耗时的，它在第一次运行结果里并不是最后才完成的。任务1是最不耗时的，但是它在第二次运行结果里也不是最先完成的。</p>
</li>
<li><p>异步执行的任务1-5无论完成顺序如何，只有当他们都完成后才会调用主线程的打印“都完成了”。</p>
</li>
</ol>
</blockquote>
<h4 id="6-4-dispatch-barrier"><a href="#6-4-dispatch-barrier" class="headerlink" title="6.4 dispatch_barrier"></a>6.4 dispatch_barrier</h4><p>需求点：虽然我们有时要执行几个不同的异步任务，但是我们还是要将其分成两组：当第一组异步任务都执行完成后才执行第二组的异步任务。这里的组可以包含一个任务，也可以包含多个任务。</p>
<p>为了实现这个需求，我们需要使用<code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code>在两组任务之间形成“栅栏”，使其“下方”的异步任务在其“上方”的异步任务都完成之前是无法执行的。</p>
<pre><code>
    dispatch_queue_t queue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT);

    dispatch_async(queue, ^{
        NSLog(@&quot;----任务 1-----&quot;);
    });

    dispatch_async(queue, ^{
        NSLog(@&quot;----任务 2-----&quot;);
    });    

    dispatch_barrier_async(queue, ^{
        NSLog(@&quot;----barrier-----&quot;);
    });

    dispatch_async(queue, ^{
        NSLog(@&quot;----任务 3-----&quot;);
    });

    dispatch_async(queue, ^{
        NSLog(@&quot;----任务 4-----&quot;);
    });
</code></pre><p>示例代码：</p>
<pre><code>    dispatch_queue_t queue = dispatch_queue_create(&quot;12312312&quot;, DISPATCH_QUEUE_CONCURRENT);

    dispatch_async(queue, ^{

        for (NSInteger index = 0; index &lt; 10000; index ++) {
        }
        NSLog(@&quot;完成了任务1&quot;);

    });

    dispatch_async(queue, ^{

        for (NSInteger index = 0; index &lt; 20000; index ++) {
        }
        NSLog(@&quot;完成了任务2&quot;);

    });

    dispatch_async(queue, ^{

        for (NSInteger index = 0; index &lt; 200000; index ++) {
        }
        NSLog(@&quot;完成了任务3&quot;);

    });


    dispatch_barrier_async(queue, ^{        
        NSLog(@&quot;--------我是分割线--------&quot;);        
    });


    dispatch_async(queue, ^{

        for (NSInteger index = 0; index &lt; 400000; index ++) {
        }
        NSLog(@&quot;完成了任务4&quot;);

    });

    dispatch_async(queue, ^{

        for (NSInteger index = 0; index &lt; 1000000; index ++) {
        }
        NSLog(@&quot;完成了任务5&quot;);

    });

    dispatch_async(queue, ^{

        for (NSInteger index = 0; index &lt; 1000; index ++) {
        }
        NSLog(@&quot;完成了任务6&quot;);

    });
</code></pre><p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-ca923e54d3839b2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_barrier 的使用运行结果"></p>
<blockquote>
<p>从这三次运行结果来看:</p>
<ol>
<li>无论任务1-3内部的执行顺序如何，只有当三者都完成了才会执行任务4-6。</li>
<li>1-3内部的执行顺序和4-6内部的完成顺序都是不可控的，同上一个知识点类似。</li>
</ol>
</blockquote>
<p>本文介绍了需要了解GCD所需的最重要的知识，因为怕打断读者思路，并没有涵盖所有细节。以后有机会会再写一篇深入介绍GCD的文章，查缺补漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;励志打造一篇浅显易懂地介绍iOS中GCD的文章！&lt;br&gt;笔者见过很多其他讲解GCD的博客，有些写得非常详细非常专业，几乎涵盖了GCD大大小小的全部知识，细致庞杂的内容容易让人摸不清主次，笔者觉得这类文章&lt;strong&gt;并不适合初学者学习&lt;/strong&gt;，于是决定写一篇针对
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>远程工作才是实现高效工作和幸福生活的有效途径 - 读《重来2》有感</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C%E6%89%8D%E6%98%AF%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E5%92%8C%E5%B9%B8%E7%A6%8F%E7%94%9F%E6%B4%BB%E7%9A%84%E6%9C%89%E6%95%88%E9%80%94%E5%BE%84%20-%20%E8%AF%BB%E3%80%8A%E9%87%8D%E6%9D%A52%E3%80%8B%E6%9C%89%E6%84%9F/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/远程工作才是实现高效工作和幸福生活的有效途径 - 读《重来2》有感/</id>
    <published>2017-01-13T05:18:16.000Z</published>
    <updated>2017-01-13T05:18:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>朝九晚五，被禁锢在办公室里的工作模式是工业社会的产物。然而，在互联网崛起的今天，这种固定死板的工作模式反而拖累了我们。办公室早已变成了干扰工厂，把你的时间切成七零八碎的小块儿，工作无法顺利、及时地完成，更会造成心理上的疲惫。</p>
<p>如果您也是一名互联网从业者，特别是程序员，问问周围的人：如果你可以自己选择时间地点来完成工作你会选择哪里？你能在哪一时间段或是哪一地点才能高效地完成工作？我想答案<strong>一定不是下午的办公室</strong>。</p>
<p>笔者自己就是一名程序员，上班的时候被会议和同行的打断弄得苦不堪言，虽然有些沟通确是必要的。不过有一点我很清楚，我经常是在早上上班之前或是晚上睡觉之前才能<strong>完完全全，满意地</strong>完成一个模块的开发。在下午的时候，我就会给自己安排做一些难度不高的任务，这样一来，打断所带来的负面影响会很低。</p>
<p>因此笔者非常期望自己可以远程工作，摆脱这种固话的工作和生活方式，因为它能带来的好处真的是太多太多了！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-92f9e8f6e5690223.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远程工作"></p>
<h1 id="远程工作好处多："><a href="#远程工作好处多：" class="headerlink" title="远程工作好处多："></a>远程工作好处多：</h1><hr>
<h2 id="再也不用通勤了"><a href="#再也不用通勤了" class="headerlink" title="再也不用通勤了"></a>再也不用通勤了</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-3c7fb69828e09480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通勤路上"></p>
<p>有的人为了减少通勤时间在自己的公司附近花费了高额租金。。。<br>有的人为了节省开支，住的离公司很远，但却在拥挤的地铁里倍受煎熬。。。<br>有的人虽然有私家车通勤，但是持续性需要支付的燃油费和停车费也是不可避免的。。。</p>
<p>然而，这一切在远程工作的系统里，完全可以避免！</p>
<p>大多数人将人生耗费在通勤路上，导致心情变糟，影响幸福感，更别说浪费的时间了。。<br>节省了两个小时的时间+疲劳，对于工作效率和幸福感的提升是显而易见的。<br>时间节省了，财产变多了，空气更好了(尾气排放)，世界更美好了不是么？^^</p>
<h2 id="员工可以自己规划自己的生活"><a href="#员工可以自己规划自己的生活" class="headerlink" title="员工可以自己规划自己的生活"></a>员工可以自己规划自己的生活</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-5ec1095da5690e2b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="规划生活"></p>
<p>有的员工是早起族，他们每天早早起来但是到了下午缺疲惫不堪。。。<br>有的员工是夜猫子，他们只有在凌晨2-3点的时候才是高效工作时间，因此早起上班让他们苦不堪言。。。<br>有的员工家里有小孩，顾家的他们无法平衡接送自己小孩和上下班的时间表。。。</p>
<p>如果我们启动了远程工作的模式，我们几乎可以满足每个雇员的需求：早起族，夜猫子，每天接送孩子的员工。他们的生活不再受朝九晚五的固定模式所束缚，可以充分规划自己的人生。只要能出色完成任务，员工如何安排自己的生活又有什么关系呢？</p>
<p>而且让自己的生活更加丰富多彩，更有助于迸射出创意的火花，这是一个良性循环，何乐而不为呢？</p>
<h2 id="衡量员工的标准更加本质化"><a href="#衡量员工的标准更加本质化" class="headerlink" title="衡量员工的标准更加本质化"></a>衡量员工的标准更加本质化</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-54b23bd2350977c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只看成果"></p>
<p>有的员工工作不认真，但是运用其圆滑的处事能力和政治素养在公司里平步青云，这种情况并不少见。。。<br>我们更希望那些具有真才实学的人身居高位，为我们指点江山，不过现实总是让人很无奈。</p>
<p>但是！远程工作使得衡量员工的标准更加单一,更加本质化：我们只看<strong>工作成果</strong>，也可以说我们只能看到工作成果。</p>
<p>远程工作模式让我们更加关注员工的工作成果，从中我们可以看到员工的真实水平和成长情况，而不是其他混淆我们视听，登不上台面的东西，一些在将来可能把我们公司送上不归路的东西。</p>
<p>在这里，引用程序员界的一句比较著名的话：</p>
<blockquote>
<p>talk is cheap，show me the code。</p>
</blockquote>
<p>我们也可以说：</p>
<blockquote>
<p>talk is cheap, show me your work!</p>
</blockquote>
<h2 id="将世界各地的人才纳入囊中"><a href="#将世界各地的人才纳入囊中" class="headerlink" title="将世界各地的人才纳入囊中"></a>将世界各地的人才纳入囊中</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-4b84c7490a984b94.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远方的人"></p>
<p>远程工作系统不受地域的限制，可以雇佣分布在各地的最优秀的人才，而且也不会担心员工搬家或者出国居住的情况。<br>人才本来就是不受地域限制的，并不是说顶尖人才就一定在一线城市里，我们要充分利用一切资源找到那些散落在世界各地的人才为我们工作。而且，不论他们居住在哪里，在当地的生活水平如何，我们都要给他们丰厚的薪水和待遇，让他们自己觉得自己即使远在天涯也依然被“组织”重视着。</p>
<h2 id="大家更加珍惜彼此见面的机会"><a href="#大家更加珍惜彼此见面的机会" class="headerlink" title="大家更加珍惜彼此见面的机会"></a>大家更加珍惜彼此见面的机会</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-c572e4100af965ca.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="愉快聚会"></p>
<p>其实就算是执行远程工作模式，还是要挑出一些时间来让团队的人员彼此见面的，<br>在远程工作系统中，见面的稀缺提升了它的价值：大家不会浪费时间，会更加珍惜面对面交流，培养感情的机会。</p>
<h1 id="一些反对远程工作的声音"><a href="#一些反对远程工作的声音" class="headerlink" title="一些反对远程工作的声音"></a>一些反对远程工作的声音</h1><hr>
<h3 id="“我怎么知道他们在干活？”"><a href="#“我怎么知道他们在干活？”" class="headerlink" title="“我怎么知道他们在干活？”"></a>“我怎么知道他们在干活？”</h3><p>如果我们不知道该不该信任这个员工，就说明当初这个招聘决定是错误的，如果某个成员不能取得好结果，或是没法管理好自己的工作日程和工作量，那我们也没必要继续聘用他。要么学会信任你的下属，要么就换人吧。</p>
<h3 id="“家里的干扰比较多”"><a href="#“家里的干扰比较多”" class="headerlink" title="“家里的干扰比较多”"></a>“家里的干扰比较多”</h3><p>我们可以给自己单独一个工作房间，而且你也可以去附近的咖啡厅。<br>像笔者自己有的时候在周末就比较喜欢去咖啡厅，个人觉得在一些稍微有点吵杂又比较干净高雅的场所反而能更加集中注意力。而且在家里可能会觉得比较舒服，反而会提不起精神来，影响工作效率。</p>
<h1 id="远程工作的具体实践"><a href="#远程工作的具体实践" class="headerlink" title="远程工作的具体实践"></a>远程工作的具体实践</h1><hr>
<ol>
<li>最好还是能规划出重叠时间，可以避免信息延迟，也能让大家产生同在一个团队的感觉。</li>
<li>共享日历，让每个成员的时间表透明化，节省了沟通成本。</li>
<li>共享所有的资料，通过搜索来节省沟通成本。</li>
<li>每周一次的展示会来秀你的工作进展：谈谈自己上周做了什么，这周做了什么，下周打算做什么。</li>
<li>对于目前还没有实践远程工作的公司，可以先找几位信得过的员工，看看结果。</li>
<li>在家工作时，最好可以把工作区和休闲区分开。</li>
<li>避免过度疲劳，可以在工作后切换到平板电脑，把紧绷的思维转换一下。</li>
<li>或许可以用上午做一些避开干扰的事情，然后在下午去公司做那些需要更多协作的工作。</li>
</ol>
<h1 id="远程工具箱"><a href="#远程工具箱" class="headerlink" title="远程工具箱"></a>远程工具箱</h1><hr>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-bd5885fa7b4658ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远程工具箱"></p>
<ol>
<li>WebEx:共享屏幕，给异地的某人做产品介绍。</li>
<li>Google Hangouts : 视频会议，可以通过电脑上或手机上的摄像头进行视频通话。</li>
<li>Dropbox:公司文档的存放处，支持多平带，只要可以连上网络就能在世界各处访问公司的资料。</li>
<li>Google Docs:实时共享文档。</li>
</ol>
<h1 id="远程工作的副作用"><a href="#远程工作的副作用" class="headerlink" title="远程工作的副作用"></a>远程工作的副作用</h1><hr>
<h2 id="不要过多延长了工作时间"><a href="#不要过多延长了工作时间" class="headerlink" title="不要过多延长了工作时间"></a>不要过多延长了工作时间</h2><p>我们需要担心的是，如果将一个工作狂放在家里工作，可能导致他干的太多了，造成过度疲劳。<br>解决办法：在规定的工作后，问问自己今天有没有好好工作？如果回答是，就可以停止了。如果不是，问自己五个为什么，找出问题的根源。</p>
<h2 id="换个环境"><a href="#换个环境" class="headerlink" title="换个环境"></a>换个环境</h2><p>就算是远程工作，也尽量不要憋在家里，去咖啡厅或者公园也是蛮不错的选择。</p>
<h2 id="注意健康"><a href="#注意健康" class="headerlink" title="注意健康"></a>注意健康</h2><p>有些人如果可以让他持续坐在电脑前就很难让他离开了（包括我），要注意多运动，特别要使用优良的工作设备：例如人体工学椅。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr>
<p>我们可以看到，远程工作所能带来的好处太多了：节省通勤的时间和金钱，更好规划员工自己的生活，更加正确地衡量员工的能力和工作态度。。而这些优势，能够吸引更多世界各地的人才，让一群优秀的团队成员合作，是取得巅峰绩效的关键。</p>
<p>随着时间的推移，大家彼此越来越熟悉，相处的越来越融洽，自然而然地，工作质量就会变得很高。在人生的幸福来源中，和卓越的人共事，做出卓越的业绩正式其中之一。</p>
<p>要激发出员工的动力，唯一靠得住的办法就是鼓励他们从事自己喜欢的，在乎的事情，而且跟他们喜欢的，在乎的人一起做事，此外没有捷径可走。</p>
<p>你还在等什么？如果你是雇主，何不启动远程工作系统试试看？如果你是雇员，何不向自己的雇主建议一下呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;朝九晚五，被禁锢在办公室里的工作模式是工业社会的产物。然而，在互联网崛起的今天，这种固定死板的工作模式反而拖累了我们。办公室早已变成了干扰工厂，把你的时间切成七零八碎的小块儿，工作无法顺利、及时地完成，更会造成心理上的疲惫。&lt;/p&gt;
&lt;p&gt;如果您也是一名互联网从业者，特别是
    
    </summary>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="IT" scheme="https://github.com/knightsj/knightsj.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>浅谈互联网商业思维的几个误区 - 读《重来》有感</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E6%B5%85%E8%B0%88%E4%BA%92%E8%81%94%E7%BD%91%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E7%9A%84%E5%87%A0%E4%B8%AA%E8%AF%AF%E5%8C%BA%20-%20%E8%AF%BB%E3%80%8A%E9%87%8D%E6%9D%A5%E3%80%8B%E6%9C%89%E6%84%9F/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/浅谈互联网商业思维的几个误区 - 读《重来》有感/</id>
    <published>2017-01-13T05:12:57.000Z</published>
    <updated>2017-01-13T05:14:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近读了一些关于互联网思维和管理的一些书籍，感触颇深，想从团队，产品，公司方向和个人几个方面，结合笔者的个人经历分享一下笔者的思考和感悟。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-063cce725ad58f38.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：www.pexels.com"></p>
<hr>
<h1 id="关于团队"><a href="#关于团队" class="headerlink" title="关于团队"></a>关于团队</h1><h3 id="“鸡尾酒会”并不是一个好的氛围"><a href="#“鸡尾酒会”并不是一个好的氛围" class="headerlink" title="“鸡尾酒会”并不是一个好的氛围"></a>“鸡尾酒会”并不是一个好的氛围</h3><p>鸡尾酒会就是关系并不熟的人的聚会，人们都把自己与他们拉开一段距离，秉承着“你好我好大家好，井水不犯河水”的原则，互不侵犯，生怕说错话，想赶紧结束走人。</p>
<p>很显然，这种工作氛围是及其危险的，因为没人敢说实话。笔者个人非常不喜欢这种工作氛围。</p>
<p>笔者在韩国留学的时候，研究室里就是这种氛围，韩国人的等级制度很严重：后辈，也就是相对比较晚加入的年轻人是不能对前辈的行为有任何指点，更不用说批评了。笔者对这种畸形的文化已经厌恶至极，因此毅然决然，毕业后回到了祖国发展。</p>
<p>我们应该营造一个敢说任何胡但是还非常有安全感的环境，这样一来，公司的各种问题都会立即被大家知晓，然后找出解决办法，立马执行！</p>
<h3 id="市场营销并不是一个独立的部门"><a href="#市场营销并不是一个独立的部门" class="headerlink" title="市场营销并不是一个独立的部门"></a>市场营销并不是一个独立的部门</h3><p>笔者所在的公司，技术人员和用户几乎是无交流的，但是如果让技术人员亲自去和反馈问题的用户沟通，那么用户应该会满意很多，因为至少他们所得到的服务是相对更专业的。像这种技术人员与用户直接交流的行为就是市场营销。</p>
<p>因此，无论是技术人员也好，产品人员也好，都要积极与用户沟通交流，积极参与各种“类营销”活动，因为我们每个人都可以作为营销的一员，为公司带来好的影响。</p>
<hr>
<h1 id="关于产品"><a href="#关于产品" class="headerlink" title="关于产品"></a>关于产品</h1><h3 id="不应该为了迎合投资人，个别用户来改变产品的核心"><a href="#不应该为了迎合投资人，个别用户来改变产品的核心" class="headerlink" title="不应该为了迎合投资人，个别用户来改变产品的核心"></a>不应该为了迎合投资人，个别用户来改变产品的核心</h3><p>有很多初创公司听从了投资人的要求或者个别用户的抱怨就改变了产品的初衷，做出了一个连自己都不喜欢的产品。后来，那个提出怪异要求的投资人拿着钱走了，那个抱怨的客户不在使用产品了，公司就只剩下一个面目全非毫无个性的产品，这无疑是让人心痛的。</p>
<p>想要创造一个伟大的产品或某项卓越的服务，最简单的办法就是做你自己想用的东西。<br>这个东西有一个核心，它在你的创业等式中是无法被拿掉的。无论投资人，客户，还是个别用户想要撼动他都无济于事，因为这是你自己的产品，你爱你自己的产品，你要去捍卫它，不断地去完善它。这才是事业成功的根本。</p>
<h3 id="不要为了增加功能拖延上线的时间"><a href="#不要为了增加功能拖延上线的时间" class="headerlink" title="不要为了增加功能拖延上线的时间"></a>不要为了增加功能拖延上线的时间</h3><p>有些时候，产品那边一直想要增加需求，甚至是在测试阶段。这是一种非常不明智的做法。</p>
<p>在产品形成初期，产品迭代的节奏和速度是最重要的，与其把某一项功能做的成熟，不如赶紧做好最基本的功能放到市场，这样才有利于把握市场方向，把选择权交给市场而不是在公司里面瞎猜。</p>
<h3 id="不要只关注主打产品，找到副产品给公司带来额外收益"><a href="#不要只关注主打产品，找到副产品给公司带来额外收益" class="headerlink" title="不要只关注主打产品，找到副产品给公司带来额外收益"></a>不要只关注主打产品，找到副产品给公司带来额外收益</h3><p>在不耽误主打产品研发的前提下，可以挖据公司的副产品，虽然收效可能不高，但对于提高公司的影响力和亲和力是由积极影响的。</p>
<p>开个博客，分享有意义的知识；写书，来记录公司的信条；拍个纪录片，来记录公司的成长都是不错的选择。</p>
<hr>
<h1 id="关于方向"><a href="#关于方向" class="headerlink" title="关于方向"></a>关于方向</h1><h3 id="“发展成为大公司”并不一定是一个好的目标"><a href="#“发展成为大公司”并不一定是一个好的目标" class="headerlink" title="“发展成为大公司”并不一定是一个好的目标"></a>“发展成为大公司”并不一定是一个好的目标</h3><p>很多小公司都有想变壮大，而很多大公司却梦想变得更敏捷，更灵活。<br>但是可悲的是，一旦公司做大了，要想再缩小，就在所难免要进行裁员，那么后果就是打击士气，影响工作氛围，这往往是致命的。所以我个人认为，公司不必做得很大，因为这样会导致信息流通效率变低，而团队信息流通效率是团队执行效率的根本。</p>
<p>有一个高效敏捷的小团队胜过低效笨重的大团队，因为它能够对变化迅速做出反应，而且每次的决策都可以迅速下达和执行，这是我们希望看到的。</p>
<h3 id="不应该让对手的方向影响你的方向"><a href="#不应该让对手的方向影响你的方向" class="headerlink" title="不应该让对手的方向影响你的方向"></a>不应该让对手的方向影响你的方向</h3><p>把目光放在自己身上，而不是对手身上。如果你把时间浪费在关注他人身上时，头脑里只会充斥着别人的想法，然后将自己的想法冲淡，更别提自我提高了。</p>
<p>如果你还要制造一个类ipod的产品，注定是失败的。因为游戏规则是他们定下的，而你是无法打败游戏规则制定者的。</p>
<p>走别人走过的路成不了大气候的，不要去挑战规则的制定者，要走出一条自己的路。而不是把别人修好的路在旁边种一排树，这无非是给他人做嫁衣。机智一点，勇敢一点去修一条自己独有的路吧。</p>
<h3 id="不要依赖计划"><a href="#不要依赖计划" class="headerlink" title="不要依赖计划"></a>不要依赖计划</h3><p>最危险的莫过于“不知道自己不知道了”，定制计划时，有很多因素是我们无法预料到的，因为产品投入市场后，有太多的不确定因素，而这些不确定因素恰恰有可能对计划产生不可估量的影响。所以还是加快节奏，尽快把产品投放到市场。</p>
<h3 id="不要自恃清高，应该时刻想着如何盈利"><a href="#不要自恃清高，应该时刻想着如何盈利" class="headerlink" title="不要自恃清高，应该时刻想着如何盈利"></a>不要自恃清高，应该时刻想着如何盈利</h3><p>不要依赖投资人的钱，要从一开始就时时刻刻想着如何给公司带来收益，因为就算你想亏待自己，你也不能亏待你的员工。而且，如果过分依赖别人的钱，那还谈什么坚持走自己的路，开创自己的事业呢？</p>
<hr>
<h1 id="关于个人"><a href="#关于个人" class="headerlink" title="关于个人"></a>关于个人</h1><h3 id="“工作狂”并不是一个好的定位"><a href="#“工作狂”并不是一个好的定位" class="headerlink" title="“工作狂”并不是一个好的定位"></a>“工作狂”并不是一个好的定位</h3><p>我们经常会看到公司中有一些人自诩为“工作狂”，每天加班到很晚，但是工作成果平平，而且精神状态萎靡不振。其实这些人大多是通过增加时间的方式来去完成一些事实上比较次要的任务或者细节，或是不去思考完成任务的正确方法，低效率工作。</p>
<p>其实我们应该明智地去工作，不应靠蛮力来弥补思维上的惰性，应该准确判断任务的主次，想出最高效的方法解决掉它。</p>
<p>前一阵子，笔者独立负责公司的一个项目，压力很大，但是怕刚不上工期，便一味地延长工作时间:加班+回家再搞到1点。虽然产品及时上线，但是回想一下好多工作都返工了，因为当时并没有做好决策，选择最好的解决办法。</p>
<p>不过当我认识到了问题的严重性后，刻意逼迫自己回家只做自己的事情。在工作时，处理每个任务之前仔细推敲逻辑，找出最合理的办法。虽然工作的节奏慢了一点(因为不是一味地蛮干)，但是功能做出来之后bug极少，几乎没有重写或者优化的部分。而且最重要的是，我每天回家都有自己的时间去给自己充电。现在回想一下当时的我还是蛮心疼的，明明可以换一种更加轻松高效方式去生活，何必把自己搞得那么累呢?</p>
<h3 id="单纯地罗列问题并不能解决问题"><a href="#单纯地罗列问题并不能解决问题" class="headerlink" title="单纯地罗列问题并不能解决问题"></a>单纯地罗列问题并不能解决问题</h3><p>很多人在使用任务清单，但是大多数只是把他们列到那里，做完了去打个勾。但是，虽然这可以起到提醒的作用，但还是不够完善，为什么呢？<br>罗列一个to-do清单并不是在部署任务，而更多地像是给大脑一个缓存而已。</p>
<p>任务是要被执行的，而执行就需要执行的时间。因此，给每一条干巴巴的项目条加上优先级并且附上执行时间和期限才是比较现实的做法。千万别列了好长的清单然后勾了几个无足轻重的任务后才发现还有一根硬骨头躺在上面等你解决。</p>
<h3 id="高端设备和工具并不是初学者应该用的"><a href="#高端设备和工具并不是初学者应该用的" class="headerlink" title="高端设备和工具并不是初学者应该用的"></a>高端设备和工具并不是初学者应该用的</h3><p>人们都喜欢高端设备，认为“好的装备”才是取胜的法宝。所以我们会经常会看到一些初学者去使用花哨的插件(为了节省编程时间)，使用一些看似能提高效率的工具。一些初创公司置办豪华的家具，给员工提供非常舒适的办公环境。但是，初学者们应该从零做起，先打好基础，而公司应该关注的是怎样赢得客户，如何盈利。</p>
<p>笔者自己几个月前非常想用机械键盘，因为觉得这是一个程序员应该用的工具。但是后来想想，如果无法准确把正在使用的编程语言的各种语句和字符打出来，而且光标也得多数靠鼠标来移动的话，即使是用机械键盘，效率也不会提高很多。所以笔者决定等自己完全熟练语法以及可以完全脱离鼠标之后再使用机械键盘。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近读了一些关于互联网思维和管理的一些书籍，感触颇深，想从团队，产品，公司方向和个人几个方面，结合笔者的个人经历分享一下笔者的思考和感悟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/8590
    
    </summary>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="IT" scheme="https://github.com/knightsj/knightsj.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AEUI/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI/</id>
    <published>2017-01-11T07:30:42.000Z</published>
    <updated>2017-01-11T08:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是斯坦福大学iOS7系列课程（CS193P）的最后一节课的总结，终于把18节课的内容都总结完了，而且这个文集也画上了句号，有点不舍的赶脚。。</p>
<p>好了，不煽情了，开始！</p>
<h1 id="国际化-Internationalization"><a href="#国际化-Internationalization" class="headerlink" title="国际化 Internationalization"></a>国际化 Internationalization</h1><hr>
<p>如果我们想要将app推广到国际市场，那么就免不了将我们的app翻译成其他国家的语言以便于当地人去使用。</p>
<p>而翻译的内容主要集中于“非内容”部分：例如标题类文字，按钮上的文字，提示框的文字等等。</p>
<p>所谓“翻译”app的过程主要分为<strong>国际化</strong>和<strong>本地化</strong>两个步骤：</p>
<ol>
<li>国际化：是让app能够本地化的过程。</li>
<li>本地化：将程序翻译另外一种语言。<ul>
<li>故事版字符串的本地化：改变故事版中出现的字符串。</li>
<li>类文件字符串的本地化：改变文件中出现的字符串，包括字符串面量和非字符串面量。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>好的UI设计：给用户呈现出的内容大多数都需要显示的（内容），而不是自己添加的（提示）。这样一来，也会减少我们本地化的工作量。</li>
<li>所有的地方都要设置好自动布局，否则本地化将无从谈起，因为将文字翻译成其他语言后，长度很可能是不一样的。</li>
</ol>
</blockquote>
<p>下面来来具体看一下本地化的方法，分为<strong>故事版中字符串</strong>的本地化和<strong>类文件中字符串</strong>的本地化。</p>
<h2 id="1-故事版中的本地化"><a href="#1-故事版中的本地化" class="headerlink" title="1. 故事版中的本地化"></a>1. 故事版中的本地化</h2><p>在故事版中本地化的过程是：</p>
<ol>
<li>在项目里添加其他语言。</li>
<li>在被添加语言的故事版文件中找到相应的.string文件，加以更改。</li>
</ol>
<p>具体过程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-917657136741d815.gif?imageMogr2/auto-orient/strip" alt="故事版的本地化.gif"></p>
<h2 id="2-类文件中字符串的本地化"><a href="#2-类文件中字符串的本地化" class="headerlink" title="2. 类文件中字符串的本地化"></a>2. 类文件中字符串的本地化</h2><p>除了需要本地化故事版中的字符串，类文件中的字符串也需要本地化，因为故事版并不能显示所有需要翻译的字符串。</p>
<p>而且，类文件中的字符串分为两种形式：</p>
<ol>
<li>字符串面量。</li>
<li>非字符串面量。</li>
</ol>
<p>字符串面量:</p>
<p><code>NSString *myName = @“Jack”;</code></p>
<p>类似这样的字符串是比较好找的，只需要搜索<code>@</code>即可很容易找到。<br>但是，我们仍然会通过该方法搜索到不应该本地化的字符串：<br>也就是不出现在UI中的字符串面量。</p>
<p>例如：</p>
<ul>
<li>文件扩展名</li>
<li>segure的identifier</li>
<li>stiringWithFormat:</li>
</ul>
<h4 id="2-1字符串面量的本地化步骤："><a href="#2-1字符串面量的本地化步骤：" class="headerlink" title="2.1字符串面量的本地化步骤："></a>2.1字符串面量的本地化步骤：</h4><ol>
<li>找到需要本地化的字符串面量。</li>
<li>通过宏，将字符串面量添加到表中。</li>
<li>创建表的.string文件。</li>
<li>本地化.string文件</li>
</ol>
<p>﻿<br>1.找到 <code>@&quot;Sorry, this device cannot add a photo.&quot;</code> 字符串面量。</p>
<pre><code>- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];
    if (![[self class] canAddPhoto]) {
        [self fatalAlert:@&quot;Sorry, this device cannot add a photo.&quot;]; //
    } else {
        [self.locationManager startUpdatingLocation];
    }
}
</code></pre><p>2.通过宏，将字符串面量添加到表中。</p>
<pre><code> - (void)viewDidAppear:(BOOL)animated
 {
    [super viewDidAppear: animated];

    if (![[self class] canAddPhoto]) {
        [self fatalAlert:ALERT_CANT_ADD_PHOTO]; // @&quot;Sorry, this device cannot add a photo.&quot;
    } else {
        [self.locationManager startUpdatingLocation];
    }
 }
</code></pre><pre><code>#define ALERT_CANT_ADD_PHOTO NSLocalizedStringFromTable(@&quot;ALERT_CANT_ADD_PHOTO&quot;, @&quot;AddPhotoViewController&quot;, @&quot;Alert message delivered when there is something that prevents the user from adding a new photo to the database that the user can do nothing about.&quot;)
</code></pre><p>3.创建表的.string文件</p>
<p>我们已经在AddPhotoViewController.m文件里将需要本地化的字符串添加到了叫做AddPhotoViewController的表里，下面就需要用命令行工具找到该.m文件：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-a043fa2da855615c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="找到.m文件所在目录"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b3adf539663b1269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入genstrigns ^*m命令"></p>
<p>4.本地化.string文件</p>
<p>在第三步中，我们需要手动创建<code>AddPhotoViewController</code>表的.string文件，然后在文件内部将对应的key进行翻译。因为过程略繁琐，所以以动图的形式呈献给大家：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-100dfbddbe7399bb.gif?imageMogr2/auto-orient/strip" alt="本地化string.gif"></p>
<blockquote>
<p>失误了，右侧的字符串应该是没有“@”的，大家注意。因为到最后才发现的，不好改了 额。。 理解万岁。。</p>
</blockquote>
<h2 id="2-2-非字面量字符串的本地化："><a href="#2-2-非字面量字符串的本地化：" class="headerlink" title="2.2 非字面量字符串的本地化："></a>2.2 非字面量字符串的本地化：</h2><p>在类文件里，有些显示出来的字符串并不都是通过字符串面量赋值的，比如下面这个例子：</p>
<p><code>self.title = newfrc.fetchRequest.entity.name;</code></p>
<p>在这里，title取的是模型里的字段，并没有用字面量语法来表示。<br>对于这种情况，我们需要用NSBundle的<code>localizedStringForKey:value:table:</code>方法来进行本地化。</p>
<pre><code>self.title = [[NSBundle mainBundle] localizedStringForKey:newfrc.fetchRequest.entity.name
                         value:newfrc.fetchRequest.entity.name     
                         table:@&quot;Entities&quot;];
</code></pre><p>这样一来，我们就生成了对应名字叫<strong>Entities</strong>的表的映射。但是这张表对应的.string文件还没有生成，需要我们手动去生成，并设置对应的key和value。生成方法如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-965d85e9b008d0c8.gif?imageMogr2/auto-orient/strip" alt="手动生成.string文件"></p>
<h1 id="设置页的UI"><a href="#设置页的UI" class="headerlink" title="设置页的UI"></a>设置页的UI</h1><hr>
<p>在苹果系统的设置里，会有我们装入的app的信息和设置。有时，我们需要将一些设置选项放在这里面供用户使用。</p>
<p>而这里的UI是通过通过Settings bundle来设定的。我们首先要新建一个Settings Bundle:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d49a21d343306156.gif?imageMogr2/auto-orient/strip" alt="创建Settings Bundle"></p>
<p>创建成功后，分别有一个slider，switch，和textfield来对应设置页里的UI。</p>
<p>在设置页里的样子是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6dc1b24f8d070871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建的Settings Bundle 后的设置页效果"></p>
<p>那么如何使用呢？我们设置一下上一节课的Bouncer Demo的弹性系数：让用户通过调节设置里的slider来调整app里的弹性系数。</p>
<pre><code>- (void)resetElasticity
{
    //连接代码与Setting Bundle
    NSNumber *elasticity = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;Setting_Elasticity&quot;];//连接setting bundle
    if (elasticity) {
        //如果有，就取当前设定的
        self.elastic.elasticity = [elasticity floatValue];
    } else {
        //如果没有，就设置为1
        self.elastic.elasticity = 1.0;
    }
}
</code></pre><p>在这里，通过<code>valueForKey</code>的键值对应了Setting Bundle plist 文件里的<code>identifier</code>，我们将plist文件里的<code>identifier</code>修改成了<code>Setting_Elasticity</code>而且更改了<code>Title</code>，而且将按钮和文本框删除掉，只保留了slider：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f195429739d8262b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Setting Bundle plist"></p>
<p>所对应的设置页的UI：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-1d15dcab18d5df94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新的设置页UI"></p>
<p>现在我们可以通过identifier连接了代码和plist文件，获取到了键对应的值。</p>
<p>而且，我们还需考虑在程序运行过程中，用户跳转到了设置页面来设置弹性系数的情况。因此，我们需要监听用户是否更改了设置里的选项：</p>
<p>监听用户在设置中的行为：</p>
<pre><code>    [[NSNotificationCenter defaultCenter] addObserverForName:NSUserDefaultsDidChangeNotification
                                                      object:nil
                                                       queue:nil
                                                  usingBlock:^(NSNotification *note) {
                                                      [self resetElasticity];
                                                  }];
</code></pre><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>当~当~当~当~！<br>笔者终于利用了2个月的部分业余时间总结了所有斯坦福iOS7的课程和相关Demo。通过以博客的形式总结，更加加深了对知识的理解和认识，也对基础知识进行了一次查缺补漏，或许也在一定程度上给其他看到这些博客的同仁们一些帮助吧~</p>
<p>最后附上这一系列笔者总结的所有Demo在GitHub上的地址：<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">Stanford_iOS_Lecture_DemoBundle</a>。</p>
<p>笔者下一阶段应该是总结下面两本书的内容：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0eeac0652f909c84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Effective Objective- C 2.0"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c1046257878a01d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Swift 基础教程"></p>
<p>这两本书笔者都已经看了3分之一，因为要总结归纳，所以应该进度不是很快，不过还是会坚持写博客的！</p>
<p>加油~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是斯坦福大学iOS7系列课程（CS193P）的最后一节课的总结，终于把18节课的内容都总结完了，而且这个文集也画上了句号，有点不舍的赶脚。。&lt;/p&gt;
&lt;p&gt;好了，不煽情了，开始！&lt;/p&gt;
&lt;h1 id=&quot;国际化-Internationalization&quot;&gt;&lt;a href
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十七）：CoreMotion，app的生命周期，方块碰撞游戏Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%B8%83%EF%BC%89%EF%BC%9ACoreMotion%EF%BC%8Capp%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%8C%E6%96%B9%E5%9D%97%E7%A2%B0%E6%92%9E%E6%B8%B8%E6%88%8FDemo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十七）：CoreMotion，app的生命周期，方块碰撞游戏Demo/</id>
    <published>2017-01-11T07:30:02.000Z</published>
    <updated>2017-01-11T08:50:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲解了Core Motion框架的知识，简单介绍了app的生命周期，最后用一个方块碰撞游戏来对本节课的知识作总结。</p>
<h1 id="Core-Motion"><a href="#Core-Motion" class="headerlink" title="Core Motion"></a>Core Motion</h1><hr>
<p>CoreMotion是一个专门处理设备“动作”的框架，其中包含了加速度计，陀螺仪和磁力针。加速计由三个坐标轴决定，用户最常见的操作设备的动作移动，晃动手机(摇一摇)，倾斜手机都可以被设备检测到，加速计可以检测到线性的变化。陀螺仪可以更好的检测到偏转的动作，可以根据用户的动作做出相应的动作；磁力针可以判断设备的方向。</p>
<p>CoreMotion的工作是基于<code>CMMotionManager</code>类来执行的。我们看一下该类的API：</p>
<h2 id="CMMotionManager"><a href="#CMMotionManager" class="headerlink" title="CMMotionManager"></a>CMMotionManager</h2><h3 id="检测硬件设备："><a href="#检测硬件设备：" class="headerlink" title="检测硬件设备："></a>检测硬件设备：</h3><pre><code>@property(readonly, nonatomic, getter=isAccelerometerAvailable) BOOL accelerometerAvailable __TVOS_PROHIBITED;
@property(readonly, nonatomic, getter=isGyroAvailable) BOOL gyroAvailable __TVOS_PROHIBITED;
@property(readonly, nonatomic, getter=isMagnetometerAvailable) BOOL magnetometerAvailable NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;
@property(readonly, nonatomic, getter=isDeviceMotionAvailable) BOOL deviceMotionAvailable __TVOS_PROHIBITED;
</code></pre><h3 id="开启相应的模块："><a href="#开启相应的模块：" class="headerlink" title="开启相应的模块："></a>开启相应的模块：</h3><pre><code>- (void)startAccelerometerUpdates __TVOS_PROHIBITED;
- (void)startGyroUpdates __TVOS_PROHIBITED;
- (void)startMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;
- (void)startDeviceMotionUpdates __TVOS_PROHIBITED;
</code></pre><h3 id="检测相应的模块是否正在收集数据："><a href="#检测相应的模块是否正在收集数据：" class="headerlink" title="检测相应的模块是否正在收集数据："></a>检测相应的模块是否正在收集数据：</h3><pre><code>@property(readonly, nonatomic, getter=isAccelerometerActive) BOOL accelerometerActive __TVOS_PROHIBITED;
@property(readonly, nonatomic, getter=isGyroActive) BOOL gyroActive __TVOS_PROHIBITED;
@property(readonly, nonatomic, getter=isMagnetometerActive) BOOL magnetometerActive NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;
@property(readonly, nonatomic, getter=isDeviceMotionActive) BOOL deviceMotionActive __TVOS_PROHIBITED;
</code></pre><h3 id="关闭相应的模块："><a href="#关闭相应的模块：" class="headerlink" title="关闭相应的模块："></a>关闭相应的模块：</h3><pre><code>- (void)stopAccelerometerUpdates __TVOS_PROHIBITED;
- (void)stopGyroUpdates __TVOS_PROHIBITED;
- (void)stopMagnetometerUpdates NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;
- (void)stopDeviceMotionUpdates __TVOS_PROHIBITED;
</code></pre><h3 id="使用block监听"><a href="#使用block监听" class="headerlink" title="使用block监听"></a>使用block监听</h3><pre><code>- (void)startAccelerometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMAccelerometerHandler)handler __TVOS_PROHIBITED;
- (void)startGyroUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMGyroHandler)handler __TVOS_PROHIBITED;
- (void)startMagnetometerUpdatesToQueue:(NSOperationQueue *)queue withHandler:(CMMagnetometerHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;
- (void)startDeviceMotionUpdatesUsingReferenceFrame:(CMAttitudeReferenceFrame)referenceFrame toQueue:(NSOperationQueue *)queue withHandler:(CMDeviceMotionHandler)handler NS_AVAILABLE(NA,5_0) __TVOS_PROHIBITED;
</code></pre><h3 id="CMMotionManager的工作步骤"><a href="#CMMotionManager的工作步骤" class="headerlink" title="CMMotionManager的工作步骤"></a>CMMotionManager的工作步骤</h3><ol>
<li>首先初始化<code>CMMotionManager</code>类。</li>
<li>判断硬件设备的可使用性。</li>
<li>调用API<br>详细的使用方法请看Demo部分的讲解部分。</li>
</ol>
<h1 id="app的生命周期"><a href="#app的生命周期" class="headerlink" title="app的生命周期"></a>app的生命周期</h1><hr>
<p>程序在运行过程中，是由各种不同的状态的，在这些状态之间切换时可以执行一些代码用于满足一定的业务需求。</p>
<h2 id="应用程序的几种状态："><a href="#应用程序的几种状态：" class="headerlink" title="应用程序的几种状态："></a>应用程序的几种状态：</h2><ul>
<li>Not running:未运行  程序没启动</li>
<li>Inactive:未激活, 程序在前台运行，不过没有接收到事件。在没有事件处理情况下程序通常停留在这个状态。</li>
<li>Active:激活,  程序在前台运行而且接收到了事件。这是程序在前台运行的正常状态。</li>
<li>Backgroud:后台, 程序在后台而且能执行代码。大多数程序进入这个状态后会在在这个状态上停留一会， 时间到之后会进入挂起状态(Suspended)。</li>
<li>Suspended:挂起 ,程序在后台不能执行代码。系统会自动把程序变成这个状态而且不会发出通知。当挂起时，程序还是停留在内存中的，当系统内存低时，系统就把挂起的程序清除掉，为当前处于前台程序提供更多的内存。</li>
</ul>
<h2 id="应用程序的状态之间切换时调用的代理方法（AppDelegate）："><a href="#应用程序的状态之间切换时调用的代理方法（AppDelegate）：" class="headerlink" title="应用程序的状态之间切换时调用的代理方法（AppDelegate）："></a>应用程序的状态之间切换时调用的代理方法（AppDelegate）：</h2><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions   //启动基本完成，程序准备开始运行时调用。
- (void)applicationWillResignActive:(UIApplication *)application          //当应用程序将要入非活动状态执行。在此期间，应用程序不接收消息或事件，比如来电话时。
- (void)applicationDidBecomeActive:(UIApplication *)application           //当应用程序入活动状态执行。
- (void)applicationDidEnterBackground:(UIApplication *)application        //当程序被推到后台的时候调用。
- (void)applicationWillEnterForeground:(UIApplication *)application       //当程序从后台将要重新回到前台时候调用。
- (void)applicationWillTerminate:(UIApplication *)application             // 当程序将要退出时调用，通常是用来保存数据和一些退出前的清理工作。
</code></pre><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求:"></a>Demo需求:</h2><ul>
<li>显示两个小方块，一黑一红，二者可以随着屏幕的转动而移动。</li>
<li>由红色方块碰撞黑色方块来得分。</li>
</ul>
<h2 id="Demo效果图："><a href="#Demo效果图：" class="headerlink" title="Demo效果图："></a>Demo效果图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-baa2c6607140ad2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：游戏进行中 | 右：游戏暂停"></p>
<h2 id="重要知识点和代码段："><a href="#重要知识点和代码段：" class="headerlink" title="重要知识点和代码段："></a>重要知识点和代码段：</h2><h4 id="1-添加animator和重力行为和碰撞行为"><a href="#1-添加animator和重力行为和碰撞行为" class="headerlink" title="1. 添加animator和重力行为和碰撞行为"></a>1. 添加animator和重力行为和碰撞行为</h4><pre><code>- (UIDynamicAnimator *)animator
{
    if (!_animator) _animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.view];
    return _animator;
}
- (UICollisionBehavior *)collider
{
    if (!_collider) {
        UICollisionBehavior *collider = [[UICollisionBehavior alloc] init];
        collider.translatesReferenceBoundsIntoBoundary = YES;
        [self.animator addBehavior:collider];
        self.collider = collider;
    }
    return _collider;
}
- (UIGravityBehavior *)gravity
{
    if (!_gravity) {
        UIGravityBehavior *gravity = [[UIGravityBehavior alloc] init];
        [self.animator addBehavior:gravity];
        self.gravity = gravity;
    }
    return _gravity;
}
</code></pre><blockquote>
<p>老规矩，还是要将animtor添加到view里面再向其添加各种动作行为。有关动画的讲解请参考笔者之前一篇总结：<a href="http://www.jianshu.com/p/5f1f40f963ac" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（八） ：协议，block，动画，俄罗斯方块Demo</a>。</p>
</blockquote>
<h4 id="2-根据偏移量来设置方块的位置"><a href="#2-根据偏移量来设置方块的位置" class="headerlink" title="2. 根据偏移量来设置方块的位置"></a>2. 根据偏移量来设置方块的位置</h4><pre><code>- (UIView *)addBlockOffsetFromCenterBy:(UIOffset)offset
{
    CGPoint blockCenter = CGPointMake(CGRectGetMidX(self.view.bounds)+offset.horizontal,
                                      CGRectGetMidY(self.view.bounds)+offset.vertical);

    CGRect blockFrame = CGRectMake(blockCenter.x-blockSize.width/2,
                                   blockCenter.y-blockSize.height/2,
                                   blockSize.width,
                                   blockSize.height);

    UIView *block = [[UIView alloc] initWithFrame:blockFrame];
    [self.view addSubview:block];
    return block;
}
</code></pre><blockquote>
<p>在这里，使用了<code>CGRectGetMidX</code>函数来获得view的横向中心点。</p>
</blockquote>
<h4 id="3-初始化红色和黑色方块"><a href="#3-初始化红色和黑色方块" class="headerlink" title="3. 初始化红色和黑色方块"></a>3. 初始化红色和黑色方块</h4><pre><code>        self.redBlock = [self addBlockOffsetFromCenterBy:UIOffsetMake(-100, 0)];
        self.redBlock.backgroundColor = [UIColor redColor];
        [self.collider addItem:self.redBlock];
        [self.gravity addItem:self.redBlock];

        self.blackBlock = [self addBlockOffsetFromCenterBy:UIOffsetMake(+100, 0)];
        self.blackBlock.backgroundColor = [UIColor blackColor];
        [self.collider addItem:self.blackBlock];

        //将开始的重力设为0：方块将不感受重力，只能通过人为手段施加
        self.gravity.gravityDirection = CGVectorMake(0, 0);
</code></pre><blockquote>
<p>在这里，红色方块具有碰撞和重力行为，但是黑色方块却只有碰撞行为。因为黑色是不受重力控制的，它的运动的触发只来自红色方块的碰撞。</p>
</blockquote>
<h4 id="4-在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作："><a href="#4-在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作：" class="headerlink" title="4. 在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作："></a>4. 在程序即将要挂起或者恢复前台活动状态时进行暂停游戏的操作：</h4><pre><code>    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationWillResignActiveNotification
                                                      object:nil
                                                       queue:nil
                                                  usingBlock:^(NSNotification *note) {
                                                      [self pauseGame];
                                                  }];

    [[NSNotificationCenter defaultCenter] addObserverForName:UIApplicationDidBecomeActiveNotification
                                                     object:nil
                                                       queue:nil
                                                  usingBlock:^(NSNotification *note) {
                                                      if (self.view.window) [self resumeGame];
                                                  }];
</code></pre><blockquote>
<p>我们也可以在appdelegate里面来实现这些方法，不过个人认为将方法写在一起看起来比较直观</p>
</blockquote>
<h4 id="5-CMMotionManager的初始化和使用"><a href="#5-CMMotionManager的初始化和使用" class="headerlink" title="5. CMMotionManager的初始化和使用"></a>5. CMMotionManager的初始化和使用</h4><pre><code>//初始化
- (CMMotionManager *)motionManager
{
    if (!_motionManager) {
        _motionManager = [[CMMotionManager alloc] init];
        _motionManager.accelerometerUpdateInterval = 0.1;
    }
    return _motionManager;
}

//将方法放在主线程的代码块中
 if (!self.motionManager.isAccelerometerActive) {

        [self.motionManager startAccelerometerUpdatesToQueue:[NSOperationQueue mainQueue]

                                                 withHandler:^(CMAccelerometerData *accelerometerData, NSError *error) {
    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿//获取加速器的方向
                                                     CGFloat x = accelerometerData.acceleration.x;
                                                     CGFloat y = accelerometerData.acceleration.y;
    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿
    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿    ﻿//根据设备的方向来给方块施加不同方向的重力
                                                     switch (self.interfaceOrientation) {
                                                         case UIInterfaceOrientationLandscapeRight:
                                                            self.gravity.gravityDirection = CGVectorMake(- y, - x); break;

                                                       case UIInterfaceOrientationLandscapeLeft:
                                                             self.gravity.gravityDirection = CGVectorMake(y, x); break;

                                                         case UIInterfaceOrientationPortrait:
                                                             self.gravity.gravityDirection = CGVectorMake(x, - y); break;

                                                         case UIInterfaceOrientationPortraitUpsideDown:
                                                            self.gravity.gravityDirection = CGVectorMake(- x, y); break;
                                                     }

                                                     [self updateScore];
                                                 }];
    }
</code></pre><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>如果嫌麻烦的童鞋可以在留言留下邮箱，笔者会将Demo包发给你~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲解了Core Motion框架的知识，简单介绍了app的生命周期，最后用一个方块碰撞游戏来对本节课的知识作总结。&lt;/p&gt;
&lt;h1 id=&quot;Core-Motion&quot;&gt;&lt;a href=&quot;#Core-Motion&quot; class=&quot;headerlink&quot; title=&quot;Co
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十六）：模态视图，UITextField，UImagePickerController，在Flickr添加摄影师照片Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E5%85%AD%EF%BC%89%EF%BC%9A%E6%A8%A1%E6%80%81%E8%A7%86%E5%9B%BE%EF%BC%8CUITextField,UImagePickerController%EF%BC%8C%E5%9C%A8Flickr%E6%B7%BB%E5%8A%A0%E6%91%84%E5%BD%B1%E5%B8%88%E7%85%A7%E7%89%87Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十六）：模态视图，UITextField,UImagePickerController，在Flickr添加摄影师照片Demo/</id>
    <published>2017-01-11T07:28:46.000Z</published>
    <updated>2017-01-11T08:32:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲解了模态视图，文本框，UImagePickerController的相关知识，并延续了上一节课的Demo，添加了照相并存储照片的功能。</p>
<h1 id="模态视图"><a href="#模态视图" class="headerlink" title="模态视图"></a>模态视图</h1><hr>
<p>模态视图不同于左右滑入的视图，它是从下往上，覆盖整个屏幕的视图。每次滑入都会重新新建一个控制器。通常用于修改信息等操作。</p>
<p>显示模态视图：</p>
<pre><code>  [self presentViewController:(nonnull UIViewController *) animated:(BOOL) completion:^{}];
</code></pre><p>让模态视图消失：</p>
<pre><code>- (void)dissmissViewControllerAnimated:(BOOL)animated completion:(void(^))block;
</code></pre><blockquote>
<p>注意:该消息是发送给present该模态视图的控制器，而不是该模态视图本身。因此，调用方法应该是：</p>
</blockquote>
<pre><code>[self.presentingViewController dissmissViewControllerAnimated:YES ...];
</code></pre><h1 id="UITextField"><a href="#UITextField" class="headerlink" title="UITextField"></a>UITextField</h1><hr>
<p>UITextField是文本框，可以用来输入文字，类似于UILabel。</p>
<h3 id="让键盘出现和消失："><a href="#让键盘出现和消失：" class="headerlink" title="让键盘出现和消失："></a>让键盘出现和消失：</h3><pre><code>[textField becomeFirstResponder];
[textField resignFirstResponder];
</code></pre><h2 id="代理方法："><a href="#代理方法：" class="headerlink" title="代理方法："></a>代理方法：</h2><h4 id="1-当点击了确定按键-让键盘消失"><a href="#1-当点击了确定按键-让键盘消失" class="headerlink" title="1. 当点击了确定按键,让键盘消失"></a>1. 当点击了确定按键,让键盘消失</h4><pre><code>- (BOOL)textFieldShouldReturn:(UITextField *)textField
{
    [textField resignFirstResponder];
    return YES;
}
</code></pre><h4 id="2-当resignFirstResponder完成后执行："><a href="#2-当resignFirstResponder完成后执行：" class="headerlink" title="2. 当resignFirstResponder完成后执行："></a>2. 当resignFirstResponder完成后执行：</h4><pre><code>- (void)textFieldDidEndEditing:(UITextField *)textField;
</code></pre><h4 id="3-内容发生变化时收到通知："><a href="#3-内容发生变化时收到通知：" class="headerlink" title="3. 内容发生变化时收到通知："></a>3. 内容发生变化时收到通知：</h4><p>注册这个广播，就可以收到该通知：</p>
<pre><code>UIKIT_EXTERN NSString *const UITextFieldTextDidChangeNotification;
</code></pre><h4 id="4-键盘"><a href="#4-键盘" class="headerlink" title="4. 键盘"></a>4. 键盘</h4><p>设置键盘的类型需要通过给实现<code>UITextInputTraits</code>的协议方法，通常是<code>UITextField</code></p>
<pre><code>@protocol UITextInputTraits &lt;NSObject&gt;

@optional
@property(nonatomic) UITextAutocapitalizationType autocapitalizationType; // 自动大写
@property(nonatomic) UIKeyboardType keyboardType;                         // default is UIKeyboardTypeDefault
@property(nonatomic) UIReturnKeyType returnKeyType;                       // 回车键，返回键，搜索键盘
@property(nonatomic,getter=isSecureTextEntry) BOOL secureTextEntry;       // 密码
@end
</code></pre><h4 id="5-监听键盘的高度："><a href="#5-监听键盘的高度：" class="headerlink" title="5. 监听键盘的高度："></a>5. 监听键盘的高度：</h4><p>通过注册<code>UIKeyboard{will,did} {show hide}</code>广播来计算键盘弹出后的高度。</p>
<h1 id="Alert"><a href="#Alert" class="headerlink" title="Alert"></a>Alert</h1><p>Alert是用来提醒用户某些消息的控件，它会出现在屏幕的正中央。我们可以自定义它的显示消息和按钮。也可以设定点击某个按钮执行的操作。</p>
<h2 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h2><pre><code>- (instancetype)initWithTitle:(nullable NSString *)title delegate:(nullable id&lt;UIActionSheetDelegate&gt;)delegate cancelButtonTitle:(nullable NSString *)cancelButtonTitle destructiveButtonTitle:(nullable NSString *)destructiveButtonTitle otherButtonTitles:(nullable NSString *)otherButtonTitles, ... NS_REQUIRES_NIL_TERMINATION NS_EXTENSION_UNAVAILABLE_IOS(&quot;Use UIAlertController instead.&quot;);
</code></pre><h2 id="增加按钮"><a href="#增加按钮" class="headerlink" title="增加按钮"></a>增加按钮</h2><pre><code>- (NSInteger)addButtonWithTitle:(nullable NSString *)title;
</code></pre><h2 id="显示在屏幕上"><a href="#显示在屏幕上" class="headerlink" title="显示在屏幕上:"></a>显示在屏幕上:</h2><pre><code>- (void)showFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated NS_AVAILABLE_IOS(3_2);
- (void)showInView:(UIView *)view;
</code></pre><h2 id="处理点击事件："><a href="#处理点击事件：" class="headerlink" title="处理点击事件："></a>处理点击事件：</h2><pre><code>- (void)actionSheet:(UIActionSheet *)actionSheet didDismissWithButtonIndex:(NSInteger)buttonIndex NS_DEPRECATED_IOS(2_0, 8_3) __TVOS_PROHIBITED;  // after animation
</code></pre><h2 id="手动让其消失"><a href="#手动让其消失" class="headerlink" title="手动让其消失"></a>手动让其消失</h2><pre><code>- (void)dismissWithClickedButtonIndex:(NSInteger)buttonIndex animated:(BOOL)animated;
</code></pre><h1 id="UImagePickerController"><a href="#UImagePickerController" class="headerlink" title="UImagePickerController"></a>UImagePickerController</h1><hr>
<p>UImagePickerController是用来选取图片，视频资源的控制器，也可以进行拍照。</p>
<h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><ol>
<li>alloc/init, set delegate</li>
<li>配置摄像头，照片库，用户是否可以编辑相片</li>
<li>显示</li>
<li>实现代理方法，获取媒体</li>
</ol>
<h2 id="检查硬件设备："><a href="#检查硬件设备：" class="headerlink" title="检查硬件设备："></a>检查硬件设备：</h2><pre><code>+ (BOOL)isSourceTypeAvailable:(UIImagePickerControllerSourceType)sourceType;  

typedef NS_ENUM(NSInteger, UIImagePickerControllerSourceType) {
    UIImagePickerControllerSourceTypePhotoLibrary,
    UIImagePickerControllerSourceTypeCamera,
    UIImagePickerControllerSourceTypeSavedPhotosAlbum
}
</code></pre><h2 id="检查是否可以摄像："><a href="#检查是否可以摄像：" class="headerlink" title="检查是否可以摄像："></a>检查是否可以摄像：</h2><pre><code>+ (nullable NSArray&lt;NSString *&gt; *)availableMediaTypesForSourceType:(UIImagePickerControllerSourceType)sourceType;
</code></pre><p>返回的数组是否有相应的字段：<br>kUTTypeImage<br>kUTTypeMovie</p>
<h2 id="允许用户编辑（裁剪）："><a href="#允许用户编辑（裁剪）：" class="headerlink" title="允许用户编辑（裁剪）："></a>允许用户编辑（裁剪）：</h2><pre><code>@property BOOL allowEditing;
</code></pre><h2 id="获取了媒体（照片）后的代理方法"><a href="#获取了媒体（照片）后的代理方法" class="headerlink" title="获取了媒体（照片）后的代理方法"></a>获取了媒体（照片）后的代理方法</h2><pre><code>- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info;
</code></pre><h2 id="点击了取消后的代理方法："><a href="#点击了取消后的代理方法：" class="headerlink" title="点击了取消后的代理方法："></a>点击了取消后的代理方法：</h2><pre><code>- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker
{
    [self dismissViewControllerAnimated:YES completion:NULL];
}
</code></pre><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求："><a href="#Demo需求：" class="headerlink" title="Demo需求："></a>Demo需求：</h2><ul>
<li>在原摄影师列表的第一行添加“我的照片”。</li>
<li>点击“我的照片”后，显示地图上“我”所照照片的地点。</li>
<li>点击大头针，显示相应照片详情。</li>
<li>在导航栏右上角显示照相机按钮。</li>
<li>点击照相机按钮，从底部弹出添加照片的页面。</li>
<li>点击“Take Photo”,启动相机，照相并可以裁剪。</li>
<li>裁剪后，回到添加剂照片的页面。设置标题和副标题后，保存照片。</li>
<li>回到地图页面，自动添加刚才所增加照片的大头针。</li>
</ul>
<h2 id="Demo效果图"><a href="#Demo效果图" class="headerlink" title="Demo效果图"></a>Demo效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-b1f9ecf0f562f5c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：添加照片 | 中：在地图上标注位置 | 右：点击查看大图"></p>
<h2 id="重要知识点和代码段"><a href="#重要知识点和代码段" class="headerlink" title="重要知识点和代码段"></a>重要知识点和代码段</h2><h4 id="1-在添加照片页面显示后判断是否可以拍照"><a href="#1-在添加照片页面显示后判断是否可以拍照" class="headerlink" title="1. 在添加照片页面显示后判断是否可以拍照"></a>1. 在添加照片页面显示后判断是否可以拍照</h4><pre><code>
- (void)viewDidAppear:(BOOL)animated
{
    [super viewDidAppear:animated];

    if (![[self class] canAddPhoto]) {
        [self fatalAlert:@&quot;Sorry, this device cannot add a photo.&quot;];
    } else {
        [self.locationManager startUpdatingLocation];//开始更新位置
    }
}

- (void)viewWillDisappear:(BOOL)animated
{
    [super viewWillDisappear:animated];
    //页面消失前，停止更新位置，避免耗能    
    [self.locationManager stopUpdatingLocation];
}

/**
 *  判断当前设备是否可以添加照片
 *
 *  @return 是否
 */

+ (BOOL)canAddPhoto
{
    //判断相机是否可用
    if ([UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {
        //返回支持媒体类型的数组
        NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];

        //判断数组里有无照片类型
        if ([availableMediaTypes containsObject:(NSString *)kUTTypeImage]) {

            //判断可以支持照片类型后，判断当前设备是否可以获取位置信息
            if ([CLLocationManager authorizationStatus] != kCLAuthorizationStatusRestricted) {

                return YES;
            }
        }
    }
    return NO;
}

- (void)fatalAlert:(NSString *)msg
{
    [[[UIAlertView alloc] initWithTitle:@&quot;Add Photo&quot;
                                message:msg
                               delegate:self
                      cancelButtonTitle:nil
                      otherButtonTitles:@&quot;Cancel&quot;, nil] show];
}
</code></pre><h4 id="2-CLLocationManager的初始化和使用"><a href="#2-CLLocationManager的初始化和使用" class="headerlink" title="2. CLLocationManager的初始化和使用"></a>2. CLLocationManager的初始化和使用</h4><pre><code>- (CLLocationManager *)locationManager
{
    if (!_locationManager) {

        //1. 初始化
        CLLocationManager *locationManager = [[CLLocationManager alloc] init];

        //2. 设置代理
        locationManager.delegate = self;

        //3. 设置精度
        locationManager.desiredAccuracy = kCLLocationAccuracyBest;
        _locationManager = locationManager;
        //4. iOS8以上要调用，否则无法监听位置！
        [_locationManager requestAlwaysAuthorization];
        [_locationManager requestWhenInUseAuthorization];
    }
    return _locationManager;
}

- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray *)locations
{
    //获取最后得到的位置信息（最准确）
    self.location = [locations lastObject];
}

- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error
{
    //获取错误码
    self.locationErrorCode = error.code;
}
</code></pre><h4 id="3-UIImagePickerController的初始化和使用"><a href="#3-UIImagePickerController的初始化和使用" class="headerlink" title="3. UIImagePickerController的初始化和使用"></a>3. UIImagePickerController的初始化和使用</h4><pre><code>
/**
 *  点击了“Take Photo 添加照片”
 */
- (IBAction)takePhoto
{
    //1. 初始化
    UIImagePickerController *uiipc = [[UIImagePickerController alloc] init];

    //2. 设置代理
    uiipc.delegate = self;

    //3. 获取图片媒体
    uiipc.mediaTypes = @[(NSString *)kUTTypeImage];
    uiipc.sourceType = UIImagePickerControllerSourceTypeCamera | UIImagePickerControllerSourceTypePhotoLibrary;

    //4. 允许裁剪
    uiipc.allowsEditing = YES;

    //5. 弹出UIImagePickerController
    [self presentViewController:uiipc animated:YES completion:NULL];

}

/**
 *  拍照成功
 *
 *  @param picker 当前的UIImagePickerController
 *  @param info   获取的照片信息
 */

- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info
{
    //获取裁剪后的图片
    UIImage *image = info[UIImagePickerControllerEditedImage];

    //如果无法获取裁剪后的图片，获取原图
    if (!image) image = info[UIImagePickerControllerOriginalImage];

    //更新当前的image属性
    self.image = image;

    [self dismissViewControllerAnimated:YES completion:NULL];
}

/**
 *  点击了取消
 *
 *  @param picker 当前的UIImagePickerController
 */
- (void)imagePickerControllerDidCancel:(UIImagePickerController *)picker
{
    [self dismissViewControllerAnimated:YES completion:NULL];
}
</code></pre><h4 id="4-判断是否执行某个Segue的Identifier"><a href="#4-判断是否执行某个Segue的Identifier" class="headerlink" title="4. 判断是否执行某个Segue的Identifier"></a>4. 判断是否执行某个Segue的Identifier</h4><pre><code>- (BOOL)shouldPerformSegueWithIdentifier:(NSString *)identifier sender:(id)sender
{

    if ([identifier isEqualToString:@&quot;Do Add Photo&quot;]) {
        if (!self.image) {
            //无照片
            [self alert:@&quot;No photo taken!&quot;];
            return NO;

        } else if (![self.titleTextField.text length]) {

            //无标题
            [self alert:@&quot;Title required!&quot;];
            return NO;

        } else if (!self.location) {

            //没有获取到位置信息
            switch (self.locationErrorCode) {

                case kCLErrorLocationUnknown:
                    [self alert:@&quot;Couldn&#39;t figure out where this photo was taken (yet).&quot;]; break;

                case kCLErrorDenied:
                    [self alert:@&quot;Location Services disabled under Privacy in Settings application.&quot;]; break;

                case kCLErrorNetwork:
                    [self alert:@&quot;Can&#39;t figure out where this photo is being taken.  Verify your connection to the network.&quot;]; break;

                default:
                    [self alert:@&quot;Cant figure out where this photo is being taken, sorry.&quot;]; break;
            }

            return NO;

        } else {
            return YES;
        }

    } else {

        return [super shouldPerformSegueWithIdentifier:identifier sender:sender];
    }
}

- (void)alert:(NSString *)msg
{

    [[[UIAlertView alloc] initWithTitle:@&quot;Add Photo&quot;
                                message:msg
                               delegate:nil
                      cancelButtonTitle:nil
                      otherButtonTitles:@&quot;Cancel&quot;, nil] show];
}
</code></pre><blockquote>
<p>在添加照片后，我们需要将该页面取消并储存相应的数据。但由于业务需求，如果想要储存数据的前提下取消页面的话，那么就需要在取消页面之前来判断当前的数据是否满足储存的条件：是否有照片；是否设置了标题；是否获取了位置信息等。</p>
</blockquote>
<h4 id="5-确定页面可以被取消后，在页面被取消前储存数据："><a href="#5-确定页面可以被取消后，在页面被取消前储存数据：" class="headerlink" title="5. 确定页面可以被取消后，在页面被取消前储存数据："></a>5. 确定页面可以被取消后，在页面被取消前储存数据：</h4><pre><code>- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{

    if ([segue.identifier isEqualToString:@&quot;Do Add Photo&quot;]) {

        NSManagedObjectContext *context = self.photographerTakingPhoto.managedObjectContext;

        if (context) {

            Photo *photo = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Photo&quot;  inManagedObjectContext:context];

            photo.title = self.titleTextField.text;
            photo.subtittle = self.subtitleTextField.text;
            photo.whoTook = self.photographerTakingPhoto;
            photo.latitude = @(self.location.coordinate.latitude);
            photo.longitude = @(self.location.coordinate.longitude);
            photo.imageURL = [self.imageURL absoluteString];
            photo.thumbnailURL = [self.thumbnailURL absoluteString];            

            self.addedPhoto = photo;         
            self.imageURL = nil;
            self.thumbnailURL = nil;
        }
    }
}
</code></pre><h4 id="6-获取新增图片的本地路径"><a href="#6-获取新增图片的本地路径" class="headerlink" title="6. 获取新增图片的本地路径"></a>6. 获取新增图片的本地路径</h4><pre><code>/**
 *  获取图片的本地URL
 *
 *  @return 图片的本地URL
 */

- (NSURL *)imageURL
{
    if (!_imageURL &amp;&amp; self.image) {
        NSURL *url = [self uniqueDocumentURL];
        if (url) {
            //UIImage -&gt; NSData
            NSData *imageData = UIImageJPEGRepresentation(self.image, 1.0);
            //将data写入url
            if ([imageData writeToURL:url atomically:YES]) {
                //如果写入成功，更新imageURL属性
                _imageURL = url;
            }
        }
    }
    return _imageURL;
}

/**
 *  获取图片缩略图的本地URL
 *
 *  @return 缩略图的本地URL
 */

- (NSURL *)thumbnailURL
{

    NSURL *url = [self.imageURL URLByAppendingPathExtension:@&quot;thumbnail&quot;];
    if (![_thumbnailURL isEqual:url]) {

        _thumbnailURL = nil;
        if (url) {
            //以某Size压缩图片（详情请看本Demo添加的image分类）
            UIImage *thumbnail = [self.image imageByScalingToSize:CGSizeMake(75, 75)];

            //0.5倍压缩
            NSData *imageData = UIImageJPEGRepresentation(thumbnail, 0.5);

            if ([imageData writeToURL:url atomically:YES]) {
                _thumbnailURL = url;
            }
        }
    }
    return _thumbnailURL;
}

/**
 *  以时间来生成唯一本地路径
 *
 *  @return 本地路径
 */

- (NSURL *)uniqueDocumentURL
{

    NSArray *documentDirectories = [[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask];

    NSString *unique = [NSString stringWithFormat:@&quot;%.0f&quot;, floor([NSDate timeIntervalSinceReferenceDate])];
    return [[documentDirectories firstObject] URLByAppendingPathComponent:unique];

}
</code></pre><blockquote>
<p>在这里，我们用当前的时间来拼接Document路径，获得了图片的唯一地址。</p>
</blockquote>
<p>笔者今天在公司附近拍了一张照片来验证效果：一张南京东路苹果旗舰店的照片，不过定位比较不准。可能是由于周围高楼比较多，而且定位时间不够长的关系。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>如果嫌麻烦的童鞋可以在留言留下邮箱，笔者会将Demo包发给你~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲解了模态视图，文本框，UImagePickerController的相关知识，并延续了上一节课的Demo，添加了照相并存储照片的功能。&lt;/p&gt;
&lt;h1 id=&quot;模态视图&quot;&gt;&lt;a href=&quot;#模态视图&quot; class=&quot;headerlink&quot; title=&quot;模态视图&quot;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E5%9B%9B%20%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9ACoreLocation%EF%BC%8CMapKit%EF%BC%8C%E5%9C%A8%E5%9C%B0%E5%9B%BE%E4%B8%8A%E6%A0%87%E8%AF%86Flickr%E6%91%84%E5%BD%B1%E5%B8%88%E7%9A%84%E4%BD%9C%E5%93%81/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品/</id>
    <published>2017-01-11T07:27:10.000Z</published>
    <updated>2017-01-11T08:43:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>本总结将第十四和十五课放在了一起，原因有二：第一是略去了ipad开发Demo的部分（因为笔者木有ipad，无法进行调试）。第二是两节课都讲解了关于地图框架的相关知识，故将二者放在一起总结。</p>
<p>在本篇总结的最后，会给大家讲解在地图上显示Flickr上摄影师的照片作品。</p>
<h1 id="Network-Activity-Indicator"><a href="#Network-Activity-Indicator" class="headerlink" title="Network Activity Indicator"></a>Network Activity Indicator</h1><hr>
<p>顾名思义，该控件叫做网络活动指示器。当app有网络活动时，可以让状态栏左边的小圆圈滚动用来提示用户当前的网络状态。</p>
<pre><code>@property(nonatomic,getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible;
</code></pre><p>如果设定为YES，状态栏上的小转轮就会转，反之亦然。</p>
<blockquote>
<p>注意：应用中的所有线程都可使用这个转轮，我们需要通过各种方法来向用户准确显示转轮的状态。</p>
</blockquote>
<h1 id="Core-Location"><a href="#Core-Location" class="headerlink" title="Core Location"></a>Core Location</h1><hr>
<p>通过该框架的基本类：<code>CLLocation</code>，我们能获得设备处于地球上的位置信息。</p>
<h2 id="Core-Location几个重要的属性："><a href="#Core-Location几个重要的属性：" class="headerlink" title="Core Location几个重要的属性："></a>Core Location几个重要的属性：</h2><h4 id="1-坐标属性"><a href="#1-坐标属性" class="headerlink" title="1. 坐标属性"></a>1. 坐标属性</h4><pre><code>typedef struct {
CLLocationDegrees latitude;    //double value
CLLocationDegrees longitude;   //double value
} CLLocationCoordinate2D;
</code></pre><h4 id="2-高度"><a href="#2-高度" class="headerlink" title="2. 高度"></a>2. 高度</h4><pre><code>@property(readonly, nonatomic) CLLocationDistance altitude; //单位是米
</code></pre><h4 id="3-变化精度："><a href="#3-变化精度：" class="headerlink" title="3. 变化精度："></a>3. 变化精度：</h4><pre><code>@property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy;//水平精度
@property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy;//高度精度
</code></pre><p>如何获得CLLocation？<br>通过实例化<code>CLLocationManager</code>类，让其告诉它的代理当前设备所处的位置。<br>下面来介绍一下<code>CLLocationManager</code>:</p>
<h1 id="CLLocationManager"><a href="#CLLocationManager" class="headerlink" title="CLLocationManager"></a>CLLocationManager</h1><hr>
<h2 id="CLLocationManager的工作步骤："><a href="#CLLocationManager的工作步骤：" class="headerlink" title="CLLocationManager的工作步骤："></a>CLLocationManager的工作步骤：</h2><p>1.查看硬件是否支持位置更新。<br>2.实例化<code>CLLocationManager</code>让其告诉它的代理当前的位置。<br>3.设置位置更新的类型(精度)。</p>
<pre><code>@property(assign, nonatomic) CLLocationAccuracy desiredAccuracy; //期望的经度
@property(assign, nonatomic) CLLocationDistance distanceFilter;  //更新到该距离之内不要告诉我更新了多少
</code></pre><p>4.开始位置监控。</p>
<pre><code>- (void)startUpdatingLocation;//开始更新位置
- (void)stopUpdatingLocation;//停止位置更新
- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations;//位置更新的代理方法
- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error;//更新失败
</code></pre><h2 id="位置监控的类型："><a href="#位置监控的类型：" class="headerlink" title="位置监控的类型："></a>位置监控的类型：</h2><h4 id="1-基于精度的监控"><a href="#1-基于精度的监控" class="headerlink" title="1. 基于精度的监控"></a>1. 基于精度的监控</h4><pre><code>extern const CLLocationAccuracy kCLLocationAccuracyBestForNavigation; //最精确，但是非常耗能
extern const CLLocationAccuracy kCLLocationAccuracyBest;
extern const CLLocationAccuracy kCLLocationAccuracyNearestTenMeters;
extern const CLLocationAccuracy kCLLocationAccuracyHundredMeters;
extern const CLLocationAccuracy kCLLocationAccuracyKilometer;
extern const CLLocationAccuracy kCLLocationAccuracyThreeKilometers;
</code></pre><blockquote>
<p>注意：精度越高，耗电量越大</p>
</blockquote>
<h4 id="2-位置发生重大变化时更新。"><a href="#2-位置发生重大变化时更新。" class="headerlink" title="2. 位置发生重大变化时更新。"></a>2. 位置发生重大变化时更新。</h4><pre><code>- (void)startMonitoringSignificantLocationChanges;
- (void)stopMonitoringSignificantLocationChanges ;
</code></pre><p>该方法在前台和后台都能监控位置的变化，甚至关掉app后，也可以启动应用告诉用户位置更新:</p>
<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    //如果``launchOptions``存在``UIApplicationLaunchOptionsLocationKey``，说明程序启动的原因是因为位置发生了重大变化
    return YES;
}
</code></pre><h4 id="3-进入某个区域更新。"><a href="#3-进入某个区域更新。" class="headerlink" title="3. 进入某个区域更新。"></a>3. 进入某个区域更新。</h4><p>3.1设定一个圆形的区域，经过该区域的时候会更新</p>
<pre><code>- (void)startMonitoringForRegion:(CLRegion *)region;
- (void)requestStateForRegion:(CLRegion *)region;
</code></pre><p>3.2 通过一个信标来监控</p>
<pre><code>@property (readonly, nonatomic) CLLocationDistance maximumRegionMonitoringDistance;//设置最大监控距离

- (void)startRangingBeaconsInRegion:(CLBeaconRegion *)region;//设置信标
</code></pre><h4 id="4-监控前进的方向"><a href="#4-监控前进的方向" class="headerlink" title="4. 监控前进的方向"></a>4. 监控前进的方向</h4><h1 id="MapKit"><a href="#MapKit" class="headerlink" title="MapKit"></a>MapKit</h1><hr>
<p>MapKit是用于显示地图的框架，它通过<code>MKMapView</code>来显示地图。<br>我们来看一下该框架中几个比较重要的元素：</p>
<h2 id="1-MKMapView"><a href="#1-MKMapView" class="headerlink" title="1. MKMapView"></a>1. MKMapView</h2><p>MKMapView就是用来显示地图的View。</p>
<p>MKMapView的属性：</p>
<pre><code>@property (nonatomic) MKMapType mapType;// MKMapTypeStandard : 标准；MKMapTypeSatellite:卫星；MKMapTypeHybrid：叠加
@property (nonatomic) BOOL showsUserLocation; //显示用户的地点
@property (nonatomic, readonly, getter=isUserLocationVisible) BOOL userLocationVisible;
//用户坐标是否可见
@property (nonatomic, getter=isZoomEnabled) BOOL zoomEnabled; //是否可放大缩小
@property (nonatomic, getter=isRotateEnabled) BOOL rotateEnabled; //是否可旋转
@property (nonatomic, getter=isPitchEnabled) BOOL pitchEnabled; //3D效果
</code></pre><h2 id="2-MKAnnotationView"><a href="#2-MKAnnotationView" class="headerlink" title="2. MKAnnotationView"></a>2. MKAnnotationView</h2><p>在<code>MKMapView</code>视图里，可以显示用于标注具体位置的“大头针” ，它是MapKit框架里的<code>AnnotationView</code>。</p>
<p>MKAnnotationView的属性：</p>
<pre><code>@property (nonatomic, strong, nullable) id &lt;MKAnnotation&gt; annotation;
@property (nonatomic, strong, nullable) UIImage *image;//大头针的图像
@property (strong, nonatomic, nullable) UIView *leftCalloutAccessoryView;//左附属对话框
@property (strong, nonatomic, nullable) UIView *rightCalloutAccessoryView;//右附属对话框
@property (nonatomic, getter=isDraggable) BOOL draggable //是否可拖动
</code></pre><p>大头针被点击时调用的方法：</p>
<pre><code>- (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view
</code></pre><h2 id="3-id"><a href="#3-id" class="headerlink" title="3. id"></a>3. id<mkannotation></mkannotation></h2><p>AnnotationView的数据源就是：id<mkannotation>，任何遵从该协议的对象都可以成为AnnotationView的数据源，也就是说，任何遵守    <code>MKAnootation</code>协议的对象你都可以将其放入地图中。</mkannotation></p>
<p>我们先看一下在MKMapView里的关于MKAnnotation的属性：</p>
<pre><code>@property (nonatomic, readonly) NSArray&lt;id&lt;MKAnnotation&gt;&gt; *annotations;//包含MapView所显示的所有Annotaion
</code></pre><p>注意：annotations是只读的数组，只能添加或者删除。</p>
<pre><code>- (void)addAnnotation:(id &lt;MKAnnotation&gt;)annotation;
- (void)addAnnotations:(NSArray&lt;id&lt;MKAnnotation&gt;&gt; *)annotations;
- (void)removeAnnotation:(id &lt;MKAnnotation&gt;)annotation;
- (void)removeAnnotations:(NSArray&lt;id&lt;MKAnnotation&gt;&gt; *)annotations;
</code></pre><p>MKAnnotation协议的方法：</p>
<pre><code>

@protocol MKAnnotation &lt;NSObject&gt;
@property (nonatomic, readonly) CLLocationCoordinate2D coordinate; //坐标

@optional
@property (nonatomic, readonly, copy, nullable) NSString *title;//标题
@property (nonatomic, readonly, copy, nullable) NSString *subtitle;//副标题

- (void)setCoordinate:(CLLocationCoordinate2D)newCoordinate ;//设置坐标
</code></pre><p>那么二者是如何关联的呢？<br>通过MKMapView的代理方法：</p>
<pre><code>- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation
{
    //提供一个 annotation，返回一个 MKAnnotationView
}
</code></pre><h2 id="4-Callout-对话框"><a href="#4-Callout-对话框" class="headerlink" title="4. Callout(对话框)"></a>4. Callout(对话框)</h2><p>点击大头针（MKAnnotationView），会出现一个白底的对话框，它被叫做<code>callout</code>,可以设置它的主标题和副标题。另外还有左右附属实图，它们可以显示图片或者箭头，也可被点击。
﻿</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求："><a href="#Demo需求：" class="headerlink" title="Demo需求："></a>Demo需求：</h2><ul>
<li>显示从flickr抓取的摄影师列表。</li>
<li>点击列表中的一项，打开地图，在当前摄影师所照照片的地点显示大头针。</li>
<li>点击其中的一个大头针，显示照片详情：缩略图和名称。</li>
<li>点击箭头按钮，滑入显示照片的页面，显示原始照片。</li>
</ul>
<h2 id="Demo效果图："><a href="#Demo效果图：" class="headerlink" title="Demo效果图："></a>Demo效果图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-269dd622430d4972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在地图显示照片拍摄位置"></p>
<h2 id="重要代码段和知识点："><a href="#重要代码段和知识点：" class="headerlink" title="重要代码段和知识点："></a>重要代码段和知识点：</h2><h4 id="1-更改Core-Data模型"><a href="#1-更改Core-Data模型" class="headerlink" title="1. 更改Core Data模型"></a>1. 更改Core Data模型</h4><p>在上一节课的基础上，我们需要在模型里的<code>Photo</code>实体添加经度和纬度的属性，还有大头针缩略图的URL属性。<br>在更新属性后，一定要重新生成对应该实体的类文件，并且要将原app删除，因为数据库前后是不兼容的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0bf538fa1a08fe3d.gif?imageMogr2/auto-orient/strip" alt="更新模型"></p>
<h4 id="2-新建PhotosByPhotographerMapViewController-h，用来显示MKMapView"><a href="#2-新建PhotosByPhotographerMapViewController-h，用来显示MKMapView" class="headerlink" title="2. 新建PhotosByPhotographerMapViewController.h，用来显示MKMapView"></a>2. 新建PhotosByPhotographerMapViewController.h，用来显示<code>MKMapView</code></h4><p>因为要在地图上显示摄影师所照照片的位置，因此，该类的数据源来自摄影师模型：<code>Photographer</code>。</p>
<pre><code>#import &lt;UIKit/UIKit.h&gt;
#import &quot;Photographer.h&quot;
@interface PhotosByPhotographerMapViewController : UIViewController
@property (nonatomic, strong) Photographer *photographer;//公共API：摄影师
@end
</code></pre><p>``</p>
<p>#import “PhotosByPhotographerMapViewController.h”</p>
<p>#import <mapkit mapkit.h=""></mapkit></p>
<p>@interface PhotosByPhotographerMapViewController ()<mkmapviewdelegate><br>@property (strong, nonatomic) IBOutlet MKMapView <em>mapView;//地图view<br>@property (nonatomic,strong) NSArray </em>photosByPhotographer;//装入摄影师拥有的照片的数组<br>@end</mkmapviewdelegate></p>
<p>@implementation PhotosByPhotographerMapViewController<br>@end<br>``</p>
<h4 id="3-导入Mapkit的framework"><a href="#3-导入Mapkit的framework" class="headerlink" title="3. 导入Mapkit的framework"></a>3. 导入Mapkit的framework</h4><p>需要注意的是，除了要在类文件引用<code>&lt;MapKit/MapKit.h&gt;</code>框架以外，还要手动向项目中添加该框架：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-8fb04dfbac7bbdd7.gif?imageMogr2/auto-orient/strip" alt="手动添加MapKit框架.gif"></p>
<h4 id="4-更新photographer和mapView后更新annotation："><a href="#4-更新photographer和mapView后更新annotation：" class="headerlink" title="4. 更新photographer和mapView后更新annotation："></a>4. 更新photographer和mapView后更新annotation：</h4><pre><code>- (void)setMapView:(MKMapView *)mapView
{
    _mapView = mapView;

    //设置代理
    self.mapView.delegate = self;

    //更新
    [self updateMapViewAnnotations];
}

- (void)setPhotographer:(Photographer *)photographer
{
    _photographer = photographer;
    //导航栏标题
    self.title = photographer.name;
    //准备更新数组，要事先设置其为nil，否则不会生成新的
    self.photosByPhotographer = nil;
    [self updateMapViewAnnotations];
}

- (void)updateMapViewAnnotations
{
    [self.mapView removeAnnotations:self.mapView.annotations];
    [self.mapView addAnnotations:self.photosByPhotographer];
    [self.mapView showAnnotations:self.photosByPhotographer animated:YES];
}
</code></pre><h4 id="5-自定义点击大头针后显示的view"><a href="#5-自定义点击大头针后显示的view" class="headerlink" title="5. 自定义点击大头针后显示的view"></a>5. 自定义点击大头针后显示的view</h4><pre><code>- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation
{

    //类似UITableviewCell的复用
    static NSString *reuseId = @&quot;PhotosByPhotographerMapViewController&quot;;    

    MKPinAnnotationView *view = (MKPinAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:reuseId];    

    if (!view) {
        view = [[MKPinAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:reuseId];
       //是否显示callout
        view.canShowCallout = YES;
        //设置左部分的callout：UIImageView
        UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 46, 46)];
        view.leftCalloutAccessoryView = imageView;
        //设置右部分的callout：UIButton
        UIButton *disclosurebutton = [[UIButton alloc] init];
        [disclosurebutton setBackgroundImage:[UIImage imageNamed:@&quot;disclosure&quot;] forState:UIControlStateNormal];
        [disclosurebutton sizeToFit];
        view.rightCalloutAccessoryView = disclosurebutton;
    }

    view.annotation = annotation;
    return view;

}
</code></pre><h4 id="6-点击大头针，更新callout左侧显示的缩略图"><a href="#6-点击大头针，更新callout左侧显示的缩略图" class="headerlink" title="6. 点击大头针，更新callout左侧显示的缩略图"></a>6. 点击大头针，更新callout左侧显示的缩略图</h4><pre><code>
/**
 *  点击大头针view
 *
 *  @param mapView 大头针所属的mapView
 *  @param view    大头针view
 */
- (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view
{
    [self updateLeftCalloutAccessoryViewInAnnotationView:view];
}

/**
 *  更新callout里的图片（在左侧）
 *
 *  @param annotationView 当前被点击的大头针view
 */
- (void)updateLeftCalloutAccessoryViewInAnnotationView:(MKAnnotationView *)annotationView
{
    UIImageView *imageView = nil;
    if ([annotationView.leftCalloutAccessoryView isKindOfClass:[UIImageView class]]) {
        imageView = (UIImageView *)annotationView.leftCalloutAccessoryView;
    }
    if (imageView) {
        Photo *photo = nil;
        if ([annotationView.annotation isKindOfClass:[Photo class]]) {
            photo = (Photo *)annotationView.annotation;
        }
        if (photo) {
            NSString *urlString = photo.thumbnailURL;
            imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]]];
        }
    }
}
</code></pre><blockquote>
<p>注意：显示图片的代码：<code>imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]]];</code>方法会阻塞主线程，实际操作中应该放在子线程中执行。详情请参考笔者另一篇讲解关于多线程的博客：<a href="http://www.jianshu.com/p/6e74f5438f2c" target="_blank" rel="external">最浅显易懂的iOS多线程技术 - GCD的教程</a>。</p>
</blockquote>
<h4 id="7-点击callout，在下一页面显示原图"><a href="#7-点击callout，在下一页面显示原图" class="headerlink" title="7. 点击callout，在下一页面显示原图"></a>7. 点击callout，在下一页面显示原图</h4><pre><code>/**
 *  点击callout实行跳转
 *
 *  @param mapView 当前的mapView
 *  @param view    当前callout所属的AnnotationView
 *  @param control callout内部被点击的控件
 */
- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view calloutAccessoryControlTapped:(UIControl *)control
{
    [self performSegueWithIdentifier:@&quot;Show Photo&quot; sender:view];
}

/**
 *  调转执行前的代码
 *
 *  @param segue  连接前后两个控制器的segue
 *  @param sender 被点击的AnnotaionView
 */
- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{

    if ([sender isKindOfClass:[MKAnnotationView class]]) {
        [self prepareViewController:segue.destinationViewController
                           forSegue:segue.identifier
                   toShowAnnotation:((MKAnnotationView *)sender).annotation];
    }
}

/**
 *  为目标控制器准备数据（图片的URL）
 *
 *  @param vc              目标控制器
 *  @param segueIdentifier segue.identifier
 *  @param annotation      被点击的AnnotaionView
 */
- (void)prepareViewController:(id)vc
                     forSegue:(NSString *)segueIdentifier
             toShowAnnotation:(id &lt;MKAnnotation&gt;)annotation
{
    Photo *photo = nil;
    if ([annotation isKindOfClass:[Photo class]]) {
        photo = (Photo *)annotation;
    }
    if (photo) {
        if (![segueIdentifier length] || [segueIdentifier isEqualToString:@&quot;Show Photo&quot;]) {
            if ([vc isKindOfClass:[ImageViewController class]]) {
                ImageViewController *ivc = (ImageViewController *)vc;
                ivc.imageURL = [NSURL URLWithString:photo.imageURL];
                ivc.title = photo.title;
            }
        }
    }
}
</code></pre><blockquote>
<p>注意：这里的<code>ivc.imageURL = [NSURL URLWithString:photo.imageURL];</code>代码同样会阻塞主线程，实际操作中应该放在子线程来做！</p>
<p>而且,本demo的图片地址应该都是在墙外的，所以最好先让电脑翻墙，然后在模拟器上运行比较好。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本总结将第十四和十五课放在了一起，原因有二：第一是略去了ipad开发Demo的部分（因为笔者木有ipad，无法进行调试）。第二是两节课都讲解了关于地图框架的相关知识，故将二者放在一起总结。&lt;/p&gt;
&lt;p&gt;在本篇总结的最后，会给大家讲解在地图上显示Flickr上摄影师的照片作
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十二 十三）：CoreData,表格视图，Flickr摄影师资料列表Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%BA%8C%20%E5%8D%81%E4%B8%89%EF%BC%89%EF%BC%9ACoreData%EF%BC%8C%E8%A1%A8%E6%A0%BC%E8%A7%86%E5%9B%BE%EF%BC%8CFlickr%E6%91%84%E5%BD%B1%E5%B8%88%E8%B5%84%E6%96%99%E5%88%97%E8%A1%A8/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十二 十三）：CoreData，表格视图，Flickr摄影师资料列表/</id>
    <published>2017-01-11T07:21:28.000Z</published>
    <updated>2017-01-11T08:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>第十二课和第十三课都介绍了CoreData的知识，并在十三课的中段通过一个Demo来具体实现了CoreData的操作。</p>
<p>笔者之前从未接触过Core Data的相关知识，因此学期这两节课比较吃力，这一篇总结还是有很多需要改进的地方，以后随着对Core Data认识的深入和对这两节课的反复咀嚼，会不断更新该总结。</p>
<p>开始吧！</p>
<h1 id="Core-Data"><a href="#Core-Data" class="headerlink" title="Core Data"></a>Core Data</h1><hr>
<p>Core Data是一种持久化技术，它能将模型对象的状态持久化到磁盘，但它最重要的特点是：Core Data不仅是一个加载、保存数据的框架，它还能和内存中的数据很好的共事。</p>
<p>排除错误认识：Core Data<strong>并不是数据库!</strong> 它只是连接类（Class）和数据库（SQL）的桥梁。通过Core Data的相关功能，我们可以对数据库进行增删改查的操作。</p>
<h2 id="CoreData是如何工作的呢？"><a href="#CoreData是如何工作的呢？" class="headerlink" title="CoreData是如何工作的呢？"></a>CoreData是如何工作的呢？</h2><h3 id="1-创建对象的可视化映射"><a href="#1-创建对象的可视化映射" class="headerlink" title="1. 创建对象的可视化映射"></a>1. 创建对象的可视化映射</h3><p>在看到可视化映射之前，需要了解<strong>实体</strong>的概念：</p>
<blockquote>
<p><strong>实体的概念</strong>：每个实体是一个表，每个表对应一个对象。<br>简单粗暴的理解：实体在数据库领域叫做表，在面向对象领域叫做对象。</p>
<p><strong>实体之间的关系</strong>=表之间创建关系，对象之间的关系。</p>
</blockquote>
<p><strong>注意</strong>：两个对象之间的关系在两个对象端具有不同的名称。而且关系的对应数量也是不同的：<code>to one</code>,<code>to many</code>。</p>
<blockquote>
<p>举个🌰 ：摄影者和照片的关系：<br>摄影者对应多个照片，但是照片只对应一个摄影者。</p>
</blockquote>
<p>那么言归正传，如何创建对象的可视化映射呢？</p>
<ol>
<li>创建模型文件，用来装入各种需要映射的实体。</li>
<li>在模型内部添加实体（Entity），创建实体之间的关系（必要时）。</li>
</ol>
<p>下面笔者录制了创建实体，增加实体属性，连接实体的操作：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-ca646fa9e1e18f5a.gif?imageMogr2/auto-orient/strip" alt="创建实体，增加属性"></p>
<h3 id="2-为实体创建NSManagedObjectd子类"><a href="#2-为实体创建NSManagedObjectd子类" class="headerlink" title="2. 为实体创建NSManagedObjectd子类"></a>2. 为实体创建NSManagedObjectd子类</h3><p>我们需要将刚得到的可视化的实体“转变为”具体的类。在Core Data中，这些类都是NSManagedObjectd子类。</p>
<p>下面演示一下其创建过程：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-2eab784599ea6776.gif?imageMogr2/auto-orient/strip" alt="创建NSManagedObjectd子类"></p>
<p>以实体<code>Photo</code>为例，系统为我们生成了<code>Photo.h</code>和<code>Photo.m</code>。</p>
<p>我们先看一下<code>Photo.h</code>:</p>
<p>``</p>
<p>#import <foundation foundation.h=""></foundation></p>
<p>#import <coredata coredata.h=""></coredata></p>
<p>NS_ASSUME_NONNULL_BEGIN<br>@interface Photo : NSManagedObject<br>// Insert code here to declare functionality of your managed object subclass<br>@end<br>NS_ASSUME_NONNULL_END</p>
<p>#import “Photo+CoreDataProperties.h”<br>``</p>
<blockquote>
<p>我们可以看到，<code>Photo</code>类继承了<code>NSManagedObject</code>。</p>
</blockquote>
<p>但是，有意思的是，系统还为我们自动生成了<code>Photo+CoreDataProperties.h</code>和<code>Photo+CoreDataProperties.m</code>，详情见动图左侧，创建实体类之后。</p>
<p><strong>思考</strong>：<br>生成这两个文件的目的是什么呢？<br>首先，我们首先要知道这两个文件是什么：<br>他们构成了<code>Photo</code>类的分类(Category)。</p>
<p>那么什么是分类呢？<br>通过分类，我们可以向原有的类添加方法，而不需要通过继承的方式。分类的局限是：在分类里不能再添加属性。</p>
<p>那么显然，通过<code>Photo+CoreDataProperties</code>，我们就可以不用继承<code>Photo</code>类来给其添加方法。因为原有的<code>Photo</code>类只具有属性，除了获取属性之外，并不能为我们做其他的事情。这时，如果可以在其他的地方给其无限地添加方法还是很具有诱惑力的。令人欣慰的是，系统可以自动为我们生成。</p>
<h3 id="3-通过创建NSManagedObjectContext访问，操作数据库"><a href="#3-通过创建NSManagedObjectContext访问，操作数据库" class="headerlink" title="3. 通过创建NSManagedObjectContext访问，操作数据库"></a>3. 通过创建NSManagedObjectContext访问，操作数据库</h3><p>数据库创建对象，设置对象属性，查询对象都需要<code>NSManagedObjectContext</code>。</p>
<p>创建<code>NSManagedObjectContext</code>的两个不同的方法：</p>
<p>1.通过其自身的初始化：</p>
<p><code>[NSManagedObjectContext alloc] init];</code></p>
<p>2.通过UIManagedDocument创建：</p>
<p>UIManagedDocument 用于管理存储的机制，将Core Data数据库放入某存储空间。<br><code>UIManagedDocument *document = [[UIManagedDocument alloc] initWithFileURL:url];
//url:这个core data 数据库存储的地方</code></p>
<h2 id="数据库的操作："><a href="#数据库的操作：" class="headerlink" title="数据库的操作："></a>数据库的操作：</h2><h4 id="1-向数据库添加对象（实体）："><a href="#1-向数据库添加对象（实体）：" class="headerlink" title="1. 向数据库添加对象（实体）："></a>1. 向数据库添加对象（实体）：</h4><p><code>[NSEntityDescription insertNewObjectForEntityForName:@&quot;Photo&quot; inManagedObjectContext:context];</code></p>
<h4 id="2-从数据库删除对象（实体）："><a href="#2-从数据库删除对象（实体）：" class="headerlink" title="2. 从数据库删除对象（实体）："></a>2. 从数据库删除对象（实体）：</h4><p><code>[aDocument.managedObjectContext deleteObject:photo];</code></p>
<p>删除对象后，系统会向所有对象发送这个消息</p>
<p>``</p>
<ul>
<li>(void)prepareForDeletion{<br>//在这里保持数据同步，比如删掉这个对象的时候会影响到其他对象的数据<br>//应该在这个对象被删除前及时更新那个数据<br>}</li>
</ul>
<p>``</p>
<h4 id="3-在数据库查询对象（实体）："><a href="#3-在数据库查询对象（实体）：" class="headerlink" title="3. 在数据库查询对象（实体）："></a>3. 在数据库查询对象（实体）：</h4><p>我们使用<code>NSFetchRequest</code>类查询数据库的对象，通过设置其不同属性来查找符合不同标准的数据：</p>
<p>举个🌰 ：查找出100个photo的实体：</p>
<pre><code>NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;Photo&quot;];
request.fetchLimit = 100;
</code></pre><h2 id="关于Core-data的线程安全"><a href="#关于Core-data的线程安全" class="headerlink" title="关于Core data的线程安全"></a>关于Core data的线程安全</h2><pre><code>//让context在安全队列中执行的方法
[context performBlock:^{
    [A doSomething];
}];
</code></pre><h1 id="NSFetchedResultsController"><a href="#NSFetchedResultsController" class="headerlink" title="NSFetchedResultsController"></a>NSFetchedResultsController</h1><hr>
<p>NSFetchedResultsController的作用是将NSFetchRequest 和 UITalbleView联系到一起。<br>和TableView的数据源方法类似：</p>
<pre><code>- (NSInteger)numberOfRowsInSection:(NSInteger)section{
  return [[self.fetchedResultsController sections] count];
}

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView{
   return [[self.fetchedResultsController sections] count] objectAtIndex:section] numberOfObjects];
}
</code></pre><p>详细的使用方法会在Demo讲解部分中告诉大家。</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>每隔20分钟，从flickr拿回最新的摄影者数据。</li>
<li>用一个TableView显示当前拿回的摄影者的名字和所照的照片数。</li>
</ul>
<h2 id="Demo效果图"><a href="#Demo效果图" class="headerlink" title="Demo效果图"></a>Demo效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-72dc6873f1c13917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="摄影师的信息列表"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-在启动接口获取flickr的数组"><a href="#1-在启动接口获取flickr的数组" class="headerlink" title="1. 在启动接口获取flickr的数组"></a>1. 在启动接口获取flickr的数组</h4><pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
     self.photoDatabaseContext = [self createMainQueueManagedObjectContext];    
     [self startFlickrFetch];   
     return YES;
}

- (void)startFlickrFetch
{
    [self.flickrDownloadSession getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
        if (![downloadTasks count]) {
            NSURLSessionDownloadTask *task = [self.flickrDownloadSession downloadTaskWithURL:[FlickrFetcher URLforRecentGeoreferencedPhotos]];
            task.taskDescription = FLICKR_FETCH;
            [task resume];
        } else {
            for (NSURLSessionDownloadTask *task in downloadTasks) [task resume];
        }
    }];
}
</code></pre><h4 id="2-每隔20分钟获取新的内容"><a href="#2-每隔20分钟获取新的内容" class="headerlink" title="2. 每隔20分钟获取新的内容"></a>2. 每隔20分钟获取新的内容</h4><pre><code>- (void)setPhotoDatabaseContext:(NSManagedObjectContext *)photoDatabaseContext
{
    _photoDatabaseContext = photoDatabaseContext;

    //photoDatabaseContext设定成功后，每隔20分钟重新获取信息
    if (self.photoDatabaseContext)
    {
        self.flickrForegroundFetchTimer = [NSTimer scheduledTimerWithTimeInterval:FOREGROUND_FLICKR_FETCH_INTERVAL
                                                                           target:self
                                                                         selector:@selector(startFlickrFetch:)
                                                                         userInfo:nil
                                                                          repeats:YES];
    }

    //photoDatabaseContext设定成功后 向控制器发送消息
    NSDictionary *userInfo = self.photoDatabaseContext ? @{ PhotoDatabaseAvailabilityContext : self.photoDatabaseContext } : nil;
    [[NSNotificationCenter defaultCenter] postNotificationName:PhotoDatabaseAvailabilityNotification
                                                        object:self
                                                      userInfo:userInfo];
}
</code></pre><h4 id="3-在表格视图查询所有摄影师的名字"><a href="#3-在表格视图查询所有摄影师的名字" class="headerlink" title="3. 在表格视图查询所有摄影师的名字"></a>3. 在表格视图查询所有摄影师的名字</h4><pre><code>- (void)setManagedObjectContext:(NSManagedObjectContext *)managedObjectContext
{
    //哪个数据库
    _managedObjectContext = managedObjectContext;

    NSFetchRequest *requet = [NSFetchRequest fetchRequestWithEntityName:@&quot;Photographer&quot;];
    requet.predicate = nil;//所有的,无过滤
    requet.sortDescriptors = @[[NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES selector:@selector(localizedStandardCompare:)]];

    self.fetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:requet managedObjectContext:managedObjectContext sectionNameKeyPath:nil cacheName:nil];

}
</code></pre><h4 id="4-重写tablelViwe-cellForRowAtIndex-方法，显示摄影师数据"><a href="#4-重写tablelViwe-cellForRowAtIndex-方法，显示摄影师数据" class="headerlink" title="4. 重写tablelViwe:cellForRowAtIndex:方法，显示摄影师数据"></a>4. 重写<code>tablelViwe:cellForRowAtIndex:</code>方法，显示摄影师数据</h4><pre><code>- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Photographer cell&quot;];

    //拿到摄影师的名字和摄影数量
    Photographer *photographer = [self.fetchedResultsController objectAtIndexPath:indexPath];
    cell.textLabel.text = photographer.name;
    cell.detailTextLabel.text = [NSString stringWithFormat:@&quot;%lu photos&quot;, [photographer.photos count]];    
    return cell;

}
</code></pre><p>本Demo显然是一个未完成品，它只显示了摄影师的相关信息，并且只有一个页面。在接下来的课程中应该会对该Demo进行更多过的扩展。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第十二课和第十三课都介绍了CoreData的知识，并在十三课的中段通过一个Demo来具体实现了CoreData的操作。&lt;/p&gt;
&lt;p&gt;笔者之前从未接触过Core Data的相关知识，因此学期这两节课比较吃力，这一篇总结还是有很多需要改进的地方，以后随着对Core Data认
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E8%A1%A8%E6%A0%BC%E8%A7%86%E5%9B%BE%EF%BC%8CFlickr-%E7%85%A7%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo/</id>
    <published>2017-01-11T07:20:18.000Z</published>
    <updated>2017-01-11T08:34:03.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UITableview"><a href="#UITableview" class="headerlink" title="UITableview"></a>UITableview</h1><hr>
<p>UITableview是iOS软件中最常见的视图，用来以表格的形式显示数据。</p>
<h2 id="数据源方法"><a href="#数据源方法" class="headerlink" title="数据源方法"></a>数据源方法</h2><pre><code>- (NSInteger)numberOfRowsInSection:(NSInteger)section;//表格的总section数，默认为返回1，可以不实现
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; //返回当前section的行数，必须实现
- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; //返回某section某row的cell，必须实现
</code></pre><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><pre><code>- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//cell被点击是调用的方法
</code></pre><h2 id="根据cell获得对应的indexPath"><a href="#根据cell获得对应的indexPath" class="headerlink" title="根据cell获得对应的indexPath"></a>根据cell获得对应的indexPath</h2><pre><code> NSIndexPath *indexPath = [self.tableView  indexPathForCell :sender];
</code></pre><h2 id="UITableView-Spinner"><a href="#UITableView-Spinner" class="headerlink" title="UITableView Spinner"></a>UITableView Spinner</h2><p>顶部加载时显示的小圆圈动画</p>
<pre><code>@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl;

- (void)beginRefreshing;
- (void)endRefreshing;
</code></pre><h2 id="模型改变，刷新表格"><a href="#模型改变，刷新表格" class="headerlink" title="模型改变，刷新表格"></a>模型改变，刷新表格</h2><pre><code>- (void)reloadData; //刷新全部表格：一般在模型大部分变化的时候才调用，在某个数据变化时不推荐使用

- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//只刷新某一个cell，在某行货少数行数据变化时推荐使用
</code></pre><h1 id="Universal-Application"><a href="#Universal-Application" class="headerlink" title="Universal Application"></a>Universal Application</h1><hr>
<p>Universal Application通用应用是指既可以在iPhone上运行，也可以在iPad上运行的应用，它有两个故事版文件，一个是针对iphone的，另一个是针对ipad的。</p>
<p>iPad有两种独有的视图：</p>
<ol>
<li>Split View：拆分视图</li>
<li>Popover:弹窗</li>
</ol>
<p>识别是否是ipad</p>
<pre><code>BOOL iPad  = ([{UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad)
</code></pre><h1 id="UISplitViewController"><a href="#UISplitViewController" class="headerlink" title="UISplitViewController"></a>UISplitViewController</h1><hr>
<h2 id="UISplitViewController包括"><a href="#UISplitViewController包括" class="headerlink" title="UISplitViewController包括"></a>UISplitViewController包括</h2><ul>
<li>Master View Controller</li>
<li>Detail View Controller</li>
</ul>
<p>UISplitViewController是storyboard的最顶层，不能被加入到UIViewController里面</p>
<h2 id="获得SplitViewController："><a href="#获得SplitViewController：" class="headerlink" title="获得SplitViewController："></a>获得SplitViewController：</h2><p>返回当前UIViewcontroller所在的SplitViewController:</p>
<pre><code>UIViewController.h

@property (strong) UISplitViewController  *splitViewController;
</code></pre><h2 id="获得SplitViewController的master和detail："><a href="#获得SplitViewController的master和detail：" class="headerlink" title="获得SplitViewController的master和detail："></a>获得SplitViewController的master和detail：</h2><pre><code>@property (copy) NSArray *viewControllers;//0：master;1: detail
</code></pre><h2 id="UISplitViewControllerDelegate"><a href="#UISplitViewControllerDelegate" class="headerlink" title="UISplitViewControllerDelegate"></a>UISplitViewControllerDelegate</h2><p>在awakeFromNib设置此代理,代理负责 控制master和detail何时出现</p>
<p>代理的几个方法：</p>
<pre><code>- (BOOL)splitViewController:(UISplitViewController *)svc shouldHideViewController:(UIViewController *)vc inOrientation:(UIInterfaceOrientation)orientation{
           return NO; //永远不隐藏master，master和detail将一直在屏幕上显示，无论是横屏或竖屏 
           return UIInterfaceOrientationIsPortrait(orientation);//竖屏不显示master 但是竖屏时左上角有按键可以显示master，但是
不实现这个代理就不能出现按钮了。
}
</code></pre><p>在横屏或竖屏是否该隐藏master</p>
<h1 id="Popovers"><a href="#Popovers" class="headerlink" title="Popovers"></a>Popovers</h1><hr>
<p>Popover是弹窗控件，它的作用是控制另一个视图控制器弹出到屏幕上，也是ipad独有的控件。<br>因为ipad的面积比较大，所以有时可以只以弹窗的形式提供信息而不用跳转到下一页面。</p>
<p>注意：这个控件并没有继承UIViewController，是一个NSObject</p>
<h2 id="Popover的Segue是UIStroyboardPopoverSegue。"><a href="#Popover的Segue是UIStroyboardPopoverSegue。" class="headerlink" title="Popover的Segue是UIStroyboardPopoverSegue。"></a>Popover的Segue是<code>UIStroyboardPopoverSegue</code>。</h2><p>在Popover出现之前：</p>
<pre><code>- (void)prepareForSegue: (UIStoryboardSegue *)segue sender: (id)sender
{
    if([segue isKindOfClass:[UIStroyboardPopoverSegue class]]){

         UIPopoverController *popoverController = ((UIStroyboardPopoverSegue *)segue.)popoverController;

     }
}
</code></pre><h2 id="使Popover消失："><a href="#使Popover消失：" class="headerlink" title="使Popover消失："></a>使Popover消失：</h2><pre><code>- (void)dismissPopoverAnimated:(BOOL)animated;
</code></pre><p>默认情况下，点击外部任何的地方都能使它消失，除非我们给它指定即使点击也不会消失的<code>UIVIew</code>。</p>
<pre><code>@property (copy) NSArray *passthroughViews;
</code></pre><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<p>该Demo是同时适用iPad 和iPhone的，可惜笔者没有iPad，无法调试，于是只适配了iPhone，以后有机会会补上适配iPad的代码的。</p>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>第一个页面用表格显示从Flickr抓取的图片数据，只显示图片名和图片详情。</li>
<li>点击第一个页面的cell，跳转到图片详情页。</li>
<li>图片详情页显示具体的大图，可以伸缩，可以移动。</li>
</ul>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-b0a8e98131ae59b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-获取Flickr上的数据"><a href="#1-获取Flickr上的数据" class="headerlink" title="1. 获取Flickr上的数据"></a>1. 获取Flickr上的数据</h4><p>Flickr提供了公共的接口提供了自家的照片，接口文件在本Demo里的<code>Flickr Fetcher</code>文件里，唯一注意的是需要申请<code>APIKEY</code>,<a href="[http://www.flickr.com/services/api/misc.api_keys.html](http://www.flickr.com/services/api/misc.api_keys.html">申请网址</a>)。</p>
<p>解析照片数据的过程是比较耗时的，所以需要分配到子线程来进行。获得数组后，在主线程将数组赋予当前类的属性里。</p>
<pre><code>- (void)fetchPhotos
{
    self.photos = nil;
    NSURL *url = [FlickrFetcher URLforRecentGeoreferencedPhotos];

    //手动创建一个子线程
    dispatch_queue_t fetchQ = dispatch_queue_create(&quot;flickr fetcher&quot;, NULL);

    dispatch_async(fetchQ, ^{

        //获得json数据，比较耗时
        NSData *jsonResults = [NSData dataWithContentsOfURL:url];

        //获得字典
        NSDictionary *propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:NULL];
        NSArray *photos = [propertyListResults valueForKeyPath:FLICKR_RESULTS_PHOTOS];

        dispatch_async(dispatch_get_main_queue(), ^{

           //回到主线程     
            self.photos = photos;

        });    
    });
}
</code></pre><blockquote>
<p>NULL是C指针，代表指向OC指针的指针没有指向任何对象</p>
</blockquote>
<p>什么是指向OC指针的指针？：&amp;error是指向error的指针<br>如果我们这样写，就可以获得error：</p>
<pre><code> NSError *error = nil;
 NSDictionary *propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:&amp;error];
</code></pre><p>如果我们不关心error，就可以传NULL。</p>
<p>好了，现在我们获得了数据，需要刷新表格：</p>
<h4 id="2-刷新表格"><a href="#2-刷新表格" class="headerlink" title="2. 刷新表格"></a>2. 刷新表格</h4><pre><code>- (void)setPhotos:(NSArray *)photos
{
    _photos = photos;
    [self.tableView reloadData];
}
</code></pre><p>只是刷新表格是不够的，还要实现<code>UITableView</code>的数据源方法来告诉<code>TableView</code>如何显示数据。（调用<code>reload</code>方法后会调用这些数据源方法）</p>
<h4 id="3-实现数据源方法"><a href="#3-实现数据源方法" class="headerlink" title="3. 实现数据源方法"></a>3. 实现数据源方法</h4><pre><code>#pragma mark - Table view data source

- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
    //只有一组
     return 1;
}

- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
   //行数为图片的个数
    return self.photos.count;
}

- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {

    //从重用池中拿到cell
    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Flickr Photo Cell&quot; forIndexPath:indexPath];

    //通过indexPath来获得在数据里对应的图片数据
    NSDictionary *photoDict = self.photos[indexPath.row];
    //设置主标题和副标题

    cell.textLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_TITLE];

    cell.detailTextLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_DESCRIPTION];    

    return cell;

}
</code></pre><h4 id="4-点击cell，实现跳转"><a href="#4-点击cell，实现跳转" class="headerlink" title="4. 点击cell，实现跳转"></a>4. 点击cell，实现跳转</h4><pre><code>#pragma mark - Navigation

// In a storyboard-based application, you will often want to do a little preparation before navigation

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender {

    if ([sender isKindOfClass:[UITableViewCell class]]) {

        NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];    

        if (indexPath) {

            if ([segue.destinationViewController isKindOfClass:[ImageViewController class]]) {

                [self prepareImageViewController:segue.destinationViewController toDisplayPhoto:self.photos[indexPath.row]];                

            }
        }
    }
}

- (void)prepareImageViewController:(ImageViewController *)ivc toDisplayPhoto:(NSDictionary*)photo
{

   //获得图像的URL传给ImageViewController
    ivc.imageURL = [FlickrFetcher URLforPhoto:photo format:FlickrPhotoFormatLarge];
   //导航栏的标题为图片的名字
    ivc.title = [photo valueForKey:FLICKR_PHOTO_TITLE];

}
</code></pre><blockquote>
<p>这里的<code>ImageViewController</code>复用了<a href="http://www.jianshu.com/p/ddb4f528b334" target="_blank" rel="external">斯坦福大学iOS开发公开课总结（十） ：多线程，UIScrollView，图片浏览器Demo</a>里第二个页面。</p>
</blockquote>
<h4 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h4><p>每次跳转到图片详情页，将图片的原点设置在最左上端，并且大小恢复到该图片的原始大小</p>
<pre><code>- (void)setImage:(UIImage *)image
{

    //重置缩放大小为1
    self.scrollView.zoomScale = 1.0;
    self.imageView.image = image;
    [self.imageView sizeToFit];

    //将视图框的原点设在左上角
    self.imageView.frame = CGRectMake(0, 0, self.image.size.width, self.image.size.height);

    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;

    [self.spinner stopAnimating];

}
</code></pre><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UITableview&quot;&gt;&lt;a href=&quot;#UITableview&quot; class=&quot;headerlink&quot; title=&quot;UITableview&quot;&gt;&lt;/a&gt;UITableview&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;UITableview是iOS软件中最常见的视图，用来以表
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十）：多线程，UIScrollView，图片浏览器Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%EF%BC%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8CUIScrollView%EF%BC%8C%E5%9B%BE%E7%89%87%E6%B5%8F%E8%A7%88%E5%99%A8Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十）：多线程，UIScrollView，图片浏览器Demo/</id>
    <published>2017-01-11T07:19:16.000Z</published>
    <updated>2017-01-11T08:34:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲授了多线程编程和UIScrollview控件，最后通过一个显示图片的Demo综合了本节课讲解的知识。通过本节课的学习，我们可以初步了解该如何处理耗时的任务来提高系统性能的方法以及通过UIScrollview控件来显示超出屏幕大小的图片并实现滚动和缩放的效果。</p>
<h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><hr>
<p>实现多线程编程（将不同的任务放在主线程和子线程工作），可以有效利用系统硬件优势提高系统性能。<br>首先，先介绍几个概念：</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列：在队列中放入用来执行任务的block。这些block按照队列的性质被取出到应该工作的线程(主线程，子线程)。</p>
<p>队列分为串行队列和并行队列。</p>
<ul>
<li>放入串行队列的任务将会在主线程执行，执行顺序是按照顺序执行。</li>
<li>放入并行队列的任务会在子线程执行，执行顺序是并行执行。</li>
</ul>
<p>那么什么样的任务会放在主线程或子线程执行呢？</p>
<h2 id="主线程-amp-子线程"><a href="#主线程-amp-子线程" class="headerlink" title="主线程&amp;子线程"></a>主线程&amp;子线程</h2><p>主线程：负责执行UI活动，绝大部分的UI活动都要在这里调用，不能让其阻塞，要将耗时的任务放到子线程来做。<br>子线程：负责执行耗时的运算，网络请求等不能放在主线程的任务。</p>
<p>系统为我们提供了共用的主队列(Main Dispatch Queue)和全局并行队列(Global Dispatch Queue)。我们只需将需要执行的任务放入到这两类队列里就可以实现多线程编程。</p>
<h2 id="得到主队列"><a href="#得到主队列" class="headerlink" title="得到主队列"></a>得到主队列</h2><pre><code>dispatch_queue_t mainQ = dispatch_get_main_queue();
NSOperationQueue *mainQ = [NSOperationQueue mainQueue];
</code></pre><h2 id="得到主队列并布置任务"><a href="#得到主队列并布置任务" class="headerlink" title="得到主队列并布置任务"></a>得到主队列并布置任务</h2><pre><code>//NSThread
- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;

//GCD
 dispatch_async(dispatch_get_main_queue(), ^{                   

                        [doSomething];

                    });
</code></pre><h2 id="得到全局并行队列"><a href="#得到全局并行队列" class="headerlink" title="得到全局并行队列"></a>得到全局并行队列</h2><pre><code>dispatch queue_t globalDispatchQueueDefault = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
</code></pre><h2 id="得到全局并行队列并布置任务"><a href="#得到全局并行队列并布置任务" class="headerlink" title="得到全局并行队列并布置任务"></a>得到全局并行队列并布置任务</h2><pre><code>  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

           [doSomething];
  });
</code></pre><h2 id="使用多线程的例子：线程之间通信"><a href="#使用多线程的例子：线程之间通信" class="headerlink" title="使用多线程的例子：线程之间通信"></a>使用多线程的例子：线程之间通信</h2><p>很多情况下，我们需要在子线程进行下载任务，下载完成后在主线程更新UI，这时候就需要线程之间的通信：</p>
<pre><code>  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{

              //下载图片
              NSData *dataFromURL = [NSData dataWithContentsOfURL:imageURL];
              UIImage *imageFromData = [UIImage imageWithData:dataFromURL];

      dispatch_async(dispatch_get_main_queue(), ^{

              //加载完成更新view
              UIImageView *imageView = [[UIImageView alloc] initWithImage:imageFromData];

      });

  });
</code></pre><blockquote>
<p>在这里，我们在全局并行队列的回调block里调用了主线程，并在主线程里执行了UI操作。</p>
</blockquote>
<h2 id="使用多线程的例子：通过NSURLSession下载"><a href="#使用多线程的例子：通过NSURLSession下载" class="headerlink" title="使用多线程的例子：通过NSURLSession下载"></a>使用多线程的例子：通过NSURLSession下载</h2><pre><code>- (void)mainQueueCallBack
{
    NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL];
    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:nil delegateQueue:[NSOperationQueue mainQueue]];
    NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
         //这里是主队列，可以更新UI        
    }];

    [task resume];
}
</code></pre><blockquote>
<p>在这里，<code>delegateQueue</code>的参数是主线程，所以<code>downloadTaskWithRequest::</code>方法的回调函数是在主线程，我们就可以在那里作更新UI的操作。</p>
</blockquote>
<p>如果没有<code>delegateQueue</code>呢？我们需要自己获取主线程</p>
<pre><code>- (void)noDelegateQueueRequest
{
    NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL];
    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];
    NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {

     //获取主线程-通过NSThread
     [self performSelectorOnMainThread:(doUIThings) withObject:nil waitUntilDone:NO];
     //获取主线程-通过GCD
    dispatch_async(dispatch_get_main_queue(), ^{                   
                        [doUIThings]
                    });         
    }];    
    [task resume];
}
</code></pre><h1 id="UIScrollView"><a href="#UIScrollView" class="headerlink" title="UIScrollView"></a>UIScrollView</h1><hr>
<p>UIScrollView是滚动视图，可以实现滚动和缩放的功能。</p>
<h2 id="几个比较重要的属性："><a href="#几个比较重要的属性：" class="headerlink" title="几个比较重要的属性："></a>几个比较重要的属性：</h2><p>视图要滚动的区域：<code>contentSize</code><br>目前滚动的位置：<code>contentOffset</code><br>滚动窗口的大小：<code>scrollView.bounds</code></p>
<h2 id="几个比较重要的方法："><a href="#几个比较重要的方法：" class="headerlink" title="几个比较重要的方法："></a>几个比较重要的方法：</h2><p>获取当前显示的部分：</p>
<pre><code>CGRect visibleRect = [scrollView convertRect：scrollView.bounds toView:subview];
</code></pre><p>用代码滚动视图：</p>
<pre><code>- (void)scrollRectToVisible :(CGRect)aRect animated:(BOOL)animated;
</code></pre><p>代码实现缩放：</p>
<pre><code>@property(nonatomic) CGFloat zoomScale;  
- (void)setZoomScale:(CGFloat)scale animated:(BOOL)animated);
- (void)zoomToRect:(CGRect)rect animated:(BOOL)animated;
</code></pre><p>告诉要缩放哪个<code>UIView</code>:</p>
<pre><code>- (nullable UIView *)viewForZoomingInScrollView:(UIScrollView *)
</code></pre><h2 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h2><h4 id="设置缩放极限"><a href="#设置缩放极限" class="headerlink" title="设置缩放极限"></a>设置缩放极限</h4><pre><code>scrollView.minimumZoomSize = 0.5;
scrollView.maximumZoomSize = 2.0;
</code></pre><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>第一个页面显示三个按钮，在跳转后分别下载并显示不同图片。</li>
<li>在图片的下载过程中给予提示。</li>
<li>图片显示出来后可以移动，缩放。</li>
</ul>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-30b1dbbc035c8e1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：第一页 | 右：第二页"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-在跳转之前将图片下载的URL传给第二个页面"><a href="#1-在跳转之前将图片下载的URL传给第二个页面" class="headerlink" title="1. 在跳转之前将图片下载的URL传给第二个页面"></a>1. 在跳转之前将图片下载的URL传给第二个页面</h4><pre><code>- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
     //通过内省判断跳转的页面类
     if ([segue.destinationViewController isKindOfClass:[ImageViewController class]]) {       

        //告诉编译期，即将跳转的页面类
        ImageViewController *imageVC = (ImageViewController *)segue.destinationViewController;        
        //初始化指针，将其设为nil 
        NSString *string = nil;
        //通过identifier判断跳转界面
        if ([segue.identifier isEqualToString:@&quot;paint&quot;]) {            
            //这张图貌似得翻墙，而且图片很大，建议换一张
            string = @&quot;https://lh6.ggpht.com/ZoD88QrTxZbZnhpJgQbo9SPuosryX9ujjdRaHvjjvbUGeZcI-9C4AFQsWQm7-pVDv1E=h900&quot;;       

        }else if ([segue.identifier isEqualToString:@&quot;earth&quot;]) {
            //这张图不是很大，可以不用花很久就能显示
            string = @&quot;http://news.nationalgeographic.com/content/dam/news/2016/02/12/01asteroidearth.jpg&quot;;           

        }else if ([segue.identifier isEqualToString:@&quot;night&quot;])  {
            //这张图貌似得翻墙，而且图片很大，建议换一张
            string = @&quot;https://lh5.ggpht.com/j4C_pXnbRc5FnxNO90wIqodn4QA3f_6rB0cyu2sVnCeSwLDmyZf-xSrC9L8c3oxr6NE=h900&quot;;

        }        

        imageVC.imageURL = [NSURL URLWithString:string];

         //设置导航栏的标题
        imageVC.title = segue.identifier;

    }
}
</code></pre><h4 id="2-使UIScrollView控件能够拖动"><a href="#2-使UIScrollView控件能够拖动" class="headerlink" title="2. 使UIScrollView控件能够拖动"></a>2. 使UIScrollView控件能够拖动</h4><pre><code>/**
 *  设置图片后，重新imageView的图片和自己的大小，并设置contentSize
 *
 *  @param image &lt;#image description#&gt;
 */
- (void)setImage:(UIImage *)image
{
    self.imageView.image = image;
    //根据图片大小设置imageview的大小

    [self.imageView sizeToFit];
    //保护机制：有图片设置size，否则size=0

    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;

}
</code></pre><blockquote>
<p>为了使UIScrollView控件能够拖动，<strong>必须</strong>要设置它的contentSize大小，否则无法滚动！</p>
</blockquote>
<h4 id="3-设置UIScrollView伸缩"><a href="#3-设置UIScrollView伸缩" class="headerlink" title="3. 设置UIScrollView伸缩"></a>3. 设置UIScrollView伸缩</h4><pre><code>
- (void)setScrollView:(UIScrollView *)scrollView
{
    _scrollView = scrollView;
    _scrollView.minimumZoomScale = 0.2;
    _scrollView.maximumZoomScale = 2.0;
    _scrollView.delegate = self;
    //设置两次contSize的原因是我们不确保这两个方法哪个是先被调用的

    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;

}
</code></pre><p>效果图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-2d0da3c643a5b7d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现伸缩效果"></p>
<h4 id="4-下载图片"><a href="#4-下载图片" class="headerlink" title="4. 下载图片"></a>4. 下载图片</h4><p>错误做法：阻塞主线程</p>
<pre><code>- (void)setImageURL:(NSURL *)imageURL
{
    _imageURL = imageURL;   
    self.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:self.imageURL]];
}
</code></pre><blockquote>
<p>永远不要在主线程调用下载的方法！主线程负责UI相应，如果调用耗时的方法会使得其下一项任务在下载完成之前无法执行（主线程是串行队列），造成卡死的情况。<br>所以，我们应该另外开一个子线程让其负责下载：</p>
</blockquote>
<pre><code>- (void)startDownloading
{
    //先清空现有图片
    self.image = nil;   

    if (self.imageURL) {        

        //转动的小动画，提示正在下载
       [self.spinner startAnimating];
        NSURLRequest *request = [NSURLRequest requestWithURL:self.imageURL];
        NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration ephemeralSessionConfiguration];
        NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration];
        NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {            

            if(!error){

                //判断URL是否被更改，因为这是一个异步操作，无法保证在下载过程中一定能保持原来的数据
                if ([request.URL isEqual:self.imageURL])
                {
                    //下载完成，拿到本地的路径
                    UIImage *image = [UIImage imageWithData:[NSData dataWithContentsOfURL:location]];                    
                    //获得主队列
                    dispatch_async(dispatch_get_main_queue(), ^{

                        //在主队列更新UI
                        self.image = image;

                    });
                }
            }
        }];        

        [task resume];
    }
}
</code></pre><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。</p>
<p>笔者这两天会总结一下这一系列的Demo，发布到我的个人GitHub账号上去，以后就可以方便很多了~</p>
<p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲授了多线程编程和UIScrollview控件，最后通过一个显示图片的Demo综合了本节课讲解的知识。通过本节课的学习，我们可以初步了解该如何处理耗时的任务来提高系统性能的方法以及通过UIScrollview控件来显示超出屏幕大小的图片并实现滚动和缩放的效果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（九）：AutoLayout，自动布局Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B9%9D%EF%BC%89%EF%BC%9AAutoLayout%EF%BC%8C%E8%87%AA%E5%8A%A8%E5%B8%83%E5%B1%80Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（九）：AutoLayout，自动布局Demo/</id>
    <published>2017-01-11T07:18:19.000Z</published>
    <updated>2017-01-11T08:35:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课介绍了iOS在故事版里构造AutoLayout(自动布局)的三种方法并通过沿用了第六课的<a href="http://www.jianshu.com/p/8d5a4a8ac2be" target="_blank" rel="external">Demo</a>具体演示了添加约束的过程。内容较少也比较简单，可惜的是没有讲解用纯代码构造自动布局。</p>
<p><strong>PS：严重多图预警！</strong></p>
<p>因为操作都是在故事版里进行的，所以只能通过截图来演示具体操作步骤。。。</p>
<h1 id="AutoLayout"><a href="#AutoLayout" class="headerlink" title="AutoLayout"></a>AutoLayout</h1><hr>
<h2 id="在故事版里构造AutoLayout的三种方法："><a href="#在故事版里构造AutoLayout的三种方法：" class="headerlink" title="在故事版里构造AutoLayout的三种方法："></a>在故事版里构造AutoLayout的三种方法：</h2><ol>
<li>使用蓝色辅助线，并选择系统建议约束。</li>
<li>点击底部的布局菜单，根据需求选择相应的约束。</li>
<li>按住control按键拖动触发菜单，根据需求选择相应约束。</li>
</ol>
<p>下面具体每种方法的做法：</p>
<h2 id="1-使用蓝色辅助线，并选择系统建议约束"><a href="#1-使用蓝色辅助线，并选择系统建议约束" class="headerlink" title="1. 使用蓝色辅助线，并选择系统建议约束"></a>1. 使用蓝色辅助线，并选择系统建议约束</h2><p>我们现在要将“Thing 1”和“Thing 2”两个标签放在左上角和右下角。<br><img src="http://upload-images.jianshu.io/upload_images/859001-1f209520ddccc48e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用蓝色辅助线"></p>
<blockquote>
<p>在拖动空间的时候，系统会在某些时刻给出建议的约束，用蓝色虚线表示，详情看左图。<br>在约束显示出来的前提下放下控件，再选择系统建议的约束可以添加系统建议的约束，也就是之前虚线表示出来的约束，详情看右图。</p>
</blockquote>
<h2 id="2-点击底部的布局菜单，根据需求选择相应的约束"><a href="#2-点击底部的布局菜单，根据需求选择相应的约束" class="headerlink" title="2. 点击底部的布局菜单，根据需求选择相应的约束"></a>2. 点击底部的布局菜单，根据需求选择相应的约束</h2><p>我们现在要添加“Bad Thing”按钮，将其置于屏幕正中间。<br><img src="http://upload-images.jianshu.io/upload_images/859001-38cf0f8b7dddb55b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用底部布局菜单"></p>
<blockquote>
<p>想让控件居中显示，可以根据底部的按钮弹出的菜单设置，具体看左图。</p>
<p>添加约束后，生成了黄色虚线框，如中间的图所示。黄色虚线框为控件添加该约束后，控件应有的frame。这时，应该点击左上角的黄色小三角选择“update frame”，具体看右图。</p>
</blockquote>
<p>最终效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-4ed297bd355f392e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图1"></p>
<blockquote>
<p>点击黄色小三角显示的选项的意义：  </p>
<ol>
<li>update frame：通过修改frame 来适应约束。 </li>
<li>update constrains: 修改约束 适应这个控件的frame。</li>
<li>reset to suggested constrains:使用建议约束。</li>
</ol>
</blockquote>
<h2 id="3-按住control按键拖动触发菜单，根据需求选择相应约束。"><a href="#3-按住control按键拖动触发菜单，根据需求选择相应约束。" class="headerlink" title="3. 按住control按键拖动触发菜单，根据需求选择相应约束。"></a>3. 按住control按键拖动触发菜单，根据需求选择相应约束。</h2><p>我们现在要将“Bad Thing”和”Thing 2”垂直距离固定，右边对其。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-192fcf72d0c3b71e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="按住control键"></p>
<p>在拖动控件”Bad Thing”后，并不会改变其原有的约束(出现了黄色虚线框)，如左图。我们需要先删除其原有的约束。<br>然后点击“Bad Thing”按住<code>control</code>拖动到<code>Thing 2</code>,弹出菜单后，设置二者的垂直距离固定，右边对其，如右图所示。</p>
<p>最终效果图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c292148931dab740.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图2"></p>
<blockquote>
<p>拖动也有三种方式：</p>
<ol>
<li>从一个控件按住control按键到另一个控件，选择相应的排列方式。</li>
<li>从一个控件拖拽到它的父视图：水平居中，垂直居中等。</li>
<li>从一个控件拖拽到它自己：选择固定宽度等。</li>
</ol>
</blockquote>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<p>首先我们拿到之前的属性字符串Demo，按照第一种设定约束的方法，结果不尽人意：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-143c8a529cb76416.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="宽度不等"></p>
<p>显然，我们需要让四个彩色按钮宽度保持一致：<br>点击下方弹出菜单，选择“Equal Width”。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-4d27907e6dc68116.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置等宽"></p>
<p>现在确实是等宽了，但是控制台有报错信息，虽然运行木有问题。</p>
<p>什么问题呢？</p>
<p>因为我们在让四个彩色按钮宽度相等的同时<strong>硬编码</strong>了它们的宽度，这显然不同时适用于横屏和竖屏的情况，需要将它们的固定宽度删去：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-bf9616a1e7401713.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="删除固定宽度"></p>
<p>在第二个页面，我们把两个Label放到左下角：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d8c09edac6a09686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="垂直固定"></p>
<ol>
<li>首先用下方的菜单，将靠左和靠下的距离固定，如左图。</li>
<li>然后用拖动control键的方法设定第二个标签的左对齐和垂直距离，效果如右图。</li>
</ol>
<p>在这里没有固定标签的宽度，这很好，因为如果数字是多位的，固定的宽度可能无法全部显示标签内的内容。</p>
<p>那么手动固定一下其中一个标签的宽度，通过拖动control键拖动到自己的方法点击“width”，使宽度固定：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b9ab01e556babf45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="固定宽度.png"></p>
<blockquote>
<p>固定宽度的标签无法完整显示了内容，因此这是一个危险的做法。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课介绍了iOS在故事版里构造AutoLayout(自动布局)的三种方法并通过沿用了第六课的&lt;a href=&quot;http://www.jianshu.com/p/8d5a4a8ac2be&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Demo&lt;/a&gt;具体演
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（八）：协议，block，动画，俄罗斯方块Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%85%AB%EF%BC%89%EF%BC%9A%E5%8D%8F%E8%AE%AE%EF%BC%8Cblock%EF%BC%8C%E5%8A%A8%E7%94%BB%EF%BC%8C%E4%BF%84%E7%BD%97%E6%96%AF%E6%96%B9%E5%9D%97Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（八）：协议，block，动画，俄罗斯方块Demo/</id>
    <published>2017-01-11T07:17:25.000Z</published>
    <updated>2017-01-11T08:43:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课介绍了协议，block，动画的相关知识，最后结合了这些知识点展示了一个类似<strong>俄罗斯方块</strong>的小游戏Demo。<br>总体来说本节课的内容比较重要，稍微摆脱了UI层面的知识，对于初学者来说理解起来不是很容易，不过笔者会尽量详细地讲解给大家。</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><hr>
<p>关于协议所介绍的知识点比较简单，而且实现起来相对容易，故不做详细介绍，各位可以参考文档或者相关博客即可。<br>在这里只强调一个知识点：</p>
<h3 id="id-obj-和-id-lt-MyProtocol-gt-obj的相同点和不同点"><a href="#id-obj-和-id-lt-MyProtocol-gt-obj的相同点和不同点" class="headerlink" title="id obj 和 id&lt;MyProtocol&gt;obj的相同点和不同点:"></a><code>id obj</code> 和 <code>id&lt;MyProtocol&gt;obj</code>的相同点和不同点:</h3><p><strong>相同点</strong>：都表示了某个对象。<br><strong>不同点</strong>：<br><code>id obj</code>表示<code>obj</code>是具体某一类的实例对象。<br><code>id&lt;MyProtocol&gt;obj</code>只表示遵守了某协议的对象 。</p>
<blockquote>
<p>因为有的时候我们并不需要确保某个对象一定是某个类的实例对象，而只需要它遵循了某个协议，这个时候就需要用第二行的写法来确保这个对象确实遵循了<myprotocol>。</myprotocol></p>
</blockquote>
<h1 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h1><hr>
<p>关于block的概念和语法在这里就不赘述了，因为有文档和很多牛人已经总结地很好了。<br>在这里只强调两点关于block的使用注意事项。</p>
<h2 id="修改block内部变量的方案"><a href="#修改block内部变量的方案" class="headerlink" title="修改block内部变量的方案"></a>修改block内部变量的方案</h2><p>如果我们要在block里将<code>found</code>值设为YES,就应该在block外部添加<code>__block</code>关键字。</p>
<pre><code>    __block BOOL found = NO;
    //通过__block关键字，将found从栈中移动到堆中保证其可以被修改；block结束后，将该变量复制一份到堆中，再放回栈上

    [dict enumerateKeysAndObjectsUsingBlock:^(id  _Nonnull key, id  _Nonnull obj, BOOL * _Nonnull stop){        

        if ([targetString isEqualToString:obj]) {            

            *stop = YES; //停止
            found = YES;
        }        
    }];
</code></pre><h2 id="存储循环的解决方案"><a href="#存储循环的解决方案" class="headerlink" title="存储循环的解决方案"></a>存储循环的解决方案</h2><p>只要block存在，block内部消息中的每个对象都会被block的一个强指针指着。此时，如果这些对象里的某个或几个对象也有指向该block的指针，就会造成存储循环。</p>
<p>问题重现：</p>
<pre><code>
    //这个block有强指针指向self，而self也通过myBlocks数组有强指针指向block

    [self.myBlocks addObject:^{    

        [self doSomething];

    }];
</code></pre><p>解决方案：创建弱类型的局部变量</p>
<pre><code>
    __weak ViewController *weakSelf = self; //创建弱类型的局部变量

    [self.myBlocks addObject:^{    

        [weakSelf doSomething];

    }];
</code></pre><h2 id="Block的应用"><a href="#Block的应用" class="headerlink" title="Block的应用"></a>Block的应用</h2><p>block可以直接保存在变量中，属性中，字典和数组中。</p>
<p>具体使用环境：</p>
<ul>
<li>多线程：用于主线程，子线程的回调。</li>
<li>枚举：数组，字典的枚举等。</li>
<li>通知：某件事情发生后，信息的传递。</li>
<li>错误时调用：“包住”错误发生后需要执行的代码。</li>
<li>成功时调用：“包住”任务成功后需要执行的代码。</li>
<li>动画</li>
<li>排序</li>
</ul>
<h1 id="通过View改变视图的属性来实现动画"><a href="#通过View改变视图的属性来实现动画" class="headerlink" title="通过View改变视图的属性来实现动画"></a>通过View改变视图的属性来实现动画</h1><hr>
<ul>
<li>改变<code>frame</code></li>
<li>改变<code>transform</code></li>
<li>改变<code>alpha</code></li>
</ul>
<p>具体通过UIView的类方法来改变</p>
<pre><code>+ (void)animateWithDuration:(NSTimeInterval)duration   //动画在这个屏幕上出现的时间
                                     delay:(NSTimeInterval)delay       //等待多长时间再执行
                                  options:(UIViewAnimationOptions)options 
                             animations:(void (^)(void))animations  //在此代码块中修改frame，transform 和 alpha
                             completion:(void (^ __nullable)(BOOL finished))completion;
</code></pre><p>options参数：</p>
<pre><code>    UIViewAnimationOptionLayoutSubviews            = 1 &lt;&lt;  0,
    UIViewAnimationOptionAllowUserInteraction      = 1 &lt;&lt;  1, // turn on user interaction while animating
    UIViewAnimationOptionBeginFromCurrentState     = 1 &lt;&lt;  2, // start all views from current value, not initial value
    UIViewAnimationOptionRepeat                    = 1 &lt;&lt;  3, // repeat animation indefinitely
    UIViewAnimationOptionAutoreverse               = 1 &lt;&lt;  4, // if repeat, run animation back and forth
    UIViewAnimationOptionOverrideInheritedDuration = 1 &lt;&lt;  5, // ignore nested duration
    UIViewAnimationOptionOverrideInheritedCurve    = 1 &lt;&lt;  6, // ignore nested curve
    UIViewAnimationOptionAllowAnimatedContent      = 1 &lt;&lt;  7, // animate contents (applies to transitions only)
    UIViewAnimationOptionShowHideTransitionViews   = 1 &lt;&lt;  8, // flip to/from hidden state instead of adding/removing
    UIViewAnimationOptionOverrideInheritedOptions  = 1 &lt;&lt;  9, // do not inherit any options or animation type
</code></pre><h1 id="通过给视图添加物理效果实现动画"><a href="#通过给视图添加物理效果实现动画" class="headerlink" title="通过给视图添加物理效果实现动画"></a>通过给视图添加物理效果实现动画</h1><hr>
<p>添加物理效果主要需要三个元素：</p>
<ol>
<li>DynamicAnimator</li>
<li>UIGravityBehavior</li>
<li>遵守<uidynamicitem>协议的item(大部分情况是UIView)</uidynamicitem></li>
</ol>
<h2 id="DynamicAnimator：动力动画"><a href="#DynamicAnimator：动力动画" class="headerlink" title="DynamicAnimator：动力动画"></a>DynamicAnimator：动力动画</h2><pre><code>UIDynamicAnimator *animator =[ [ UIDynamicAnimator alloc] initWithReferenceView:aView]; //aview是动画Views的顶级视图
</code></pre><p>动力动画的初始化需要给其添加要进行动画的顶级视图，详细内容后面再介绍。</p>
<h2 id="UIDynamicBehavior：动力行为"><a href="#UIDynamicBehavior：动力行为" class="headerlink" title="UIDynamicBehavior：动力行为"></a>UIDynamicBehavior：动力行为</h2><p>动力行为分为重力动力行为，碰撞行为等具体的行为。<br>这个类有很多子类：</p>
<h3 id="1-UIGravityBehavior：重力行为"><a href="#1-UIGravityBehavior：重力行为" class="headerlink" title="1. UIGravityBehavior：重力行为"></a>1. UIGravityBehavior：重力行为</h3><pre><code>@property (readwrite, nonatomic) CGFloat angle;//重力方向
@property (readwrite, nonatomic) CGFloat magnitude; //重力加速度值
</code></pre><h3 id="2-UICollisionBehavior：碰撞行为"><a href="#2-UICollisionBehavior：碰撞行为" class="headerlink" title="2. UICollisionBehavior：碰撞行为"></a>2. UICollisionBehavior：碰撞行为</h3><pre><code>@property (nonatomic, readwrite) UICollisionBehaviorMode collisionMode;//互相碰撞弹开还是只是从边界碰撞弹开

@property (nonatomic, readwrite) BOOL translatesReferenceBoundsIntoBoundary; //是否是有弹性的边界
</code></pre><h3 id="3-UIAttachmentBehavior-：吸附行为"><a href="#3-UIAttachmentBehavior-：吸附行为" class="headerlink" title="3. UIAttachmentBehavior ：吸附行为"></a>3. UIAttachmentBehavior ：吸附行为</h3><pre><code>@property (readwrite, nonatomic) CGPoint anchorPoint; //设置锚点
- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item attachedToAnchor:(CGPoint)point;//将动力项吸附在锚点上
- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item1 attachedToItem:(id &lt;UIDynamicItem&gt;)item2;//吸附两个动力项
</code></pre><h3 id="4-UISnapBehavior：速甩行为"><a href="#4-UISnapBehavior：速甩行为" class="headerlink" title="4. UISnapBehavior：速甩行为"></a>4. UISnapBehavior：速甩行为</h3><pre><code>- (instancetype)initWithItem:(id &lt;UIDynamicItem&gt;)item snapToPoint:(CGPoint)point NS_DESIGNATED_INITIALIZER;
</code></pre><h3 id="5-UIPushBehavior：推动行为"><a href="#5-UIPushBehavior：推动行为" class="headerlink" title="5. UIPushBehavior：推动行为"></a>5. UIPushBehavior：推动行为</h3><pre><code>@property (nonatomic, readonly) UIPushBehaviorMode mode;
@property (readwrite, nonatomic) CGFloat magnitude;//推力
@property (readwrite, nonatomic) CGVector pushDirection;//推动方向
</code></pre><h3 id="6-UIDynamicItemBehavior：动力项行为"><a href="#6-UIDynamicItemBehavior：动力项行为" class="headerlink" title="6. UIDynamicItemBehavior：动力项行为"></a>6. UIDynamicItemBehavior：动力项行为</h3><pre><code>@property (readwrite, nonatomic) CGFloat elasticity; // Usually between 0 (inelastic) and 1 (collide elastically) 

@property (readwrite, nonatomic) CGFloat friction; // 0 being no friction between objects slide along each other

@property (readwrite, nonatomic) CGFloat density; // 1 by default

@property (readwrite, nonatomic) CGFloat resistance; // 0: no velocity damping

- (CGPoint)linearVelocityForItem:(id &lt;UIDynamicItem&gt;)item;//线速度
- (CGFloat)angularVelocityForItem:(id &lt;UIDynamicItem&gt;)item;//角速度
</code></pre><h2 id="遵守协议的item-大部分情况是UIView"><a href="#遵守协议的item-大部分情况是UIView" class="headerlink" title="遵守协议的item(大部分情况是UIView)"></a>遵守<uidynamicitem>协议的item(大部分情况是UIView)</uidynamicitem></h2><p>只要是遵守了<uidynamicitem>协议（动力项协议）的对象，都可以添加动力行为。</uidynamicitem></p>
<pre><code>id&lt;UIDynamicItem&gt;item1 = ....;
id&lt;UIDynamicItem&gt;item2 = ....;
[gravity addItem:itme2];
</code></pre><p>动力项协议的属性：</p>
<pre><code>@property (nonatomic, readwrite) CGPoint center;//动力项的中心

@property (nonatomic, readonly) CGRect bounds; //动力项的绘制区域，只读，通过变换，居中，移动进行修改

@property (nonatomic, readwrite) CGAffineTransform transform;//动力项的旋转或缩放比例
</code></pre><p>若想与animator的动画相抗争，需要调用animator的以下方法：</p>
<pre><code>- (void)updateItemUsingCurrentState:(id &lt;UIDynamicItem&gt;)item;
</code></pre><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>点击屏幕后，在顶部随机位置生成具有随机色的正方形，正方形显示后立即下落并停止。</li>
<li>方块排满的行会自动被炸飞，而且带动画。</li>
</ul>
<h2 id="Demo效果图"><a href="#Demo效果图" class="headerlink" title="Demo效果图"></a>Demo效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-6116d4bb61ba202a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：炸飞前 | 右：炸飞后"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><p>因为每个方块的动作行为都是一致的，所以在这里自定义了一个<code>UIDynamicBehavior</code>类，给每个方块增加相同的动作行为。</p>
<p><strong>1. 自定义统一行为类：DropItBehavior</strong></p>
<pre><code>- (instancetype)init
{
    self = [super init];    
   //重写初始化方法，同时增加重力和碰撞行为
    [self addChildBehavior:self.gravity];
    [self addChildBehavior:self.collider];
    return self;
}

//同时增加重力和碰撞行为
- (void)addItem:(id&lt;UIDynamicItem&gt;)item
{
    [self.gravity addItem:item];
    [self.collider addItem:item];
}

//同时移除重力和碰撞行为

- (void)removeItem:(id&lt;UIDynamicItem&gt;)item
{
    [self.gravity removeItem:item];
    [self.collider removeItem:item];
}

- (UIGravityBehavior *)gravity
{

    if (!_gravity) {

        _gravity = [[UIGravityBehavior alloc] init];
         //设置重力加速度
        _gravity.magnitude = 1.9;
    }
    return _gravity;
}

- (UICollisionBehavior *)collider
{
    if (!_collider) {
        _collider = [[UICollisionBehavior alloc] init];
        //触碰边缘弹性 
        _collider.translatesReferenceBoundsIntoBoundary = YES;
    }
    return _collider;
}
</code></pre><p><strong>2. 初始化animator</strong></p>
<pre><code>- (UIDynamicAnimator *)animator
{
    if (!_animator) {
        //self.gameView 是动画实现的顶级视图，它的子视图是掉落的方块
        _animator = [[UIDynamicAnimator alloc] initWithReferenceView:self.gameView];
    }
    return _animator;
}
</code></pre><p><strong>3. 给<code>UIDynamicAnimator</code>添加行为</strong></p>
<pre><code>
- (DropItBehavior *)dropitBehavior
{
    if (!_dropitBehavior) {
         _dropitBehavior = [[DropItBehavior alloc] init];
        [self.animator addBehavior:_dropitBehavior];
    }
    return _dropitBehavior;
}
</code></pre><p><strong>4. 生成随机方块并让其下落</strong></p>
<pre><code>/**
 *  生成随机方块并下落
 */
- (void)drop
{
    //1. 随机位置

    CGRect frame;
    frame.origin = CGPointZero;
    frame.size = DROP_SIZE;
    int x = (arc4random()%(int)self.gameView.bounds.size.width)/DROP_SIZE.width;
    frame.origin.x = x * DROP_SIZE.width;
    UIView *dropView = [[UIView alloc] initWithFrame:frame];

    //2. 随机颜色
    dropView.backgroundColor = [self randomColor];
    [self.gameView addSubview:dropView];

    //3. 添加下落
    [self.dropitBehavior addItem:dropView];
}
</code></pre><blockquote>
<p>目前小方块下落碰到障碍物后会旋转，所以容易让这些小方块散落成堆。这样一来，就不能计算好整行的排列情况，所以我们应该让小方块们没有旋转的特性。</p>
</blockquote>
<p><strong>5.取消旋转特性</strong></p>
<p>在公用的behavior类<code>DropItBehavior</code>里增加一个<code>UIDynamicItemBehavior</code>实例，取消其旋转特性。</p>
<pre><code>- (UIDynamicItemBehavior *)animationOptions
{
    if (!_animationOptions) {

        _animationOptions = [[UIDynamicItemBehavior alloc] init];
        _animationOptions.allowsRotation = NO;        
    }
    return _animationOptions;
}
</code></pre><p>这样就能整齐排列小方块了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-a6bc68132ab0425a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左：可旋转 | 右：不可旋转"></p>
<p><strong>6. 动画炸掉排满的行</strong></p>
<p>最好在方块都静止了之后再判断是否有排满的行，这里需要遵守协议<code>&lt;UIDynamicAnimatorDelegate&gt;</code></p>
<pre><code>
/**
 *  监听动力动画内部的所有动画停止后调用炸飞整行的方法
 *
 *  @param animator 动力动画
 */
- (void)dynamicAnimatorDidPause:(UIDynamicAnimator *)animator

{
    [self removeCompleteRows];
}
</code></pre><p>下面来看一下炸飞整行的方法：</p>
<pre><code>
/**
 *  炸飞整行的方法：包括查看是否存在整行的算法和炸飞整行的动画
 */
- (void)removeCompleteRows
{
    NSMutableArray *dropsToRemove = [[NSMutableArray alloc] init];

    //遍历每一行
    for (CGFloat y = self.gameView.bounds.size.height - DROP_SIZE.height/2;y &gt; 0;y-= DROP_SIZE.height) {

        BOOL rowIsComplete = YES;
        NSMutableArray *dropsFound = [[NSMutableArray alloc] init];

        for (CGFloat x = DROP_SIZE.width/2; x &lt; self.gameView.bounds.size.width - DROP_SIZE.width/2; x+=DROP_SIZE.width) {

            //移动(x,y)获取这个点所在的view
            UIView *hitView = [self.gameView hitTest:CGPointMake(x, y) withEvent:NULL];

            if ([hitView superview] == self.gameView) {

                //如果获取的view的父视图是gameView,就说明它是方块
                [dropsFound addObject:hitView];

            }else{

                //否则这个行肯定是不完整的
                rowIsComplete = NO;
                break;
            }
        }

        if (![dropsFound count]) break;
        if (rowIsComplete)[dropsToRemove addObjectsFromArray:dropsFound];

    }    

    //如果有排满的行，则炸掉它
    if ([dropsToRemove count]){
        for (UIView *drop in dropsToRemove){
            [self.dropitBehavior removeItem:drop];
        }
        [self animatedRemovingDrops:dropsToRemove];
    }
}

/**
 *  炸飞整行
 *
 *  @param dropsToRemove 需要炸飞的View的数组
 */

- (void)animatedRemovingDrops:(NSArray *)dropsToRemove
{
    [UIView animateWithDuration:0.5 animations:^{

        for (UIView *drop in dropsToRemove) {

            //设定炸飞后终点的位置
            int x = (arc4random()%(int)(self.gameView.bounds.size.width*5)) - (int)self.gameView.bounds.size.width*2;
            int y = self.gameView.bounds.size.height;
            drop.center = CGPointMake(x,-y);

        }

    } completion:^(BOOL finished) {

        [dropsToRemove makeObjectsPerformSelector:@selector(removeFromSuperview)];

    }];
}
</code></pre><h1 id="思考一下"><a href="#思考一下" class="headerlink" title="思考一下"></a>思考一下</h1><hr>
<p>关于通过给view添加物理效果的方法添加动画，需要弄清楚<code>DynamicAnimator</code>,<code>UIDynamicBehavior</code>和遵守<uidynamicitem>协议的item三者之间的关系。</uidynamicitem></p>
<p>通过对代码的分析以及讲师的讲解，笔者将这三者以比喻的方法将他们的关系梳理了一下：</p>
<ul>
<li><code>DynamicAnimator</code>:代表了一个游乐场。</li>
<li><code>UIDynamicBehavior</code>：代表了游乐场里的娱乐设施。</li>
<li>遵守<uidynamicitem>协议的item：代表了去游乐场玩儿的小孩。</uidynamicitem></li>
</ul>
<p>我们从代码看一下如何映射他们的关系：</p>
<h4 id="DynamicAnimator"><a href="#DynamicAnimator" class="headerlink" title="DynamicAnimator"></a>DynamicAnimator</h4><p><code>UIDynamicAnimator *animator =[ [ UIDynamicAnimator alloc] initWithReferenceView:aView];</code><br>在这里，<code>aView</code>代表了一片空地，这句话的意思是我们把游乐场建在了这片空地上。</p>
<h4 id="UIDynamicBehavior"><a href="#UIDynamicBehavior" class="headerlink" title="UIDynamicBehavior"></a>UIDynamicBehavior</h4><p><code>[self.animator addBehavior:_dropitBehavior];</code><br>在这里，代表了我们在这个游乐场里增加了某个娱乐设施。</p>
<h4 id="遵守协议的item"><a href="#遵守协议的item" class="headerlink" title="遵守协议的item"></a>遵守<uidynamicitem>协议的item</uidynamicitem></h4><pre><code>- (void)addItem:(id&lt;UIDynamicItem&gt;)item
{
    [self.gravity addItem:item];
    [self.collider addItem:item];
}
</code></pre><p>在这里，代表了我们让某个小孩来玩儿某个娱乐设施。</p>
<p>这样就理清了：我们要让一个小孩玩儿一个娱乐设施就应该:</p>
<ol>
<li>找一片空地建设游乐场。</li>
<li>在游乐场引进娱乐设备。</li>
<li>孩子来玩儿这个娱乐设备。</li>
</ol>
<p>笔者在开始看到这三者的相关代码的时候略懵逼，不知道为什么会这么设计，但是用了“比喻法”之后，顿时豁然开朗了~</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课介绍了协议，block，动画的相关知识，最后结合了这些知识点展示了一个类似&lt;strong&gt;俄罗斯方块&lt;/strong&gt;的小游戏Demo。&lt;br&gt;总体来说本节课的内容比较重要，稍微摆脱了UI层面的知识，对于初学者来说理解起来不是很容易，不过笔者会尽量详细地讲解给大家。&lt;
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（七）：自定义视图，手势识别，绘制纸牌Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E5%9B%BE%EF%BC%8C%E6%89%8B%E5%8A%BF%E8%AF%86%E5%88%AB%EF%BC%8C%E7%BB%98%E5%88%B6%E7%BA%B8%E7%89%8CDemo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（七）：自定义视图，手势识别，绘制纸牌Demo/</id>
    <published>2017-01-11T07:16:20.000Z</published>
    <updated>2017-01-11T08:43:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>本节课介绍了UIView的一些知识，自定义UIView的方法以及手势识别。最后应用本节所讲的大部分知识点向我们演示了一个绘制纸牌的Demo。</p>
<h1 id="UIView"><a href="#UIView" class="headerlink" title="UIView"></a>UIView</h1><hr>
<h2 id="关于UIView，你需要知道的零散知识"><a href="#关于UIView，你需要知道的零散知识" class="headerlink" title="关于UIView，你需要知道的零散知识"></a>关于UIView，你需要知道的零散知识</h2><ul>
<li>视图是可以多层嵌套的。</li>
<li>每个视图可以有多个子视图，但是只能有一个父视图。</li>
<li>控制器的view属性指向自己的顶级视图。</li>
<li>令视图透明会加大系统的开销。</li>
<li>通过判断控制器view的<code>self.view.window</code>是否存在来判断控制器view是否被显示出来。</li>
</ul>
<h2 id="UIView的一些属性和方法"><a href="#UIView的一些属性和方法" class="headerlink" title="UIView的一些属性和方法"></a>UIView的一些属性和方法</h2><pre><code>@property CGFloat contentScaleFactor; //返回每个点所有的像素数 ：非retina为1，retina为2

- (UIView *)superView; //指向自己的父视图
- (NSArray *)subview; //自己的所有子视图的数组

- (void)addSubview: (Uiview *)aView;// 发送给目标父视图，让其把aView作为自己的子视图
- (void)removeFromSuperview;  //消息发送给要移除的vie
</code></pre><h2 id="View的初始化方法："><a href="#View的初始化方法：" class="headerlink" title="View的初始化方法："></a>View的初始化方法：</h2><pre><code>- (void)awakeFromNib {[self setup];}  //通过故事版创建的View的初始化
- (id)initWithFrame: (CGRect)aRect    //通过纯代码创建的View的初始化
{
     self = [super initWithFrame:aRect];
     [self setup];
     return self;
}

- (void)setup {....};
</code></pre><h2 id="Custom-View-自定义视图"><a href="#Custom-View-自定义视图" class="headerlink" title="Custom View 自定义视图"></a>Custom View 自定义视图</h2><p>在iOS中，自定义是图的方法是创建一个UIView的子类并重写 <code>- (void)drawInRect:(Rect)rect</code>方法。</p>
<blockquote>
<p>注意：永远都不要自己调用这个方法，要交给系统负责！<br>可以调用以下的方法，告诉系统这个视图要被重绘：</p>
<pre><code>- (void)setNeedsDisplay;
- (void)setNeedsDisplayInRect: (CGRect)aRect
</code></pre></blockquote>
<p>那么具体怎样重写 <code>- (void)drawInRect:(Rect)rect</code>方法来绘图呢？<br>答：应用Core Graphics的相关知识。</p>
<h2 id="Core-Graphics"><a href="#Core-Graphics" class="headerlink" title="Core Graphics"></a>Core Graphics</h2><p>Core Graphics是一套基于C的API框架，使用了Quartz作为绘图引擎，使用Core Graphics，可以创建直线、路径、渐变、文字与图像等内容，并可以做变形处理。</p>
<h3 id="Core-Grephics的工作步骤："><a href="#Core-Grephics的工作步骤：" class="headerlink" title="Core Grephics的工作步骤："></a>Core Grephics的工作步骤：</h3><ol>
<li>取得图形上下文。</li>
<li>设置绘图路径(利用UIBezierPath)。</li>
<li>设置颜色。</li>
<li>用颜色填充路径 。</li>
</ol>
<p>各位看官不用着急，具体方法在最后的Demo代码里给大家呈现。</p>
<h1 id="UIGestureRecoginizer-：手势识别抽象类"><a href="#UIGestureRecoginizer-：手势识别抽象类" class="headerlink" title="UIGestureRecoginizer ：手势识别抽象类"></a>UIGestureRecoginizer ：手势识别抽象类</h1><hr>
<p><strong>简单介绍</strong>：<code>UIGestureRecoginizer</code>是一个抽象类，它的各种子类可以用于识别各种不同的手势：如捏合，滑动等等。通过识别各种不同的手势，实现各种交互操作。</p>
<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><ol>
<li>在视图中添加手势识别对象。</li>
<li>提供手势发生时所需要调用的方法。</li>
</ol>
<h2 id="手势种类："><a href="#手势种类：" class="headerlink" title="手势种类："></a>手势种类：</h2><p><strong>1. UIPanGestureRecognizer ： 拖动手势</strong></p>
<pre><code>- (void)setPannableView:(UIView*)pannableView
{
     _pannableView = pananbleView;
     UIPanGestureRecognizer *pangr = [UIPanGestureRecognizer alloc] initWithTarget:pannableView action: @selector(pan:)];
     [pannableView addGestureRecognnizer:panr];
}
</code></pre><p><strong>2. UIPinchGestureReccognizer ：捏合手势</strong></p>
<pre><code>@property CGFloat scale;   捏合手势距离
@property (readonly) CGFloat velocity; 每分钟变化的速度
</code></pre><p><strong>3. UIRotationGestureRecgnizer 旋转手势</strong></p>
<pre><code>@property CGFloat rotation;   弧度
@property (readonly) CGFloat velocity; 每秒变化的速度
</code></pre><p><strong>4. UISwipeGestureRecgnizer ： 滑动手势</strong></p>
<pre><code>@property UISwipeGestureRecognizerDirection direction 滑动方向
@property NSUInteger numberOfTouchesRequired; 几只手指来完成
</code></pre><p><strong>5. UITapGestureRecognizer ：点击手势</strong></p>
<pre><code>@property NSUInteger numberOfTapsReqired；几次点击
@property NSUInteger numberOfTouchesRequired;     几只手指来完成
</code></pre><blockquote>
<p>以上第4，5项手势是非连续手势；1，2，3属于连续手势。<br>注意区分滑动手势和拖动手势。滑动手势是指短促，快速地滑动的手势，而拖动手势是相对较慢，路径较长的手势。</p>
</blockquote>
<h1 id="绘制纸牌Demo"><a href="#绘制纸牌Demo" class="headerlink" title="绘制纸牌Demo"></a>绘制纸牌Demo</h1><hr>
<h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul>
<li>绘制一张纸拍放到屏幕上，包括正面和背面。</li>
<li>滑动手势可以翻牌。</li>
<li>捏合手势可以伸缩纸牌正面的图案大小。</li>
</ul>
<h2 id="Demo效果图"><a href="#Demo效果图" class="headerlink" title="Demo效果图"></a>Demo效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-aedaf67a6c46a092.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左二图：翻牌 | 右二图：伸缩"></p>
<h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-绘制纸牌正反面"><a href="#1-绘制纸牌正反面" class="headerlink" title="1. 绘制纸牌正反面"></a>1. 绘制纸牌正反面</h4><pre><code>- (void)drawRect:(CGRect)rect {

    //初始化一个圆角矩形
    UIBezierPath *roundRect = [UIBezierPath bezierPathWithRoundedRect:self.bounds cornerRadius:[self cornerRadius]];

    //裁剪，保证不会绘制四角
    [roundRect addClip];

    //填充白色
    [[UIColor whiteColor] setFill];
     UIRectFill(self.bounds);

    //轮廓
    [[UIColor blackColor] setStroke];
    [roundRect stroke];

    if (self.faceUp) {

        //1. 纸牌正面
        //1.1 纸牌正面中间的图
        UIImage *faceImage = [UIImage imageNamed:[NSString stringWithFormat:@&quot;%@%@&quot;,[self rankAsString],self.suit]];

        if (faceImage) {

            CGRect imageRect = CGRectInset(self.bounds, self.bounds.size.width * (1.0 - self.faceCardScaleFactor) + 20, self.bounds.size.height * ( 1.0 - self.faceCardScaleFactor  ) + 20);
            [faceImage drawInRect:imageRect];
        }

        //1.2 纸牌正面四个角
        [self drawCorners];

    }else{

        //2. 纸牌背面
        [[UIImage imageNamed:@&quot;cardBack&quot;] drawInRect:self.bounds];
    }
}
</code></pre><h4 id="2-绘制纸牌边角的花色和数字"><a href="#2-绘制纸牌边角的花色和数字" class="headerlink" title="2. 绘制纸牌边角的花色和数字"></a>2. 绘制纸牌边角的花色和数字</h4><pre><code>- (void)drawCorners
{    
    //设定段落排列
    NSMutableParagraphStyle *paragraphStype = [[NSMutableParagraphStyle alloc] init];
    paragraphStype.alignment = NSTextAlignmentCenter;

   //设定字体
    UIFont *cornerFont = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];
    cornerFont = [cornerFont fontWithSize:cornerFont.pointSize * [self cornerScaleFactor]]; 

    //角落文字
    NSAttributedString *cornerText = [[NSAttributedString alloc] initWithString:[NSString stringWithFormat:@&quot;%@\n%@&quot;, [self rankAsString], self.suit] attributes:@{NSFontAttributeName:cornerFont,NSParagraphStyleAttributeName:paragraphStype}];

    //左上角
    //1. 获得图片的rect
    CGRect textBounds;
    textBounds.origin = CGPointMake([self cornerOffset], [self cornerOffset]);
    textBounds.size = [cornerText size];

     //2.绘制文字
    [cornerText drawInRect:textBounds];

    //右下角
    //1. 获取上下文
    CGContextRef context = UIGraphicsGetCurrentContext();
    // 2. 移动上下文
    CGContextTranslateCTM(context, self.bounds.size.width, self.bounds.size.height);
     //3. 翻转上下文（翻转180度）
    CGContextRotateCTM(context, M_PI);
     //4. 绘制
    [cornerText drawInRect:textBounds];
}
</code></pre><blockquote>
<p>我们可以看到，图片和文字的绘图方法都是可以通过<code>drawInRect:</code>方法来进行：通过传入需要绘制的<code>rect</code>，可以让系统根据原始的素材（图片，文字）来绘图。</p>
</blockquote>
<h4 id="3-添加手势：连线方式"><a href="#3-添加手势：连线方式" class="headerlink" title="3. 添加手势：连线方式"></a>3. 添加手势：连线方式</h4><pre><code>/**
 *  滑动手势翻转牌
 *
 *  @param sender 滑动手势
 */

- (IBAction)swipe:(id)sender {

   //翻转牌面
    self.playCardView.faceUp  = !self.playCardView.faceUp;

}
</code></pre><h4 id="4-添加手势：代码方式"><a href="#4-添加手势：代码方式" class="headerlink" title="4. 添加手势：代码方式"></a>4. 添加手势：代码方式</h4><pre><code>//1. 添加捏合手势
 [self.playCardView addGestureRecognizer:[[UIPinchGestureRecognizer alloc] initWithTarget:self.playCardView
                                                                                    action:@selector(pinch:)]];

/**
 *  2. 捏合手势调用的方法
 *
 *  @param gesture 捏合手势
 */

- (void)pinch:(UIPinchGestureRecognizer *)gesture
{
    if (gesture.state == UIGestureRecognizerStateChanged || gesture.state == UIGestureRecognizerStateEnded) {
       //根据捏合的程度来伸缩图片
        self.faceCardScaleFactor *= gesture.scale;
        gesture.scale = 1.0;

    }
}
</code></pre><blockquote>
<p>在手势识别调用的方法里，我们需要对手势本身的状态加以判断以确保各种交互的实现都是正确的。</p>
</blockquote>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p>
<p>本文为笔者原创，如需转载，请事先与笔者交涉~</p>
<h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr>
<p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课介绍了UIView的一些知识，自定义UIView的方法以及手势识别。最后应用本节所讲的大部分知识点向我们演示了一个绘制纸牌的Demo。&lt;/p&gt;
&lt;h1 id=&quot;UIView&quot;&gt;&lt;a href=&quot;#UIView&quot; class=&quot;headerlink&quot; title=&quot;UI
    
    </summary>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>

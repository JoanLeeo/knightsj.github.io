<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J_Knight_</title>
  
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/knightsj/knightsj.github.io/"/>
  <updated>2018-10-21T12:25:33.536Z</updated>
  <id>https://github.com/knightsj/knightsj.github.io/</id>
  
  <author>
    <name>J_Knight_</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象设计的六大设计原则（附 Demo 及 UML 类图）</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/09/09/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%85%AD%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%EF%BC%88%E9%99%84%20Demo%20%E5%8F%8A%20UML%20%E7%B1%BB%E5%9B%BE%EF%BC%89/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/09/09/面向对象设计的六大设计原则（附 Demo 及 UML 类图）/</id>
    <published>2018-09-09T14:56:38.000Z</published>
    <updated>2018-10-21T12:25:33.536Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/oodbanner.png" alt=""></p><h1 id="学习初衷与讲解方式"><a href="#学习初衷与讲解方式" class="headerlink" title="学习初衷与讲解方式"></a>学习初衷与讲解方式</h1><p>笔者想在 iOS 从业第三年结束之前系统学习一下关于设计模式方面的知识。而在学习设计模式之前，觉得更有必要先学习面向对象设计（OOD：Object Oriented Design）的几大设计原则，为后面设计模式的学习打下基础。</p><p>本篇分享的就是笔者近阶段学习和总结的面向对象设计的六个设计原则：</p><table><thead><tr><th>缩写</th><th>英文名称</th><th>中文名称</th></tr></thead><tbody><tr><td>SRP</td><td>Single Responsibility Principle</td><td>单一职责原则</td></tr><tr><td>OCP</td><td>Open Close Principle</td><td>开闭原则</td></tr><tr><td>LSP</td><td>Liskov Substitution Principle</td><td>里氏替换原则</td></tr><tr><td>LoD</td><td>Law of Demeter （ Least Knowledge Principle）</td><td>迪米特法则（最少知道原则）</td></tr><tr><td>ISP</td><td>Interface Segregation Principle</td><td>接口分离原则</td></tr><tr><td>DIP</td><td>Dependency Inversion Principle</td><td>依赖倒置原则</td></tr></tbody></table><a id="more"></a><blockquote><p>注意，通常所说的<code>SOLID</code>（上方表格缩写的首字母，从上到下）设计原则没有包含本篇介绍的迪米特法则，而只有其他五项。另外，本篇不包含合成/聚合复用原则(CARP)，因为笔者认为该原则没有其他六个原则典型，而且在实践中也不容易违背。有兴趣的同学可以自行查资料学习。</p></blockquote><p>在下一章节笔者将分别讲解这些设计原则，讲解的方式是将概念与代码及其对应的UML 类图结合起来讲解的方式。</p><p>代码的语言使用的是笔者最熟悉的Objective-C语言。虽然是一个比较小众的语言，但是因为有 UML 类图的帮助，而且主流的面向对象语言关于类，接口（Objective-C里面是协议）的使用在形式上类似，所以笔者相信语言的小众不会对知识的理解产生太大的阻力。</p><p>另外，在每个设计模式的讲解里，笔者会首先描述一个应用场景（需求点），接着用<strong>两种设计的代码来进行对比</strong>讲解：先提供相对不好的设计的代码，再提供相对好的设计的代码。而且两种代码都会附上标准的 UML 类图来进行更形象地对比，帮助大家来理解。同时也可以帮助不了解 UML 类图的读者先简单熟悉一下 UML 类图的语法。</p><h1 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h1><p>本篇讲解六大设计原则的顺序大致按照难易程序排列。在这里最先讲解开闭原则，因为其在理解上比较简单，而且也是其他设计原则的基石。</p><blockquote><p>注意：</p><ol><li>六个原则的讲解所用的例子之间并没有关联，所以阅读顺序可以按照读者的喜好来定。</li><li>Java语言里的接口在Objective-C里面叫做协议。虽然Demo是用Objective-C写的，但是因为协议的叫法比较小众，故后面一律用接口代替协议这个说法。</li></ol></blockquote><h2 id="原则一：开闭原则（Open-Close-Principle）"><a href="#原则一：开闭原则（Open-Close-Principle）" class="headerlink" title="原则一：开闭原则（Open Close Principle）"></a>原则一：开闭原则（Open Close Principle）</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.</p></blockquote><p>即：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><h3 id="定义的解读"><a href="#定义的解读" class="headerlink" title="定义的解读"></a>定义的解读</h3><ul><li>用抽象构建框架，用实现扩展细节。</li><li>不以改动原有类的方式来实现新需求，而是应该以实现事先抽象出来的接口（或具体类继承抽象类）的方式来实现。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>实践开闭原则的优点在于可以在不改动原有代码的前提下给程序扩展功能。增加了程序的可扩展性，同时也降低了程序的维护成本。</p><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>下面通过一个简单的关于在线课程的例子讲解一下开闭原则的实践。</p><h4 id="需求点"><a href="#需求点" class="headerlink" title="需求点"></a>需求点</h4><p>设计一个在线课程类：</p><p>由于教学资源有限，开始的时候只有类似于博客的，通过文字讲解的课程。<br>但是随着教学资源的增多，后来增加了视频课程，音频课程以及直播课程。</p><p>先来看一下不好的设计：</p><h4 id="不好的设计"><a href="#不好的设计" class="headerlink" title="不好的设计"></a>不好的设计</h4><p>最开始的文字课程类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Course.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Course</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *courseTitle;         <span class="comment">//课程名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *courseIntroduction;  <span class="comment">//课程介绍</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *teacherName;         <span class="comment">//讲师姓名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *content;             <span class="comment">//课程内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p><code>Course</code>类声明了最初的在线课程所需要包含的数据：</p><ul><li>课程名称</li><li>课程介绍</li><li>讲师姓名</li><li>文字内容</li></ul><p>接着按照上面所说的需求变更：增加了视频，音频，直播课程：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Course.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Course</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *courseTitle;         <span class="comment">//课程名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *courseIntroduction;  <span class="comment">//课程介绍</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *teacherName;         <span class="comment">//讲师姓名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *content;             <span class="comment">//文字内容</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//新需求：视频课程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *videoUrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新需求：音频课程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *audioUrl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新需求：直播课程</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *liveUrl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>三种新增的课程都在原<code>Course</code>类中添加了对应的url。也就是每次添加一个新的类型的课程，都在原有<code>Course</code>类里面修改：新增这种课程需要的数据。</p><p>这就导致：我们从<code>Course</code>类实例化的视频课程对象会包含并不属于自己的数据：<code>audioUrl</code>和<code>liveUrl</code>：这样就造成了冗余，视频课程对象并不是纯粹的视频课程对象，它包含了音频地址，直播地址等成员。</p><p>很显然，这个设计不是一个好的设计，因为（对应上面两段叙述）：</p><ol><li>随着需求的增加，需要反复修改之前创建的类。</li><li>给新增的类造成了不必要的冗余。</li></ol><p>之所以会造成上述两个缺陷，是因为该设计<strong>没有遵循对修改关闭，对扩展开放的开闭原则</strong>，而是反其道而行之：开放修改，而且不给扩展提供便利。</p><p>难么怎么做可以遵循开闭原则呢？下面看一下遵循开闭原则的较好的设计：</p><h4 id="较好的设计"><a href="#较好的设计" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>首先在<code>Course</code>类中仅仅保留所有课程都含有的数据：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Course.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Course</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *courseTitle;         <span class="comment">//课程名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *courseIntroduction;  <span class="comment">//课程介绍</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *teacherName;         <span class="comment">//讲师姓名</span></span><br></pre></td></tr></table></figure><p>接着，针对文字课程，视频课程，音频课程，直播课程这三种新型的课程采用继承<code>Course</code>类的方式。而且继承后，添加自己独有的数据：</p><p>文字课程类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== TextCourse.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TextCourse</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *content;             <span class="comment">//文字内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>视频课程类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== VideoCourse.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">VideoCourse</span> : <span class="title">Course</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *videoUrl;            <span class="comment">//视频地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>音频课程类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== AudioCourse.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AudioCourse</span> : <span class="title">Course</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *audioUrl;            <span class="comment">//音频地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>直播课程类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== LiveCourse.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">LiveCourse</span> : <span class="title">Course</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *liveUrl;             <span class="comment">//直播地址</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>这样一来，上面的两个问题都得到了解决：</p><ol><li>随着课程类型的增加，不需要反复修改最初的父类（<code>Course</code>），只需要新建一个继承于它的子类并在子类中添加仅属于该子类的数据（或行为）即可。</li><li>因为各种课程独有的数据（或行为）都被分散到了不同的课程子类里，所以每个子类的数据（或行为）没有任何冗余。</li></ol><p>而且对于第二点：或许今后的视频课程可以有高清地址，视频加速功能。而这些功能只需要在<code>VideoCourse</code>类里添加即可，因为它们都是视频课程所独有的。同样地，直播课程后面还可以支持在线问答功能，也可以仅加在<code>LiveCourse</code>里面。</p><p>我们可以看到，正是由于最初程序设计合理，所以对后面需求的增加才会处理得很好。</p><p>下面来看一下这两个设计的UML 类图，可以更形象地看出两种设计上的区别：</p><h4 id="UML-类图对比"><a href="#UML-类图对比" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践开闭原则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/OCP11.png" alt="未实践开闭原则"></p><p>实践了开闭原则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/OCP2.png" alt="实践了开闭原则"></p><blockquote><p>在实践了开闭原则的 UML 类图中，四个课程类继承了<code>Course</code>类并添加了自己独有的属性。（在 UML 类图中：实线空心三角箭头代表继承关系：由子类指向其父类）</p></blockquote><h3 id="如何实践"><a href="#如何实践" class="headerlink" title="如何实践"></a>如何实践</h3><p>为了更好地实践开闭原则，在设计之初就要想清楚在该场景里哪些数据（或行为）是一定不变（或很难再改变）的，哪些是很容易变动的。将后者抽象成接口或抽象方法，以便于在将来通过创造具体的实现应对不同的需求。</p><h2 id="原则二：单一职责原则（Single-Responsibility-Principle）"><a href="#原则二：单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="原则二：单一职责原则（Single Responsibility Principle）"></a>原则二：单一职责原则（Single Responsibility Principle）</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>A class should have a single responsibility, where a responsibility is nothing but a reason to change.</p></blockquote><p>即：一个类只允许有一个职责，即只有一个导致该类变更的原因。</p><h3 id="定义的解读-1"><a href="#定义的解读-1" class="headerlink" title="定义的解读"></a>定义的解读</h3><ul><li><p>类职责的变化往往就是导致类变化的原因：也就是说如果一个类具有多种职责，就会有多种导致这个类变化的原因，从而导致这个类的维护变得困难。</p></li><li><p>往往在软件开发中随着需求的不断增加，可能会给原来的类添加一些本来不属于它的一些职责，从而违反了单一职责原则。如果我们发现当前类的职责不仅仅有一个，就应该将本来不属于该类真正的职责分离出去。</p></li><li>不仅仅是类，函数（方法）也要遵循单一职责原则，即：一个函数（方法）只做一件事情。如果发现一个函数（方法）里面有不同的任务，则需要将不同的任务以另一个函数（方法）的形式分离出去。</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>如果类与方法的职责划分得很清晰，不但可以提高代码的可读性，更实际性地更降低了程序出错的风险，因为清晰的代码会让bug无处藏身，也有利于bug的追踪，也就是降低了程序的维护成本。</p><h3 id="代码讲解-1"><a href="#代码讲解-1" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>单一职责原则的demo比较简单，通过对象（属性）的设计上讲解已经足够，不需要具体的客户端调用。我们先看一下需求点：</p><h4 id="需求点-1"><a href="#需求点-1" class="headerlink" title="需求点"></a>需求点</h4><p>初始需求：需要创造一个员工类，这个类有员工的一些基本信息。</p><p>新需求：增加两个方法：</p><ul><li>判定员工在今年是否升职</li><li>计算员工的薪水</li></ul><p>先来看一下不好的设计：</p><h4 id="不好的设计-1"><a href="#不好的设计-1" class="headerlink" title="不好的设计"></a>不好的设计</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Employee.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Employee</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//============ 初始需求 ============</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;       <span class="comment">//员工姓名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *address;    <span class="comment">//员工住址</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *employeeID; <span class="comment">//员工ID</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">//============ 新需求 ============</span></span><br><span class="line"><span class="comment">//计算薪水</span></span><br><span class="line">- (<span class="keyword">double</span>)calculateSalary;</span><br><span class="line"></span><br><span class="line"><span class="comment">//今年是否晋升</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)willGetPromotionThisYear;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>由上面的代码可以看出：</p><ul><li>在初始需求下，我们创建了<code>Employee</code>这个员工类，并声明了3个员工信息的属性：员工姓名，地址，员工ID。</li><li>在新需求下，两个方法直接加到了员工类里面。</li></ul><p>新需求的做法看似没有问题，因为都是和员工有关的，但却违反了单一职责原则：<strong>因为这两个方法并不是员工本身的职责</strong>。</p><ul><li><code>calculateSalary</code>这个方法的职责是属于会计部门的：薪水的计算是会计部门负责。</li><li><code>willPromotionThisYear</code>这个方法的职责是属于人事部门的：考核与晋升机制是人事部门负责。</li></ul><p>而上面的设计将本来不属于员工自己的职责强加进了员工类里面，而这个类的设计初衷（原始职责）就是单纯地保留员工的一些信息而已。因此这么做就是给这个类引入了新的职责，故<strong>此设计违反了单一职责原则</strong>。</p><p>我们可以简单想象一下这么做的后果是什么：如果员工的晋升机制变了，或者税收政策等影响员工工资的因素变了，我们还需要修改当前这个类。</p><p>那么怎么做才能不违反单一职责原则呢？- 我们需要将这两个方法（责任）分离出去，让本应该处理这类任务的类来处理。</p><h4 id="较好的设计-1"><a href="#较好的设计-1" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>我们保留员工类的基本信息：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Employee.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Employee</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始需求</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *address;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *employeeID;</span><br></pre></td></tr></table></figure></p><p>然后创建新的<strong>会计部门</strong>类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== FinancialApartment.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Employee.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//会计部门类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FinancialApartment</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算薪水</span></span><br><span class="line">- (<span class="keyword">double</span>)calculateSalary:(Employee *)employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>和<strong>人事部门</strong>类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== HRApartment.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Employee.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//人事部门类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">HRApartment</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//今年是否晋升</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)willGetPromotionThisYear:(Employee*)employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>通过创建了两个分别专门处理薪水和晋升的部门，会计部门和人事部门的类：<code>FinancialApartment</code> 和 <code>HRApartment</code>，把两个任务（责任）分离了出去，让本该处理这些职责的类来处理这些职责。</p><p>这样一来，不仅仅在此次新需求中满足了单一职责原则，以后如果还要增加人事部门和会计部门处理的任务，就可以直接在这两个类里面添加即可。</p><p>下面来看一下这两个设计的UML 类图，可以更形象地看出两种设计上的区别：</p><h4 id="UML-类图对比-1"><a href="#UML-类图对比-1" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践单一职责原则：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/SRP11.png" alt="未实践单一职责原则"></p><p>实践了单一职责原则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/SRP2.png" alt="实践了单一职责原则"></p><blockquote><p>可以看到，在实践了单一职责原则的 UML 类图中，不属于<code>Employee</code>的两个职责被分类了<code>FinancialApartment</code>类 和 <code>HRApartment</code>类。（在 UML 类图中，虚线箭头表示依赖关系，常用在方法参数等，由依赖方指向被依赖方）</p></blockquote><p>上面说过除了类要遵循单一职责设计原则之外，在函数（方法）的设计上也要遵循单一职责的设计原则。因函数（方法）的单一职责原则理解起来比较容易，故在这里就不提供Demo和UML 类图了。</p><p>可以简单举一个例子：</p><p>APP的默认导航栏的样式是这样的：</p><ul><li>白色底</li><li>黑色标题</li><li>底部有阴影</li></ul><p>那么创建默认导航栏的伪代码可能是这样子的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认样式的导航栏</span></span><br><span class="line">- (<span class="keyword">void</span>)createDefaultNavigationBarWithTitle:(<span class="built_in">NSString</span> *)title&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create white color background view</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create black color title</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create shadow bottom</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们可以用这个方法统一创建默认的导航栏了。<br>但是过不久又有新的需求来了，有的页面的导航栏需要做成透明的，因此需要一个透明样式的导航栏：</p><ul><li>透明底</li><li>白色标题</li><li>底部无阴影</li></ul><p>针对这个需求，我们可以新增一个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//透明样式的导航栏</span></span><br><span class="line">- (<span class="keyword">void</span>)createTransParentNavigationBarWithTitle:(<span class="built_in">NSString</span> *)title&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create transparent color background view</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//create white color title</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看出问题来了么？在这两个方法里面，创造background view和 title color title的方法的差别仅仅是颜色不同而已，而其他部分的代码是重复的。<br>因此我们应该将这两个方法抽出来：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据传入的颜色参数设置导航栏的背景色</span></span><br><span class="line">- (<span class="keyword">void</span>)createBackgroundViewWithColor:(<span class="built_in">UIColor</span>)color;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据传入的标题字符串和颜色参数设置标题</span></span><br><span class="line">- (<span class="keyword">void</span>)createTitlewWithColorWithTitle:(<span class="built_in">NSString</span> *)title color:(<span class="built_in">UIColor</span>)color;</span><br></pre></td></tr></table></figure><p>而且上面的制造阴影的部分也可以作为方法抽出来：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)createShadowBottom;</span><br></pre></td></tr></table></figure><p>这样一来，原来的两个方法可以写成：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认样式的导航栏</span></span><br><span class="line">- (<span class="keyword">void</span>)createDefaultNavigationBarWithTitle:(<span class="built_in">NSString</span> *)title&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置白色背景</span></span><br><span class="line">    [<span class="keyword">self</span> createBackgroundViewWithColor:[<span class="built_in">UIColor</span> whiteColor]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置黑色标题</span></span><br><span class="line">    [<span class="keyword">self</span> createTitlewWithColorWithTitle:title color:[<span class="built_in">UIColor</span> blackColor]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置底部阴影</span></span><br><span class="line">    [<span class="keyword">self</span> createShadowBottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//透明样式的导航栏</span></span><br><span class="line">- (<span class="keyword">void</span>)createTransParentNavigationBarWithTitle:(<span class="built_in">NSString</span> *)title&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置透明背景</span></span><br><span class="line">    [<span class="keyword">self</span> createBackgroundViewWithColor:[<span class="built_in">UIColor</span> clearColor]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置白色标题</span></span><br><span class="line">    [<span class="keyword">self</span> createTitlewWithColorWithTitle:title color:[<span class="built_in">UIColor</span> whiteColor]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且我们也可以将里面的方法拿出来在外面调用也可以：</p><p>设置默认样式的导航栏：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置白色背景</span></span><br><span class="line">[navigationBar createBackgroundViewWithColor:[<span class="built_in">UIColor</span> whiteColor]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置黑色标题</span></span><br><span class="line">[navigationBar createTitlewWithColorWithTitle:title color:[<span class="built_in">UIColor</span> blackColor]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置阴影</span></span><br><span class="line">[navigationBar createShadowBottom];</span><br></pre></td></tr></table></figure></p><p>设置透明样式的导航栏:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置透明色背景</span></span><br><span class="line">[navigationBar createBackgroundViewWithColor:[<span class="built_in">UIColor</span> clearColor]];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置白色标题</span></span><br><span class="line">[navigationBar createTitlewWithColorWithTitle:title color:[<span class="built_in">UIColor</span> whiteColor]];</span><br></pre></td></tr></table></figure></p><p>这样一来，无论写在一个大方法里面调用或是分别在外面调用，都能很清楚地看到导航栏的每个元素是如何生成的，因为每个职责都分配到了一个单独的方法里面。而且还有一个好处是，透明导航栏如果遇到浅色背景的话，使用白色字体不如使用黑色字体好，所以遇到这种情况我们可以在<code>createTitlewWithColorWithTitle:color:</code>方法里面传入黑色色值。<br>而且今后可能还会有更多的导航栏样式，那么我们只需要分别改变传入的色值即可，不需要有大量的重复代码了，修改起来也很方便。</p><h3 id="如何实践-1"><a href="#如何实践-1" class="headerlink" title="如何实践"></a>如何实践</h3><p>对于上面的员工类的例子，或许是因为我们先入为主，知道一个公司的合理组织架构，觉得这么设计理所当然。但是在实际开发中，我们很容易会将不同的责任揉在一起，这点还是需要开发者注意的。</p><h2 id="原则三：依赖倒置原则（Dependency-Inversion-Principle）"><a href="#原则三：依赖倒置原则（Dependency-Inversion-Principle）" class="headerlink" title="原则三：依赖倒置原则（Dependency Inversion Principle）"></a>原则三：依赖倒置原则（Dependency Inversion Principle）</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote><ul><li>Depend upon Abstractions. Do not depend upon concretions.</li><li>Abstractions should not depend upon details. Details should depend upon abstractions</li><li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li></ul></blockquote><p>即：</p><ul><li>依赖抽象，而不是依赖实现。</li><li>抽象不应该依赖细节；细节应该依赖抽象。</li><li>高层模块不能依赖低层模块，二者都应该依赖抽象。</li></ul><h3 id="定义解读"><a href="#定义解读" class="headerlink" title="定义解读"></a>定义解读</h3><ul><li>针对接口编程，而不是针对实现编程。</li><li>尽量不要从具体的类派生，而是以继承抽象类或实现接口来实现。</li><li>关于高层模块与低层模块的划分可以按照决策能力的高低进行划分。业务层自然就处于上层模块，逻辑层和数据层自然就归类为底层。 </li></ul><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>通过抽象来搭建框架，建立类和类的关联，以减少类间的耦合性。而且以抽象搭建的系统要比以具体实现搭建的系统更加稳定，扩展性更高，同时也便于维护。</p><h3 id="代码讲解-2"><a href="#代码讲解-2" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>下面通过一个模拟项目开发的例子来讲解依赖倒置原则。</p><h3 id="需求点-2"><a href="#需求点-2" class="headerlink" title="需求点"></a>需求点</h3><p>实现下面这样的需求：</p><p>用代码模拟一个实际项目开发的场景：前端和后端开发人员开发同一个项目。</p><h4 id="不好的设计-2"><a href="#不好的设计-2" class="headerlink" title="不好的设计"></a>不好的设计</h4><p>首先生成两个类，分别对应前端和后端开发者：</p><p>前端开发者：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== FrondEndDeveloper.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FrondEndDeveloper</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeJavaScriptCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== FrondEndDeveloper.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FrondEndDeveloper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeJavaScriptCode&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Write JavaScript code"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>后端开发者：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== BackEndDeveloper.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BackEndDeveloper</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeJavaCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== BackEndDeveloper.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BackEndDeveloper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeJavaCode&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Write Java code"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这两个开发者分别对外提供了自己开发的方法：<code>writeJavaScriptCode</code>和<code>writeJavaCode</code>。</p><p>接着创建一个<code>Project</code>类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Project.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Project</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法，传入开发者的数组</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDevelopers:(<span class="built_in">NSArray</span> *)developers;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始开发</span></span><br><span class="line">- (<span class="keyword">void</span>)startDeveloping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Project.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Project.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"FrondEndDeveloper.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"BackEndDeveloper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Project</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *_developers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDevelopers:(<span class="built_in">NSArray</span> *)developers&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _developers = developers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startDeveloping&#123;</span><br><span class="line">    </span><br><span class="line">    [_developers enumerateObjectsUsingBlock:^(<span class="keyword">id</span>  _Nonnull developer, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([developer isKindOfClass:[FrondEndDeveloper <span class="keyword">class</span>]]) &#123;</span><br><span class="line">            </span><br><span class="line">            [developer writeJavaScriptCode];</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> ([developer isKindOfClass:[BackEndDeveloper <span class="keyword">class</span>]])&#123;</span><br><span class="line">            </span><br><span class="line">            [developer writeJavaCode];</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//no such developer</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在<code>Project</code>类中，我们首先通过一个构造器方法，将开发者的数组传入<code>project</code>的实例对象。然后在开始开发的方法<code>startDeveloping</code>里面，遍历数组并判断元素类型的方式让不同类型的开发者调用和自己对应的函数。</p><p>思考一下，这样的设计有什么问题？</p><p><strong>问题一：</strong></p><p>假如后台的开发语言改成了GO语言，那么上述代码需要改动两个地方：</p><ul><li><code>BackEndDeveloper</code>:需要向外提供一个<code>writeGolangCode</code>方法。</li><li><code>Project</code>类的<code>startDeveloping</code>方法里面需要将<code>BackEndDeveloper</code>类的<code>writeJavaCode</code>改成<code>writeGolangCode</code>。</li></ul><p><strong>问题二：</strong></p><p>假如后期老板要求做移动端的APP（需要iOS和安卓的开发者），那么上述代码仍然需要改动两个地方：</p><ul><li>还需要给<code>Project</code>类的构造器方法里面传入<code>IOSDeveloper</code>和<code>AndroidDeveloper</code>两个类。而且按照现有的设计，还要分别向外部提供<code>writeSwiftCode</code>和<code>writeKotlinCode</code>。</li><li><code>Project</code>类的<code>startDeveloping</code>方法里面需要再多两个<code>elseif</code>判断，专门判断<code>IOSDeveloper</code>和<code>AndroidDeveloper</code>这两个类。</li></ul><blockquote><p>开发安卓的代码也可以用Java，但是为了和后台的开发代码区分一下，这里用了同样可以开发安卓的Kotlin语言。</p></blockquote><p>很显然，在这两种假设的场景下，<strong>高层模块（Project）都依赖了低层模块（BackEndDeveloper）的改动，因此上述设计不符合依赖倒置原则</strong>。</p><p>那么该如何设计才可以符合依赖倒置原则呢？</p><p>答案是<strong>将开发者写代码的方法抽象出来，让Project类不再依赖所有低层的开发者类的具体实现，而是依赖抽象。而且从下至上，所有底层的开发者类也都依赖这个抽象，通过实现这个抽象来做自己的任务</strong>。</p><p>这个抽象可以用接口，也可以用抽象类的方式来做，在这里笔者用<strong>使用接口</strong>的方式进行讲解：</p><h4 id="较好的设计-2"><a href="#较好的设计-2" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>首先，创建一个接口，接口里面有一个写代码的方法<code>writeCode</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== DeveloperProtocol.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">DeveloperProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>然后，让前端程序员和后端程序员类实现这个接口（遵循这个协议）并按照自己的方式实现：</p><p>前端程序员类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== FrondEndDeveloper.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FrondEndDeveloper</span> : <span class="title">NSObject</span>&lt;<span class="title">DeveloperProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== FrondEndDeveloper.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FrondEndDeveloper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeCode&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Write JavaScript code"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>后端程序员类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== BackEndDeveloper.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">BackEndDeveloper</span> : <span class="title">NSObject</span>&lt;<span class="title">DeveloperProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== BackEndDeveloper.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BackEndDeveloper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeCode&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Write Java code"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>最后我们看一下新设计后的<code>Project</code>类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Project.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DeveloperProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Project</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//只需传入遵循DeveloperProtocol的对象数组即可</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDevelopers:(<span class="built_in">NSArray</span> &lt;<span class="keyword">id</span> &lt;DeveloperProtocol&gt;&gt;*)developers;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始开发</span></span><br><span class="line">- (<span class="keyword">void</span>)startDeveloping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Project.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"FrondEndDeveloper.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"BackEndDeveloper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Project</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> &lt;<span class="keyword">id</span> &lt;DeveloperProtocol&gt;&gt;* _developers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDevelopers:(<span class="built_in">NSArray</span> &lt;<span class="keyword">id</span> &lt;DeveloperProtocol&gt;&gt;*)developers&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _developers = developers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startDeveloping&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每次循环，直接向对象发送writeCode方法即可，不需要判断</span></span><br><span class="line">    [_developers enumerateObjectsUsingBlock:^(<span class="keyword">id</span>&lt;DeveloperProtocol&gt;  _Nonnull developer, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">        </span><br><span class="line">        [developer writeCode];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>新的<code>Project</code>的构造方法只需传入遵循DeveloperProtocol协议的对象构成的数组即可。这样也比较符合现实中的需求：只需要会写代码就可以加入到项目中。</p><p>而新的<code>startDeveloping</code>方法里：每次循环，直接向当前对象发送writeCode方法即可，不需要对程序员的类型做判断。因为这个对象一定是遵循<code>DeveloperProtocol</code>接口的，而遵循该接口的对象一定会实现<code>writeCode</code>方法（就算不实现也不会引起重大错误）。</p><p>现在新的设计接受完了，我们通过上面假设的两个情况来和之前的设计做个对比：</p><p><strong>假设1：后台的开发语言改成了GO语言</strong></p><p>在这种情况下，只需更改<code>BackEndDeveloper</code>类里面对于<code>DeveloperProtocol</code>接口的<code>writeCode</code>方法的实现即可：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== BackEndDeveloper.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">BackEndDeveloper</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeCode&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Old：</span></span><br><span class="line">    <span class="comment">//NSLog(@"Write Java code");</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//New:</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Write Golang code"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>而在<code>Project</code>里面不需要修改任何代码，因为<code>Project</code>类只依赖了接口方法<code>WriteCode</code>，没有依赖其具体的实现。</p><p>我们接着看一下第二个假设：</p><p><strong>假设2：后期老板要求做移动端的APP（需要iOS和安卓的开发者）</strong></p><p>在这个新场景下，我们只需要将新创建的两个开发者类：<code>IOSDeveloper</code>和<code>AndroidDeveloper</code>分别实现<code>DeveloperProtocol</code>接口的<code>writeCode</code>方法即可。</p><p>同样，<code>Project</code>的接口和实现代码都不用修改：客户端只需要在<code>Project</code>的构建方法的数组参数里面添加这两个新类的实例即可，不需要在<code>startDeveloping</code>方法里面添加类型判断，原因同上。</p><p>我们可以看到，新设计很好地在高层类（<code>Project</code>）与低层类（各种<code>developer</code>类）中间加了一层抽象，解除了二者在旧设计中的耦合，使得在低层类中的改动没有影响到高层类。</p><p>同样是抽象，新设计同样也可以用抽象类的方式：创建一个<code>Developer</code>的抽象类并提供一个<code>writeCode</code>方法，让不同的开发者类继承与它并按照自己的方式实现<code>writeCode</code>方法。这样一来，在<code>Project</code>类的构造方法就是传入已<code>Developer</code>类型为元素的数组了。有兴趣的小伙伴可以自己实现一下~ </p><p>下面来看一下这两个设计的UML 类图，可以更形象地看出两种设计上的区别：</p><h4 id="UML-类图对比-2"><a href="#UML-类图对比-2" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践依赖倒置原则：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/DIP1.png" alt="未实践依赖倒置原则"></p><p>实践了依赖倒置原则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/DIP22.png" alt="实践了依赖倒置原则"></p><blockquote><p>在实践了依赖倒置原则的 UML 类图中，我们可以看到<code>Project</code>仅仅依赖于新的接口；而且低层的<code>FrondEndDevelope</code>和<code>BackEndDevelope</code>类按照自己的方式实现了这个接口：通过接口解除了原有的依赖。（在 UML 类图中，虚线三角箭头表示接口实线，由实现方指向接口）</p></blockquote><h3 id="如何实践-2"><a href="#如何实践-2" class="headerlink" title="如何实践"></a>如何实践</h3><p>今后在处理高低层模块（类）交互的情景时，尽量将二者的依赖通过抽象的方式解除掉，实现方式可以是通过接口也可以是抽象类的方式。</p><h2 id="原则四：接口分离原则（Interface-Segregation-Principle）"><a href="#原则四：接口分离原则（Interface-Segregation-Principle）" class="headerlink" title="原则四：接口分离原则（Interface Segregation Principle）"></a>原则四：接口分离原则（Interface Segregation Principle）</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><blockquote><p>Many client specific interfaces are better than one general purpose interface.</p></blockquote><p>即：多个特定的客户端接口要好于一个通用性的总接口。</p><h3 id="定义解读-1"><a href="#定义解读-1" class="headerlink" title="定义解读"></a>定义解读</h3><ul><li>客户端不应该依赖它不需要实现的接口。</li><li>不建立庞大臃肿的接口，应尽量细化接口，接口中的方法应该尽量少。</li></ul><p>需要注意的是：接口的粒度也不能太小。如果过小，则会造成接口数量过多，使设计复杂化。</p><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><p>避免同一个接口里面包含不同类职责的方法，接口责任划分更加明确，符合高内聚低耦合的思想。</p><h3 id="代码讲解-3"><a href="#代码讲解-3" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>下面通过一个餐厅服务的例子讲解一下接口分离原则。</p><h4 id="需求点-3"><a href="#需求点-3" class="headerlink" title="需求点"></a>需求点</h4><p>现在的餐厅除了提供传统的店内服务，多数也都支持网上下单，网上支付功能。写一些接口方法来涵盖餐厅的所有的下单及支付功能。</p><h4 id="不好的设计-3"><a href="#不好的设计-3" class="headerlink" title="不好的设计"></a>不好的设计</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== RestaurantProtocol.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RestaurantProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeOnlineOrder;         <span class="comment">//下订单：online</span></span><br><span class="line">- (<span class="keyword">void</span>)placeTelephoneOrder;      <span class="comment">//下订单：通过电话</span></span><br><span class="line">- (<span class="keyword">void</span>)placeWalkInCustomerOrder; <span class="comment">//下订单：在店里</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payOnline;                <span class="comment">//支付订单：online</span></span><br><span class="line">- (<span class="keyword">void</span>)payInPerson;              <span class="comment">//支付订单：在店里支付</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在这里声明了一个接口，它包含了下单和支付的几种方式：</p><ul><li><p>下单：</p><ul><li>online下单</li><li>电话下单</li><li>店里下单（店内服务）</li></ul></li><li><p>支付</p><ul><li>online支付（适用于online下单和电话下单的顾客）</li><li>店里支付（店内服务）</li></ul></li></ul><blockquote><p>这里先不讨论电话下单的顾客是用online支付还是店内支付。</p></blockquote><p>对应的，我们有三种下单方式的顾客：</p><p>1.online下单，online支付的顾客</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== OnlineClient.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RestaurantProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OnlineClient</span> : <span class="title">NSObject</span>&lt;<span class="title">RestaurantProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== OnlineClient.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OnlineClient</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeOnlineOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"place on line order"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeTelephoneOrder&#123;</span><br><span class="line">    <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeWalkInCustomerOrder&#123;</span><br><span class="line">    <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payOnline&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"pay on line"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payInPerson&#123;</span><br><span class="line">    <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>2.电话下单，online支付的顾客</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== TelephoneClient.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RestaurantProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TelephoneClient</span> : <span class="title">NSObject</span>&lt;<span class="title">RestaurantProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== TelephoneClient.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TelephoneClient</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeOnlineOrder&#123;</span><br><span class="line">    <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeTelephoneOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"place telephone order"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeWalkInCustomerOrder&#123;</span><br><span class="line">    <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payOnline&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"pay on line"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payInPerson&#123;</span><br><span class="line">    <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>3.在店里下单并支付的顾客：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== WalkinClient.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RestaurantProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WalkinClient</span> : <span class="title">NSObject</span>&lt;<span class="title">RestaurantProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== WalkinClient.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WalkinClient</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeOnlineOrder&#123;</span><br><span class="line">   <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeTelephoneOrder&#123;</span><br><span class="line">    <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeWalkInCustomerOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"place walk in customer order"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payOnline&#123;</span><br><span class="line">   <span class="comment">//not necessarily</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payInPerson&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"pay in person"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们发现，并不是所有顾客都必须要实现<code>RestaurantProtocol</code>里面的所有方法。<strong>由于接口方法的设计造成了冗余，因此该设计不符合接口隔离原则</strong>。</p><blockquote><p>注意，Objective-C中的协议可以通过<code>@optional</code>关键字设置不需要必须实现的方法，该特性不与接口分离原则冲突：只要属于同一类责任的接口，都可以放入同一接口中。</p></blockquote><p>那么如何做才符合接口隔离原则呢？我们来看一下较好的设计。</p><h4 id="较好的设计-3"><a href="#较好的设计-3" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>要符合接口隔离原则，只需要将不同类型的接口分离出来即可。我们将原来的<code>RestaurantProtocol</code>接口拆分成两个接口：下单接口和支付接口。</p><p>下单接口：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== RestaurantPlaceOrderProtocol.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RestaurantPlaceOrderProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeOrder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>支付接口：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== RestaurantPaymentProtocol.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RestaurantPaymentProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payOrder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>现在有了下单接口和支付接口，我们就可以让不同的客户来以自己的方式实现下单和支付操作了：</p><p>首先创建一个所有客户的父类，来遵循这个两个接口：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Client.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RestaurantPlaceOrderProtocol.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RestaurantPaymentProtocol.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Client</span> : <span class="title">NSObject</span>&lt;<span class="title">RestaurantPlaceOrderProtocol</span>,<span class="title">RestaurantPaymentProtocol</span>&gt;</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>接着另online下单，电话下单，店内下单的顾客继承这个父类，分别实现这两个接口的方法：</p><p>1.online下单，online支付的顾客</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== OnlineClient.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Client.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">OnlineClient</span> : <span class="title">Client</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== OnlineClient.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">OnlineClient</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"place on line order"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"pay on line"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>2.电话下单，online支付的顾客</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== TelephoneClient.h ==================</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Client.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">TelephoneClient</span> : <span class="title">Client</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== TelephoneClient.m ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TelephoneClient</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"place telephone order"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"pay on line"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>3.在店里下单并支付顾客：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== WalkinClient.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Client.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">WalkinClient</span> : <span class="title">Client</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== WalkinClient.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">WalkinClient</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)placeOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"place walk in customer order"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)payOrder&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"pay in person"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>因为我们把不同职责的接口拆开，使得接口的责任更加清晰，简洁明了。不同的客户端可以根据自己的需求遵循所需要的接口来以自己的方式实现。</p><p>而且今后如果还有和下单或者支付相关的方法，也可以分别加入到各自的接口中，避免了接口的臃肿，同时也提高了程序的内聚性。</p><p>下面来看一下这两个设计的UML 类图，可以更形象地看出两种设计上的区别：</p><h4 id="UML-类图对比-3"><a href="#UML-类图对比-3" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践接口分离原则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/ISP1.png" alt="未实践接口分离原则"></p><p>实践了接口分离原则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/ISP2.png" alt="实践了接口分离原则"></p><blockquote><p>通过遵守接口分离原则，接口的设计变得更加简洁，而且各种客户类不需要实现自己不需要实现的接口。</p></blockquote><h3 id="如何实践-3"><a href="#如何实践-3" class="headerlink" title="如何实践"></a>如何实践</h3><p>在设计接口时，尤其是在向现有的接口添加方法时，我们需要仔细斟酌这些方法是否是处理同一类任务的：如果是则可以放在一起；如果不是则需要做拆分。</p><p>做iOS开发的朋友对<code>UITableView</code>的<code>UITableViewDelegate</code>和<code>UITableViewDataSource</code>这两个协议应该会非常熟悉。这两个协议里的方法都是与<code>UITableView</code>相关的，但iOS SDK的设计者却把这些方法放在不同的两个协议中。原因就是这两个协议所包含的方法所处理的任务是不同的两种：</p><ul><li><code>UITableViewDelegate</code>：含有的方法是<code>UITableView</code>的实例告知其代理一些点击事件的方法，即<strong>事件的传递</strong>，方向是从<code>UITableView</code>的实例到其代理。</li><li><code>UITableViewDataSource</code>：含有的方法是<code>UITableView</code>的代理传给<code>UITableView</code>一些必要数据供<code>UITableView</code>展示出来，即<strong>数据的传递</strong>，方向是从<code>UITableView</code>的代理到<code>UITableView</code>。</li></ul><p>很显然，<code>UITableView</code>协议的设计者很好地实践了接口分离的原则，值得我们大家学习。</p><h2 id="原则五：迪米特法则（Law-of-Demeter）"><a href="#原则五：迪米特法则（Law-of-Demeter）" class="headerlink" title="原则五：迪米特法则（Law of Demeter）"></a>原则五：迪米特法则（Law of Demeter）</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><blockquote><p>You only ask for objects which you directly need.</p></blockquote><p>即：一个对象应该对尽可能少的对象有接触，也就是只接触那些真正需要接触的对象。</p><h3 id="定义解读-2"><a href="#定义解读-2" class="headerlink" title="定义解读"></a>定义解读</h3><ul><li>迪米特法则也叫做最少知道原则（Least Know Principle）， 一个类应该只和它的成员变量，方法的输入，返回参数中的类作交流，而不应该引入其他的类（间接交流）。</li></ul><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><p>实践迪米特法则可以良好地降低类与类之间的耦合，减少类与类之间的关联程度，让类与类之间的协作更加直接。</p><h3 id="代码讲解-4"><a href="#代码讲解-4" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>下面通过一个简单的关于汽车的例子来讲解一下迪米特法则。</p><h4 id="需求点-4"><a href="#需求点-4" class="headerlink" title="需求点"></a>需求点</h4><p>设计一个汽车类，包含汽车的品牌名称，引擎等成员变量。提供一个方法返回引擎的品牌名称。</p><h4 id="不好的设计-4"><a href="#不好的设计-4" class="headerlink" title="不好的设计"></a>不好的设计</h4><p>Car类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//================== Car.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">GasEngine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(GasEngine *)engine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回私有成员变量：引擎的实例</span></span><br><span class="line">- (GasEngine *)usingEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Car.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GasEngine.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">&#123;</span><br><span class="line">    GasEngine *_engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(GasEngine *)engine&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (GasEngine *)usingEngine&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>从上面可以看出，Car的构造方法需要传入一个引擎的实例对象。而且因为引擎的实例对象被赋到了Car对象的私有成员变量里面。所以Car类给外部提供了一个返回引擎对象的方法：<code>usingEngine</code>。</p><p>而这个引擎类<code>GasEngine</code>有一个品牌名称的成员变量<code>brandName</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== GasEngine.h ==================</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GasEngine</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *brandName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>这样一来，客户端就可以拿到引擎的品牌名称了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Client.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GasEngine.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)findCarEngineBrandName:(Car *)car&#123;</span><br><span class="line"></span><br><span class="line">    GasEngine *engine = [car usingEngine];</span><br><span class="line">    <span class="built_in">NSString</span> *engineBrandName = engine.brandName;<span class="comment">//获取到了引擎的品牌名称</span></span><br><span class="line">    <span class="keyword">return</span> engineBrandName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的设计完成了需求，但是却违反了迪米特法则。原因是<strong>在客户端的</strong><code>findCarEngineBrandName:</code><strong>中引入了和入参（Car）和返回值（NSString）无关的</strong><code>GasEngine</code><strong>对象</strong>。增加了客户端与<br><code>GasEngine</code>的耦合。而这个耦合显然是不必要更是可以避免的。</p><p>接下来我们看一下如何设计可以避免这种耦合：</p><h4 id="较好的设计-4"><a href="#较好的设计-4" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>同样是Car这个类，我们去掉原有的返回引擎对象的方法，而是增加一个直接返回引擎品牌名称的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Car.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">GasEngine</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Car</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(GasEngine *)engine;</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接返回引擎品牌名称</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)usingEngineBrandName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Car.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GasEngine.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Car</span></span></span><br><span class="line">&#123;</span><br><span class="line">    GasEngine *_engine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEngine:(GasEngine *)engine&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _engine = engine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)usingEngineBrandName&#123;</span><br><span class="line">    <span class="keyword">return</span> _engine.brand;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>因为直接<code>usingEngineBrandName</code>直接返回了引擎的品牌名称，所以在客户端里面就可以直接拿到这个值，而不需要间接地通过原来的<code>GasEngine</code>实例来获取。</p><p>我们看一下客户端操作的变化：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Client.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Car.h"</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)findCarEngineBrandName:(Car *)car&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *engineBrandName = [car usingEngineBrandName]; <span class="comment">//直接获取到了引擎的品牌名称</span></span><br><span class="line">    <span class="keyword">return</span> engineBrandName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之前的设计不同，在客户端里面，没有引入<code>GasEngine</code>类，而是直接通过<code>Car</code>实例获取到了需要的数据。</p><p>这样设计的好处是，如果这辆车的引擎换成了电动引擎(原来的<code>GasEngine</code>类换成了<code>ElectricEngine</code>类)，<strong>客户端代码可以不做任何修改</strong>！因为它没有引入任何引擎类，而是直接获取了引擎的品牌名称。</p><p>所以在这种情况下我们只需要修改Car类的<code>usingEngineBrandName</code>方法实现，将新引擎的品牌名称返回即可。</p><p>下面来看一下这两个设计的UML 类图，可以更形象地看出两种设计上的区别：</p><h4 id="UML-类图对比-4"><a href="#UML-类图对比-4" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践迪米特法则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/LOD111.png" alt="未实践迪米特法则"></p><p>实践了迪米特法则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/LOD2.png" alt="实践了迪米特法则"></p><blockquote><p>很明显，在实践了迪米特法则的 UML 类图里面，没有了<code>Client</code>对<code>GasEngine</code>的依赖，耦合性降低。</p></blockquote><h3 id="如何实践-4"><a href="#如何实践-4" class="headerlink" title="如何实践"></a>如何实践</h3><p>今后在做对象与对象之间交互的设计时，应该极力避免引出中间对象的情况（需要导入其他对象的类）：需要什么对象直接返回即可，降低类之间的耦合度。</p><h2 id="原则六：里氏替换原则（Liskov-Substitution-Principle）"><a href="#原则六：里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="原则六：里氏替换原则（Liskov Substitution Principle）"></a>原则六：里氏替换原则（Liskov Substitution Principle）</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><blockquote><p>In a computer program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) without altering any of the desirable properties of the program (correctness, task performed, etc.)</p></blockquote><p>即：所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。</p><h3 id="定义的解读-2"><a href="#定义的解读-2" class="headerlink" title="定义的解读"></a>定义的解读</h3><p>在继承体系中，子类中可以增加自己特有的方法，也可以实现父类的抽象方法，但是不能重写父类的非抽象方法，否则该继承关系就不是一个正确的继承关系。</p><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><p>可以检验继承使用的正确性，约束继承在使用上的泛滥。</p><h3 id="代码讲解-5"><a href="#代码讲解-5" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>在这里用一个简单的长方形与正方形的例子讲解一下里氏替换原则。</p><h4 id="需求点-5"><a href="#需求点-5" class="headerlink" title="需求点"></a>需求点</h4><p>创建两个类：长方形和正方形，都可以设置宽高（边长），也可以输出面积大小。</p><h4 id="不好的设计-5"><a href="#不好的设计-5" class="headerlink" title="不好的设计"></a>不好的设计</h4><p>首先声明一个长方形类，然后让正方形类继承于长方形。</p><p>长方形类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Rectangle.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Rectangle</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@protected</span> <span class="keyword">double</span> _width;</span><br><span class="line"><span class="keyword">@protected</span> <span class="keyword">double</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置宽高</span></span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width;</span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="keyword">double</span>)height;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取宽高</span></span><br><span class="line">- (<span class="keyword">double</span>)width;</span><br><span class="line">- (<span class="keyword">double</span>)height;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取面积</span></span><br><span class="line">- (<span class="keyword">double</span>)getArea;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Rectangle.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Rectangle</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width&#123;</span><br><span class="line">    _width = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="keyword">double</span>)height&#123;</span><br><span class="line">    _height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)width&#123;</span><br><span class="line">    <span class="keyword">return</span> _width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)height&#123;</span><br><span class="line">    <span class="keyword">return</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)getArea&#123;</span><br><span class="line">    <span class="keyword">return</span> _width * _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>正方形类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Square.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Square</span> : <span class="title">Rectangle</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Square.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Square</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width&#123;</span><br><span class="line">    </span><br><span class="line">    _width = width;</span><br><span class="line">    _height = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="keyword">double</span>)height&#123;</span><br><span class="line">    </span><br><span class="line">    _width = height;</span><br><span class="line">    _height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>可以看到，正方形类继承了长方形类以后，为了保证边长永远是相等的，特意在两个set方法里面强制将宽和高都设置为传入的值，也就是重写了父类<code>Rectangle</code>的两个set方法。但是里氏替换原则里规定，子类不能重写父类的方法，所以上面的设计是违反该原则的。</p><p>而且里氏替换原则原则里面所属：子类对象能够替换父类对象，而程序执行效果不变。我们通过一个例子来看一下上面的设计是否符合：</p><p>在客户端类写一个方法：传入一个<code>Rectangle</code>类型并返回它的面积：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">double</span>)calculateAreaOfRect:(Rectangle *)rect&#123;</span><br><span class="line">    <span class="keyword">return</span> rect.getArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先用<code>Rectangle</code>对象试一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Rectangle *rect = [[Rectangle alloc] init];</span><br><span class="line">rect.width = <span class="number">10</span>;</span><br><span class="line">rect.height = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">double</span> rectArea = [<span class="keyword">self</span> calculateAreaOfRect:rect];<span class="comment">//output:200</span></span><br></pre></td></tr></table></figure><p>长宽分别设置为10，20以后，结果输出200，没有问题。</p><p>现在我们使用<code>Rectange</code>的子类<code>Square</code>的对象替换原来的<code>Rectange</code>对象，看一下结果如何：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Square *square = [[Square alloc] init];</span><br><span class="line">square.width = <span class="number">10</span>;</span><br><span class="line">square.height = <span class="number">20</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">double</span> squareArea = [<span class="keyword">self</span> calculateAreaOfRect:square];<span class="comment">//output:400</span></span><br></pre></td></tr></table></figure><p>结果输出为400，结果不一致，再次说明了上述设计不符合里氏替换原则，因为子类的对象<code>square</code>替换父类的对象<code>rect</code>以后，程序执行的结果变了。</p><p>不符合里氏替换原则就说明该继承关系不是正确的继承关系，也就是说正方形类不能继承于长方形类，程序需要重新设计。</p><p>我们现在看一下比较好的设计。</p><h4 id="较好的设计-5"><a href="#较好的设计-5" class="headerlink" title="较好的设计"></a>较好的设计</h4><p>既然正方形不能继承于长方形，那么是否可以让二者都继承于其他的父类呢？答案是可以的。</p><p>既然要继承于其他的父类，它们这个父类肯定具备这两种形状共同的特点：有4个边。那么我们就定义一个四边形的类：<code>Quadrangle</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Quadrangle.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Quadrangle</span> : <span class="title">NSObject</span></span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">@protected</span> <span class="keyword">double</span> _width;</span><br><span class="line"><span class="keyword">@protected</span> <span class="keyword">double</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width;</span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="keyword">double</span>)height;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)width;</span><br><span class="line">- (<span class="keyword">double</span>)height;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)getArea;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>接着，让<code>Rectangle</code>类和<code>Square</code>类继承于它：</p><p><code>Rectangle</code>类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Rectangle.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"Quadrangle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Rectangle</span> : <span class="title">Quadrangle</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Rectangle.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Rectangle</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width&#123;</span><br><span class="line">    _width = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="keyword">double</span>)height&#123;</span><br><span class="line">    _height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)width&#123;</span><br><span class="line">    <span class="keyword">return</span> _width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)height&#123;</span><br><span class="line">    <span class="keyword">return</span> _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)getArea&#123;</span><br><span class="line">    <span class="keyword">return</span> _width * _height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p><code>Square</code>类：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//================== Square.h ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Square</span> : <span class="title">Quadrangle</span></span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@protected</span> <span class="keyword">double</span> _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setSideLength:(<span class="keyword">double</span>)sideLength;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">double</span>)sideLength;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//================== Square.m ==================</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Square</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)setSideLength:(<span class="keyword">double</span>)sideLength&#123;    </span><br><span class="line">    _sideLength = sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(<span class="keyword">double</span>)sideLength&#123;</span><br><span class="line">    <span class="keyword">return</span> _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setWidth:(<span class="keyword">double</span>)width&#123;</span><br><span class="line">    _sideLength = width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setHeight:(<span class="keyword">double</span>)height&#123;</span><br><span class="line">    _sideLength = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)width&#123;</span><br><span class="line">    <span class="keyword">return</span> _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)height&#123;</span><br><span class="line">    <span class="keyword">return</span> _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">double</span>)getArea&#123;</span><br><span class="line">    <span class="keyword">return</span> _sideLength * _sideLength;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>我们可以看到，<code>Rectange</code>和<code>Square</code>类都以自己的方式实现了父类<code>Quadrangle</code>的公共方法。而且由于<code>Square</code>的特殊性，它也声明了自己独有的成员变量<code>_sideLength</code>以及其对应的公共方法。</p><blockquote><p>注意，这里<code>Rectange</code>和<code>Square</code>并不是重写了其父类的公共方法，而是实现了其抽象方法。</p></blockquote><p>下面来看一下这两个设计的UML 类图，可以更形象地看出两种设计上的区别：</p><h4 id="UML-类图对比-5"><a href="#UML-类图对比-5" class="headerlink" title="UML 类图对比"></a>UML 类图对比</h4><p>未实践里氏替换原则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/LSP11.png" alt="未实践里氏替换原则"></p><p>实践了里氏替换原则：<br><img src="http://oih3a9o4n.bkt.clouddn.com/LSP22.png" alt="实践了里氏替换原则"></p><h3 id="如何实践-5"><a href="#如何实践-5" class="headerlink" title="如何实践"></a>如何实践</h3><p>里氏替换原则是对继承关系的一种检验：检验是否真正符合继承关系，以避免继承的滥用。因此，在使用继承之前，需要反复思考和确认该继承关系是否正确，或者当前的继承体系是否还可以支持后续的需求变更，如果无法支持，则需要及时重构，采用更好的方式来设计程序。</p><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>到这里关于六大设计原则的讲解已经结束了。本篇文章所展示的Demo和UML 类图都在笔者维护的一个专门的GitHub库中：<a href="https://github.com/knightsj/object-oriented-design">object-oriented-design</a>。想看Demo和UML图的同学可以点击链接查看。欢迎fork，更欢迎给出更多语言的不同例子的PR~ 而且后续还会添加关于设计模式的 代码和 UML 类图。</p><p>关于这几个设计原则还有最后一点需要强调的是：<br>设计原则是设计模式的基石，但是很难在使实际开发中的某个设计中全部都满足这些设计原则。因此我们需要抓住具体设计场景的特殊性，有选择地遵循最合适的设计原则。</p><hr><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/oodbanner.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;学习初衷与讲解方式&quot;&gt;&lt;a href=&quot;#学习初衷与讲解方式&quot; class=&quot;headerlink&quot; title=&quot;学习初衷与讲解方式&quot;&gt;&lt;/a&gt;学习初衷与讲解方式&lt;/h1&gt;&lt;p&gt;笔者想在 iOS 从业第三年结束之前系统学习一下关于设计模式方面的知识。而在学习设计模式之前，觉得更有必要先学习面向对象设计（OOD：Object Oriented Design）的几大设计原则，为后面设计模式的学习打下基础。&lt;/p&gt;
&lt;p&gt;本篇分享的就是笔者近阶段学习和总结的面向对象设计的六个设计原则：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;英文名称&lt;/th&gt;
&lt;th&gt;中文名称&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SRP&lt;/td&gt;
&lt;td&gt;Single Responsibility Principle&lt;/td&gt;
&lt;td&gt;单一职责原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OCP&lt;/td&gt;
&lt;td&gt;Open Close Principle&lt;/td&gt;
&lt;td&gt;开闭原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LSP&lt;/td&gt;
&lt;td&gt;Liskov Substitution Principle&lt;/td&gt;
&lt;td&gt;里氏替换原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LoD&lt;/td&gt;
&lt;td&gt;Law of Demeter （ Least Knowledge Principle）&lt;/td&gt;
&lt;td&gt;迪米特法则（最少知道原则）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ISP&lt;/td&gt;
&lt;td&gt;Interface Segregation Principle&lt;/td&gt;
&lt;td&gt;接口分离原则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DIP&lt;/td&gt;
&lt;td&gt;Dependency Inversion Principle&lt;/td&gt;
&lt;td&gt;依赖倒置原则&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Object-Oriented" scheme="https://github.com/knightsj/knightsj.github.io/categories/Object-Oriented/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objectice-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objectice-C/"/>
    
      <category term="Object-Oriented" scheme="https://github.com/knightsj/knightsj.github.io/tags/Object-Oriented/"/>
    
  </entry>
  
  <entry>
    <title>《如何有效整理信息》- 读书笔记</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/08/20/%E3%80%8A%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E6%95%B4%E7%90%86%E4%BF%A1%E6%81%AF%E3%80%8B%20-%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/08/20/《如何有效整理信息》 - 读书笔记/</id>
    <published>2018-08-20T13:56:40.870Z</published>
    <updated>2018-08-20T13:59:24.639Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/rhyxzlxx2.png" alt="《如何有效整理信息》封面"></p><p>本书作者（奥野宣之）介绍了一个关于整理笔记的方法：“一元笔记法”。该方法摒弃了将笔记进行分类整理的方式，而是采用了一元化的方案：<strong>不采用分类记录的方式，而是将所有分类的笔记按照时间顺序写到一起记录</strong>。</p><a id="more"></a> <p><img src="http://oih3a9o4n.bkt.clouddn.com/mergenotes2.png" alt="一元化笔记法"></p><p>最开始笔者看到这种整理笔记的方式的时候觉得非常诧异，很多人都应该是将笔记分类整理。包括笔者本人也是在自己的笔记软件里面分了。包括笔者本人，笔者使用不同类别来管理不同类型的笔记：iOS类，个人心得类，英语类，读书笔记类（而读书笔记里面又会分为心理学，经济学，职场等二级类别）等等。</p><p>但是当看到本书作者这种整理笔记的实践方法和带来的好处以后，笔者内心不得不对本书作者的这套理念以及将此套方法论付诸实践的持之以恒产生敬佩（作者亲身实践了18年）。</p><p>那么到底这种“一元化”笔记法好在哪里呢？</p><p>它好在<strong>能更好地让笔记成为产生创意和新想法的素材</strong>：</p><p>因为作者认为，笔记的作用不仅仅是记录和整理，而是应该将笔记作为能够容易产生知识的素材。而为了达到这一目的，就需要将一些平时对自己有触动的事物或者事件，以及平时看到的一些资讯，知识和自己的思考按照时间顺序夹杂在一起记录（而不是分类整理），反复查阅，让不同类的部分激荡碰撞从而迸射出创新的火花。</p><p>以上简单介绍了一元笔记法的实践方法和意图，下面笔者从以下几点来详细介绍：</p><ul><li>一元笔记法的三原则</li><li>一元笔记法的方法论</li><li>一元笔记法的小技巧</li></ul><p>在介绍笔记的方法论之前，我们先看一下一元化笔记的使用需要遵循哪些原则：</p><h1 id="一元笔记法的三原则"><a href="#一元笔记法的三原则" class="headerlink" title="一元笔记法的三原则"></a>一元笔记法的三原则</h1><p>一元化笔记法的实践有三个原则，即：</p><ul><li>一元化</li><li>时序化</li><li>索引化</li></ul><h2 id="原则一：一元化"><a href="#原则一：一元化" class="headerlink" title="原则一：一元化"></a>原则一：一元化</h2><p><img src="http://oih3a9o4n.bkt.clouddn.com/puzzle-1794612_1280111.jpg" alt=""></p><blockquote><p>像上面所提到过的，所谓一元化就是所有的内容聚集到一起。</p></blockquote><p>一旦履行一元化原则，你就再不需要有：</p><ol><li>按照分类整理笔记的成本：思考这条笔记到底属于哪一分类。</li><li>按照分类查询的成本：只需要全局搜索即可。分类整理也支持搜索，但是如果你在一个分类里面没有找到，还需要想在其他哪个分类里面会有这个内容。</li></ol><p>而且最重要的一点好处是，也是上面提到的，更容易让不同类的笔记之间产生化学反应，从而产生灵感，新的想法。</p><h3 id="原则二：时序化"><a href="#原则二：时序化" class="headerlink" title="原则二：时序化"></a>原则二：时序化</h3><p><img src="http://oih3a9o4n.bkt.clouddn.com/pexels-photo-1020323222.jpeg" alt=""></p><blockquote><p>所谓时序化就是指按照时间顺序记录所有的笔记。</p></blockquote><p>这样一来就默认地给笔记本增加了时间线，一条条笔记就像按照时间顺序发生的故事一样呈现出来。而且也会方便看到当时记录这条笔记的时候所发生的其他事情，清楚了前后文更加有助于帮助理解和记忆。</p><h3 id="原则三：索引化"><a href="#原则三：索引化" class="headerlink" title="原则三：索引化"></a>原则三：索引化</h3><p><img src="http://oih3a9o4n.bkt.clouddn.com/blank-2970215_1920111.jpg" alt=""></p><blockquote><p>所谓索引化就是给笔记添加标签，也是一个类似分类的操作，而且如果加了标签也更便于搜索。</p></blockquote><p>比如有一些想法是关于iOS的，就可以在这段笔记前面加上“iOS”这个标签；同样，关于面试的技巧，自己面试的经历，关于面试的感悟等这些关于面试的笔记，可以给其填上“面试”这个标签。</p><p>这样做产生的效果是：一旦你搜索某个标签，那么被添加该标签的笔记内容就会按照时间顺序呈现在你眼前：你的思考，你的经历，你收集的信息交织在一起，所形成的感觉就会更加立体。</p><p>了解一元化笔记的三个原则有助于在实际中规范一元化笔记法的使用。下面就来看一下我们应该如何使用一元化笔记法：</p><h1 id="一元笔记法的方法论"><a href="#一元笔记法的方法论" class="headerlink" title="一元笔记法的方法论"></a>一元笔记法的方法论</h1><p>一元笔记法的方法论其实就是作者所说的让笔记带来新想法的实践过程：</p><h2 id="如何利用笔记产生新想法"><a href="#如何利用笔记产生新想法" class="headerlink" title="如何利用笔记产生新想法"></a>如何利用笔记产生新想法</h2><p>利用笔记产生新想法一共分为以下几个步骤：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/bjflowchart2.png" alt="利用笔记产生新想法的几个步骤"></p><h3 id="步骤1：收集"><a href="#步骤1：收集" class="headerlink" title="步骤1：收集"></a>步骤1：收集</h3><p>这里讲的收集是：信息，知识和想法的收集。</p><p>用书中作者的话：</p><blockquote><p>你要相信自己的直觉，把有趣的、炫酷的、美丽的、可爱的、想要的、想尝试的、能让工作生活更方便的事物和想去的地点不断记录和粘贴在笔记本上。 关键的是，要从浩瀚广博的信息中收集能让你眼前一亮的东西。</p></blockquote><p>从作者的话中可以看出来，不管是什么样的内容，最重要的就是它可以让你“眼前一亮”。那么为什么要记录这类内容呢？这里面隐藏的原理是什么呢？</p><p>笔者对这个问题进行了思考：</p><p>能够让你眼前一亮的东西，必定是一个超出你的认知但却让你觉得好的东西：比如一个你不曾想到过的好点子，使用过APP里面的一个比较炫酷的效果，开源框架里面某个精彩的设计等等。</p><p>所以说如果你可以记录并活用它，必定对你是有帮助的，因为它可以让你对某些事物的认知提升几个点，因为：</p><ol><li>你自己想不出来</li><li>它是好的</li></ol><p>那么试想一下，如果你的笔记里面充斥着这类东西，对你来说会意味着什么？</p><p>而且又因为这些不同类别的内容交织在一起，又可以进行互相作用，产生化学反应，可能会不断地激发，刺激出新的想法。</p><p>另外，那些让人犹豫，看似觉得目前对自己没有帮助的内容也可以先记下来，因为可能以后对自己也会有启发，作者说：</p><blockquote><p>就算是无意义的想法也应该先记下来。因为判断笔记本上内容的价值的并不是现在的自己，而是你现在根本不知道会变成怎样的将来的自己。</p></blockquote><p>关于笔记内容的表现形式，可以不拘泥于文字，图片，截图都可以放在里面。</p><p>关于笔记本的使用方面，笔者没有使用作者推荐的纸质笔记本，因为毕竟还要随身携带。<br>笔者还是比较喜欢使用笔记软件来做这些事情。笔者使用的软件是有道笔记，它支持电脑端，手机端，网页端。</p><ul><li>使用手机端可以在身边无网络，无电脑的时候记录笔记。</li><li>网页端可以在电脑里没有安装有道笔记的地方登陆你的笔记账号进行同步。</li><li>有道笔记还有谷歌浏览器的插件，可以保存网页信息同步到有道笔记里面。</li><li>也可以将微信公众号的文章分享到有道笔记里面，非常方便。</li></ul><p>使用笔记本软件的好处还有一个就是便于搜索。只要在搜索框输入想要看的文字，所有带有该文字的笔记就都会被搜索出来，非常方便。而使用纸质笔记本则需要不断翻阅。</p><h3 id="步骤2：咀嚼"><a href="#步骤2：咀嚼" class="headerlink" title="步骤2：咀嚼"></a>步骤2：咀嚼</h3><p>虽然我们可以记录很多让我们眼前一亮的东西，但是如果我们没有反复地去咀嚼，理解，思考，那么我们始终无法形成我们自己的东西。用作者的话说：</p><blockquote><p>最能产生知识的是自己输出的知识，而不是从别人那里搬过来的</p></blockquote><p>所以笔记记下来之后，需要我们不断地去翻阅，去品尝。并不需要当时就产生新的想法或是思考，给大脑一点时间，一部分思考也可以留给我们的潜意识来做，这就到了下一环节：发酵。</p><h3 id="步骤3：发酵"><a href="#步骤3：发酵" class="headerlink" title="步骤3：发酵"></a>步骤3：发酵</h3><p>发酵指的是通过不断咀嚼我们记下来的内容，在我们头脑里可能会留下一个个问号。而当我们不再去看笔记的时候，这些问号可能会让我们的潜意识开始工作，不断地去寻找答案。而随着时间的推移，就可能会在将来的某一个时间点茅塞顿开 - 问号变成了叹号，你找到了新的想法！</p><h3 id="步骤4：顿悟"><a href="#步骤4：顿悟" class="headerlink" title="步骤4：顿悟"></a>步骤4：顿悟</h3><p>顿悟就是你想到新想法的时候，这时候你不妨拿出你的笔记本，赶紧将你的新想法记录下来。避免忘记。而且你在记录这个新想法之后，也没准大脑还会在潜意识里继续对它进行优化。</p><h3 id="步骤5：具体化"><a href="#步骤5：具体化" class="headerlink" title="步骤5：具体化"></a>步骤5：具体化</h3><p>所谓具体化就是将你的新想法转为实际可操作的方法论：看看在实际操作中如何来实践它。</p><p>因为毕竟想法是要转变成实际行动才有意义，如果不行动，那么改变则无从谈起。所以一旦有了新的想法和创意，就要继续思考如何将这些运用到实际当中。</p><h2 id="一元笔记法的小技巧"><a href="#一元笔记法的小技巧" class="headerlink" title="一元笔记法的小技巧"></a>一元笔记法的小技巧</h2><p><img src="http://oih3a9o4n.bkt.clouddn.com/coffee-2306471_1920111.jpg" alt=""></p><p>​        </p><p>作者除了介绍一元化笔记的方法论和原则，还介绍了几个可以使用的几个小技巧，有了这些技巧，可以更加灵活方便地使用我们的笔记。在这里笔者挑出3个来说一下：</p><ul><li>添加标题</li><li>添加日期</li><li>添加标记</li></ul><h3 id="技巧一：添加标题"><a href="#技巧一：添加标题" class="headerlink" title="技巧一：添加标题"></a>技巧一：添加标题</h3><p>给每条笔记添加标题可以使整个笔记流显得更加工整；同时标题也可以作为该条笔记内容的简短介绍，便于使用笔记的人快速查阅和浏览这个笔记流。</p><h3 id="技巧二：添加日期"><a href="#技巧二：添加日期" class="headerlink" title="技巧二：添加日期"></a>技巧二：添加日期</h3><p>作者介绍了他所使用的6位日期记录法：将年月日用6位数字来表示。比如2018年8月8日可以表示位：180808。</p><p>这样一来，笔记的使用这可以快速用时间来定位笔记的位置和具体内容。因为可能有的时候只能记住某条笔记大概是哪天（哪个日期区间）来记录的。而且反过来，也可以在看到笔记的时候知道当时记录这条笔记的日期。</p><h3 id="技巧三：添加标记"><a href="#技巧三：添加标记" class="headerlink" title="技巧三：添加标记"></a>技巧三：添加标记</h3><p>在笔记里面也可以给不同的内容添加不同的标记：</p><p>作者用<code>“#”</code>代表信息，用<code>“@”</code>代表从信息里面得出的自己的想法。</p><p>使用这种标记的方法可以一目了然地区分出哪些内容属于从外部得来的信息，哪些内容属于从内部输出的自己的想法。</p><p>而随着时间的推移，从内部输出的自己的想法所占的比重应该越来越大，这样才说明了我们真正地思考了，真正利用好了这些外部的信息。</p><p>而且随着我们自己的思考的比重的增加，会刺激大脑产生更多的新的想法。</p><h1 id="笔记的最终目的"><a href="#笔记的最终目的" class="headerlink" title="笔记的最终目的"></a>笔记的最终目的</h1><p><img src="http://oih3a9o4n.bkt.clouddn.com/directory-1273088_1920.jpg" alt=""></p><p>对于“一元笔记法”的目的，作者只是说到了“产生新的创意和想法”就结束了，并没有强调对新想法的实践。然而如果新的创意和想法并没有落地实践的话也只能算是空谈而已。</p><p>因此即使是产生了新的想法我们也要将它转化为行动。只有这样，之前的努力才是有意义的。</p><p>我们可以将所有新的创意和想法将我们当前的认知和行为做关联，看是否能改变我们现在或是将来的某些行为：可以是技术上的，可以是生活上的，也可以是情感上的等等~</p><p>如果找到切入点，可以列一个计划，在合理的时候付诸实践。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/rhyxzlxx2.png&quot; alt=&quot;《如何有效整理信息》封面&quot;&gt;&lt;/p&gt;
&lt;p&gt;本书作者（奥野宣之）介绍了一个关于整理笔记的方法：“一元笔记法”。该方法摒弃了将笔记进行分类整理的方式，而是采用了一元化的方案：&lt;strong&gt;不采用分类记录的方式，而是将所有分类的笔记按照时间顺序写到一起记录&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/categories/BookNote/"/>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
  </entry>
  
  <entry>
    <title>出一套 iOS 高级面试题</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/07/24/%E5%87%BA%E4%B8%80%E5%A5%97%20iOS%20%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/07/24/出一套 iOS 高级面试题/</id>
    <published>2018-07-23T17:56:31.373Z</published>
    <updated>2018-07-24T00:46:10.818Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/ios-interview_1.jpg" alt=""></p><p>一千个读者眼中有一千个哈姆雷特，一千名 iOS 程序员心目中就有一千套 iOS 高级面试题。本文就是笔者认为可以用来面试高级 iOS 程序员的面试题。</p><a id="more"></a><p>这套题的题目跟公司和业务都没有关系，而且也并不代表笔者本人可以把这些题回答得非常好，笔者只是将一部分觉得比较好的题从收集的面试题里面抽出来了而已。</p><p>收集的面试题有以下三个来源：</p><ol><li><p>笔者在准备面试的过程中搜集并整理过的面试题。</p></li><li><p>笔者在准备面试的过程中自己思考过的新题。</p></li><li><p>笔者在面试过程中遇到的觉得比较好的题。</p></li></ol><p>本文分为三个部分展开：</p><ol><li><p>面试题</p></li><li><p>喜欢考察的和不喜欢考察的题</p></li><li><p>建议准备数据结构和算法题</p></li></ol><p>第一部分就是面试题了；第二部分给出了笔者喜欢考察和不喜欢考察的题以及原因；第三部分是笔者建议大家准备数据结构和算法题的原因。</p><h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="iOS-基础题"><a href="#iOS-基础题" class="headerlink" title="iOS 基础题"></a>iOS 基础题</h2><ol><li>分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？</li><li>讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？</li><li>被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？</li><li>关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将其指针置空么？</li><li>KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？</li><li><code>Autoreleasepool</code>所使用的数据结构是什么？<code>AutoreleasePoolPage</code>结构体了解么？</li><li>讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？</li><li><code>class_ro_t</code> 和  <code>class_rw_t</code> 的区别？</li><li>iOS 中内省的几个方法？<code>class</code>方法和<code>objc_getClass</code>方法有什么区别?</li><li>在运行时创建类的方法<code>objc_allocateClassPair</code>的方法名尾部为什么是pair（成对的意思）？</li><li>一个int变量被<code>__block</code>修饰与否的区别？</li><li>为什么在block外部使用<code>__weak</code>修饰的同时需要在内部使用<code>__strong</code>修饰？</li><li>RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说）</li><li>哪些场景可以触发离屏渲染？（知道多少说多少）</li></ol><h2 id="iOS-实战题"><a href="#iOS-实战题" class="headerlink" title="iOS 实战题"></a>iOS 实战题</h2><ol><li>AppDelegate如何瘦身？</li><li>反射是什么？可以举出几个应用场景么？（知道多少说多少）</li><li>有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少）</li><li>App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少）</li><li>App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少）</li><li>你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少）</li><li>你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少）</li></ol><h2 id="网络题"><a href="#网络题" class="headerlink" title="网络题"></a>网络题</h2><ol><li>App 网络层有哪些优化策略？</li><li>TCP为什么要三次握手，四次挥手？</li><li>对称加密和非对称加密的区别？分别有哪些算法的实现？</li><li>HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么？</li><li>HTTPS是如何实现验证身份和验证完整性的？</li><li>如何用Charles抓HTTPS的包？其中原理和流程是什么？</li><li>什么是中间人攻击？如何避免？</li></ol><h2 id="计算机系统题"><a href="#计算机系统题" class="headerlink" title="计算机系统题"></a>计算机系统题</h2><ol><li>了解编译的过程么？分为哪几个步骤？</li><li>静态链接了解么？静态库和动态库的区别？</li><li>内存的几大区域，各自的职能分别是什么？</li><li>static和const有什么区别？</li><li>了解内联函数么？</li><li>什么时候会出现死锁？如何避免？</li><li>说一说你对线程安全的理解？</li><li>列举你知道的线程同步策略？</li><li>有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说</li></ol><h2 id="设计模式题"><a href="#设计模式题" class="headerlink" title="设计模式题"></a>设计模式题</h2><ol><li>除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下</li><li>最喜欢哪个设计模式？为什么？</li><li>iOS SDK 里面有哪些设计模式的实践？</li><li>**设计模式是为了解决什么问题的？</li><li>**设计模式的成员构成以及工作机制是什么？</li><li>**设计模式的优缺点是什么？</li></ol><h2 id="架构-amp-设计题"><a href="#架构-amp-设计题" class="headerlink" title="架构 &amp; 设计题"></a>架构 &amp; 设计题</h2><ol><li>MVC和MVVM的区别？MVVM和MVP的区别？</li><li>面向对象的几个设计原则了解么？最好可以结合场景来说。</li><li>可以说几个重构的技巧么？你觉得重构适合什么时候来做？</li><li>你觉得框架和设计模式的区别是什么？</li><li>看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究）</li></ol><h2 id="数据结构-amp-算法题"><a href="#数据结构-amp-算法题" class="headerlink" title="数据结构&amp;算法题"></a>数据结构&amp;算法题</h2><ol><li>链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？</li><li>哈希表是如何实现的？如何解决地址冲突？</li><li>排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？</li><li>链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？</li><li>数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？</li><li>二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？</li></ol><h1 id="喜欢出的和不喜欢出的题"><a href="#喜欢出的和不喜欢出的题" class="headerlink" title="喜欢出的和不喜欢出的题"></a>喜欢出的和不喜欢出的题</h1><p>不难看出，整套面试题中的iOS部分占比其实并不大（三分之一），因为笔者认为:</p><blockquote><p>高级 iOS 开发 = 高级开发 + （高级） iOS 开发。</p></blockquote><p>而其中<strong>高级开发</strong>的部分应该作为优先考核的内容，目的在于首先要验证面试者<strong>是否具备高级开发必备的基本素质</strong>。这部分知识的掌握程度会直接影响一个开发者的研究和设计能力，包括横向和纵向的。而笔者个人觉得后面的<strong>（高级） iOS 开发</strong>的部分仅仅考查的是面试者对于 iOS 本身的理解程度（API，系统，开发工具等等）。</p><p>在这套里面，笔者个人最喜欢的几道题是：</p><ol><li>iOS SDK 里面有哪些设计模式的实践？</li><li>说一说你对线程安全的理解？</li><li>你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？</li><li>看过哪些第三方框架的源码，它们是怎么设计的？</li><li>可以说几个重构的技巧么？你觉得重构适合什么时候来做？</li></ol><blockquote><ol><li>这道题一箭双雕，不仅考察了面试者对设计模式这种通用性知识的了解，还可以考察其对iOS SDK的熟悉和思考程度。这里可以简单提几个：单例：UIApplication；观察者模式：KVO；类簇：NSNumber；装饰者模式：分类；命令模式：NSInvocation；享元模式：UITableviewCell（UITableview的重用）。还有更多，有兴趣的读者可以看一下《Objective-C 编程之道》这本书，它介绍了很多在 iOS SDK中使用的设计模式。</li><li>这道题我看到网上有些答案是错的，说的大概的意思是“同一时刻只有一个线程访问”。但是如果按照这个定义的话，那么那些无法改变的常量就不算是线程安全的了，所以显然这类定义就是错的。所以说学东西要具备批判性思维，尤其是看博客的时候，很多情况需要自己想想，主动去认证，去思考。</li><li>导致app崩溃的原因有很多，比如向某个对象发送其无法响应的方法，数组越界，集合类中添加nil对象，string访问越界，KVO不合理的移除关联key（KVO导致的崩溃不仅仅这一种原因）等。而崩溃非常影响用户体验，所以笔者认为一名高级 iOS 开发应该具备避免这些崩溃的能力，起码至少也要知道这些容易导致崩溃的场景。</li><li>看一些优秀开源框架的代码，梳理实现思路和细节可以帮助我们提高在类似场景下设计系统的能力。其实道理很简单，小时候学习写作文的办法是什么？- 就是背诵课文而已啊。因为写作是一种输出，所以如果你没有好词好句的积累（输入），自然写不出辞藻丰富的文章。写代码也是一样的道理~</li><li>重构的能力是笔者非常看重的能力。其实笔者个人认为关于重构的技巧可以早早学习，在后面写代码的时候尽可能做到一步到位（如果在排期允许的情况下），而且也对设计代码方面能力的提高有帮助：怎样才能设计出一个低耦合，高内聚，易扩展，易修改的系统？有专门的一本书来介绍重构：《重构 改善既有代码的设计》。</li></ol></blockquote><p>上面说了笔者喜欢考察的问题，下面说一下笔者不喜欢考察的是哪些问题：</p><ol><li>如何查询线上的崩溃？</li><li>了解发布流程么？几个证书的区别？</li><li>有没有做过支付/地图/分享？</li><li>dysm文件是什么，有什么作用？</li></ol><p>笔者不考察这类问题的原因有两个：</p><ol><li>这类问题考查不了面试者作为一名程序员的基本素质，因为其考察的内容仅仅局限于iOS本身。</li><li>这类问题往往是“做过即知道”，更没办法量化能力。在实际开发中遇到了就做过了；就算没遇到，没做过，笔者也相信一名优秀的程序员在第一次也会高效地做好。</li></ol><h1 id="建议准备数据结构和算法题"><a href="#建议准备数据结构和算法题" class="headerlink" title="建议准备数据结构和算法题"></a>建议准备数据结构和算法题</h1><p>在本文的最后说一下数据结构和算法题。</p><p>这类问题是比较大的公司喜欢考核的内容，也就是说大部分公司其实并不考（但是如果了解的话是会加分的）。但是笔者个人认为如果时间上允许，多少还是准备一些会比较好。除了应对面试，其实算法方面的学习会对编程能力的提高有帮助，这一点笔者自己深有体会：</p><p>笔者这次准备面试的过程中，在LeetCode上面刷了一些道题，其中链表，数组，二叉树的题加起来有30道左右，并把这些题放在了个人仓库里面：<a href="https://github.com/knightsj/awesome-algorithm-question-solution">awesome-algorithm-question-solution</a>。欢迎PR Swift，Java的算法题和答案~</p><p>在刷题和学习的过程中渐渐能够感觉到对代码的理解能力提高了很多，尤其是链表题可以强化对指针操作的理解，而且对执行条件的检查，边界问题的处理能力也提升了一些~</p><p>好了，这套题就分享到这里了，在文章后面也建议大家平时注意数据结构和算法方面的学习。和上一篇一样，这篇博客主观方面的内容还是多一些的，还是希望读者可以多多和我交流~</p><hr><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/ios-interview_1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;一千个读者眼中有一千个哈姆雷特，一千名 iOS 程序员心目中就有一千套 iOS 高级面试题。本文就是笔者认为可以用来面试高级 iOS 程序员的面试题。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>2018年 iOS 面试心得</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/07/17/2018%E5%B9%B4%20iOS%20%E9%9D%A2%E8%AF%95%E5%BF%83%E5%BE%97/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/07/17/2018年 iOS 面试心得/</id>
    <published>2018-07-16T17:32:54.879Z</published>
    <updated>2018-07-17T00:12:06.341Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/interview_title.png" alt=""></p><p>面试了几家公司之后，最后来到了爱奇艺（坐标上海），工作的内容是笔者个人非常感兴趣的领域。能拿到这个结果对于入行两年半&amp;非科班的笔者来说无疑是幸运的。</p><a id="more"></a><p>很感谢面试官给我这次机会，因为并不是所有人都会认可你的努力，生活本来就没有任何理所应当。</p><p>具体的面了哪些公司，有哪些面试题在这里就不分享了，因为感觉借鉴意义并不是很大。</p><ul><li>面了哪些公司还是不方便在这里公开的。</li><li>这几家公司的面试题相差并不大，主要还是需要重视答题质量；而且即便是同一个面试官，在面对不同面试者的时候问的问题也很可能不一样，因为很可能受到答题者的回答影响会问一些计划之外的题，这点我在作面试官的时候有体会。</li></ul><p>面试题方面笔者会专门在下一篇出一套自己认为可以用来面试高级 iOS 的面试题。所以请对面试题关注比较大的同学耐心等待1个星期。</p><p>本篇主要分享的是笔者在这阶段是如何准备面试的。可能每个人都有适合自己的学习方法，笔者的这套方法更谈不上十分高效，但还是希望对大家可以有一定的借鉴意义。</p><h1 id="准备面试"><a href="#准备面试" class="headerlink" title="准备面试"></a>准备面试</h1><p>准备面试主要从三个点展开：</p><ul><li>使用的工具</li><li>面试题的整理</li><li>时间管理</li></ul><h2 id="使用的工具"><a href="#使用的工具" class="headerlink" title="使用的工具"></a>使用的工具</h2><p>在准备面试的过程中使用频率最多的工具有两个：</p><ul><li>有道笔记</li><li>奇妙清单</li></ul><h3 id="1-有道笔记"><a href="#1-有道笔记" class="headerlink" title="1. 有道笔记"></a>1. 有道笔记</h3><ul><li>用途1：用来收集知识源：有道笔记浏览器插件可以一键快速保存网页，也可以收藏公众号的文章。</li><li>用途2：用来整理面试题：支持多级文件夹，可以清晰看到知识结构；支持MarkDown，可以保存代码。</li></ul><blockquote><p>笔记的整理过程就是理解的过程，反复咀嚼自己的笔记可以帮助理解。</p></blockquote><h3 id="2-奇妙清单"><a href="#2-奇妙清单" class="headerlink" title="2. 奇妙清单"></a>2. 奇妙清单</h3><ul><li>用途1：用来记录突然想到的问题点：有的时候可能在头脑出蹦出一个问题来，但是没办法立刻想出答案。这时候需要在一个自己熟悉的位置保存一下。</li><li>用途2：罗列现在为止没有攻克的面试题：可以更直观地看到距离复习完成还有多少任务。</li></ul><blockquote><p>清单这种工具是为了解放大脑，因为大脑是用来思考的，不是用来记忆的。把需要惦记的事情先扔进去，让大脑脱离出来~</p></blockquote><p>这两个工具还有一个非常大的优势就是跨平台：都支持（Mac，Windows，Android，iOS）系统，同步的功能做的也都很好。所以使用它们可以在不方便用电脑的时候随时更新，<strong>特别是有一个好想法的时候可以马上在手机上记下来</strong>。</p><h2 id="面试题的整理"><a href="#面试题的整理" class="headerlink" title="面试题的整理"></a>面试题的整理</h2><h3 id="面试题分类"><a href="#面试题分类" class="headerlink" title="面试题分类"></a>面试题分类</h3><p>笔者尽可能搜罗了网上所有的iOS面试题，难度从低到高，当然也有介绍某个知识点的一些文章。笔者将这些题汇总以后分成了几个主题放在了有道笔记里面：</p><ul><li>iOS 基础题：例如“KVO的实现原理？”等等。</li><li>iOS 应用题：例如“可能导致崩溃的几个原因以及如何避免崩溃？”等等。</li><li>Block：例如：“基本类型的变量和对象被__block修饰与否各有什么区别？”等等。</li><li>RunLoop：例如“利用RunLoop可以实现哪些功能？”等等。</li><li>Runtime：例如“从一个对象收到一个它无法响应的方法到崩溃之间发生了什么？”等等。</li><li>网络：例如“HTTPS的握手流程？”等等。</li><li>多线程：例如“线程同步的几个策略？知道哪几种锁及其它们之前区别？”等等。</li><li>计算机系统：例如“内存的几块区域以及职能？”等等。</li><li>设计模式：“iOS SDK里面有哪些设计模式的实践？”等等。</li><li>架构：例如“MVVM和MVP的区别？”等等。</li><li>数据结构：例如“哈希表的实现原理？如何解决冲突？”等等。</li></ul><h3 id="算法题的准备"><a href="#算法题的准备" class="headerlink" title="算法题的准备"></a>算法题的准备</h3><p>最后还要说一下算法题：笔者因为没有算法方面的基础，而且时间上也比较紧，所以只准备了数组，链表，二叉树为主的算法题，语言是C++。这些题目的来源主要是《剑指offer》和LeetCode上面的题目，一共学习了大概一个月的时间。</p><p>笔者把已经掌握的算法题放在了我的GitHub库上面（有答案，而且都是正确的）：<a href="https://github.com/knightsj/awesome-algorithm-question-solution">awesome-algorithm-question-solution</a>。这个库里面的算法题大部分都是移动端面试比较常考的算法题。</p><p>目前都基于C++语言，有兴趣的同学欢迎提交Java和Swift的答案。</p><h3 id="相关书籍"><a href="#相关书籍" class="headerlink" title="相关书籍"></a>相关书籍</h3><p>还有就是可以用来准备面试的书籍：</p><ul><li><p><strong>iOS基础</strong></p><ul><li>《Effective Objective-C》：讲解了Objective-C开发的一些规范和技巧性的知识。笔者写了三篇总价这本书的文章：<ul><li><a href="https://juejin.im/post/5a4f34226fb9a01cb0492016" target="_blank" rel="noopener">《Effective Objective-C》干货三部曲（一）：概念篇</a></li><li><a href="https://juejin.im/post/5a4f36206fb9a01cab280e7c" target="_blank" rel="noopener">《Effective Objective-C》干货三部曲（二）：规范篇</a></li><li><a href="https://juejin.im/post/5a4f3710f265da3e4d728239" target="_blank" rel="noopener">《Effective Objective-C》干货三部曲（三）：技巧篇</a></li></ul></li><li>《Objective-C 高级编程》：讲解了内存管理，Block底层，GCD方面的知识。同样笔者也写了三篇总结这本书的文章：<ul><li><a href="https://juejin.im/post/58ead8c344d904006d4f17af" target="_blank" rel="noopener">《Objective-C 高级编程》干货三部曲（一）：引用计数篇</a></li><li><a href="https://juejin.im/post/58f40c0a8d6d810064879aaf" target="_blank" rel="noopener">《Objective-C 高级编程》干货三部曲（二）：Blocks篇</a></li><li><a href="https://juejin.im/post/58fd55c08d6d81005898df46" target="_blank" rel="noopener">《Objective-C 高级编程》干货三部曲（三）：GCD篇</a></li></ul></li></ul></li><li><p><strong>网络</strong></p><ul><li>《图解HTTP》：讲解了HTTP相关的知识，浅显易懂。</li><li>《图解TCP/IP》：讲解了TCP/IP相关的知识，风格和《图解HTTP》类似。</li></ul></li><li><p><strong>设计模式</strong></p><ul><li>《Objective-C编程之道:iOS设计模式解析》：这本书介绍了 iOS SDK 中使用的设计模式，将理论和实践结合到了一起，是笔者本人比较喜欢的一本书。有一定的 iOS 基础的同学看这本书会比较顺畅一点。不建议基础稍薄弱，业务场景遇到的不多的同学看这本书，因为会感到很晦涩。</li></ul></li><li><p><strong>数据结构和算法</strong></p><ul><li>《剑指offer》：这本书的难度不是很大，如果没有任何基础，可以挑几个感觉是上比较简单的基于数组的算法题去学习。而且这本书中也介绍了一些面试算法题的一些技巧和需要注意的地方（俗称套路）。就算是没有看这里的算法题也会有所收获。</li><li>LeetCode算法题：如果时间比较紧，可以直接看笔者上面的GitHub仓库（<a href="https://github.com/knightsj/awesome-algorithm-question-solution">awesome-algorithm-question-solution</a>），因为这里大部分都是移动端比较常考的算法题。然而并不保证算法性能一定是最好的，因为提升算法性能也需要一些时间成本来学习，这里暂时只能保证性能适中，而且肯定是正确的输出结果。</li></ul><p>总的来说如果时间很紧迫，建议先看一些《剑指offer》里面关于算法面试的“套路”方面的讲解。然后就直奔主题，找一些常考的算法题去学习。</p></li><li><p><strong>计算机系统方面知识</strong>：</p><ul><li>《程序员的自我修养》(俞甲子，石凡，潘爱民)：第一章对进程，线程安全，各种锁的讲解比较好。后面的部分偏深一些，如果时间不允许的话可以先不看。</li></ul></li></ul><h2 id="时间管理"><a href="#时间管理" class="headerlink" title="时间管理"></a>时间管理</h2><p>好的时间管理策略可以更好地帮助计划的落地。在这里从两个点来介绍笔者的时间管理策略：</p><ul><li>每天都做哪些事情</li><li>不做哪些事情</li></ul><h3 id="每天都做哪些事情"><a href="#每天都做哪些事情" class="headerlink" title="每天都做哪些事情"></a>每天都做哪些事情</h3><p>因为当时在职的关系准备面试的时间比较有限，但是每天对不同类型的知识点都有比较固定比例的时间分配：</p><ul><li><p>类型一：全新的知识点。这类知识点是每天都要看的，因为对于新知识需要时间去消化和吸收。所分配的时间大概占一天总学习时间的一半左右。</p></li><li><p>类型二：不熟悉的知识点。这类知识点是指那些刚理解好的全新的知识点或者比较难以理解的，需要反复看和消化的知识点。大概占一天总学习时间的一半以内。</p></li><li><p>类型三：很熟悉的知识点。这部分知识点属于理解的比较透彻的，但也需要抽时间复习，是这部分时间占比不是很重，简单扫一眼即可。</p></li></ul><p>另外还要费分配出整理知识点的时间：对于上面这三种知识点其实都需要反复的整理和吸收，尝试着用自己的话表示出来，需要的时间占比也不是很重，但是却很有用。</p><h3 id="不做哪些事情"><a href="#不做哪些事情" class="headerlink" title="不做哪些事情"></a>不做哪些事情</h3><p>在时间管理这块，笔者个人比较赞同的一个观点是：<strong>比起知道做什么，首先知道不做什么更重要</strong>。因为人的精力是有限的，一天就只有24个小时，当某件事很重要的时候，其他的事情就要做个让步。</p><p>为了准备面试，笔者在今年上半年放弃了很多事情：</p><ol><li>健身卡虽然快过期了，但是一次都没有去。</li><li>同学，家人聚会也婉言谢绝了。</li><li>没有玩儿“吃鸡”，也没有去过电影院。</li></ol><p>坦白说在笔者拿到offer以后才去了健身房，和同学家人聚会，也见了老朋友，算是都补上了。他们也都表示比较理解，所以笔者也感觉也蛮欣慰的。</p><p>找一份工作并不难，但是找一份目前最适合自己的工作却非常难，希望大家也能够做一些取舍，列好计划并付诸实践，应该是会有好的结果的。</p><p>简单讲完了这阶段的面试经历和准备面试的方法策略，下面说一下笔者对一些同行的某些想法想说的。因为这些也包括这上半年面试别人和自己去面试体会到的，所以在这里就和面试心得一起说了。某些地方可能有些主观。</p><h1 id="对一些同行的某些想法想说的"><a href="#对一些同行的某些想法想说的" class="headerlink" title="对一些同行的某些想法想说的"></a>对一些同行的某些想法想说的</h1><h2 id="“行业不景气了”"><a href="#“行业不景气了”" class="headerlink" title="“行业不景气了”"></a>“行业不景气了”</h2><p>这句话每个月都会听到一两次。<br>今年上半年很多朋友在面试，可能因为有些朋友不是很顺利，有感而发了。<br>而且笔者上半年也在给公司招人，招的是高级 iOS 开发，有一个感觉就是很难招。虽然年限已经有3，4年了，但是关于设计模式，数据结构，iOS 底层方面的知识了解的甚少，开源库也只看过SDWebimage（或许只是看了网上的解析而已），总之没有达到笔者个人对一个高级 iOS 开发的要求。</p><p>但是反过来我也听到好多人去了很不错的公司，比如今日头条，BAT等等，评级也比较高。</p><p>所以笔者个人觉得并不是这个行业不景气，而恰恰是<strong>很多开发者没有保持一个持续学习的状态，只是将一年的经验重复多年，最终导致自己的能力小于所属年限的能力标准的情况出现</strong>。</p><p>笔者认为既然做为一名软件开发人员，就要不断地突破自己。对于前端的开发人员，要尽可能地多学一些脱离UI层面上的通用性的知识，比如数据结构和算法，网络协议，设计模式，看一些好的开源库也是不错的（上半年面试了不少于10个人，问看过哪些开源库没有一个不说SDWebImage的）。在这里推荐笔者之前写的一些源码解析的博客：</p><ul><li><a href="https://juejin.im/post/5a657a946fb9a01cb64ee761" target="_blank" rel="noopener">YYCache 源码解析</a></li><li><a href="https://juejin.im/post/596d9f536fb9a06bc7497bc5" target="_blank" rel="noopener">YYTKNetwork 源码解析</a></li><li><a href="https://juejin.im/post/5a36fe1af265da431876d432" target="_blank" rel="noopener">MJRefresh 源码解析</a></li><li><a href="https://juejin.im/post/5a38604b5188252bca04f9fb" target="_blank" rel="noopener">VVeboTableView 源码解析</a></li><li><a href="https://juejin.im/post/5a3c5c106fb9a0451c3a93f9" target="_blank" rel="noopener">PNChart 源码解析</a></li><li><a href="https://juejin.im/post/5a4080d16fb9a0451969d0aa" target="_blank" rel="noopener">SDWebImage 源码解析</a></li></ul><h2 id="“因为我学历不好，所以很难拿到面试机会”"><a href="#“因为我学历不好，所以很难拿到面试机会”" class="headerlink" title="“因为我学历不好，所以很难拿到面试机会”"></a>“因为我学历不好，所以很难拿到面试机会”</h2><p>这些话在跟我比较熟的同行里面听到比较多，他们觉得自己的面试机会受限于学历。</p><p>但其实简历上面可以吸引人的地方可以有很多：高质量的博客，高质量的Github代码，优秀的项目经验，有深度的技术分享等等。</p><p>有句话笔者个人非常喜欢：</p><blockquote><p>Alter what is changeable, and accept what is mutable</p></blockquote><p>意思是<strong>改变能改变的，接收不能改变的</strong>。学历既然很难改变了，那就接受它，不去抱怨，不去拿它当借口，应该把精力放在能改变的事情上：</p><ol><li>博客：现在自己搭建博客都是很容易的事情，有现成的框架（hexo），学习成本很低，如果你有一定的技术积累可以在这里做一下介绍。</li><li>GitHub：这个就不用介绍了，如果你封装了好用的组件就可以放在上面，不断更新优化，能体现出个人的成长。如果能参与大型的开源项目就更好了。</li><li>项目经验：这个可能也是个人无法掌控的，但是你可以将某个功能点做到极致不是么？</li><li>技术分享：如果你研究了一个新技术，是否可以给同事们分享一下呢？同时也可以锻炼下自己。</li></ol><p>笔者个人是比较看重1，2点的：从这两点可以看出这个人对技术的追求，是否热衷于分享，是否有比较好的表达能力和思路。而3，4点由于客观方面的影响比较多一些，所以相对来说笔者个人并不是很侧重。</p><p>笔者看到过一项调查：<strong>相对来说学历越高，毕业学校越好的开发者往往在GitHub和博客上面产出更多</strong>。这不失为一个值得思考的问题，同时也更加说明了学历和毕业学校相对来说不是那么太靠前的开发者更要注重GitHub和博客这两块。</p><h2 id="“（大公司）面试造火箭，工作拧螺丝。”"><a href="#“（大公司）面试造火箭，工作拧螺丝。”" class="headerlink" title="“（大公司）面试造火箭，工作拧螺丝。”"></a>“（大公司）面试造火箭，工作拧螺丝。”</h2><p>这句话也听过不少次了，能听出来说这句话的人多数带着些许负面情绪说的。</p><p>笔者个人认为大公司的这种招人策略是非常道理的：因为既然是大公司，有丰富的资源，它要么是正在造火箭，要么就是准备造火箭，所以招人的话肯定是招那些<strong>已经具备造火箭能力的人或者是那些培养之后可以造火箭的基础比较好的人</strong>。而且万丈高楼平地起，总不会大家都是围着设计图讨论吧？每个人都有每个人的职责，况且哪个将领不是从士兵开始做起的呢？</p><p>所以我们应该以正确的态度去对待这件事情：</p><ul><li>如果你真的想进大公司，那么就削尖了脑袋，好好准备底层知识和算法题去争取：拿到offer最好，就算拿不到也肯定会有收获，毕竟你努力了，你也切身体会了一次大公司的要求。</li><li>如果你真的不想进大公司，那么就尽量不要去惦记这件事情，更不要去传播这种负面情绪。</li><li>如果你还没确定要不要去大公司，那么最好现在就定一下方向，方向有了计划才会有，计划有了才会有成果出来。</li></ul><h2 id="“这部分工作中我没遇到过，所以不了解”"><a href="#“这部分工作中我没遇到过，所以不了解”" class="headerlink" title="“这部分工作中我没遇到过，所以不了解”"></a>“这部分工作中我没遇到过，所以不了解”</h2><p>今年上半年也为公司招了人，上面这句话是笔者做面试官的时候经常听到的，比如问“NSSet和NSArray的区别”，“iOS有哪些反射实践？”这样的问题的时候，面试者<strong>通常把自己没有做过作为自己不会的借口</strong>。</p><p>其实笔者觉得上面这两个知识点和做没做过相应业务没有太直接的关系（笔者本人在实际项目中也没有做过）。</p><ul><li>对于第一个问题，如果你学习了哈希表，并顺带去了解其在iOS SDK的实现，或者是调研过除了数组，字典以外的其他集合类的话，就一定会遇到NSSet。再或者你如果看过AFNetworking的源码的话也可以接触到它。</li><li>对于第二个问题，如果你知道Java中有反射的概念，那么你如果举一反三去探索iOS的反射的话，就可以知道使用运行时的一些函数就可以实现反射。</li></ul><p>所以说无论学习哪个语言，如果可以从一些通用性知识点里探索出该语言对该知识点的实现的话，会更有助于加深对该语言本身的理解，也可以提高相应的业务能力：</p><blockquote><p>比方说如果你仅仅需要一个集合，将来只需要判断元素在不在其中的话，你只需要用NSSet就好了；但是如果你不知道NSSet的存在的话，你可能就只会用NSArray来做，要知道数组的查询速度是要比哈希表低的多的。</p></blockquote><p>所以说做学问最怕的是<strong>不知道自己不知道</strong>：多接触，多探索总还是好的。</p><h2 id="“我不是科班的，所以数据结构和算法我不会”"><a href="#“我不是科班的，所以数据结构和算法我不会”" class="headerlink" title="“我不是科班的，所以数据结构和算法我不会”"></a>“我不是科班的，所以数据结构和算法我不会”</h2><p>笔者作面试官的时候发现：在非科班的群体里想主动学习数据结构和算法的人并不是很多。因为每当笔者问一些关于数据结构和算法方面的知识的时候，总会听到以<strong>自己不是科班出身</strong>作为不会这类题的借口。</p><p>笔者认为如果想要在写程序这条路上面走远，这一块是肯定绕不过去的。<br>有一个公式：</p><blockquote><p>程序 = 数据结构 + 算法</p></blockquote><p>一个好的程序往往跟这两者是分不开的。即是说若想写出好的程序，就要选择好合理的数据结构和算法（至少也要选择正确的数据结构）。</p><p>举一个例子：<br>现在需要你用一个集合来保存一些人名，并提供一个接口来判断传入的人名是否在这个集合里。那么如果让你来实现这个功能，这个集合的数据结构你会用数组，字典，还是Set呢？</p><p>如果你不了解Set的优势，那么你很可能就会用数组来做了（通过返回的index来判断）。但是数组查询的时间复杂度是O(N),远不如Set的O(1)，所以这就说明了使用合适的数据结构对于性能的帮助会有多大。</p><p>笔者也不是科班出身的，但是学习了数据结构和算法之后，发现自己在设计功能，以及理解代码的能力上提高了一大截。像上文所说的笔者也只是掌握了30到LeetCode题，和一些比较基础的数据结构而已。所以很希望各位非科班的同学也可以好好规划自己这一块的学习。而且有一些科班出身的同学，恰恰因为自己是科班出身，所以在工作之后反而就没有主动去精进这方面知识了，所以非科班的同学更要主动去规划自己，以最快速度填补自己的这块漏洞。</p><p>以上就是笔者这段时间的一些思考和想法了。</p><p>这篇总结就在这里写完了，一共两个部分，希望您能有所收获，也非常欢迎能跟我一起交流~</p><hr><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/interview_title.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;面试了几家公司之后，最后来到了爱奇艺（坐标上海），工作的内容是笔者个人非常感兴趣的领域。能拿到这个结果对于入行两年半&amp;amp;非科班的笔者来说无疑是幸运的。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 &amp; 算法 in Swift （二）：算法概述和排序算法</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20&amp;%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/08/数据结构 &amp; 算法 in Swift （二）：算法概述和排序算法/</id>
    <published>2018-02-08T00:53:22.000Z</published>
    <updated>2018-07-16T16:44:37.693Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/da_header_2.png" alt=""></p><p>本篇是《数据结构 &amp; 算法 in Swift》系列连载的第二篇，内容分为如下两个部分：</p><ul><li>算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。</li><li>排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。</li></ul><a id="more"></a><h1 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h1><blockquote><p>该部分是给那些对算法以及相关知识不了解的读者准备的，如果已经对算法的相关知识有所了解，可以略过该部分，直接看本文的第二部分：排序算法。</p></blockquote><p>关于该部分的讨论不属于本文介绍的重点，因此没有过多非常专业的论述，只是让那些对算法不了解的读者可以对算法先有一个基本的认识，为阅读和理解本文的第二部分做好准备。</p><h2 id="算法的概念"><a href="#算法的概念" class="headerlink" title="算法的概念"></a>算法的概念</h2><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</p><blockquote><p>摘自《大话数据结构》</p></blockquote><p>简单说来，算法就是“一个问题的解法”。对于相同一个问题，可能会有多种不同的解法。这些解法虽然可以得到相同的结果，但是每个算法的执行所需要的时间和空间资源却可以是千差万别的。</p><p>以消耗的时间的角度为出发点，我们看一下对于同一个问题，两种不同的解法的效率会相差多大：</p><p>现在让我们解决这个问题：<strong>计算从1到100数字的总和</strong>。</p><p>把比较容易想到的下面两种方法作为比较：</p><ol><li>1到100循环遍历逐步相加</li><li>等差数列求和</li></ol><p>用Swift函数来分别实现一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOpration1</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span> ... n &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">sumOpration1(<span class="number">100</span>)<span class="comment">//5050</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOpration2</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> + n) * n/<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">sumOpration2(<span class="number">100</span>)<span class="comment">//5050</span></span><br></pre></td></tr></table></figure><p>上面的代码中，<code>sumOpration1</code>使用的是循环遍历的方式；<code>sumOpration2</code>使用的是等差数列求和的公式。</p><p>虽然两个函数都能得到正确的结果，但是不难看出两个函数实现的效率是有区别的:</p><p><strong>遍历求和所需要的时间是依赖于传入函数的n的大小的，而等差数列求和的方法所需要的时间对传入的n的大小是完全不依赖的。</strong></p><p>在遍历求和中，如果传入的n值是100，则需要遍历100次并相加才能得到结果，那么如果传入的n值是一百万呢？</p><p>而在等差数列求和的函数中，无论n值有多大，只需要一个公式就可以解决。</p><p>我们对此可以以小见大：世上千千万万种问题（算法题）可能也有类似的情况：相同的问题，相同的结果，但是执行效率缺差之千里。那么有没有什么方法可以度量某种算法的执行效率以方便人们去选择或是衡量算法之间的差异呢？ 答案是肯定的。</p><p>下面笔者就向大家介绍算法所消耗资源的两个维度：时间复杂度和空间复杂度。</p><h2 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h2><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的时间复杂度是指算法需要消耗的时间资源。一般来说，计算机算法是问题规模!n的函数f(n)，算法的时间复杂度也因此记做：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175d7ca0cf3a" alt=""></p><p>常见的时间复杂度有：常数阶O(1)，对数阶O(log n），线性阶 O(n)，线性对数阶O(nlog n)，平方阶O(n^{2})，立方阶O(n^{3})，!k次方阶O(n^{k})，指数阶 O(2^{n})}。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。</p><p>拿其中几个复杂度做对比：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175e46a4baf6?w=840&amp;h=460&amp;f=png&amp;s=366231" alt=""></p><p>从上图中我们可以看到，平方阶O(n^{2})随着n值的增大，其复杂度近乎直线飙升；而线性阶 O(n)随着n的增大，复杂度是线性增长的；我们还可以看到常数阶 O(1)随着n增大，其复杂度是不变的。</p><p>参考上一节的求和问题，我们可以看出来遍历求和的算法复杂度是线性阶O(n)：随着求和的最大数值的大小而线性增长；而等差数列求和算法的复杂度为常数阶 O(1)其算法复杂度与输入n值的大小无关。</p><p>读者可以试着想一个算法的复杂度与输入值n的平方成正比的算法。</p><p>在这里笔者举一个例子：求一个数组中某两个元素和为某个值的元素index的算法。数组为<code>[0,2,1,3,6]</code>，和为8：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findTwoSum</span><span class="params">(<span class="number">_</span> array: [Int], target: Int)</span></span> -&gt; (<span class="type">Int</span>, <span class="type">Int</span>)? &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;array.<span class="built_in">count</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">left</span> = array[i]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> (i + <span class="number">1</span>)..&lt;array.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">right</span> = array[j]</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">left</span> + <span class="keyword">right</span> == target &#123;</span><br><span class="line">                <span class="keyword">return</span> (i, j)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> indexes = findTwoSum(array, target: <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(indexes) <span class="comment">//1， 4</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"No pairs are found"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的算法准确地计算出了两个元素的index为1和4。因为使用了两层的遍历，所以这里算法的复杂度是平方阶O(n^{2}。关于算法复杂度的详细推倒方法，可以参考网上和算法相关书籍的资料。</p><p>而其实，不需要遍历两层，只需要遍历一层即可：在遍历的时候，我么知道当前元素的值a，那么只要其余元素里面有值等于（target - a）的值即可。所以这次算法的复杂度就是线性阶O(n)了。</p><p>同样地，上面两种算法虽然可以达到相同的效果，但是当n非常大的时候，二者的计算效率就会相差更大：n = 1000的时候，二者得到结果所需要的时间可能会差好几百倍。可以说平方阶O(n^{2})复杂度的算法在数据量很大的时候是无法让人接受的。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>算法的空间复杂度是指算法需要消耗的空间资源。其计算和表示方法与时间复杂度类似，一般都用复杂度的渐近性来表示。同时间复杂度相比，空间复杂度的分析要简单得多。而且控件复杂度不属于本文讨论的重点，因此在这里不展开介绍了。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>在算法的实现中，遍历与递归是经常出现的两种操作。</p><p>对于遍历，无非就是使用一个for循环来遍历集合里的元素，相信大家已经非常熟悉了。但是对于递归操作就可能比较陌生。而且由于本文第二部分讲解算法的是时候有两个算法（也是比较重要）的算法使用了递归操作，所以为了能帮助大家理解这两个算法，笔者觉得有必要将递归单独拿出来讲解。</p><p>先看一下递归的概念。</p><h3 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h3><p>递归的概念是：在<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6" target="_blank" rel="noopener">数学</a>与<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6" target="_blank" rel="noopener">计算机科学</a>中，是指在函数的定义中使用函数自身的方法摘自维基百科</p><blockquote><p>摘自维基百科</p></blockquote><p>通过使用递归，可以把一个<strong>大型复杂的问题逐层转化为一个与原问题相似的规模较小的问题来求解</strong>。因此如果使用递归，可以达到使用少量的代码就可描述出解题过程所需的多次重复计算的目的，减少了程序的代码量 。</p><p>下面用一个例子来具体感受一下递归操作：</p><p>大家应该都比较熟悉阶乘的算法：3！= 3 <em> 2 </em> 1 ； 4！= 4 <em> 3 </em> 2 * 1</p><p>不难看出，在这里反复执行了一个逐渐-1和相乘的操作，如果可以使用某段代码达到重复调用的效果就很方便了，在这里就可以使用递归：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &lt; <span class="number">2</span> ? <span class="number">1</span>: n * factorial(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">3</span>) <span class="comment">//6</span></span><br></pre></td></tr></table></figure><p>在上面的代码里，<code>factorial</code>函数调用了它自己，并且在n&lt;2的时候返回了1；否则继续调用自己。</p><p>从代码本身其实不难理解函数调用的方式，但是这个6究竟是怎么算出来的呢？这就涉及到递归的实现原理了。</p><h3 id="递归的实现原理"><a href="#递归的实现原理" class="headerlink" title="递归的实现原理"></a>递归的实现原理</h3><p>递归的调用实际上是通过调用栈（callback stack）来实现的，笔者用一张图从factorial(3)开始调用到最后得出6这个顺序之间发生的事情画了出来：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175e51624070?w=941&amp;h=429&amp;f=png&amp;s=31535" alt=""></p><p>由上图可以看出，整个递归的过程和栈的入栈出栈的操作非常类似：橘黄色背景的圆角矩形代表了栈顶元素，也就是正在执行的操作，而灰色背景的圆角矩形则代表了其余的元素，它们的顺序就是当初被调用的顺序，而且在内容上保持了当时被调用时执行的代码。</p><p>现在笔者按照时间顺序从左到右来说明一下整个调用的过程：</p><ul><li>最开始传入3之后，3满足了n&gt;=2的条件，继续调用自己：3 * factorial(2) ，入栈。</li><li>传入2之后，2满足了n&gt;=2的条件，继续调用自己：2 * factorial(1) ，入栈。</li><li>传入1之后，1满足了n&lt;2的条件，停止调用自己，返回了1，出栈。</li><li>此时的栈顶元素为2 <em> factorial(1) ，而刚刚factorial(1)返回了1，所以现在这里变成了2 </em> 1 = 2，出栈。</li><li>同样地，此时栈顶元素为3 <em> factorial(2)里的 factorial(2)返回了2，所以现在这里变成了3 </em> 2 = 6，出栈。</li><li>最后，factorial(3)返回了6，出栈，递归结束。</li></ul><p>按照笔者个人的理解：整个递归的过程可以大致理解为：在使递归继续的条件为false之前，持续递归调用，以栈的形式保存调用上下文（临时变量，函数等）。一旦这个条件变为true，则立即按照出栈的顺序（入栈顺序的逆序）来返回值，逐个传递，最终传递到最开始调用的那一层返回最终结果。</p><p>再简单点，递归中的“递”就是入栈，传递调用信息；“归”就是出栈，输出返回值。</p><p>而这个分界线就是递归的终止条件。很显然，这个终止条件在整个递归过程中起着举足轻重的作用。试想一下，如果这个条件永远不会改变，那么就会一直入栈，就会发生栈溢出的情况。</p><h3 id="使用递归时需要注意的问题"><a href="#使用递归时需要注意的问题" class="headerlink" title="使用递归时需要注意的问题"></a>使用递归时需要注意的问题</h3><p>基于上面递归的例子，我们将递归终止条件去掉：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorialInfinite</span><span class="params">(<span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * factorialInfinite(n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorialInfinite(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这段代码如果放在playground里，经过一小段时间（几秒钟或更多）后，会报一个运行时错误。也可以在return语句上面写一个print函数打印一些字符串，接着就会看到不停的打印，直到运行时错误，栈溢出。</p><p>所以说在今后写关于递归的代码的时候，一定要注意递归的终止条件是否合理，因为即使条件存在也不一定就是合理的条件。我们看一下下面这个例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOperation</span><span class="params">( <span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + sumOperation(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumOperation(<span class="number">2</span>) <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>上面的代码跟阶乘类似，也是和小于当前参数的值相加，如果传入2，那么知道 n=0时就开始出栈，</p><p>2 + 1 + 0 = 3。看似没什么问题，但是如果一开始传入 - 1 呢？结果就是不停的入栈，直到栈溢出。因为 n == 0 这个条件在传入 - 1 的时候是无法终止入栈的，因为 - 1 之后的 -1 操作都是非0的。</p><p>所以说这个条件就不是合理的，一个比较合理的条件是 n &lt; = 0。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOperation</span><span class="params">( <span class="number">_</span> n:Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + sumOperation(n - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sumOperation(-<span class="number">1</span>) <span class="comment">//0</span></span><br></pre></td></tr></table></figure><p>相信到这里，读者应该对递归的使用，调用过程以及注意事项有个基本的认识了。</p><p>那么到这里，关于算法的基本介绍已经讲完了，下面正式开始讲解排序算法。</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>讲解算法之前，我们先来看一下几个常见的排序算法的对比：</p><table><thead><tr><th>排序算法</th><th>平均情况下</th><th>最好情况</th><th>最坏情况</th><th>稳定性</th><th>空间复杂度</th></tr></thead><tbody><tr><td>冒泡</td><td>O(n^2)</td><td>O(n）</td><td>O(n^2)</td><td>稳定</td><td>1</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>不稳定</td><td>1</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n）</td><td>O(n^2)</td><td>稳定</td><td>1</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>依赖步长</td><td>依赖步长</td><td>稳定</td><td>1</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>1</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>稳定</td><td>O(n）</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td>不稳定</td><td>O(logn)</td></tr></tbody></table><blockquote><p>最好情况和最坏情况以及稳定性的概念不在本文的讨论范围之内，有兴趣的读者可以查阅相关资料。</p></blockquote><p>现在只看平均情况下的性能：</p><ul><li>冒泡排序，选择排序，插入排序的时间复杂度为平方阶O(n^{2})</li><li>希尔排序，堆排序，归并排序，快速排序的时间复杂度为线性对数阶O(nlog n)</li></ul><p>本篇要给大家介绍的是冒泡排序，选择排序，插入排序，归并排序和快速排序。</p><p>希尔排序是基于插入排序，理解了插入排序以后，理解希尔排序会很容易，故在本文不做介绍。堆排序涉及到一个全新的数据结构：堆，所以笔者将堆这个数据结构和堆排序放在下一篇来做介绍。</p><h2 id="排序初探"><a href="#排序初探" class="headerlink" title="排序初探"></a>排序初探</h2><p>在讲排序算法之前，我们先看一种最简单的排序算法（也是性能最低的，也是最好理解的），在这里先称之为“交换排序”。</p><blockquote><p>注意，这个名称是笔者自己起的，在互联网和相关技术书籍上面没有对该算法起名。</p></blockquote><h3 id="算法讲解"><a href="#算法讲解" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>用两个循环来嵌套遍历：</p><ul><li>外层遍历数组从0到末尾的元素，索引为i.</li><li>里层遍历数组从i+1至数组末尾的元素，索引为j。</li><li>当i上的元素比j上的元素大的时候，交换i和j的元素，目的是保持index为i的元素是最小的。</li></ul><p>我们用一个例子看一下是怎么做交换的：</p><p>给定一个初始数组：<code>array = [4, 1, 2, 5, 0]</code></p><p><strong>i = 0 时</strong>：</p><ul><li>array[0] &gt; array[1] : 交换4和1：<code>[1, 4, 2, 5, 0]</code>，内层的j继续遍历，j++。</li><li>array[0] &gt; array[4] : 交换0和1：<code>[0, 4, 2, 5, 1]</code>，i = 0的外层循环结束，i++。</li></ul><p><strong>i  = 1时</strong>：</p><ul><li>array[1] &gt; array[2] : 交换2和4：<code>[0, 2, 4, 5, 1]</code>，内层的j继续遍历，j++。</li><li>array[1] &gt; array[4] : 交换1和2：<code>[0, 1, 4, 5, 2]</code>，i = 1的外层循环结束，i++。</li></ul><p><strong>i = 2 时</strong>：</p><ul><li>array[2] &gt; array[4] : 交换2和4：<code>[0, 1, 2, 5, 4]</code>，i = 2的外层循环结束，i++。</li></ul><p><strong>i = 3 时</strong>：</p><ul><li>array[3] &gt; array[4] : 交换5和4：<code>[0, 1, 2, 4, 5]</code>，i = 3的外层循环结束，i++。</li></ul><p><strong>i = 4 时</strong>：不符合内循环的边界条件，不进行内循环，排序结束。</p><p>那么用代码如何实现呢？</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span> ..&lt; array.<span class="built_in">count</span> &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> array[i] &gt; array[j] &#123;</span><br><span class="line">                array.swapAt(i, j) </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"\(array)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面<code>swapAt</code>函数是使用了Swift内置的数组内部交换两个index的函数，在后面会经常用到。</p><p>为了用代码验证上面所讲解的交换过程，可以在<code>swapAt</code>函数下面将交换元素后的数组打印出来：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalArray = [<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"original array:\n\(originalArray)\n"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">switchSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span> ..&lt; array.<span class="built_in">count</span> &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> array[i] &gt; array[j] &#123;</span><br><span class="line">                array.swapAt(i, j) </span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"\(array)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">switchSort(&amp;originalArray)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">original array:</span><br><span class="line">[4, 1, 2, 5, 0]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">switch sort...</span><br><span class="line">[1, 4, 2, 5, 0]</span><br><span class="line">[0, 4, 2, 5, 1]</span><br><span class="line">[0, 2, 4, 5, 1]</span><br><span class="line">[0, 1, 4, 5, 2]</span><br><span class="line">[0, 1, 2, 5, 4]</span><br><span class="line">[0, 1, 2, 4, 5]</span><br></pre></td></tr></table></figure><p>验证后我们可以看到，结果和上面分析的结果是一样的。</p><p>各位读者也可以自己设置原数组，然后在运行代码之前按照自己的理解，把每一次交换的结果写出来，接着和运行算法之后进行对比。该方法对算法的理解很有帮助，推荐大家使用~</p><blockquote><p>请务必理解好上面的逻辑，可以通过动笔写结果的方式来帮助理解和巩固，有助于对下面讲解的排序算法的理解。</p></blockquote><p>大家看上面的交换过程（排序过程）有没有什么问题？相信细致的读者已经看出来了：<strong>在原数组中，1和2都是比较靠前的位置，但是经过中间的排序以后，被放在了数组后方，然后再次又交换回来</strong>。这显然是比较低效的，给人的感觉像是做了无用功。</p><p>那么有没有什么方法可以优化一下交换的过程，让交换后的结果与元素最终在数组的位置基本保持一致呢？</p><p>答案是肯定的，这就引出了笔者要第一个正式介绍的排序算法冒泡排序：</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="算法讲解-1"><a href="#算法讲解-1" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>与上面讲的交换排序类似的是，冒泡排序也是用两层的循环来实现的；但与其不同的是：</p><ul><li>循环的边界条件：冒泡排序的外层是[0,array.count-1);内层是[0,array.count-1-i)。可以看到内层的范围是不断缩小的，而且范围的前端不变，后端在向前移。</li></ul><ul><li>交换排序比较的是内外层索引的元素（array[i] 和 array[j]）,但是冒泡排序比较的是两个相邻的内层索引的元素：array[j]和array[j+1]。</li></ul><p>笔者用和上面交换排序使用的同一个数组来演示下元素是如何交换的：</p><p>初始数组：<code>array = [4, 1, 2, 5, 0]</code></p><p><strong>i = 0 时</strong>：</p><ul><li>array[0] &gt; array[1] : 交换4和1：<code>[1, 4, 2, 5, 0]</code>，内层的j继续遍历，j++。</li><li>array[1] &gt; array[2] : 交换4和2：<code>[1, 2, 4, 5, 0]</code>，内层的j继续遍历，j++。</li><li>array[2] &lt; array[3] : 不交换，内层的j继续遍历，j++。</li><li>array[3] &gt; array[4] : 交换5和0：<code>[1, 2, 4, 0, 5]</code>，i = 0的外层循环结束，i++。</li></ul><p><strong>i  = 1时</strong>：</p><ul><li>array[2] &gt; array[3] : 交换2和4：<code>[1, 2, 0, 4, 5]</code>，内层的j继续遍历，j++。</li><li>array[3] &lt; array[4] : 不交换，i = 1的外层循环结束，i++。</li></ul><p><strong>i = 2 时</strong>：</p><ul><li>array[1] &gt; array[2] : 交换2和0：<code>[1, 0, 2, 4, 5]</code>，内层的j继续遍历，j++，直到退出i=2的外层循环，i++。</li></ul><p><strong>i = 3 时</strong>：</p><ul><li>array[0] &gt; array[1] : 交换1和0：<code>[0, 1, 2, 4, 5]</code>，内层的j继续遍历，j++，直到退出i=3的外层循环，i++。</li></ul><p>i = 4 时：不符合外层循环的边界条件，不进行外层循环，排序结束。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们来看一下冒泡排序的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> - i &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> array[j] &gt; array[j+<span class="number">1</span>] &#123;</span><br><span class="line">                array.swapAt(j, j+<span class="number">1</span>)                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码我们可以清楚地看到循环遍历的边界条件和交换时机。同样地，我们添加上log，将冒泡排序每次交换后的数组打印出来（为了进行对比，笔者将交换排序的log也打印了出来）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">original array:</span><br><span class="line">[4, 1, 2, 5, 0]</span><br><span class="line"></span><br><span class="line">switch sort...</span><br><span class="line">[1, 4, 2, 5, 0]</span><br><span class="line">[0, 4, 2, 5, 1]</span><br><span class="line">[0, 2, 4, 5, 1]</span><br><span class="line">[0, 1, 4, 5, 2]</span><br><span class="line">[0, 1, 2, 5, 4]</span><br><span class="line">[0, 1, 2, 4, 5]</span><br><span class="line"></span><br><span class="line">bubble sort...</span><br><span class="line">[1, 4, 2, 5, 0]</span><br><span class="line">[1, 2, 4, 5, 0]</span><br><span class="line">[1, 2, 4, 0, 5]</span><br><span class="line">[1, 2, 0, 4, 5]</span><br><span class="line">[1, 0, 2, 4, 5]</span><br><span class="line">[0, 1, 2, 4, 5]</span><br></pre></td></tr></table></figure><p>从上面两组打印可以看出，冒泡排序算法解决了交换排序算法的不足：</p><ul><li>原来就处于靠前位置的1，2两个元素，在排序的过程中一直是靠前的。</li><li>原来处于末尾的0元素，在冒泡排序的过程中一点一点地向前移动，最终到了应该处于的位置。</li></ul><p>现在我们知道冒泡排序是好于交换排序的，而且它的做法是相邻元素的两两比较：如果是逆序（左大右小）的话就做交换。</p><p>那么如果在排序过程中，数组已经变成有序的了，那么再进行两两比较就很不划算了。</p><p>为了证实上面这个排序算法的局限性，我们用新的测试用例来看一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalArray = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br></pre></td></tr></table></figure><p>而且这次我们不仅仅在交换以后打log，也记录一下作比较的次数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;    </span><br><span class="line">    <span class="keyword">var</span> compareCount = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> - i &#123;</span><br><span class="line"></span><br><span class="line">            compareCount += <span class="number">1</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No.\(compareCount) compare \(array[j]) and \(array[j+1])"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> array[j] &gt; array[j+<span class="number">1</span>] &#123;</span><br><span class="line">                array.swapAt(j, j+<span class="number">1</span>) <span class="comment">//keeping index of j is the smaller one</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"after swap: \(array)"</span>)</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">original array:</span><br><span class="line">[2, 1, 3, 4, 5]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bubble sort...</span><br><span class="line">No.1 compare 2 and 1</span><br><span class="line">after swap: [1, 2, 3, 4, 5] //already sorted, but keep comparing</span><br><span class="line">No.2 compare 2 and 3</span><br><span class="line">No.3 compare 3 and 4</span><br><span class="line">No.4 compare 4 and 5</span><br><span class="line">No.5 compare 1 and 2</span><br><span class="line">No.6 compare 2 and 3</span><br><span class="line">No.7 compare 3 and 4</span><br><span class="line">No.8 compare 1 and 2</span><br><span class="line">No.9 compare 2 and 3</span><br><span class="line">No.10 compare 1 and 2</span><br></pre></td></tr></table></figure><p>从打印的结果可以看出，其实在第一次交换过之后，数组已经是有序的了，但是该算法还是继续在比较，做了很多无用功，能不能有个办法可以让这种两两比较在已知有序的情况下提前结束呢？答案是肯定的。</p><p>提前结束这个操作很容易，我们只需要跳出最外层的循环就好了。关键是这个时机：我们需要让算法自己知道<strong>什么时候数组已经是有序的了</strong>。</p><p>是否已经想到了呢？就是在一次内循环过后，如果没有发生元素交换，就说明数组已经是有序的，不需要再次缩小内循环的范围继续比较了。所以我们需要在外部设置一个布尔值的变量来标记“该数组是否有序”：</p><p>我们将这个算法称为：advanced bubble sort</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">bubbleSortAdvanced</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//bool switch</span></span><br><span class="line">        <span class="keyword">var</span> swapped = <span class="literal">false</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - i - <span class="number">1</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> array[j] &gt; array [j+<span class="number">1</span>] &#123;</span><br><span class="line">                array.swapAt(j, j+<span class="number">1</span>) </span><br><span class="line">                swapped = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if there is no swapping in inner loop, it means the the part looped is already sorted,</span></span><br><span class="line">        <span class="comment">//so it's time to break</span></span><br><span class="line">        <span class="keyword">if</span> (swapped == <span class="literal">false</span>)&#123; <span class="keyword">break</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，在第一个冒泡排序的算法之内，只添加了一个<code>swapped</code>这个布尔值，默认为false：</p><ul><li>如果在当前内循环里面没有发生过元素交换，则说明当前内循环范围的元素都是有序的；那么就说明后续的内循环范围的元素也是有序的（因为内循环每次迭代后都会缩小），就可以跳出循环了。</li><li>反之，如果在当前内循环里发生过元素交换，则说明当前内循环很可能是无序的（也可能是有序的，但是有序性需要在下一个内循环中验证，所以还是不能提前退出，还需要进行一次内循环）。</li></ul><p>为了验证上面这个改进冒泡排序是否能解决最初给出的冒泡排序的问题，我们添加上对比次数的log：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">original array:</span><br><span class="line">[2, 1, 3, 4, 5]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bubble sort...</span><br><span class="line">No.1 compare 2 and 1</span><br><span class="line">after swap: [1, 2, 3, 4, 5]</span><br><span class="line">No.2 compare 2 and 3</span><br><span class="line">No.3 compare 3 and 4</span><br><span class="line">No.4 compare 4 and 5</span><br><span class="line">No.5 compare 1 and 2</span><br><span class="line">No.6 compare 2 and 3</span><br><span class="line">No.7 compare 3 and 4</span><br><span class="line">No.8 compare 1 and 2</span><br><span class="line">No.9 compare 2 and 3</span><br><span class="line">No.10 compare 1 and 2</span><br><span class="line">bubble sort time duration : 1.96ms</span><br><span class="line"></span><br><span class="line">advanced bubble sort...</span><br><span class="line">No.1 compare 2 and 1</span><br><span class="line">after swap: [1, 2, 3, 4, 5]</span><br><span class="line">No.2 compare 2 and 3</span><br><span class="line">No.3 compare 3 and 4</span><br><span class="line">No.4 compare 4 and 5</span><br><span class="line">No.5 compare 1 and 2</span><br><span class="line">No.6 compare 2 and 3</span><br><span class="line">No.7 compare 3 and 4</span><br></pre></td></tr></table></figure><p>我们可以看到，在使用改进的冒泡排序后，对比的次数少了3次。之所以没有立即返回，是因为即使在交换完变成有序数组以后，也无法在当前内循环判断出是有序的。需要在下次内循环才能验证出来。</p><p>因为数组的元素数量比较小，所以可能对这个改进所达到的效果体会得不是很明显。现在我们增加一下数组元素的个数，并用记录<strong>比较总和</strong>的方式来看一下二者的区别：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">original array:</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>]</span><br><span class="line"></span><br><span class="line">bubble <span class="built_in">sort</span>...</span><br><span class="line">total compare <span class="built_in">count</span>： <span class="number">91</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">advanced bubble <span class="built_in">sort</span>...</span><br><span class="line">total compare <span class="built_in">count</span>： <span class="number">25</span></span><br></pre></td></tr></table></figure><p>从比较结果可以看出，这两种算法在该测试样本下的差距是比较大的，而且随着元素个数的增多这个差距会越来越大（因为做了更多没有意义的比较）。</p><p>虽然这种测试样本比较极端，但是在某种意义上还是优化了最初的冒泡排序算法。一般在网上的冒泡排序算法应该都能看到这个优化版的。</p><p>现在我们知道这个优化版的冒泡排序算法可以在知道当前数组已经有序的时候提前结束，但是毕竟不断的交换还是比较耗费性能的，有没有什么方法可以只移动一次就能做好当前元素的排序呢？答案又是肯定的，这就引出了笔者即将介绍的选择排序算法。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="算法讲解-2"><a href="#算法讲解-2" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>选择排序也是两层循环：</p><ul><li>外层循环的边界是[0,array.count-1)，index为i。</li><li>内层循环的边界是[i+1,array.count)，index为j。可以看到内层的范围也是不断缩小的，而且范围的前端一直后移，后端保持不变。</li></ul><p>具体做法是：</p><ul><li>在外层循环的开始，将i作为最小值index（很可能不是该数组的最小值）。</li><li>在内层循环里面找到当前内层循环范围内的最小值，并与已经记录的最小值作比较：<ul><li>如果与当前记录的最小值index不同，则替换</li><li>如果与当前记录的最小值index相同，则不替换</li></ul></li></ul><p>我们还是用手写迭代的方式看一下选择排序的机制，使用的数组和上面交换排序和冒泡排序（非优化版）的数组一致：<code>[4, 1, 2, 5, 0]</code></p><p>i = 0 时：</p><ol><li>记录当前的最小值的index为0，当前最小值为4。</li><li>内层循环开始，找到[1,5)之间的最小值为0，0的index为4，与当前最小值的index0不同，所以二者要做交换。交换后的数组：<code>[0, 1, 2, 5, 4]</code>。当前内层循环结束，i++。</li></ol><p><strong>i = 1 时</strong>：</p><ol><li>记录当前的最小值的index为1，当前最小值为1。</li><li>内层循环开始，找到[2,5)之间的最小值为1，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。</li></ol><p><strong>i = 2 时</strong>：</p><ol><li>记录当前的最小值的index为2，当前最小值为2。</li><li>内层循环开始，找到[3,5)之间的最小值为2，与当前记录的最小值index相同。也就是说后面没有比1还要小的了，不做交换。当前内层循环结束，i++。</li></ol><p><strong>i = 3 时</strong>：</p><ol><li>记录当前的最小值的index为3，当前最小值为2。</li><li>内层循环开始，找到[4,5)之间的最小值为4，4的index为4，与当前记录的最小值index3不同，所以二者要做交换。交换后的数组：<code>[0, 1, 2, 4, 5]</code>。当前内层循环结束，i++。</li></ol><p><strong>i = 4 时</strong>：不符合外层循环的边界条件，不进行外层循环，排序结束。</p><p>我们可以看到，同样的初始序列，使用选择排序只进行了2次交换，因为它知道需要替换的最小值是什么，做了很少没意义的交换。</p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们用代码来实现一下上面选择排序的算法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectionSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; array.<span class="built_in">count</span> - <span class="number">1</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">min</span> = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> i + <span class="number">1</span> ..&lt; array.<span class="built_in">count</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> array[j] &lt; array[<span class="built_in">min</span>] &#123;</span><br><span class="line">                <span class="built_in">min</span> = j </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//if min has changed, it means there is value smaller than array[min]</span></span><br><span class="line">        <span class="comment">//if min has not changed, it means there is no value smallter than array[min]</span></span><br><span class="line">        <span class="keyword">if</span> i != <span class="built_in">min</span> &#123;</span><br><span class="line">            array.swapAt(i, <span class="built_in">min</span>) </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看到，在这里使用了<code>min</code>这个变量记录了当前外层循环所需要被比较的index值，如果当前外层循环的内层循环内部找到了比这个最小值还小的值，就替换他们。</p><p>下面我们使用log来看一下此时选择排序作替换的次数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">original array:</span><br><span class="line">[4, 1, 2, 5, 0]</span><br><span class="line"></span><br><span class="line">advanced bubble sort...</span><br><span class="line">after swap: [1, 4, 2, 5, 0]</span><br><span class="line">after swap: [1, 2, 4, 5, 0]</span><br><span class="line">after swap: [1, 2, 4, 0, 5]</span><br><span class="line">after swap: [1, 2, 0, 4, 5]</span><br><span class="line">after swap: [1, 0, 2, 4, 5]</span><br><span class="line">after swap: [0, 1, 2, 4, 5]</span><br><span class="line"></span><br><span class="line">selection sort...</span><br><span class="line">after swap: [0, 1, 2, 5, 4]</span><br><span class="line">after swap: [0, 1, 2, 4, 5]</span><br></pre></td></tr></table></figure><p>从上面的log可以看出二者的对比应该比较明显了。</p><p>为了进一步验证选择排序的性能，笔者在网上找到了两个工具：</p><ul><li>计算程序运行时间的类：<code>executionTimeInterval.swift</code></li><li>生成各种类型随机数的Array的分类：<code>Array+Extension.swift</code></li></ul><p>首先看<code>executionTimeInterval.swift</code>的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time interval</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">executionTimeInterval</span><span class="params">(block: <span class="params">()</span></span></span> -&gt; ()) -&gt; <span class="type">CFTimeInterval</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> start = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">    block();</span><br><span class="line">    <span class="keyword">let</span> end = <span class="type">CACurrentMediaTime</span>()</span><br><span class="line">    <span class="keyword">return</span> end - start</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//formatted time</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">extension</span> <span class="title">CFTimeInterval</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> formattedTime: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span> &gt;= <span class="number">1000</span> ? <span class="type">String</span>(<span class="type">Int</span>(<span class="keyword">self</span>)) + <span class="string">"s"</span></span><br><span class="line">            : <span class="keyword">self</span> &gt;= <span class="number">1</span> ? <span class="type">String</span>(format: <span class="string">"%.3gs"</span>, <span class="keyword">self</span>)</span><br><span class="line">            : <span class="keyword">self</span> &gt;= 1e-<span class="number">3</span> ? <span class="type">String</span>(format: <span class="string">"%.3gms"</span>, <span class="keyword">self</span> * 1e3)</span><br><span class="line">            : <span class="keyword">self</span> &gt;= 1e-<span class="number">6</span> ? <span class="type">String</span>(format: <span class="string">"%.3gµs"</span>, <span class="keyword">self</span> * 1e6)</span><br><span class="line">            : <span class="keyword">self</span> &lt; 1e-<span class="number">9</span> ? <span class="string">"0s"</span></span><br><span class="line">            : <span class="type">String</span>(format: <span class="string">"%.3gns"</span>, <span class="keyword">self</span> * 1e9)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个函数以block的形式传入需要测试运行时间的函数，返回了函数运行的时间。</p><p>第二个函数是<code>CFTimeInterval</code>的分类，将秒数添加了单位：毫秒级的以毫秒显示，微秒级的以微秒显示，大于1秒的以秒单位显示。</p><p>使用方法是：将两个swift文件拖进playground里面的Sources文件夹里，并点击二者后，进入playground内部：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> selectionSortedArray = [<span class="type">Int</span>]()</span><br><span class="line"><span class="keyword">var</span> time4 = executionTimeInterval&#123;</span><br><span class="line">    selectionSortedArray = selectionSort(&amp;originalArray4) <span class="comment">//要测试的函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"selection sort time duration : \(time4.formattedTime)"</span>) <span class="comment">//打印出时间</span></span><br></pre></td></tr></table></figure><p>再来看一下<code>Array+Extension.swift</code>类：</p><p>先介绍其中的一个方法，生成随机数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">randomArray</span><span class="params">(size: Int, maxValue: UInt)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> result = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>:size)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; size &#123;</span><br><span class="line">            result[i] = <span class="type">Int</span>(arc4random_uniform(<span class="type">UInt32</span>(maxValue)))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法只需要传入数组的大小以及最大值就可以生成一个不超过这个最大值的随机数组。</p><p>比如我们要生成一个数组长度为10，最大值为100的数组：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalArray = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;.randomArray(size: inputSize, maxValue:<span class="number">100</span>)</span><br><span class="line"><span class="comment">//originalArray:[87, 56, 54, 20, 86, 33, 41, 9, 88, 55]</span></span><br></pre></td></tr></table></figure><p>那么现在有了上面两个工具，我们就可以按照我们自己的意愿来生成测试用例数组，并且打印出所用算法的执行时间。我们现在生成一个数组长度为10，最大值为100的数组，然后分别用优化的冒泡排序和选择排序来看一下二者的性能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">original array:</span><br><span class="line">[1, 4, 80, 83, 92, 63, 83, 23, 9, 85]</span><br><span class="line"></span><br><span class="line">advanced bubble sort...</span><br><span class="line">advanced bubble sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 8.53ms</span><br><span class="line"></span><br><span class="line">selection sort...</span><br><span class="line">selection sort result: [1, 4, 9, 23, 63, 80, 83, 83, 85, 92] time duration : 3.4ms</span><br></pre></td></tr></table></figure><p>我们现在让数组长度更长一点:一个长度为100，最大值为200：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">advanced bubble sort...</span><br><span class="line">advanced bubble sort sorted elemets: 100 time duration : 6.27s</span><br><span class="line"></span><br><span class="line">selection sort...</span><br><span class="line">selection sort sorted elemets: 100 time duration : 414ms</span><br></pre></td></tr></table></figure><p>可以看到，二者的差别大概在12倍左右。这个差别已经很大了，如果说用选择排序需要1天的话，冒泡排序需要12天。</p><p>现在我们学习了选择排序，知道了它是通过减少交换次数来提高排序算法的性能的。</p><p>但是关于排序，<strong>除了交换操作以外，对比操作也是需要时间的</strong>：选择排序通过内层循环的不断对比才得到了当前内层循环的最小值，然后进行后续的判断和操作。</p><p>那么有什么办法可以减少对比的次数呢？猜对了，答案又是肯定的。这就引出了笔者下面要说的算法：插入排序算法。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="算法讲解-3"><a href="#算法讲解-3" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>插入排序的基本思想是：从数组中拿出一个元素（通常就是第一个元素）以后，再从数组中按顺序拿出其他元素。如果拿出来的这个元素比这个元素小，就放在这个元素左侧；反之，则放在右侧。整体上看来有点和玩儿扑克牌的时候将刚拿好的牌来做排序差不多。</p><p>选择排序也是两层循环：</p><ul><li>外层循环的边界是[1,array.count)，index为i。</li><li>内层循环开始的时候初始index j = i，然后使用一个while循环，循环条件是<code>j&gt;0 &amp;&amp; array[j] &lt; array[j - 1]</code>,循环内侧是交换j-1和j的元素，并使得j-1。可以简单理解为如果当前的元素比前一个元素小，则调换位置；反之进行下一个外层循环。</li></ul><p>下面我们还是用手写迭代的方式看一下插入排序的机制，使用的数组和上面选择排序的数组一致：<code>[4, 1, 2, 5, 0]</code></p><p><strong>i = 1 时</strong>：</p><ol><li>j = 1：array[1] &lt; array[0]， 交换4和1：<code>[1, 4, 2, 5, 0]</code>，j-1之后不符合内层循环条件，退出内层循环，i+1。</li></ol><p><strong>i = 2 时</strong>：</p><ol><li>j = 2，array[3] &lt; array[2]，交换4和2：<code>[1, 2, 4, 5, 0]</code>，j向左移动，array[2] &gt; array[1]，不符合内层循环条件，退出内层循环，i+1。</li></ol><p><strong>i = 3 时</strong>：</p><ol><li>j = 3，array[3] &gt; array[2]，不符合内层循环条件，退出内层循环，i+1。</li></ol><p><strong>i = 4 时</strong>：</p><ol><li>j = 4，array[4] &lt; array[3]，交换5和0：<code>[1, 2, 4, 0, 5]</code>，j -1。</li><li>j = 3，array[3] &lt; array[2]，交换4和0：<code>[1, 2, 0, 4, 5]</code>，j -1。</li><li>j = 2，array[2] &lt; array[1]，交换4和0：<code>[1, 0, 2, 4, 5]</code>，j -1。</li><li>j = 1，array[1] &lt; array[0]，交换1和0：<code>[0, 1, 2, 4, 5]</code>，j -1 = 0，不符合内层循环条件，退出内层循环，i+1 = 5，不符合外层循环条件，排序终止。</li></ol><p>从上面的描述可以看出，和选择排序相比，<strong>插入排序的内层循环是可以提前推出的</strong>，其条件就是<code>array[j] &gt;= array[j - 1]</code>,也就是说，当前index为j的元素只要比前面的元素大，那么该内层循环就立即退出，不需要再排序了，因为该算法从一开始就是小的放前面，大的放后面。</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面我们通过代码来看一下如何实现插入排序算法:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertionSort</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;array.<span class="built_in">count</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> j = i</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> &amp;&amp; array[j] &lt; array[j - <span class="number">1</span>] &#123;</span><br><span class="line">             array.swapAt(j - <span class="number">1</span>, j)</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出插入排序内层循环的条件：<code>j &gt; 0 &amp;&amp; array[j] &lt; array[j - 1]</code>。只要当前元素比前面的元素小，就会一直交换下去；反之，当大于等于前面的元素，就会立即跳出循环。</p><p>之前笔者有提到相对于选择排序，说插入排序可以减少元素之间对比的次数，下面我们通过打印对比次数来对比一下两种算法：</p><p>使用元素个数为50，最大值为50的随机数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">selection sort...</span><br><span class="line">compare times:1225</span><br><span class="line">selection sort time duration : 178ms</span><br><span class="line"></span><br><span class="line">insertion sort...</span><br><span class="line">compare times:519</span><br><span class="line">insertion sort time duration : 676ms</span><br></pre></td></tr></table></figure><p>我们可以看到，使用选择排序的比较次数比插入排序的比较次数多了2倍。但是遗憾的是整体的性能选择排序要高于插入排序。</p><p>也就是说虽然插入排序的比较次数少了，但是交换的次数却比选择排序要多，所以性能上有时可能不如选择排序。</p><blockquote><p>注意，这不与笔者之前的意思相矛盾，笔者只是说在减少比较次数上插入排序是优于选择排序的，但没有说插入排序整体上优于选择排序。</p></blockquote><p>那么有何种特性的数组可以让排序算法有其用武之地呢？</p><p>从上面使用插入排序来排序<code>[4, 1, 2, 5, 0]</code>这个数组的时候，我们可以看到，因为0这个元素已经在末尾了，所以在j=4的时候我们费了好大劲才把它移到前面去。</p><p>那么将这个情况作为一个极端，我们可以这样想：如果这个数组里的元素里的index大致于最终顺序差不多的情况是不是就不用做这么多的搬移了？。这句话听起来像是理所当然的话，但是有一种数组属于“基本有序”的数组，这种数组也是无需的，但是它在整体上是有序的，比如：</p><p><code>[2,1,3,6,4,5,9,7,8]</code></p><p>用笔者的话就叫做整体有序，部分无序。</p><p>我们可以简单用这个数组来分别进行选择排序和插入排序做个比较：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">selection sort...</span><br><span class="line">compare times:36</span><br><span class="line">selection sort time duration : 4.7ms</span><br><span class="line"></span><br><span class="line">insertion sort...</span><br><span class="line">compare times:5</span><br><span class="line">insertion sort time duration : 3.2ms</span><br></pre></td></tr></table></figure><p>我们可以看到插入排序在基本有序的测试用例下表现更好。为了让差距更明显，笔者在<code>Array+Extension.swift</code>文件里增加了一个生成基本有序随机数组的方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">nearlySortedArray</span><span class="params">(size: Int, gap:Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = [<span class="type">Int</span>](repeating: <span class="number">0</span>, <span class="built_in">count</span>:size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; size &#123;</span><br><span class="line">        result[i] = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">count</span> : <span class="type">Int</span> = size / gap</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="type">Int</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; <span class="built_in">count</span> &#123;</span><br><span class="line">        arr.append(i*gap)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span> ..&lt; arr.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> swapIndex = arr[j]</span><br><span class="line">        result.swapAt(swapIndex,swapIndex+<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数需要传入数组的长度以及需要打乱顺序的index的跨度，它的实现是这样子的：</p><ul><li>首先生成一个完全有序的序列。</li><li>将数组长度除以跨度来得出需要交换的index的个数count。</li><li>根据这个count可以得出需要交换的index，把这些index放在一个新的arr里面</li><li>便利这个arr来取出index，将之前生成好的w安全有序的数组的index于index+1做交换。</li></ul><p>举个例子，如果我们生成一个数组长度为12，跨度为3的基本有序的数组，就可以这么调用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalArray = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;.nearlySortedArray(size: <span class="number">12</span>, gap: <span class="number">3</span>)</span><br><span class="line"><span class="comment">//[1, 0, 2, 4, 3, 5, 7, 6, 8, 10, 9, 11]</span></span><br></pre></td></tr></table></figure><p>跨度为3，说明有12/3 = 4 - 1 = 3 个元素需要调换位置，序号分别为0，3，6，9。所以序号为0，1；3，4；6，7；9，10的元素被调换了位置，可以看到调换后的数组还是基本有序的。</p><p>现在我们可以用一个比较大的数组来验证了：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalArray = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;.nearlySortedArray(size: <span class="number">100</span>, gap: <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">selection sort...</span><br><span class="line">compare times:4950</span><br><span class="line">selection sort time duration : 422ms</span><br><span class="line"></span><br><span class="line">insertion sort...</span><br><span class="line">compare times:10</span><br><span class="line">insertion sort time duration : 56.4ms</span><br></pre></td></tr></table></figure><p>我们可以看到差距是非常明显的，插入排序的性能是选择排序的性能的近乎10倍</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="算法讲解-4"><a href="#算法讲解-4" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>归并排序使用了算法思想里的<strong>分治思想</strong>（divide conquer）。顾名思义，就是将一个大问题，分成类似的小问题来逐个攻破。在归并排序的算法实现上，首先逐步将要排序的数组等分成最小的组成部分（通常是1各元素），然后再反过来逐步合并。</p><p>用一张图来体会一下归并算法的实现过程： </p><p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175e83e236cf?w=944&amp;h=637&amp;f=png&amp;s=70522" alt=""></p><p>上图面的虚线箭头代表拆分的过程；实线代表合并的过程。仔细看可以发现，拆分和归并的操作都是重复进行的，在这里面我们可以使用递归来操作。</p><p>首先看一下归并的操作：</p><p>归并的操作就是把两个数组（在这里这两个数组的元素个数通常是一致的）合并成一个完全有序数组。</p><p>归并操作的实现步骤是：</p><ul><li>新建一个空数组，该数组用于存放合并后的有序数组。</li><li>两个传入的数组从index 0 开始两两比较，较小的元素放在新建的空数组中，index + 1; 较大的元素不作操作，index 不变，然后继续两两比较。知道index移到末尾为止。</li><li>个别情况当两个数组长度不一致的情况下需要将数组里剩余的元素放在新建的数组中。</li></ul><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><p>我们来看一下归并排序算法的代码实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_merge</span><span class="params">(leftPile: [Int], rightPile: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> leftIndex = <span class="number">0</span>   <span class="comment">//left pile index, start from 0</span></span><br><span class="line">    <span class="keyword">var</span> rightIndex = <span class="number">0</span>  <span class="comment">//right pile index, start from 0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> sortedPile = [<span class="type">Int</span>]() <span class="comment">//sorted pile, empty in the first place</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> leftIndex &lt; leftPile.<span class="built_in">count</span> &amp;&amp; rightIndex &lt; rightPile.<span class="built_in">count</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//append the smaller value into sortedPile</span></span><br><span class="line">        <span class="keyword">if</span> leftPile[leftIndex] &lt; rightPile[rightIndex] &#123;</span><br><span class="line">            </span><br><span class="line">            sortedPile.append(leftPile[leftIndex])</span><br><span class="line">            leftIndex += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> leftPile[leftIndex] &gt; rightPile[rightIndex] &#123;</span><br><span class="line">            </span><br><span class="line">            sortedPile.append(rightPile[rightIndex])</span><br><span class="line">            rightIndex += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//same value, append both of them and move the corresponding index</span></span><br><span class="line">            sortedPile.append(leftPile[leftIndex])</span><br><span class="line">            leftIndex += <span class="number">1</span></span><br><span class="line">            sortedPile.append(rightPile[rightIndex])</span><br><span class="line">            rightIndex += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//left pile is not empty</span></span><br><span class="line">    <span class="keyword">while</span> leftIndex &lt; leftPile.<span class="built_in">count</span> &#123;</span><br><span class="line">        sortedPile.append(leftPile[leftIndex])</span><br><span class="line">        leftIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//right pile is not empty</span></span><br><span class="line">    <span class="keyword">while</span> rightIndex &lt; rightPile.<span class="built_in">count</span> &#123;</span><br><span class="line">        sortedPile.append(rightPile[rightIndex])</span><br><span class="line">        rightIndex += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sortedPile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为该函数是归并排序函数内部调用的函数，所以在函数名称的前面添加了下划线。仅仅是为了区分，并不是必须的。</p></blockquote><p>从上面代码可以看出合并的实现逻辑：</p><ul><li>新建空数组，初始化两个传入数组的index为0</li><li>两两比较两个数组index上的值，较小的放在新建数组里面并且index+1。</li><li>最后检查是否有剩余元素，如果有则添加到新建数组里面。</li></ul><p>理解了合并的算法，下面我们看一下拆分的算法。拆分算法使用了递归：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(<span class="number">_</span> array: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> middleIndex = array.<span class="built_in">count</span> / <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> leftArray = mergeSort(<span class="type">Array</span>(array[<span class="number">0</span>..&lt;middleIndex]))             <span class="comment">// recursively split left part of original array</span></span><br><span class="line">    <span class="keyword">let</span> rightArray = mergeSort(<span class="type">Array</span>(array[middleIndex..&lt;array.<span class="built_in">count</span>]))  <span class="comment">// recursively split right part of original array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _merge(leftPile: leftArray, rightPile: rightArray)             <span class="comment">// merge left part and right part</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到<code>mergeSort</code>调用了自身，它的递归终止条件是<code>!(array.count &gt;1)</code>，也就是说当数组元素个数 = 1的时候就会返回，会触发调用栈的出栈。</p><p>从这个递归函数的实现可以看到它的作用是不断以中心店拆分传入的数组。根据他的递归终止条件，当数组元素 &gt; 1的时候，拆分会继续进行。而下面的合并函数只有在递归终止，开始出栈的时候才开始真正执行。也就是说在拆分结束后才开始进行合并，这样符合了上面笔者介绍的归并算法的实现过程。</p><p>上段文字需要反复体会。</p><p>为了更形象体现出归并排序的实现过程，可以在合并函数(<code>_merge</code>)内部添加log来验证上面的说法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_merge</span><span class="params">(leftPile: [Int], rightPile: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nmerge left pile:\(leftPile)  |  right pile:\(rightPile)"</span>)</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sorted pile：\(sortedPile)"</span>)</span><br><span class="line">    <span class="keyword">return</span> sortedPile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且为了方便和上图作比较，初始数组可以取图中的<code>[3, 5, 9, 2, 7, 4, 8, 0]</code>。运行一下看看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">original array:</span><br><span class="line">[3, 5, 9, 2, 7, 4, 8, 0]</span><br><span class="line"></span><br><span class="line">merge sort...</span><br><span class="line"></span><br><span class="line">merge left pile:[3]  |  right pile:[5]</span><br><span class="line">sorted pile：[3, 5]</span><br><span class="line"></span><br><span class="line">merge left pile:[9]  |  right pile:[2]</span><br><span class="line">sorted pile：[2, 9]</span><br><span class="line"></span><br><span class="line">merge left pile:[3, 5]  |  right pile:[2, 9]</span><br><span class="line">sorted pile：[2, 3, 5, 9]</span><br><span class="line"></span><br><span class="line">merge left pile:[7]  |  right pile:[4]</span><br><span class="line">sorted pile：[4, 7]</span><br><span class="line"></span><br><span class="line">merge left pile:[8]  |  right pile:[0]</span><br><span class="line">sorted pile：[0, 8]</span><br><span class="line"></span><br><span class="line">merge left pile:[4, 7]  |  right pile:[0, 8]</span><br><span class="line">sorted pile：[0, 4, 7, 8]</span><br><span class="line"></span><br><span class="line">merge left pile:[2, 3, 5, 9]  |  right pile:[0, 4, 7, 8]</span><br><span class="line">sorted pile：[0, 2, 3, 4, 5, 7, 8, 9]</span><br></pre></td></tr></table></figure><p>我们可以看到，拆分归并的操作是先处理原数组的左侧部分，然后处理原数组的右侧部分。这是为什么呢？</p><p>我们来看下最初函数是怎么调用的：</p><p>最开始我们调用函数：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeSort</span><span class="params">(<span class="number">_</span> array: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> middleIndex = array.<span class="built_in">count</span> / <span class="number">2</span></span><br><span class="line">    <span class="keyword">let</span> leftArray = mergeSort(<span class="type">Array</span>(array[<span class="number">0</span>..&lt;middleIndex]))             <span class="comment">//1 </span></span><br><span class="line">    <span class="keyword">let</span> rightArray = mergeSort(<span class="type">Array</span>(array[middleIndex..&lt;array.<span class="built_in">count</span>]))  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _merge(leftPile: leftArray, rightPile: rightArray)            <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在//1这一行开始了递归，这个时候数组是原数组，元素个数是8，而调用mergeSort时原数组被拆分了一半，是4。而4&gt;1，不满足递归终止的条件，继续递归，直到符合了终止条件（[3]）,递归开始返回。以为此时最初被拆分的是数组的左半部分，所以左半部分的拆分会逐步合并，最终得到了<code>[2,3,5,9]</code>。</p><p>同理，再回到了最初被拆分的数组的右半部分（上面代码段中的//2），也是和左测一样的拆分和归并，得到了右侧部分的归并结果：<code>[0,4,7,8</code>。</p><p>而此时的递归调用栈只有一个mergeSort函数了，mergeSort会进行最终的合并（上面代码段中的//3），调用<code>_merge</code>函数，得到了最终的结果：<code>[0, 2, 3, 4, 5, 7, 8, 9]</code>。</p><p>关于归并排序的性能：由于使用了分治和递归并且利用了一些其他的内存空间，所以其性能是高于上述介绍的所有排序的，不过前提是初始元素量不小的情况下。</p><p>我们可以将选择排序和归并排序做个比较：初始数组为长度500，最大值为500的随机数组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">selection sort...</span><br><span class="line">selection sort time duration : 12.7s</span><br><span class="line"></span><br><span class="line">merge sort...</span><br><span class="line">merge sort time duration : 5.21s</span><br></pre></td></tr></table></figure><p>可以看到归并排序的算法是优与选择排序的。</p><p>现在我们知道归并排序使用了分治思想而且使用了递归，能够高效地将数组排序。其实还有一个也是用分治思想和递归，但是却比归并排序还要优秀的算法 - 快速排序算法。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序算法被称之为20世纪十大算法之一，也是各大公司面试比较喜欢考察的算法。</p><h3 id="算法讲解-5"><a href="#算法讲解-5" class="headerlink" title="算法讲解"></a>算法讲解</h3><p>快速排序的基本思想是：通过一趟排序将带排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><blockquote><p>上述文字摘自《大话数据结构》</p></blockquote><p>它的实现步骤为：</p><ol><li>从数列中挑出一个元素（挑选的算法可以是随机，也可以作其他的优化），称为”基准”（pivot）。</li><li>重新对数组进行排序：所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面，相同的放两边。</li><li>递归地进行分区操作，继续把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ol><p>从上面的描述可以看出，分区操作是快速排序中的核心算法。下面笔者结合实例来描述一下分区操作的过程。</p><p>首先拿到初始的数组：<code>[5,4,9,1,3,6,7,8,2]</code></p><ul><li>选择5作为pivot。</li><li>从剩下部分的两端开始：左侧1的标记为low，最右侧2的标记为high。</li><li>先看j：2 &lt; 5 , 交换5和2，j不变 ：<code>[2,4,9,1,3,6,7,8,5]</code> ；</li><li>再看i：2 &lt; 5 , i ++ ；4 &lt; 5, i++；9 &gt; 5，交换 9 和 5，i不变<code>[2,4,5,1,3,6,7,8,9]</code>。</li></ul><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="使用Swift的filter函数"><a href="#使用Swift的filter函数" class="headerlink" title="使用Swift的filter函数"></a>使用Swift的filter函数</h4><p>因为在Swift中有一个数组的filter函数可以找出数组中符合某范围的一些数值，所以笔者先介绍一个会用该函数的简单的快速排序的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort0</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> array: [T])</span></span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pivot = array[array.<span class="built_in">count</span>/<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">let</span> less = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &lt; pivot &#125;</span><br><span class="line">    <span class="keyword">let</span> greater = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; pivot &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> quickSort0(less) + quickSort0(greater)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出这里面使用了递归：选中pivot以后，将数组分成了两个部分，最后将它们合并在一起。虽然这里面使用了Swift里面内置的函数来找出符合这两个个部分的元素，但是读者可以通过这个例子更好地理解快速排序的实现方式。</p><h4 id="使用取index-0-的partition函数"><a href="#使用取index-0-的partition函数" class="headerlink" title="使用取index = 0 的partition函数"></a>使用取index = 0 的partition函数</h4><p>除了使用swift内置的filter函数，当然我们也可以自己实现分区的功能，通常使用的是自定义的partition函数。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_partition</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int], low: Int, high: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> low       = low</span><br><span class="line">    <span class="keyword">var</span> high      = high</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> pivotValue = array[low]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt; high &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> low &lt; high &amp;&amp; array[high] &gt;= pivotValue &#123;</span><br><span class="line">            high -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[low] = array[high]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> low &lt; high &amp;&amp; array[low] &lt;= pivotValue &#123;</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        array[high] = array[low]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    array[low] = pivotValue</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码实现可以看出，最初在这里选择的pivotValue是当前数组的第一个元素。</p><p>然后从数组的最右侧的index逐渐向左侧移动，如果值大于pivotValue，那么index-1；否则直接将high与low位置上的元素调换；同样左侧的index也是类似的操作。</p><p>该函数执行的最终效果就是将最初的array按照选定的pivotValue前后划分。</p><p>那么<code>_partition</code>如何使用呢？</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort1</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int], low: Int, high: Int)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> low &lt; high &#123;        </span><br><span class="line">        <span class="keyword">let</span> pivotIndex = _partition(&amp;array, low: low, high: high)</span><br><span class="line">        quickSort1(&amp;array, low: low, high: pivotIndex - <span class="number">1</span>)</span><br><span class="line">        quickSort1(&amp;array, low: pivotIndex + <span class="number">1</span>, high: high)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外层调用的<code>quickSort1</code>是一个递归函数，不断地进行分区操作，最终得到排好序的结果。</p><p>我们将上面实现的归并排序，使用swift内置函数的快速排序，以及自定义partition函数的快速排序的性能作对比：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">merge <span class="built_in">sort</span>...</span><br><span class="line">merge <span class="built_in">sort</span> time duration : <span class="number">4</span>.85s</span><br><span class="line"></span><br><span class="line">quick <span class="built_in">sort</span>...</span><br><span class="line">quick sort0 time duration : 984ms <span class="comment">//swift filter function</span></span><br><span class="line">quick sort1 time duration : <span class="number">2</span>.64s <span class="comment">//custom partition</span></span><br></pre></td></tr></table></figure><p>上面的测试用例是选择随机数组的，我们看一下测试用例为元素个数一致的基本有序的数组试一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">merge sort...</span><br><span class="line">merge sort time duration : 4.88s</span><br><span class="line"></span><br><span class="line">quick sort...</span><br><span class="line">quick sort0 time duration : 921ms</span><br><span class="line">quick sort1 time duration : 11.3s</span><br></pre></td></tr></table></figure><p>虽然元素个数一致，但是性能却差了很多，是为什么呢？因为我们在分区的时候，pivot的index强制为第一个。那么如果这个第一个元素的值本来就非常小，那么就会造成分区不均的情况（前重后轻），而且由于是迭代操作，每次分区都会造成分区不均，导致性能直线下降。所以有一个相对合理的方案就是在选取pivot的index的时候随机选取。</p><h4 id="使用随机选择pivotValue的partition函数"><a href="#使用随机选择pivotValue的partition函数" class="headerlink" title="使用随机选择pivotValue的partition函数"></a>使用随机选择pivotValue的partition函数</h4><p>实现方法肯简单，只需在分区函数里将pivotValue的index随机生成即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">_partitionRandom</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int], low: Int, high: Int)</span></span> -&gt; <span class="type">Int</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> x      = <span class="type">UInt32</span>(low)</span><br><span class="line">    <span class="keyword">let</span> y      = <span class="type">UInt32</span>(high)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="type">Int</span>(arc4random() % (y - x)) + <span class="type">Int</span>(x)</span><br><span class="line">    <span class="keyword">let</span> pivotValue = array[pivotIndex] </span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在用一个数组长度和上面的测试用例一致的基本有序的数组来测试一下随机选取pivotValue的算法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">merge sort...</span><br><span class="line">merge sort time duration : 4.73s</span><br><span class="line"></span><br><span class="line">quick sort...</span><br><span class="line">quick sort0 time duration : 866ms</span><br><span class="line">quick sort1 time duration : 15.1s  //fixed pivote index</span><br><span class="line">quick sort2 time duration : 4.28s  //random pivote index</span><br></pre></td></tr></table></figure><p>我们可以看到当随机抽取pivot的index的时候，其运行速度速度是上面方案的3倍。</p><p>现在我们知道了3种快速排序的实现，都是根据pivotValue将原数组一分为二。但是如果数组中有大量的重复的元素，而且pivotValue很有可能落在这些元素里，那么显然上面这些算法对于这些可能出现多次于pivotValue重复的情况没有单独做处理。而为了很好解决存在与pivot值相等的元素很多的数组的排序，使用三路排序算法会比较有效果。</p><h4 id="三路快速排序"><a href="#三路快速排序" class="headerlink" title="三路快速排序"></a>三路快速排序</h4><p>三路快速排序将大于，等于，小于pivotValue的元素都区分开，我们看一下具体的实现。先看一下partition函数的实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(<span class="number">_</span> arr: <span class="keyword">inout</span> [Int],  <span class="number">_</span> j: Int, <span class="number">_</span> k: Int)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> j != k <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">    arr[j] = arr[k]</span><br><span class="line">    arr[k] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort3W</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int], low: Int, high: Int)</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> high &lt;= low &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> lt = low       <span class="comment">// arr[low+1...lt] &lt; v</span></span><br><span class="line">    <span class="keyword">var</span> gt = high + <span class="number">1</span>  <span class="comment">// arr[gt...high] &gt; v</span></span><br><span class="line">    <span class="keyword">var</span> i  = low + <span class="number">1</span>   <span class="comment">// arr[lt+1...i) == v</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pivoteIndex = low</span><br><span class="line">    <span class="keyword">let</span> pivoteValue = array[pivoteIndex]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> i &lt; gt &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> array[i] &lt; pivoteValue &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="built_in">swap</span>(&amp;array, i, lt + <span class="number">1</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            lt += <span class="number">1</span></span><br><span class="line">           </span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> pivoteValue &lt; array[i]&#123;</span><br><span class="line">       </span><br><span class="line">            <span class="built_in">swap</span>(&amp;array, i, gt - <span class="number">1</span>)</span><br><span class="line">            gt -= <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">swap</span>(&amp;array, low, lt)</span><br><span class="line">    quickSort3W(&amp;array, low: low, high: lt - <span class="number">1</span>)</span><br><span class="line">    quickSort3W(&amp;array, low: gt, high: high)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quickSort3</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int] )</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    quickSort3W(&amp;array, low: <span class="number">0</span>, high: array.<span class="built_in">count</span> - <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要看<code>quickSort3W</code>方法，这里将数组分成了三个区间，分别是大于，等于，小于pivote的值，对有大量重复元素的数组做了比较好的处理。</p><p>我们生成一个元素数量为500，最大值为5的随机数组看一下这些快速排序算法的性能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">quick sort1 time duration : 6.19s //fixed pivote index</span><br><span class="line">quick sort2 time duration : 8.1s  //random pivote index</span><br><span class="line">quick sort3 time duration : 4.81s //quick sort 3 way</span><br></pre></td></tr></table></figure><p>可以看到三路快速排序（quick sort 3 way）在处理大量重复元素的数组的表现最好。</p><p>对于三路快速排序，我们也可以使用Swift内置的filter函数来实现:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort4</span><span class="params">(<span class="number">_</span> array: [Int])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> array.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> array &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> pivot = array[array.<span class="built_in">count</span>/<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">let</span> less = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &lt; pivot &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">equal</span> = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> == pivot &#125;</span><br><span class="line">    <span class="keyword">let</span> greater = array.<span class="built_in">filter</span> &#123; $<span class="number">0</span> &gt; pivot &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> quicksort4(less) + <span class="built_in">equal</span> + quicksort4(greater)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，介绍完了快速排序在Swift中的5中实现方式。</p><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文讲解了算法的一些基本概念以及结合了Swift代码的实现讲解了冒泡排序，选择排序，插入排序，归并排序，快速排序。相信认真阅读本文的读者能对这些算法有进一步的了解。</p><h2 id="关于算法学习的思考"><a href="#关于算法学习的思考" class="headerlink" title="关于算法学习的思考"></a>关于算法学习的思考</h2><p>关于算法的学习，笔者有一些思考想分享出来，也有可能有不对的地方，但笔者觉得有必要在这里说出来，希望可以引发读者的思考：</p><p><img src="https://user-gold-cdn.xitu.io/2018/2/8/1617175e884d80a7?w=580&amp;h=378&amp;f=png&amp;s=19270" alt=""></p><p>上图的Question是指问题；Mind是指想法，或者解决问题的思路；Code是指代码实现。</p><p>在阅读资料或书籍的算法学习过程，往往是按照图中1，2，3这些实线的路径进行的：</p><ul><li>路径1：给出一个既定的问题后，马上给出解题策略</li><li>路径2：给出一个既定的问题后，马上给出算法实现</li><li>路径3：给出一个算法实现后，马上告诉你这些实现代码的意思</li></ul><p>这些路径在算法的学习中虽然也是必不可少的，但是很容易给人一个错觉，这个错觉就是“<strong>我已经学会了这个算法了</strong>”。但是，仅仅是通过这些路径，对于真正理解算法，和今后对算法的应用还是远远不够的，原因是：</p><ul><li>今后遇到的问题，几乎不可能与现在学习的问题一模一样，所以应该知其所以然，将问题本身抽象出来，达到触类旁通，举一反三。</li><li>有了一个新想法，如果没有足够的代码实现经验，很难以非常合理的方式用代码将其实现出来。所以应该增强将想法转化为代码的能力。</li></ul><p>上面所说的两点的第一点，对应的是上图的路径4：给定一个策略或是设计，要思考这个策略或是设计是解决什么样的问题的，这样也就理解了这个策略或是设计的意义在哪里；而第二点对应的是上图中的路径5：怎样根据一个给定的策略来正确地，合理地用代码地实现出来；而上图中的路径6，笔者觉得也很重要：给定一份解决问题的代码，是否可以想到它所对应的问题是什么。</p><p>综上所述，笔者认为对于算法的学习，需要经常反复在问题，策略以及代码之间反复思考，这样才能真正地达到学以致用。</p><p>因为笔者也刚刚接触这一领域的知识，所以难免会在有些地方的表述有不妥当的地方，还需读者多多给出意见和建议。</p><hr><p><strong>Swift代码</strong></p><p>本篇中出现的代码已经放在GitHub仓库中：</p><ul><li>算法基础部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B3%5D.Algorithm">Algorithm Introduction</a></li><li>排序算法部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B4%5D.Sort%20algorithms">Sort Algorithms</a></li></ul><p><strong>参考文献&amp;网站</strong></p><p><a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">维基百科：算法</a></p><p>《大话数据结构》</p><p>《数据结构与算法分析：C语言描述》</p><p><strong>下篇预告</strong></p><p>下篇会介绍堆这个数据结构以及堆排序算法。</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/da_header_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本篇是《数据结构 &amp;amp; 算法 in Swift》系列连载的第二篇，内容分为如下两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算法基础：简单介绍算法的概念，时间复杂度与空间复杂度，递归，作为本文第二部分的背景知识。&lt;/li&gt;
&lt;li&gt;排序算法：结合Swift的代码实现来讲解冒泡排序，选择排序，插入排序，归并排序，快速排序。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Data Structure &amp; Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/categories/Data-Structure-Algorithm/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://github.com/knightsj/knightsj.github.io/tags/Swift/"/>
    
      <category term="Data Structure" scheme="https://github.com/knightsj/knightsj.github.io/tags/Data-Structure/"/>
    
      <category term="Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>数据结构 &amp; 算法 in Swift （一）：Swift基础和数据结构</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%20&amp;%20%E7%AE%97%E6%B3%95%20in%20Swift%20%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9ASwift%E5%9F%BA%E7%A1%80%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/数据结构 &amp; 算法 in Swift （一）：Swift基础和数据结构/</id>
    <published>2018-02-03T08:25:26.000Z</published>
    <updated>2018-07-16T16:44:42.696Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oih3a9o4n.bkt.clouddn.com/da_header_2.png" alt=""></p><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>从本文标题中的序号可以看出，本文是一个连载的开篇。</p><p>而且这个连载的标题是：数据结构 &amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：</p><h2 id="第一：为什么学习数据结构和算法？"><a href="#第一：为什么学习数据结构和算法？" class="headerlink" title="第一：为什么学习数据结构和算法？"></a>第一：为什么学习数据结构和算法？</h2><p><strong>学习通用性知识，突破技能瓶颈</strong>：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。</p><h2 id="第二：为什么用Swift语言来实现？"><a href="#第二：为什么用Swift语言来实现？" class="headerlink" title="第二：为什么用Swift语言来实现？"></a>第二：为什么用Swift语言来实现？</h2><ol><li><p><strong>选择哪个语言并不重要，重要的是数据结构和算法本身的理解</strong>：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？</p></li><li><p><strong>如今Swift的势头还在上涨</strong>：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。</p></li></ol><a id="more"></a><p>基于上面这些原因，在今年年初把<strong>数据结构，算法和Swift</strong>的学习提上了日程，并且计划以连载的形式把学习过程中的笔记和知识分享出来。</p><p>该系列的<strong>最佳受众</strong>是那些已经会Swift，但是对数据结构和算法还没有过多接触过的iOS开发者。其次是那些不会Swift也不会数据结构和算法的iOS开发者，毕竟Swift是大势所趋。</p><p>不过对于那些非iOS开发者来说也同样适合，因为还是那句话：<strong>重点不在于使用哪种语言，而是数据结构和算法本身</strong>。除了第一篇会讲解一些在这个系列文章会使用到的Swift基础语法以外，后续的文章我会逐渐<strong>弱化对Swift语言的讲解，将重点放在数据结构和算法这里</strong>。而且后续我还会不断增加其他语言的实现（Java语言是肯定要加的，其他的语言还待定）。</p><p>好了，背景介绍完了，现在正式开始：</p><p>作为该系列的开篇，本文分为两个部分：</p><ol><li><strong>Swift语法基</strong>础：讲解一下后续连载中讲到的数据结构和算法所涉及到的Swift语法知识（并不是很全面，也不是很深入，但是在实现数据结构和算法这块应该是够了）。</li><li><strong>数据结构</strong>：简单介绍数据结构和算法的相关概念，以及用Swift来实现几个简单的数据结构（链表，栈，队列）</li></ol><blockquote><p>注：该系列涉及到的Swift语法最低基于Swift4.0。</p></blockquote><h1 id="Swift-语法基础"><a href="#Swift-语法基础" class="headerlink" title="Swift 语法基础"></a>Swift 语法基础</h1><p>Swift语法基础从以下几点来展开：</p><ol><li>循环语句</li><li>泛型</li><li>guard</li><li>函数</li><li>集合</li></ol><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="循环条件的开闭区间"><a href="#循环条件的开闭区间" class="headerlink" title="循环条件的开闭区间"></a>循环条件的开闭区间</h3><p>Swift将循环的开闭区间做了语法上的简化：</p><h4 id="闭区间："><a href="#闭区间：" class="headerlink" title="闭区间："></a>闭区间：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index : 1</span></span><br><span class="line"><span class="comment">// index : 2</span></span><br><span class="line"><span class="comment">// index : 3</span></span><br><span class="line"><span class="comment">// index : 4</span></span><br><span class="line"><span class="comment">// index : 5</span></span><br></pre></td></tr></table></figure><h4 id="半开闭区间："><a href="#半开闭区间：" class="headerlink" title="半开闭区间："></a>半开闭区间：</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index : 1</span></span><br><span class="line"><span class="comment">// index : 2</span></span><br><span class="line"><span class="comment">// index : 3</span></span><br><span class="line"><span class="comment">// index : 4</span></span><br></pre></td></tr></table></figure><h3 id="循环的升序与降序"><a href="#循环的升序与降序" class="headerlink" title="循环的升序与降序"></a>循环的升序与降序</h3><p>上面两个例子都是升序的（index从小到大），我们来看一下降序的写法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> (<span class="number">1</span>..&lt;<span class="number">5</span>).reversed() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"index: \(index)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index : 4</span></span><br><span class="line"><span class="comment">// index : 3</span></span><br><span class="line"><span class="comment">// index : 2</span></span><br><span class="line"><span class="comment">// index : 1</span></span><br></pre></td></tr></table></figure><blockquote><p>降序的应用可以在下篇的冒泡排序算法中可以看到。</p></blockquote><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>使用泛型可以定义一些可复用的函数或类型，Swift中的Array和Dictionary都是泛型的集合。</p><p>为了体现出泛型的意义，下面举一个例子来说明一下：</p><blockquote><p>实现这样一个功能:将传入该函数的两个参数互换。</p></blockquote><p>整型的交换：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串的交换：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoStrings</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> String, <span class="number">_</span> b: <span class="keyword">inout</span> String)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浮点型的交换：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoDoubles</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Double, <span class="number">_</span> b: <span class="keyword">inout</span> Double)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这三种情况的实现部分其实都是一样的，但仅仅是因为传入类型的不一致，导致对于不同的类型还要定义一个新的函数。所以如果类型有很多的话，定义的新函数也会很多，这样显然是不够优雅的。</p><p>此类问题可以使用泛型来解决：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoValues</span>&lt;T&gt;<span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> T, <span class="number">_</span> b: <span class="keyword">inout</span> T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tmp = a</span><br><span class="line">    a = b</span><br><span class="line">    b = tmp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数中的T是泛型的固定写法，可以理解为“所有类型”。这样一来，我们可以传入任何相同的类型来作交换了。</p><p>泛型还有其他比较强大的功能，由于在后续的数据结构和算法的讲解里面可能不会涉及到，所以在这里先不赘述了。有兴趣的朋友可以参考官方文档：<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Generics.html#//apple_ref/doc/uid/TP40014097-CH26-ID179" target="_blank" rel="noopener">Swift：Generics</a></p><h2 id="guard"><a href="#guard" class="headerlink" title="guard"></a>guard</h2><blockquote><p>guard是 swift 2.0推出的新的判断语句的用法。</p><p>与if语句相同的是，guard也是基于一个表达式的布尔值去判断一段代码是否该被执行。与if语句不同的是，guard只有在条件不满足的时候才会执行这段代码。你可以把guard近似的看做是Assert，但是你可以优雅的退出而非崩溃</p></blockquote><p>使用guard语法，可以先对每个条件逐一做检查，如果不符合条件判断就退出（或者进行其他某些操作）。这就会让人容易看出来什么条件会让这个函数退出（或者进行其他某些操作）。</p><p>可以用一个例子来分别使用if和guard来实现，体会二者的区别：</p><h3 id="使用if-else"><a href="#使用if-else" class="headerlink" title="使用if-else"></a>使用if-else</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//money:    holding moneny (用户持有的钱数)</span></span><br><span class="line"><span class="comment">//price:    product price  (商品的价格)</span></span><br><span class="line"><span class="comment">//capacity: bag capacity   (用户用来装商品的袋子容量)</span></span><br><span class="line"><span class="comment">//volume:   product size   (商品的大小)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buying1</span><span class="params">( money: Int , price: Int , capacity: Int , volume: Int)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> money &gt;= price&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> capacity &gt;= volume&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Start buying..."</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\(money-price) money left after buying."</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"\(capacity-volume) capacity left after buying."</span>)</span><br><span class="line">        </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"No enough capacity"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"No enough money"</span>)</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的逻辑可以看出，当同时满足：</p><ol><li>用户的钱数&gt;商品价格</li><li>用户用来装商品的袋子容量&gt;商品的大小</li></ol><p>这两个情况的时候，购买才会进行，其他所有情况都无法引发购买。</p><p>对于大多数习惯使用if-else的朋友来说，上面的代码立即起来并没有难度，但是相同的逻辑，我们看一下使用guard之后的效果：</p><h3 id="使用guard"><a href="#使用guard" class="headerlink" title="使用guard"></a>使用guard</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buying2</span><span class="params">( money: Int , price: Int , capacity: Int , volume: Int)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> money &gt;= price <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"No enough money"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">guard</span> capacity &gt;= volume <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"No enough capacity"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Start buying..."</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(money-price) money after buying."</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(capacity-volume) capacity left after buying."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的实现可以看出：</p><ul><li>使用guard以后，将<code>money &lt; price</code>和<code>capacity &lt; volume</code> 这两个情况首先排除掉并填上了相应的处理代码。</li><li>在两个guard下面才是真正正确逻辑后的处理代码。</li></ul><p>因此通过两个guard判断的语句，我们知道该函数所处理的正确逻辑是什么，非常清晰。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>因为后续的数据结构和算法的讲解是离不开函数的使用的，所以在这里简单介绍一下Swift中函数的使用。</p><ul><li>无返回值的函数</li><li>有返回值的函数</li><li>省略函数的外部参数名</li><li>值传递和引用传递</li></ul><h3 id="无返回值的函数"><a href="#无返回值的函数" class="headerlink" title="无返回值的函数"></a>无返回值的函数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">log</span><span class="params">(message: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"log: \(message)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(message: <span class="string">"memory warning"</span>)</span><br><span class="line"><span class="comment">// output: log: memory warning!</span></span><br></pre></td></tr></table></figure><h3 id="有返回值的函数"><a href="#有返回值的函数" class="headerlink" title="有返回值的函数"></a>有返回值的函数</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logString</span><span class="params">(string: String)</span></span> -&gt; <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"log: "</span> + string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> logStr = logString(string: <span class="string">"memory warning!"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(logStr)"</span>)</span><br><span class="line"><span class="comment">// output: log: memory warning!</span></span><br></pre></td></tr></table></figure><h3 id="省略函数外部参数名"><a href="#省略函数外部参数名" class="headerlink" title="省略函数外部参数名"></a>省略函数外部参数名</h3><p>通过在函数形参前面加上<code>_</code>,可以起到在调用时省略外部参数的作用：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logMessage</span><span class="params">(<span class="number">_</span> message: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"log: \(message)!"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logMessage(<span class="string">"memory warning"</span>)</span><br><span class="line"><span class="comment">// output: log: memory warning!</span></span><br></pre></td></tr></table></figure><p>再来看一下两个参数的情况：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addInt</span><span class="params">(<span class="number">_</span> a : Int ,<span class="number">_</span> b : Int)</span></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"sum is \(a + b)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">addInt(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">//output : sum is 7</span></span><br></pre></td></tr></table></figure><h3 id="值传递和引用传递"><a href="#值传递和引用传递" class="headerlink" title="值传递和引用传递"></a>值传递和引用传递</h3><p>Swift中，struct是按值传递，class是按引用传递。数组和字典在Swift里是属于struct，所以需要如果在一个函数里要修改传入的数组，需要做特殊处理：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> originalArr = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeLastInArray</span><span class="params">(<span class="number">_</span> array: <span class="keyword">inout</span> [Int])</span></span>&#123;</span><br><span class="line">    array.removeLast()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\n============ before removing: \(originalArr)"</span>)</span><br><span class="line"><span class="comment">//[2, 1, 3]</span></span><br><span class="line"></span><br><span class="line">removeLastInArray(&amp;originalArr)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"============ after   removing: \(originalArr)"</span>)</span><br><span class="line"><span class="comment">//[2, 1]</span></span><br></pre></td></tr></table></figure><p>在这里使用的<code>inout</code>关键字就是将传入的数组改为引用传递了。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Swift里的集合类型有：数组，集合，字典，下面来分别讲一下。</p><blockquote><p>这三种类型都支持泛型，也就是说里面的元素可以是整数，字符串，浮点等等。</p></blockquote><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>Swift’s <code>Array</code> type is bridged to Foundation’s <code>NSArray</code> class.</p></blockquote><h4 id="可变数组与不可变数组"><a href="#可变数组与不可变数组" class="headerlink" title="可变数组与不可变数组"></a>可变数组与不可变数组</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// immutable array</span></span><br><span class="line"><span class="keyword">let</span> immutableNumbers: [<span class="type">Int</span>] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutable array</span></span><br><span class="line"><span class="keyword">var</span> mutableNumbers : [<span class="type">Int</span>] = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p>Swift中可以用<code>let</code>和<code>var</code>来分别声明可变和不可变数组：数组的添加删除等操作只能作用于可变数组。</p></blockquote><h4 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iteration 1</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> mutableNumbers &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> index = mutableNumbers.index(of: value) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Index of \(value) is \(index)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iteration 2</span></span><br><span class="line">mutableNumbers.forEach &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> index = mutableNumbers.index(of: value) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Index of \(value) is \(index)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iteration 3</span></span><br><span class="line"><span class="keyword">for</span> (index, value) <span class="keyword">in</span> mutableNumbers.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Item \(index + 1): \(value)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mutableNumbers.append(<span class="number">11</span>)</span><br><span class="line"><span class="comment">// Output: [2, 1, 5, 4, 1, 3, 11]</span></span><br><span class="line"></span><br><span class="line">mutableNumbers.insert(<span class="number">42</span>, at: <span class="number">4</span>)</span><br><span class="line"><span class="comment">// Output: [2, 1, 5, 4, 42, 1, 3, 11]</span></span><br><span class="line"></span><br><span class="line">mutableNumbers.swapAt(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// Output: [1, 2, 5, 4, 42, 1, 3, 11]</span></span><br><span class="line"></span><br><span class="line">mutableNumbers.remove(at: <span class="number">1</span>)</span><br><span class="line"><span class="comment">// Output: [2, 5, 4, 42, 1, 3, 11]</span></span><br><span class="line"></span><br><span class="line">mutableNumbers.removeFirst()</span><br><span class="line"><span class="comment">// Output: [5, 4, 42, 1, 3, 11]</span></span><br><span class="line"></span><br><span class="line">mutableNumbers.removeLast()</span><br><span class="line"><span class="comment">// Output: [5, 4, 42, 1, 3]</span></span><br><span class="line"></span><br><span class="line">mutableNumbers.removeAll()</span><br><span class="line"><span class="comment">//[]</span></span><br></pre></td></tr></table></figure><blockquote><p>append函数的作用是在数组的末尾添加元素</p><p>swapAt函数的作用是交换在传入的两个index上的元素，该方法在下篇的排序算法中使用得非常频繁。</p></blockquote><h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><blockquote><p>Swift’s <code>Set</code> type is bridged to Foundation’s <code>NSSet</code> class.</p></blockquote><h4 id="集合的无序性，值的唯一性"><a href="#集合的无序性，值的唯一性" class="headerlink" title="集合的无序性，值的唯一性"></a>集合的无序性，值的唯一性</h4><p>关于集合与数组的区别，除了数组有序，集合无序以外，数组内部的元素的数值可以不是唯一的；但是集合里元素的数值必须是唯一的，如果有重复的数值会算作是一个：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//value in set is unique</span></span><br><span class="line"><span class="keyword">let</span> onesSet: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(onesSet)</span><br><span class="line"><span class="comment">// Output: [1]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> onesArray: <span class="type">Array</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(onesArray)</span><br><span class="line"><span class="comment">// Output: [1, 1, 1, 1]</span></span><br></pre></td></tr></table></figure><h4 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbersSet: <span class="type">Set</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(numbersSet)</span><br><span class="line"><span class="comment">// Output: undefined order, e.g. [5, 2, 3, 1, 4]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// iteration 1</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> numbersSet &#123;</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output is in undefined order</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// iteration 2</span></span><br><span class="line">numbersSet.forEach &#123; value <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output is in undefined order</span></span><br></pre></td></tr></table></figure><h4 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mutableStringSet: <span class="type">Set</span> = [<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>]</span><br><span class="line"><span class="keyword">let</span> item = <span class="string">"Two"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//contains</span></span><br><span class="line"><span class="keyword">if</span> mutableStringSet.<span class="built_in">contains</span>(item) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(item) found in the set"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(item) not found in the set"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//isEmpty</span></span><br><span class="line"><span class="keyword">let</span> strings = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">if</span> strings.isEmpty &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Set is empty"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//count</span></span><br><span class="line"><span class="keyword">let</span> emptyStrings = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">if</span> emptyStrings.<span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Set has no elements"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert</span></span><br><span class="line">mutableStringSet.insert(<span class="string">"Four"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//remove 1</span></span><br><span class="line">mutableStringSet.remove(<span class="string">"Three"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove 2</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> removedElement = mutableStringSet.remove(<span class="string">"Six"</span>) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(removedElement) was removed from the Set"</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Six is not found in the Set"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//removeAll()</span></span><br><span class="line">mutableStringSet.removeAll()</span><br><span class="line"><span class="comment">// []</span></span><br></pre></td></tr></table></figure><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><blockquote><p>A dictionary <code>Key</code> type must conform to the <code>Hashable</code> protocol, like a set’s value type.</p></blockquote><h4 id="字典的声明"><a href="#字典的声明" class="headerlink" title="字典的声明"></a>字典的声明</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//empty dictionary</span></span><br><span class="line"><span class="keyword">var</span> dayOfWeek = <span class="type">Dictionary</span>&lt;<span class="type">Int</span>, <span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> dayOfWeek2 = [<span class="type">Int</span>: <span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line"><span class="comment">//not empty dictionary</span></span><br><span class="line"><span class="keyword">var</span> dayOfWeek3: [<span class="type">Int</span>: <span class="type">String</span>] = [<span class="number">0</span>: <span class="string">"Sun"</span>, <span class="number">1</span>: <span class="string">"Mon"</span>, <span class="number">2</span>: <span class="string">"Tue"</span>]</span><br><span class="line"><span class="built_in">print</span>(dayOfWeek3)</span><br><span class="line"><span class="comment">//output:[2: "Tue", 0: "Sun", 1: "Mon"]</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到字典的键值对也是无序的，它与声明时的顺序不一定一致。</p></blockquote><h4 id="字典的遍历"><a href="#字典的遍历" class="headerlink" title="字典的遍历"></a>字典的遍历</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// iteration 1</span></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> dayOfWeek &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(key): \(value)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iteration 2</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> dayOfWeek.keys &#123;</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iteration 3</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dayOfWeek.values &#123;</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字典的操作"><a href="#字典的操作" class="headerlink" title="字典的操作"></a>字典的操作</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find value</span></span><br><span class="line">dayOfWeek = [<span class="number">0</span>: <span class="string">"Sun"</span>, <span class="number">1</span>: <span class="string">"Mon"</span>, <span class="number">2</span>: <span class="string">"Tue"</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> day = dayOfWeek[<span class="number">2</span>] &#123;</span><br><span class="line">    <span class="built_in">print</span>(day)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// addValue 1</span></span><br><span class="line">dayOfWeek[<span class="number">3</span>] = <span class="string">"Wed"</span></span><br><span class="line"><span class="built_in">print</span>(dayOfWeek)</span><br><span class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// updateValue 1</span></span><br><span class="line">dayOfWeek[<span class="number">2</span>] = <span class="string">"Mardi"</span></span><br><span class="line"><span class="built_in">print</span>(dayOfWeek)</span><br><span class="line"><span class="comment">// Prints: [2: "Mardi", 0: "Sun", 1: "Mon", 3: "Wed"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// updateValue 2</span></span><br><span class="line">dayOfWeek.updateValue(<span class="string">"Tue"</span>, forKey: <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dayOfWeek)</span><br><span class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 1: "Mon", 3: "Wed"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// removeValue 1</span></span><br><span class="line">dayOfWeek[<span class="number">1</span>] = <span class="literal">nil</span></span><br><span class="line"><span class="built_in">print</span>(dayOfWeek)</span><br><span class="line"><span class="comment">// Prints: [2: "Tue", 0: "Sun", 3: "Wed"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// removeValue 2</span></span><br><span class="line">dayOfWeek.removeValue(forKey: <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(dayOfWeek)</span><br><span class="line"><span class="comment">// Prints: [0: "Sun", 3: "Wed"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// removeAll</span></span><br><span class="line">dayOfWeek.removeAll()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dayOfWeek)</span><br><span class="line"><span class="comment">// Output: [:]</span></span><br></pre></td></tr></table></figure><blockquote><p>可以看到从字典里面删除某个键值对有两个方法：</p><ol><li>使用<code>removeValue</code>方法并传入要删除的键值对里的键。</li><li>将字典取下标之后将nil赋给它。</li></ol></blockquote><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>这一部分内容主要是对连载的后续文章作铺垫，让大家对数据结构先有一个基本的认识，因此在概念上不会深入讲解。该部分由以下三点展开：</p><ul><li><p>数据结构的基本概念</p></li><li><p>抽象数据类型</p></li><li><p>链表，栈和队列的实现</p><p>​</p></li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>首先我们来看一下数据结构的概念：</p><blockquote><p>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</p></blockquote><p>由数据结构这个词汇的本身（数据的结构）以及它的概念可以看出，它的重点在于“结构”和“关系”。所以说，数据是何种数据并不重要，重要的是这些数据<strong>是如何联系起来</strong>的。</p><p>而这些联系，可以从两个维度来展开：</p><ol><li>逻辑结构：指数据对象中元素之间的相互关系。</li><li>物理结构：指数据的逻辑结构在计算机中的存储形式。</li></ol><p>可以看出，逻辑结构是抽象的联系，而物理结构是实际在计算机内存里的具体联系。那么它们自己又细分为哪些结构呢？</p><p>逻辑结构：</p><ul><li>集合结构：集合结构中的数据元素除了同属于一个集合外，它们之间没有其他关系。</li><li>线性结构：线性结构中的数据元素之间是一对一的关系。</li><li>树形结构：数据结构中的元素存在一对多的相互关系。</li><li>图形结构：数据结构中的元素存在多对多的相互关系。</li></ul><p>物理结构：</p><ul><li>顺序存储结构：把数据元素粗放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的（数组）。</li><li>链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。</li></ul><p>为了便于记忆，用思维导图总结一下上面所说的：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8da77739?w=501&amp;h=337&amp;f=png&amp;s=29900" alt=""></p><p>而通过结合这两个维度中的某个结构，可以定义出来一个实际的数据结构的实现：</p><p>比如线性表就是线性结构的一种实现：</p><ul><li>顺序存储结构的线性表就是<strong>数组</strong>：它的内存分布是连续的，元素之间可以通过内存地址来做关联；</li><li>链式存储结构的线性表就是<strong>链表</strong>：它的内存分布可以是不连续的，元素之间通过指针来做关联：<ul><li>如果每个元素（在链表中称作节点）只持有指向后面节点的指针，那此链表就是单链表。</li><li>如果每个元素（在链表中称作节点）持有指向前后节点的两个指针，那此链表就是双链表。</li></ul></li></ul><p>为什么会有链表这么麻烦的东西？像数组这样，所有内存地址都是连续的不是很方便么？既生瑜何生亮呢？</p><p>对于获取元素（节点）这一操作，使用数组这个数据结构确实非常方便：因为所有元素在内存中是连续的，所以只需要知道数组中第一个元素的地址以及要获取元素的index就能算出该index内存的地址，一步到位非常方便。</p><p>但是对于向数组中某个index中插入新的元素的操作恐怕就没有这么方便了：恰恰是因为数组中所有元素的内存是连续的，所以如果想在中间插入一个新的元素，那么这个位置后面的所有元素都要后移，显然是非常低效的。如果插在数组尾部还好，如果插在第一位的话成本就太高了。</p><p>而如果使用链表，只要把要插入到的index前后节点的指针赋给这个新的节点就可以了，不需要移动原有节点在内存中的位置。</p><blockquote><p>关于链表的这种插入操作会在后面用代码的形式体现出来。</p></blockquote><p>既然有这么多的数据结构，那么有没有一个标准的格式来将这些特定的数据结构（也可以说是数学模型）抽象出来呢？答案是肯定的，它就是我们下一节要讲的<strong>抽象数据类型</strong>。</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>首先来看一下抽象数据类型的概念，摘自《大话数据结构》:</p><blockquote><p>抽象数据类型（Abstract Data Type，ADT）：是指一个数学模型及定义在该模型上的一组操作。</p></blockquote><p>需要注意的是：抽象数据类型的定义仅仅取决于它的一组<strong>逻辑特性</strong>，而与其在计算机内部如何表示和实现没有关系。而且，抽象数据类型不仅仅指那些已经定义并实现的数据类型，还尅是计算机编程者<strong>自己定义的数据类型</strong>。</p><p>我们看一下数据类型的标准格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 抽象数据类型名</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">   数据元素之间逻辑关系的定义</span><br><span class="line">   </span><br><span class="line">Operation</span><br><span class="line">   操作1</span><br><span class="line">      初始条件</span><br><span class="line">      操作结果描述</span><br><span class="line"> </span><br><span class="line">   操作2</span><br><span class="line">      初始条件</span><br><span class="line">      操作结果描述</span><br><span class="line">      </span><br><span class="line">   操作n</span><br><span class="line"></span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>其实看上去和面向对象编程里的类的定义相似：</p><ul><li>可以把抽象数据类型的Data 和 类的成员变量联系起来。</li><li>可以把抽象数据类型的操作和类的函数联系起来。</li></ul><p>简单来说，抽象数据类型描述了一个数据模型所使用的数据和数据之间的逻辑关系，以及它可以执行的一些操作。因此，如果知道了一个数学模型的抽象数据类型，那么在真正接触数学模型的实现（代码）之前，就可以对该数学模型能做的事情有一个大致的了解。</p><p>下一章笔者会介绍链表，栈和队列这三个数学模型，在讲解每个数学模型的实现之前都会给出它们各自的抽象数据类型，让读者可以先对当前数学模型有个大致的了解。</p><blockquote><p>注意：书本文归纳的所有抽象数据类型是笔者自己根据网上资料和相关书籍而定下来的，所以严格来说它们并不是“最官方”的抽象数据类型。读者也可以参考网上的资料或是相关书籍，结合自己的思考来定义自己对着三个数据模型的抽象数据类型。</p></blockquote><h2 id="链表，栈和队列的实现"><a href="#链表，栈和队列的实现" class="headerlink" title="链表，栈和队列的实现"></a>链表，栈和队列的实现</h2><p>通过上一节的介绍，我们知道了数据结构的概念以及分类，还知道了不同的数据结构在不同的场景下会发挥不同的优势，我们要根据实际的场景来选择合适的数据结构。</p><p>下面就来介绍几种在实际应用中使用的比较多的数学模型：</p><ul><li>链表</li><li>栈</li><li>队列</li></ul><h3 id="链表（Linked-list）"><a href="#链表（Linked-list）" class="headerlink" title="链表（Linked list）"></a>链表（Linked list）</h3><p>说到链表就不得不提线性表这一数据结构，在介绍链表之前，首先看一下线性表的定义：</p><blockquote><p>线性表：零个或多个数据元素的有限序列。</p></blockquote><p>而根据物理结构的不同，线性表有两种具体的实现方式：</p><ul><li>线性表的顺序存储结构：线性表的数据元素是被一段<strong>地址连续</strong>的存储单存储起来的。</li><li>线性表的链式存储结构: 线性表的数据元素是被用一组<strong>连续或不连续</strong>的存储单元存储起来的，这些元素通过指针来作为逻辑上的连接。</li></ul><blockquote><p>注：上面两个概念是笔者用自己的话总结出来的。</p></blockquote><p>在这里，线性表的顺序存储结构的实现就是我们熟悉的数组；而线性表的链式存储结构的实现就是笔者即将要介绍的链表。</p><h4 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h4><p>相信对于读完上一节的朋友来说，应该对链表有一个比较清晰的认识了。关于链表的定义有很多不同的版本，笔者个人比较喜欢百度百科里的定义：</p><blockquote><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p></blockquote><p>而且由于数据元素所持有的指针个数和链接特性可以将链表分为：</p><ul><li>单向链表：单向链表的链接方向是单向的，其中每个结点都有指针成员变量指向列表中的下一个结点；</li><li>双向链表：双向链表的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点，它的链接方向是双向的。</li><li>循环链表：循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。</li></ul><p>笔者从中挑选出双向链表来进行讲解，它的难度适中，而且能够很好地让读者体会出链表的优势。</p><h4 id="双向链表的抽象数据类型"><a href="#双向链表的抽象数据类型" class="headerlink" title="双向链表的抽象数据类型"></a>双向链表的抽象数据类型</h4><p>因为节点是链表的基本组成单元，所以想要实现链表，必须先要介绍链表的组成部分-节点。</p><p>节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ADT 节点(node)</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">  value:持有的数据</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line">   init:初始化</span><br><span class="line">   previous:指向上一节点的指针</span><br><span class="line">   next:指向下一节点的指针</span><br><span class="line">   </span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>再来看一下链表的抽象数据类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ADT 链表（linked list）</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">  linked list:持有的线性表</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line">   init:初始化</span><br><span class="line">   count:持有节点总个数</span><br><span class="line">   isEmpty:是否为空</span><br><span class="line">   first:头节点</span><br><span class="line">   last:尾节点</span><br><span class="line">   node:传入index返回节点</span><br><span class="line">   insert:插入node到指定index</span><br><span class="line">   insertToHead:插入节点到表头</span><br><span class="line">   appendToTail:插入节点到表尾</span><br><span class="line">   removeAll:移除所有节点</span><br><span class="line">   remove:移除传入的节点</span><br><span class="line">   removeAt:移除传入index的节点</span><br><span class="line">   </span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h4 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h4><h5 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListNode</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//value of a node</span></span><br><span class="line">    <span class="keyword">var</span> value: <span class="type">T</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">//pointer to previous node</span></span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> previous: <span class="type">LinkedListNode</span>?</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//pointer to next node</span></span><br><span class="line">    <span class="keyword">var</span> next: <span class="type">LinkedListNode</span>?</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//init</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(value: <span class="type">T</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看一下链表的实现：</p><p>因为整个链表的插入，删除等操作比较多，整个链表的定义超过了200行代码，所以为了看着方便一点，在这里来分段说明一下。</p><p>首先看一下链表的成员变量:</p><h5 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">Node</span> = <span class="type">LinkedListNode</span>&lt;<span class="type">T</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//if empty</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head == <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//total count of nodes</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> node = head <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">count</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next = node.next &#123;</span><br><span class="line">            node = next</span><br><span class="line">            <span class="built_in">count</span> += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pointer to the first node, private</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> head: <span class="type">Node</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pointer to the first node, public</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> first: <span class="type">Node</span>? &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pointer to the last node</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> last: <span class="type">Node</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">var</span> node = head <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//until node.next is nil</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">let</span> next = node.next &#123;</span><br><span class="line">            node = next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信看上面的命名以及注释大家可以对链表的成员变量有个初步的理解，这里面需要说三点：</p><ol><li><code>typealias</code>是用来重新为已经存在的类型命名的：这里用<code>Node</code>代替了<code>LinkedListNode&lt;T&gt;</code>（节点类型），降低了不少阅读代码的成本。</li><li>在获取<code>count</code>和<code>last</code>的实现，都先判断了<code>head</code>这个指针是否为nil，如果是则判定为空链表，自然也就不存在节点个数和最后的节点对象了。</li><li>同样地，也是在获取<code>count</code>和<code>last</code>的实现里，使用了<code>while</code>控制语句来判断node.next节点是否存在：如果存在，则继续+1或者继续往下寻找，直到node.next为nil时才停止。在这里我们可以看到链表的寻址方式：是通过头结点开始，以节点的.next指针来寻找下一个节点的。而且作为链表的尾节点，它的.next指针不指向任何对象，因为它本来就是链表的最后一项。</li></ol><blockquote><p>最下方的…代表即将在下面介绍的一些函数，这些函数都定义在的<code>LinkedList</code>这个class里面。</p></blockquote><h5 id="获取index上node"><a href="#获取index上node" class="headerlink" title="获取index上node"></a>获取index上node</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get node of index</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">node</span><span class="params">(atIndex index: Int)</span></span> -&gt; <span class="type">Node</span>? &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//head node</span></span><br><span class="line">        <span class="keyword">return</span> head!</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> node = head!.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">guard</span> index &lt; <span class="built_in">count</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>..&lt;index &#123;</span><br><span class="line">            <span class="comment">// go on finding by .next</span></span><br><span class="line">            node = node?.next</span><br><span class="line">            <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node!</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意在这里返回的node是可以为nil的，而且在这里可以看出来，链表在寻找特定node的时候，是根据节点的.next指针来一个一个寻找的。这个与顺序存储结构的数组是不同的，在后面我会重点讲解一下这二者的不同。</p><h5 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//insert node to last index</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">appendToTail</span><span class="params">(value: T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newNode = <span class="type">Node</span>(value: value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastNode = last &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//update last node: newNode becomes new last node;</span></span><br><span class="line">        <span class="comment">//the previous last node becomes the second-last node</span></span><br><span class="line">        newNode.previous = lastNode</span><br><span class="line">        lastNode.next = newNode</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//blank linked list</span></span><br><span class="line">        head = newNode</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert node to index 0</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insertToHead</span><span class="params">(value: T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newHead = <span class="type">Node</span>(value: value)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//blank linked list</span></span><br><span class="line">        head = newHead</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        newHead.next = head</span><br><span class="line">        head?.previous = newHead</span><br><span class="line">        head = newHead</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert node in specific index</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">insert</span><span class="params">(<span class="number">_</span> node: Node, atIndex index: Int)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> index &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"invalid input index"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> newNode = node</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">count</span> == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">        head = newNode</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index == <span class="number">0</span> &#123;</span><br><span class="line"></span><br><span class="line">            newNode.next = head</span><br><span class="line">            head?.previous = newNode</span><br><span class="line">            head = newNode</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> index &gt; <span class="built_in">count</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"out of range"</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> prev = <span class="keyword">self</span>.node(atIndex: index-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">let</span> next = prev?.next</span><br><span class="line"></span><br><span class="line">            newNode.previous = prev</span><br><span class="line">            newNode.next = prev?.next</span><br><span class="line">            prev?.next = newNode</span><br><span class="line">            next?.previous = newNode</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>链表的插入节点的操作分为三种，按照从上到下的顺序依次是：</p><ol><li>在头部插入</li><li>在尾部插入</li><li>指定index插入</li></ol><p>需要注意的是</p><ul><li>在前两种插入函数中，需要先判断该链表是否是空的，如果是，则要将链表的该节点赋给链表的<code>head</code>指针。</li><li>在第三种插入函数中，还是先判断该链表是否是空的，如果是，则无论index是多少(只要不小于0)，都插在链表的头部。如果不是空的，再判断index是否为0，如果是，则直接插在头部；如果index不为0，则判断index是否大于count，如果是，则无法插入；如果不是，则获取插入位置的前后节点进行重连。</li></ul><blockquote><p>在这里判断链表为空链表后的处理是笔者自己加上去的，笔者在网上的资料里没有看到过。大家不必纠结于这种处理方式，毕竟链表操作的重点在于前后节点的重连。</p></blockquote><h5 id="移除节点"><a href="#移除节点" class="headerlink" title="移除节点"></a>移除节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//removing all nodes</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAll</span><span class="params">()</span></span> &#123;</span><br><span class="line">    head = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove the last node</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeLast</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> !isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> remove(node: last!)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//remove a node by it's refrence</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(node: Node)</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> prev = node.previous</span><br><span class="line">    <span class="keyword">let</span> next = node.next</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> prev = prev &#123;</span><br><span class="line">        prev.next = next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        head = next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next?.previous = prev</span><br><span class="line"></span><br><span class="line">    node.previous = <span class="literal">nil</span></span><br><span class="line">    node.next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> node.value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//remove a node by it's index</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">removeAt</span><span class="params">(<span class="number">_</span> index: Int)</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> node = <span class="keyword">self</span>.node(atIndex: index)</span><br><span class="line">    <span class="keyword">guard</span> node != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> remove(node: node!)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果要移除链表上所有节点，只需要将head指针置空就可以了，因为它是所有节点的“源头”，是链表寻址的第一个节点。</li><li>在持有某个节点的指针的时候可以指定链表来移除这个节点（使用<code>remove</code>函数）。在这个函数内部，首先需要将该节点的前后节点对接，然后将该几点的前后指针置空。</li><li>当有要移除节点的指针但是知道该节点在链表中的index，可以使用<code>removeAt</code>函数。在这个函数内部，首先根据index来获取对应的node的指针，然后再调用<code>remove</code>函数删除这个node。</li></ul><h5 id="打印所有节点"><a href="#打印所有节点" class="headerlink" title="打印所有节点"></a>打印所有节点</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllNodes</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">guard</span> head != <span class="literal">nil</span> <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"linked list is empty"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> node = head</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\nstart printing all nodes:"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="built_in">count</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"[\(index)]\(node!.value)"</span>)</span><br><span class="line">        node = node!.next</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数只是为了方便调试，为了跟踪链表的状态而定义的，它并不存在于链表的模型里。</p><p>为了验证上面这些方法的有效性，我们来实例化一个链表后实际操作一下，读者可以结合注释来看一下每一步对应的结果：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list = <span class="type">LinkedList</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line">list.isEmpty   <span class="comment">// true</span></span><br><span class="line">list.first     <span class="comment">// nil</span></span><br><span class="line">list.<span class="built_in">count</span>     <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">list.appendToTail(value: <span class="string">"Swift"</span>)</span><br><span class="line">list.isEmpty         <span class="comment">// false</span></span><br><span class="line">list.first!.value    <span class="comment">// "Swift"</span></span><br><span class="line">list.last!.value     <span class="comment">// "Swift"</span></span><br><span class="line">list.<span class="built_in">count</span>           <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">list.appendToTail(value:<span class="string">"is"</span>)</span><br><span class="line">list.first!.value    <span class="comment">// "Swift"</span></span><br><span class="line">list.last!.value     <span class="comment">// "is"</span></span><br><span class="line">list.<span class="built_in">count</span>           <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">list.appendToTail(value:<span class="string">"great"</span>)</span><br><span class="line">list.first!.value    <span class="comment">// "Swift"</span></span><br><span class="line">list.last!.value     <span class="comment">// "great"</span></span><br><span class="line">list.<span class="built_in">count</span>           <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]Swift</span></span><br><span class="line"><span class="comment">//[1]is</span></span><br><span class="line"><span class="comment">//[2]Great</span></span><br><span class="line"></span><br><span class="line">list.node(atIndex: <span class="number">0</span>)?.value <span class="comment">// Swift</span></span><br><span class="line">list.node(atIndex: <span class="number">1</span>)?.value <span class="comment">// is</span></span><br><span class="line">list.node(atIndex: <span class="number">2</span>)?.value <span class="comment">// great</span></span><br><span class="line">list.node(atIndex: <span class="number">3</span>)?.value <span class="comment">// nil</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"language"</span>), atIndex: <span class="number">1</span>)</span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]Swift</span></span><br><span class="line"><span class="comment">//[1]language</span></span><br><span class="line"><span class="comment">//[2]is</span></span><br><span class="line"><span class="comment">//[3]great</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.remove(node: list.first!)</span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]language</span></span><br><span class="line"><span class="comment">//[1]is</span></span><br><span class="line"><span class="comment">//[2]great</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.removeAt(<span class="number">1</span>)</span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]language</span></span><br><span class="line"><span class="comment">//[1]great</span></span><br><span class="line"></span><br><span class="line">list.removeLast()</span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]language</span></span><br><span class="line"></span><br><span class="line">list.insertToHead(value: <span class="string">"study"</span>)</span><br><span class="line">list.<span class="built_in">count</span>             <span class="comment">// 2</span></span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]study</span></span><br><span class="line"><span class="comment">//[1]language</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list.removeAll()</span><br><span class="line">list.printAllNodes()<span class="comment">//linked list is empty</span></span><br><span class="line"></span><br><span class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">3</span>)</span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]new</span></span><br><span class="line"></span><br><span class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">3</span>) <span class="comment">//out of range</span></span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]new</span></span><br><span class="line"></span><br><span class="line">list.insert(<span class="type">LinkedListNode</span>.<span class="keyword">init</span>(value: <span class="string">"new"</span>), atIndex: <span class="number">1</span>)</span><br><span class="line">list.printAllNodes()</span><br><span class="line"><span class="comment">//[0]new</span></span><br><span class="line"><span class="comment">//[1]new</span></span><br></pre></td></tr></table></figure><h3 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h3><p>栈的讲解从</p><ul><li>栈的定义</li><li>栈的抽象数据类型</li><li>栈的实现</li></ul><p>三个部分来展开。</p><h4 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h4><p>首先来看一下栈的定义：</p><blockquote><p>栈是限定仅在表的尾部进行插入和删除操作的线性表。</p></blockquote><p>从定义中可以看出，我们知道我们只能在栈的一端来操作栈：</p><ul><li>允许插入和删除的一端成为栈顶</li><li>另一端成为栈底</li></ul><p>用一张图来看一下栈的操作：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8db5eaf6?w=618&amp;h=432&amp;f=png&amp;s=73000" alt=""></p><blockquote><p>图源：《维基百科：Stack (abstract data type)》</p></blockquote><p>从上图可以看出，最先压入栈里面的只能最后访问，也就是说，栈遵循后进先出（Last In First Out, LIFO）的原则。</p><h4 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈（Stack）</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">  linked list:持有的线性表</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line">   init:初始化</span><br><span class="line">   count:栈的元素个数</span><br><span class="line">   isEmpty:是否为空</span><br><span class="line">   push:入栈</span><br><span class="line">   pop:出栈</span><br><span class="line">   top:返回顶部元素</span><br><span class="line">   </span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>上面的operation可能不全，但是涵盖了栈的一些最基本的操作。那么基于这个抽象数据类型，我们来看一下如何使用Swift来实现它。</p><h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>笔者将数组（顺序存储）作为栈的线性表的实现，同时支持泛型。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//array</span></span><br><span class="line">    fileprivate <span class="keyword">var</span> stackArray = [<span class="type">T</span>]()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//count</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackArray.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//is empty ?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackArray.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//top element</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> top: <span class="type">T</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isEmpty&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stackArray.last</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//push operation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="number">_</span> element: T)</span></span> &#123;</span><br><span class="line">        stackArray.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pop operation</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isEmpty&#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"stack is empty"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> stackArray.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print all</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllElements</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"stack is empty"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\nprint all stack elemets:"</span>)</span><br><span class="line">        <span class="keyword">for</span> (index, value) <span class="keyword">in</span> stackArray.enumerated() &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"[\(index)]\(value)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>fileprivate</code>：是Swift3.0新增的访问控制，表示在定义的声明文件里可访问。它代替了过去意义上的<code>private</code>。而有了<code>fileprivate</code>以后，新的<code>private</code>则代表了真正的私有：在这个类或结构体的外部无法访问。</li><li>这里<code>printAllElements</code>方法也不属于抽象数据类型里的方法，也是为了方便调试，可以打印出所有的数据元素。</li></ul><p>我们来实例化上面定义的栈实际操作一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = <span class="type">Stack</span>.<span class="keyword">init</span>(stackArray: [])</span><br><span class="line">stack.printAllElements() <span class="comment">//stack is empty</span></span><br><span class="line">stack.isEmpty <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">2</span>)</span><br><span class="line">stack.printAllElements()</span><br><span class="line"><span class="comment">//[0]2</span></span><br><span class="line"></span><br><span class="line">stack.isEmpty <span class="comment">//false</span></span><br><span class="line">stack.top     <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack.push(<span class="number">3</span>)</span><br><span class="line">stack.printAllElements()</span><br><span class="line"><span class="comment">//[0]2</span></span><br><span class="line"><span class="comment">//[1]3</span></span><br><span class="line"></span><br><span class="line">stack.isEmpty <span class="comment">//false</span></span><br><span class="line">stack.top     <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line">stack.printAllElements()</span><br><span class="line"><span class="comment">//[0]2</span></span><br><span class="line"></span><br><span class="line">stack.isEmpty <span class="comment">//false</span></span><br><span class="line">stack.top     <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stack.pop()</span><br><span class="line">stack.printAllElements() <span class="comment">//stack is empty</span></span><br><span class="line">stack.top <span class="comment">//nil</span></span><br><span class="line">stack.isEmpty <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">stack.pop() <span class="comment">//stack is empty</span></span><br></pre></td></tr></table></figure><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><p>队列的讲解从</p><ul><li>队列的定义</li><li>队列的抽象数据类型</li><li>队列的实现</li></ul><p>三个部分来展开。</p><h4 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h4><p><img src="https://user-gold-cdn.xitu.io/2018/1/31/16147cdb8db00b50?w=618&amp;h=432&amp;f=png&amp;s=95179" alt=""></p><blockquote><p>图源：《维基百科：FIFO (computing and electronics)》</p></blockquote><h4 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列（Queue）</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">  linked list:持有的线性表</span><br><span class="line"></span><br><span class="line">Operation</span><br><span class="line">   init:初始化</span><br><span class="line">   count:栈的元素个数</span><br><span class="line">   isEmpty:是否为空</span><br><span class="line">   front:获取队列头元素</span><br><span class="line">   enqueue:插入到队尾</span><br><span class="line">   dequeue:删除队列头元素并返回</span><br><span class="line">   </span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>和上面的栈的实现一致，队列的实现也使用数组来实现队列内部的线性表。</p><h4 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//array</span></span><br><span class="line">    fileprivate <span class="keyword">var</span> queueArray = [<span class="type">T</span>]()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//count</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> <span class="built_in">count</span>: <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queueArray.<span class="built_in">count</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//is empty?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> isEmpty: <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queueArray.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//front element</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">var</span> front: <span class="type">T</span>? &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> isEmpty &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queueArray.first</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//add element</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(<span class="number">_</span> element: T)</span></span> &#123;</span><br><span class="line">        queueArray.append(element)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//remove element</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">        <span class="keyword">if</span> isEmpty &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queueArray.removeFirst()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print all</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">printAllElements</span><span class="params">()</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">guard</span> <span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"queue is empty"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"\nprint all queue elemets:"</span>)</span><br><span class="line">        <span class="keyword">for</span> (index, value) <span class="keyword">in</span> queueArray.enumerated() &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"[\(index)]\(value)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们初始化一个队列后实际操作一下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> queue = <span class="type">Queue</span>.<span class="keyword">init</span>(queueArray: [])</span><br><span class="line">queue.printAllElements()<span class="comment">//queue is empty</span></span><br><span class="line">queue.isEmpty <span class="comment">//true</span></span><br><span class="line">queue.<span class="built_in">count</span>   <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue.enqueue(<span class="number">2</span>)</span><br><span class="line">queue.printAllElements()</span><br><span class="line">queue.isEmpty  <span class="comment">//false</span></span><br><span class="line"><span class="comment">//[0]2</span></span><br><span class="line"></span><br><span class="line">queue.enqueue(<span class="number">3</span>)</span><br><span class="line">queue.printAllElements()</span><br><span class="line"><span class="comment">//[0]2</span></span><br><span class="line"><span class="comment">//[1]3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue.enqueue(<span class="number">4</span>)</span><br><span class="line">queue.printAllElements()</span><br><span class="line"><span class="comment">//[0]2</span></span><br><span class="line"><span class="comment">//[1]3</span></span><br><span class="line"><span class="comment">//[2]4</span></span><br><span class="line">queue.front <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.printAllElements()</span><br><span class="line"><span class="comment">//[0]3</span></span><br><span class="line"><span class="comment">//[1]4</span></span><br><span class="line">queue.front <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.printAllElements()</span><br><span class="line"><span class="comment">//[0]4</span></span><br><span class="line">queue.front <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line">queue.dequeue()</span><br><span class="line">queue.printAllElements() <span class="comment">//queue is empty</span></span><br><span class="line">queue.front <span class="comment">//return nil, and print : queue is empty</span></span><br><span class="line">queue.isEmpty <span class="comment">//true</span></span><br><span class="line">queue.<span class="built_in">count</span><span class="comment">//0</span></span><br></pre></td></tr></table></figure><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>这两周学习数据结构和算法让我收获很多，除了强化了Swift语法以外，感觉自己看代码的感觉变了：看到一个设计就会想到里面所用到的数据结构，或是算法上面有没有可以优化的可能等等。</p><p>我相信对我来说编程的一扇新的门被打开了，希望自己可以坚持下去～</p><p>该系列的所有代码会放在我的GitHub的一个项目里面，项目地址：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift">Github:data-structure-and-algorithm-in-Swift</a></p><p>本篇文章的代码：</p><ul><li>Swift语法部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B1%5D.Swift%20syntax">[1].Swift syntax</a></li><li>数据结构部分：<a href="https://github.com/knightsj/data-structure-and-algorithm-in-Swift/tree/master/%5B2%5D.Data%20structure">[2].Data structure</a></li></ul><p>下篇预告：</p><p>从下一篇会开始正式讲解算法。本系列第二篇的主题是<strong>排序算法</strong>，内容是用Swift语言实现并讲解几种比较常见的排序算法：冒泡排序，选择排序，插入排序，希尔排序，堆排序，快速排序。</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/da_header_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;从本文标题中的序号可以看出，本文是一个连载的开篇。&lt;/p&gt;
&lt;p&gt;而且这个连载的标题是：数据结构 &amp;amp; 算法 in Swift。从这个连载的标题中可以看出，笔者分享的是使用Swift语言来实现所学的的数据结构和算法的知识。这里面需要解释两点：&lt;/p&gt;
&lt;h2 id=&quot;第一：为什么学习数据结构和算法？&quot;&gt;&lt;a href=&quot;#第一：为什么学习数据结构和算法？&quot; class=&quot;headerlink&quot; title=&quot;第一：为什么学习数据结构和算法？&quot;&gt;&lt;/a&gt;第一：为什么学习数据结构和算法？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;学习通用性知识，突破技能瓶颈&lt;/strong&gt;：笔者做iOS开发也有两年了，这期间通过从项目，第三方源码，相关应用类的编程书籍提高了些技术水平。而作为没学过数据结构和算法的非科班大军中的一员，这些知识始终是绕不过去的。因为对此类知识的掌握程度会对今后编程技能的提高有着无可估量的影响，所以就决定学习了。&lt;/p&gt;
&lt;h2 id=&quot;第二：为什么用Swift语言来实现？&quot;&gt;&lt;a href=&quot;#第二：为什么用Swift语言来实现？&quot; class=&quot;headerlink&quot; title=&quot;第二：为什么用Swift语言来实现？&quot;&gt;&lt;/a&gt;第二：为什么用Swift语言来实现？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;选择哪个语言并不重要，重要的是数据结构和算法本身的理解&lt;/strong&gt;：通过两个星期的学习，如今笔者已经可以使用Swift语言来实现几种数据结构和算法了，但我相信如果我使用C语言或者Objective-C语言的话会学得更快些，因为在实现的时候由于对该语言的不熟悉导致在实现过程中踩了不少坑。不过可以反过来思考：如果我可以使用Swift来实现这些，那么我今后用C，Objective-C，甚至是Java就容易多了，再加上我还顺便学习了Swift不是么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;如今Swift的势头还在上涨&lt;/strong&gt;：笔者已经观察到很多新的库，教学都使用了Swift语言。而且听说一些面试的朋友在面试过程中多少有问过Swift相关的知识，一些公司的新项目也有用Swift写了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Data Structure &amp; Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/categories/Data-Structure-Algorithm/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://github.com/knightsj/knightsj.github.io/tags/Swift/"/>
    
      <category term="Data Structure" scheme="https://github.com/knightsj/knightsj.github.io/tags/Data-Structure/"/>
    
      <category term="Algorithm" scheme="https://github.com/knightsj/knightsj.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>浅显易懂讲解iOS多线程技术-GCD</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%E8%AE%B2%E8%A7%A3%E7%9A%84iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF-GCD/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/浅显易懂讲解的iOS多线程技术-GCD/</id>
    <published>2018-02-02T16:21:25.000Z</published>
    <updated>2018-07-16T16:44:12.325Z</updated>
    
    <content type="html"><![CDATA[<p>励志打造一篇浅显易懂地介绍iOS中GCD的文章！<br>笔者见过很多其他讲解GCD的博客，有些写得非常详细非常专业，几乎涵盖了GCD大大小小的全部知识，细致庞杂的内容容易让人摸不清主次，笔者觉得这类文章<strong>并不适合初学者学习</strong>，于是决定写一篇针对一些只是听过，但是对GCD还不了解的童鞋们。</p><p>本文排除了一些细枝末节，扰乱人头绪的东西，着重讲解了GCD中重要的知识点，并在最后展示了GCD中<strong>经常使用的函数</strong>并附上结果图和讲解，简单明了。</p><a id="more"></a><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><hr><p>在了解多线程之前，需要弄清进程和线程的概念和他们之间的区别。</p><h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>系统中正在运行的一个程序，进程之间是相互独立的，每个进程都有属于自己的内存空间。比如手机中的<strong>微信</strong>应用和<strong>印象笔记</strong>应用，他们都是iOS系统中独立的进程，有着自己的内存空间。</p><h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>进程内部执行任务所需要的执行路径。进程若想执行任务，则必须得在线程下执行。也就是说进程至少有一个线程才能执行任务。但是，我们使用软件的时候，很少有只让它做一件事的时候：</p><p>举个<strong>印象笔记</strong>的🌰 ： 当你正在编辑一则笔记的时候点击了同步按钮，那么编辑任务（线程）和同步任务（线程）一定是不能按照顺序执行的。因为同步任务的完成时间是不可控的，如果在同步的过程中无法进行别的任务（线程）那就太糟糕了！</p><p>因此，我们需要让一些任务可以同时进行。既然任务是在线程上执行的，那么多任务的执行就意味着需要多线程的开启和使用。</p><p>来一张图直观地展示一下内存，进程和线程的关系：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-a1e6c65eda0d3aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存，进程和线程"></p><h1 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h1><hr><p>多线程的实现原理：虽然在同一时刻，CPU只能处理1条线程，但是CPU可以快速地在多条线程之间调度（切换），造成了多线程并发执行的假象。</p><h2 id="1-多线程的优点"><a href="#1-多线程的优点" class="headerlink" title="1. 多线程的优点"></a>1. 多线程的优点</h2><ul><li>能适当提高程序的执行效率。</li><li>能适当提高资源利用率（CPU、内存利用率）。</li></ul><h2 id="2-多线程的缺点"><a href="#2-多线程的缺点" class="headerlink" title="2. 多线程的缺点"></a>2. 多线程的缺点</h2><ul><li>创建线程是需要成本的：iOS下主要成本包括：在栈空间的子线程512KB、主线程1MB，创建线程大约需要90毫秒的创建时间。</li><li>线程越多，CPU在调度线程上的开销就越大。</li><li>线程越多，程序设计就越复杂：因为要考虑到线程之间的通信，多线程的数据共享。</li></ul><h1 id="多线程在iOS开发中的应"><a href="#多线程在iOS开发中的应" class="headerlink" title="多线程在iOS开发中的应"></a>多线程在iOS开发中的应</h1><hr><h2 id="1-iOS的主线程"><a href="#1-iOS的主线程" class="headerlink" title="1. iOS的主线程"></a>1. iOS的主线程</h2><p>一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</p><h4 id="主线程的作用"><a href="#主线程的作用" class="headerlink" title="主线程的作用:"></a>主线程的作用:</h4><ul><li>显示\刷新UI界面</li><li>处理UI事件（比如点击事件、滚动事件、拖拽事件等）</li></ul><blockquote><p>主线程的使用<strong>注意事项</strong>:<br>不能把比较耗时的操作放到主线程中，，严重影响UI的流畅度，给用户一种程序“卡顿”的体验。<br>因此，要将耗时的操作放在子线程中异步执行。这样一来，及时开始执行了耗时的操作，也不会影响主线程中UI交互的体验。</p></blockquote><h2 id="2-iOS的子线程"><a href="#2-iOS的子线程" class="headerlink" title="2. iOS的子线程"></a>2. iOS的子线程</h2><p>子线程是异步执行的，不影响主线程。在iOS开发中，我们需要将耗时的任务（网络请求，复杂的运算）放在子线程进行，不让其影响UI的交互体验。</p><h2 id="3-多线程安全"><a href="#3-多线程安全" class="headerlink" title="3. 多线程安全"></a>3. 多线程安全</h2><p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。就好比好几个人在同时修改同一个表格，造成数据的错乱。</p><h4 id="3-1-资源抢夺的解决方案"><a href="#3-1-资源抢夺的解决方案" class="headerlink" title="3.1 资源抢夺的解决方案"></a>3.1 资源抢夺的解决方案</h4><p>我们需要给数据添加<strong>互斥锁</strong>。也就是说，当某线程访问一个数据之前就要给数据加锁，让其不被其他的线程所修改。就好比一个人修改表格的时候给表格设置了密码，那么其他人就无法访问文件了。当他修改文件之后，再讲密码撤销，第二个人就可以访问该文件了。</p><blockquote><p><strong>注意</strong>：<br>这里的线程都为子线程，如果给数据加了锁，就等于将这些异步的子线程变成同步的了，这也叫做线程同步技术。</p></blockquote><h4 id="3-2-互斥锁使用："><a href="#3-2-互斥锁使用：" class="headerlink" title="3.2 互斥锁使用："></a>3.2 互斥锁使用：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(锁对象) &#123; <span class="comment">// 需要锁定的代码  &#125;;</span></span><br></pre></td></tr></table></figure><h4 id="3-3-互斥锁的优缺点"><a href="#3-3-互斥锁的优缺点" class="headerlink" title="3.3 互斥锁的优缺点"></a>3.3 互斥锁的优缺点</h4><p>优点：能有效防止因多线程抢夺资源造成的数据安全问题<br>缺点：需要消耗大量的CPU资源</p><p>互斥锁的使用前提：多条线程抢夺同一块资源的时候使用。</p><h4 id="3-4互斥锁在iOS开发中的使用"><a href="#3-4互斥锁在iOS开发中的使用" class="headerlink" title="3.4互斥锁在iOS开发中的使用"></a>3.4互斥锁在iOS开发中的使用</h4><p>OC在定义属性时有<code>nonatomic</code>和<code>atomic</code>两种选择</p><ul><li>atomic：原子属性，为setter方法加锁（默认就是atomic）</li><li>nonatomic：非原子属性，不会为setter方法加锁</li></ul><h4 id="3-5-nonatomic和atomic对比"><a href="#3-5-nonatomic和atomic对比" class="headerlink" title="3.5 nonatomic和atomic对比"></a>3.5 nonatomic和atomic对比</h4><p>atomic：线程安全，需要消耗大量的资源<br>nonatomic：非线程安全，适合内存小的移动设备</p><blockquote><p><strong>建议：</strong><br>所有属性都声明为nonatomic，尽量避免多线程抢夺同一块资源，将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力。</p></blockquote><h1 id="多线程在iOS中的应用：GCD"><a href="#多线程在iOS中的应用：GCD" class="headerlink" title="多线程在iOS中的应用：GCD"></a>多线程在iOS中的应用：GCD</h1><hr><p>GCD，全称为 Grand Central Dispatch ，是iOS用来管理线程的技术。 纯C语言，提供了非常多强大的函数。</p><h2 id="1-GCD的优势"><a href="#1-GCD的优势" class="headerlink" title="1. GCD的优势"></a>1. GCD的优势</h2><p>GCD会自动利用更多的CPU内核（比如双核、四核）。<br>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。<br>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码。</p><h2 id="2-为什么要用GCD？"><a href="#2-为什么要用GCD？" class="headerlink" title="2. 为什么要用GCD？"></a>2. 为什么要用GCD？</h2><p>为了要提高软件性能，应该异步执行耗时任务(加载图片)，以防止影响主线程任务的执行(UI相应)。</p><blockquote><p>举个🌰 ：<br>从网络加载一张图片，如果将此任务放到主线程，那么在下载完成的时间里，软件是无法相应用户的任何操作的。特别地，如果当前是在可以滚动的页面，就会造成无法滚动这种体验非常糟的情况。</p></blockquote><p>所以：应该将网络加载放在异步执行，执行成功后，再回到主线程显示加载后的图片(详细做法马上就会讲到)。</p><h2 id="3-GCD的使用步骤"><a href="#3-GCD的使用步骤" class="headerlink" title="3. GCD的使用步骤"></a>3. GCD的使用步骤</h2><ol><li>由开发者定制将要执行的任务。</li></ol><ul><li>将任务添加到队列中，GCD会自动将队列中的任务取出，放到对应的线程中执行。</li></ul><blockquote><p><strong>注意：</strong><br>任务的取出遵循队列的FIFO原则：先进先出，后进后出。</p></blockquote><h2 id="4-什么是队列？"><a href="#4-什么是队列？" class="headerlink" title="4. 什么是队列？"></a>4. 什么是队列？</h2><p>队列是用来存放任务的，由GCD将这些任务从队列中取出并放到相应的线程中执行。</p><h3 id="GCD的队列可以分为2大类型："><a href="#GCD的队列可以分为2大类型：" class="headerlink" title="GCD的队列可以分为2大类型："></a>GCD的队列可以分为2大类型：</h3><h4 id="1-并发队列（Concurrent-Dispatch-Queue）"><a href="#1-并发队列（Concurrent-Dispatch-Queue）" class="headerlink" title="1. 并发队列（Concurrent Dispatch Queue）"></a>1. 并发队列（Concurrent Dispatch Queue）</h4><p>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务），并发功能只有在异步（dispatch_async）函数下才有效</p><h4 id="2-串行队列（Serial-Dispatch-Queue）"><a href="#2-串行队列（Serial-Dispatch-Queue）" class="headerlink" title="2. 串行队列（Serial Dispatch Queue）"></a>2. 串行队列（Serial Dispatch Queue）</h4><p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）。</p><p>那么队列和线程又有什么区别？</p><p>简单来说，队列就是用来存放任务的“暂存区”，而线程是执行任务的路径，GCD将这些存在于队列的任务取出来放到相应的线程上去执行，而队列的性质决定了在其中的任务在哪种线程上执行。</p><p>下面由一张图来直观地展示任务，队列和线程的关系：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-6da601dd550b8390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="任务，队列和线程"></p><blockquote><p>在这里，我们可以看到，放入串行队列的任务会一个一个地执行。而放入并行队列的任务，会在多个线程并发地执行。</p></blockquote><h2 id="5-队列的创建"><a href="#5-队列的创建" class="headerlink" title="5. 队列的创建"></a>5. 队列的创建</h2><h3 id="5-1-串行队列的创建："><a href="#5-1-串行队列的创建：" class="headerlink" title="5.1 串行队列的创建："></a>5.1 串行队列的创建：</h3><p>GCD中获得串行有2种途径：</p><p>1.使用<code>dispatch_queue_create</code>函数创建串行队列</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"serial_queue"</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>2.使用主队列（跟主线程相关联的队列）</p><p>主队列是GCD自带的一种特殊的串行队列：放在主队列中的任务，都会放到主线程中执行。<br>可以使用dispatch_get_main_queue()获得系统提供的主队列：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure><h3 id="5-2-并发队列的创建："><a href="#5-2-并发队列的创建：" class="headerlink" title="5.2 并发队列的创建："></a>5.2 并发队列的创建：</h3><p>1.使用<code>dispatch_queue_create</code>函数创建并发队列。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"concurrent.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure><p>2.使用<code>dispatch_get_global_queue</code>获得全局并发队列。</p><p>GCD默认已经提供了全局的并发队列，供整个应用使用，可以无需手动创建。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="6-GCD的几种重要的应用"><a href="#6-GCD的几种重要的应用" class="headerlink" title="6. GCD的几种重要的应用"></a>6. GCD的几种重要的应用</h2><h3 id="6-1-子线程与主线程的通信"><a href="#6-1-子线程与主线程的通信" class="headerlink" title="6.1 子线程与主线程的通信"></a>6.1 子线程与主线程的通信</h3><p>需求点:我们有时需要在子线程处理一个耗时比较长的任务，而且此任务完成后，要在主线程执行另一个任务。<br>例子：从网络加载图片（在子线程），加载完成就更新UIView（在主线程）。</p><p>为了实现这个需求，我们需要首先拿到全局并发队列（或自己开启一个子线程）来执行耗时的操作，然后在其完成block中拿到全局串行队列来执行UI刷新的任务。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加载图片</span></span><br><span class="line">            <span class="built_in">NSData</span> *dataFromURL = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageURL];</span><br><span class="line">            <span class="built_in">UIImage</span> *imageFromData = [<span class="built_in">UIImage</span> imageWithData:dataFromURL];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//加载完成更新view</span></span><br><span class="line">            <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:imageFromData];          </span><br><span class="line">    &#125;);      </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>以笔者的拙见，除了复杂的算法，网络请求以外，大多数<code>dataWithContentsOf。。。</code>函数可能也会比较耗时，所以以后遇到与NSData交互的操作时，尽量将其放在子线程执行。</p></blockquote><h4 id="6-2-dispatch-once"><a href="#6-2-dispatch-once" class="headerlink" title="6.2 dispatch_once"></a>6.2 dispatch_once</h4><p>需求点：用于在程序启动到终止，只执行一次的代码。此代码被执行后，相当于自身全部被加上了注释，不会再执行了。<br>为了实现这个需求，我们需要使用<code>dispatch_once</code>让代码在运行一次后即刻被“雪藏”。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">// 只执行1次的代码，这里默认是线程安全的：不会有其他线程可以访问到这里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="6-3-dispatch-group"><a href="#6-3-dispatch-group" class="headerlink" title="6.3 dispatch_group"></a>6.3 dispatch_group</h4><p>需求点：执行多个耗时的异步任务，但是只能等到这些任务都执行完毕后，才能在主线程执行某个任务。<br>为了实现这个需求，我们需要让将这些异步执行的操作放在<code>dispatch_group_async</code>函数中执行，最后再调用<code>dispatch_group_notify</code>来执行最后执行的任务。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group =  dispatch_group_create();</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">&#125;);</span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>让我们看一下示例代码和运行结果：</p><p>示例代码：</p><p>为了使对比明显，笔者多开了几条线程，这样更容易看清问题。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group =  dispatch_group_create();    </span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务1"</span>);                </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务2"</span>);        </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">200000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务3"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">400000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务4"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行1个耗时的异步操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务5"</span>);</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">        </span><br><span class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"都完成了"</span>);        </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>运行结果:</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-3c8d5886442ce7b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="  dispatch_group 的使用运行结果"></p><blockquote><p>从三次运行的结果来看:</p><ol><li><p>异步执行的任务1-5的最终完成时间是与其自身完成任务所需要的时间并无绝对关联。因为任务5是最耗时的，它在第一次运行结果里并不是最后才完成的。任务1是最不耗时的，但是它在第二次运行结果里也不是最先完成的。</p></li><li><p>异步执行的任务1-5无论完成顺序如何，只有当他们都完成后才会调用主线程的打印“都完成了”。</p></li></ol></blockquote><h4 id="6-4-dispatch-barrier"><a href="#6-4-dispatch-barrier" class="headerlink" title="6.4 dispatch_barrier"></a>6.4 dispatch_barrier</h4><p>需求点：虽然我们有时要执行几个不同的异步任务，但是我们还是要将其分成两组：当第一组异步任务都执行完成后才执行第二组的异步任务。这里的组可以包含一个任务，也可以包含多个任务。</p><p>为了实现这个需求，我们需要使用<code>dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block);</code>在两组任务之间形成“栅栏”，使其“下方”的异步任务在其“上方”的异步任务都完成之前是无法执行的。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----任务 1-----"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----任务 2-----"</span>);</span><br><span class="line">&#125;);    </span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----"</span>);</span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----任务 3-----"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"----任务 4-----"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">   </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务1"</span>);       </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务2"</span>);        </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">200000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务3"</span>);        </span><br><span class="line">&#125;);</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">dispatch_barrier_async(queue, ^&#123;        </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------我是分割线--------"</span>);        </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">400000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务4"</span>);       </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务5"</span>);        </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000</span>; index ++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务6"</span>);       </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-ca923e54d3839b2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_barrier 的使用运行结果"></p><blockquote><p>从这三次运行结果来看:</p><ol><li>无论任务1-3内部的执行顺序如何，只有当三者都完成了才会执行任务4-6。</li><li>1-3内部的执行顺序和4-6内部的完成顺序都是不可控的，同上一个知识点类似。</li></ol></blockquote><p>本文介绍了需要了解GCD所需的最重要的知识，因为怕打断读者思路，并没有涵盖所有细节。以后有机会会再写一篇深入介绍GCD的文章，查缺补漏。</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;励志打造一篇浅显易懂地介绍iOS中GCD的文章！&lt;br&gt;笔者见过很多其他讲解GCD的博客，有些写得非常详细非常专业，几乎涵盖了GCD大大小小的全部知识，细致庞杂的内容容易让人摸不清主次，笔者觉得这类文章&lt;strong&gt;并不适合初学者学习&lt;/strong&gt;，于是决定写一篇针对一些只是听过，但是对GCD还不了解的童鞋们。&lt;/p&gt;
&lt;p&gt;本文排除了一些细枝末节，扰乱人头绪的东西，着重讲解了GCD中重要的知识点，并在最后展示了GCD中&lt;strong&gt;经常使用的函数&lt;/strong&gt;并附上结果图和讲解，简单明了。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>YYCache 源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/YYCache%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/YYCache 源码解析/</id>
    <published>2018-02-02T16:18:08.000Z</published>
    <updated>2018-07-16T16:47:18.950Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ibireme/YYCache">YYCache</a>是国内开发者<a href="https://blog.ibireme.com/" target="_blank" rel="noopener">ibireme</a>开源的一个线程安全的高性能键值缓存组件，代码风格简洁清晰，在GitHub上已经有了1600+颗星。</p><p>阅读它的源码有助于建立比较完整的缓存设计的思路，同时也能巩固一下双向链表，线程锁，数据库操作相关的知识。如果你还没有看过YYCache的源码，那么恭喜你，阅读此文会对理解YYCache的源码有比较大的帮助。</p><a id="more"></a><p>在正式开始讲解源码之前，先简单看一下该框架的使用方法。</p><h1 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h1><p>举一个缓存用户姓名的例子来看一下YYCache的几个API：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//需要缓存的对象</span></span><br><span class="line"> <span class="built_in">NSString</span> *userName = <span class="string">@"Jack"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要缓存的对象在缓存里对应的键</span></span><br><span class="line"> <span class="built_in">NSString</span> *key = <span class="string">@"user_name"</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//创建一个YYCache实例:userInfoCache</span></span><br><span class="line"> YYCache *userInfoCache = [YYCache cacheWithName:<span class="string">@"userInfo"</span>];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//存入键值对</span></span><br><span class="line"> [userInfoCache setObject:userName forKey:key withBlock:^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"caching object succeed"</span>);</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//判断缓存是否存在</span></span><br><span class="line"> [userInfoCache containsObjectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key, <span class="built_in">BOOL</span> contains) &#123;</span><br><span class="line">     <span class="keyword">if</span> (contains)&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"object exists"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//根据key读取数据</span></span><br><span class="line"> [userInfoCache objectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;  _Nonnull object) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"user name : %@"</span>,object);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//根据key移除缓存</span></span><br><span class="line"> [userInfoCache removeObjectForKey:key withBlock:^(<span class="built_in">NSString</span> * _Nonnull key) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"remove user name %@"</span>,key);</span><br><span class="line"> &#125;];</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//移除所有缓存</span></span><br><span class="line"> [userInfoCache removeAllObjectsWithBlock:^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"removing all cache succeed"</span>);</span><br><span class="line"> &#125;];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//移除所有缓存带进度</span></span><br><span class="line"> [userInfoCache removeAllObjectsWithProgressBlock:^(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: removedCount :%d  totalCount : %d"</span>,removedCount,totalCount);</span><br><span class="line"> &#125; endBlock:^(<span class="built_in">BOOL</span> error) &#123;</span><br><span class="line">     <span class="keyword">if</span>(!error)&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: succeed"</span>);</span><br><span class="line">     &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"remove all cache objects: failed"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure><p>总体来看这些API与<code>NSCache</code>是差不多的。<br>下面接着看一下该框架的架构：</p><h1 id="架构与职责划分"><a href="#架构与职责划分" class="headerlink" title="架构与职责划分"></a>架构与职责划分</h1><p>首先看一下架构图：</p><h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5bd7907?w=604&amp;h=344&amp;f=png&amp;s=21874" alt=""></p><h2 id="职责划分"><a href="#职责划分" class="headerlink" title="职责划分"></a>职责划分</h2><p>从架构图上来看，该组件里面的成员并不多：</p><ul><li>YYCache：提供了最外层的接口，调用了YYMemoryCache与YYDiskCache的相关方法。</li><li>YYMemoryCache：负责处理容量小，相对高速的内存缓存。线程安全，支持自动和手动清理缓存等功能。</li><li>_YYLinkedMap：YYMemoryCache使用的双向链表类。</li><li>_YYLinkedMapNode：是_YYLinkedMap使用的节点类。</li><li>YYDiskCache：负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作，自动和手动清理缓存等功能。</li><li>YYKVStorage：YYDiskCache的底层实现类，用于管理磁盘缓存。</li><li>YYKVStorageItem：内置在YYKVStorage中，是YYKVStorage内部用于封装某个缓存的类。</li></ul><p>每个成员的详细的功能会在下文结合代码介绍。</p><h1 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h1><p>知道了YYCache的架构和职责划分以后，现在结合代码开始正式讲解。<br>讲解分为下面6个部分：</p><ul><li>YYCache</li><li>YYMemoryCache</li><li>YYDiskCache</li><li>保证线程安全的不同方案</li><li>提高缓存性能的几个尝试</li><li>其他知识点</li></ul><h2 id="YYCache"><a href="#YYCache" class="headerlink" title="YYCache"></a>YYCache</h2><p>YYCache给用户提供所有最外层的缓存操作接口，而这些接口的内部内部实际上是调用了YYMemoryCache和YYDiskCache对象的相关方法。</p><blockquote><p>因为YYMemoryCache和YYDiskCache的实例作为YYCache的两个公开的属性，所以用户<strong>无法直接使用YYMemoryCache和YYDiskCache对象</strong>，只能通过属性的方式来间接使用它们。</p></blockquote><p>我们来看一下YYCache的属性和接口：</p><h3 id="YYCache的属性和接口"><a href="#YYCache的属性和接口" class="headerlink" title="YYCache的属性和接口"></a>YYCache的属性和接口</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;<span class="comment">//缓存名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYMemoryCache *memoryCache;<span class="comment">//内存缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">readonly</span>) YYDiskCache *diskCache;<span class="comment">//磁盘缓存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否包含某缓存，无回调</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//是否包含某缓存，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取缓存对象，无回调</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//获取缓存对象，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入缓存对象，无回调</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//写入缓存对象，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某缓存，无回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"><span class="comment">//移除某缓存，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有缓存，无回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line"><span class="comment">//移除所有缓存，有回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"><span class="comment">//移除所有缓存，有进度和完成的回调</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</span><br><span class="line">                                 endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>从上面的接口可以看出YYCache的接口和NSCache很相近，而且在接口上都区分了有无回调的功能。<br>下面结合代码看一下这些接口是如何实现的：</p><h3 id="YYCache的接口实现"><a href="#YYCache的接口实现" class="headerlink" title="YYCache的接口实现"></a>YYCache的接口实现</h3><p>下面省略了带有回调的接口，因为与无回调的接口非常接近。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//先检查内存缓存是否存在，再检查磁盘缓存是否存在</span></span><br><span class="line">    <span class="keyword">return</span> [_memoryCache containsObjectForKey:key] || [_diskCache containsObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//首先尝试获取内存缓存，然后获取磁盘缓存</span></span><br><span class="line">    <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; object = [_memoryCache objectForKey:key];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果内存缓存不存在，就会去磁盘缓存里面找：如果找到了，则再次写入内存缓存中；如果没找到，就返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        object = [_diskCache objectForKey:key];</span><br><span class="line">        <span class="keyword">if</span> (object) &#123;</span><br><span class="line">            [_memoryCache setObject:object forKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//先写入内存缓存，后写入磁盘缓存</span></span><br><span class="line">    [_memoryCache setObject:object forKey:key];</span><br><span class="line">    [_diskCache setObject:object forKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="comment">//先移除内存缓存，后移除磁盘缓存</span></span><br><span class="line">    [_memoryCache removeObjectForKey:key];</span><br><span class="line">    [_diskCache removeObjectForKey:key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">    <span class="comment">//先全部移除内存缓存，后全部移除磁盘缓存</span></span><br><span class="line">    [_memoryCache removeAllObjects];</span><br><span class="line">    [_diskCache removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的接口实现可以看出：在YYCache中，永远都是先访问内存缓存，然后再访问磁盘缓存（包括了写入，读取，查询，删除缓存的操作）。而且关于内存缓存（_memoryCache）的操作，是不存在block回调的。</p><p>现在了解了YYCache的接口以及实现，下面我分别讲解一下YYMemoryCache（内存缓存）和YYDiskCache（磁盘缓存）这两个类。</p><h2 id="YYMemoryCache"><a href="#YYMemoryCache" class="headerlink" title="YYMemoryCache"></a>YYMemoryCache</h2><p>YYMemoryCache负责处理容量小，相对高速的内存缓存：它将需要缓存的对象与传入的key关联起来，操作类似于NSCache。</p><p>但是与NSCache不同的是，YYMemoryCache的内部有：</p><ul><li>缓存淘汰算法：使用LRU(least-recently-used) 算法来淘汰（清理）使用频率较低的缓存。</li><li>缓存清理策略：使用三个维度来标记，分别是count（缓存数量），cost（开销），age（距上一次的访问时间）。YYMemoryCache提供了分别针对这三个维度的清理缓存的接口。用户可以根据不同的需求（策略）来清理在某一维度超标的缓存。</li></ul><p>一个是淘汰算法，另一个是清理维度，乍一看可能没什么太大区别。我在这里先简单区分一下：</p><p>缓存淘汰算法的目的在于区分出使用频率高和使用频率低的缓存，当缓存数量达到一定限制的时候会优先清理那些使用频率低的缓存。<strong>因为使用频率已经比较低的缓存在将来的使用频率也很有可能会低</strong>。</p><p>缓存清理维度是给每个缓存添加的标记：</p><ul><li><p>如果用户需要删除age（距上一次的访问时间）超过1天的缓存，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始查找，直到所有距上一次的访问时间超过1天的缓存都清理掉为止。</p></li><li><p>如果用户需要将缓存总开销清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。</p></li><li><p>如果用户需要将缓存总数清理到总开销小于或等于某个值，在YYMemoryCache内部，就会从使用频率最低的那个缓存开始清理，直到总开销小于或等于这个值。</p></li></ul><p>可以看出，无论是以哪个维度来清理缓存，都是从缓存使用频率最低的那个缓存开始清理。而YYMemoryCache保留的所有缓存的使用频率的高低，是由LRU这个算法决定的。</p><p>现在知道了这二者的区别，下面来具体讲解一下缓存淘汰算法和缓存清理策略：</p><h3 id="YYMemoryCache的缓存淘汰算法"><a href="#YYMemoryCache的缓存淘汰算法" class="headerlink" title="YYMemoryCache的缓存淘汰算法"></a>YYMemoryCache的缓存淘汰算法</h3><p>在详细讲解这个算法之前我觉得有必要先说一下该算法的核心：</p><p>我个人认为LRU缓存替换策略的核心在于<strong>如果某个缓存访问的频率越高，就认定用户在将来越有可能访问这个缓存</strong>。<br>所以在这个算法中，将那些最新访问（写入），最多次被访问的缓存移到最前面，然后那些很早之前写入，不经常访问的缓存就被自动放在了后面。这样一来，在保留的缓存个数一定的情况下，留下的缓存都是访问频率比较高的，这样一来也就提升了缓存的命中率。谁都不想留着一些很难被用户再次访问的缓存，毕竟缓存本身也占有一定的资源不是么？</p><p>其实这个道理和一些商城类app的商品推荐逻辑是一样的：<br>如果首页只能展示10个商品，对于一个程序员用户来说，可能推荐的是于那些他最近购买商品类似的机械键盘鼠标，技术书籍或者显示屏之类的商品，而不是一些洋娃娃或是钢笔之类的商品。</p><p>那么LRU算法具体是怎么做的呢？</p><p>在YYMemoryCache中，使用了双向链表这个数据结构来保存这些缓存：</p><ul><li>当写入一个新的缓存时，要把这个缓存节点放在链表头部，并且并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。</li><li>当访问一个已有的缓存时，要把这个缓存节点移动到链表头部，原位置两侧的缓存要接上，并且原链表头部的缓存节点要变成现在链表的第二个缓存节点。</li><li>（根据清理维度）自动清理缓存时，要从链表的最后端逐个清理。</li></ul><p>这样一来，就可以保证链表前端的缓存是最近写入过和经常访问过的。而且该算法总是从链表的最后端删除缓存，这也就保证了留下的都是一些“比较新鲜的”缓存。</p><p>下面结合代码来讲解一下这个算法的实现：</p><p>YYMemoryCache<strong>用一个链表节点类来保存某个单独的内存缓存的信息（键，值，缓存时间等），然后用一个双向链表类来保存和管理这些节点</strong>。这两个类的名称分别是：</p><ul><li>_YYLinkedMapNode：链表内的节点类，可以看做是对某个单独内存缓存的封装。</li><li>_YYLinkedMap：双向链表类，用于保存和管理所有内存缓存(节点)</li></ul><h4 id="YYLinkedMapNode"><a href="#YYLinkedMapNode" class="headerlink" title="_YYLinkedMapNode"></a>_YYLinkedMapNode</h4><p>_YYLinkedMapNode可以被看做是对某个缓存的封装：它包含了该节点上一个和下一个节点的指针，以及缓存的key和对应的值（对象），还有该缓存的开销和访问时间。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMapNode</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_prev; <span class="comment">// retained by dic</span></span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> _YYLinkedMapNode *_next; <span class="comment">// retained by dic</span></span><br><span class="line">    <span class="keyword">id</span> _key;                <span class="comment">//缓存key</span></span><br><span class="line">    <span class="keyword">id</span> _value;                        <span class="comment">//key对应值</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _cost;                     <span class="comment">//缓存开销</span></span><br><span class="line">    <span class="built_in">NSTimeInterval</span> _time;                 <span class="comment">//访问时间</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">_YYLinkedMapNode</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>下面看一下双向链表类：</p><h4 id="YYLinkedMap"><a href="#YYLinkedMap" class="headerlink" title="_YYLinkedMap"></a>_YYLinkedMap</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">_YYLinkedMap</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">CFMutableDictionaryRef</span> _dic; <span class="comment">// 用于存放节点</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCost;   <span class="comment">//总开销</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> _totalCount;  <span class="comment">//节点总数</span></span><br><span class="line">    _YYLinkedMapNode *_head;            <span class="comment">// 链表的头部结点</span></span><br><span class="line">    _YYLinkedMapNode *_tail; <span class="comment">// 链表的尾部节点</span></span><br><span class="line">    <span class="built_in">BOOL</span> _releaseOnMainThread;         <span class="comment">//是否在主线程释放，默认为NO</span></span><br><span class="line">    <span class="built_in">BOOL</span> _releaseAsynchronously; <span class="comment">//是否在子线程释放，默认为YES</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在链表头部插入某节点</span></span><br><span class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将链表内部的某个节点移到链表头部</span></span><br><span class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个节点</span></span><br><span class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除链表的尾部节点并返回它</span></span><br><span class="line">- (_YYLinkedMapNode *)removeTailNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有节点（默认在子线程操作）</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>从链表类的属性上看：链表类内置了CFMutableDictionaryRef，用于保存节点的键值对，它还持有了链表内节点的总开销，总数量，头尾节点等数据。</p><p>可以参考下面这张图来看一下二者的关系：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5e027e5?w=1001&amp;h=333&amp;f=png&amp;s=34319" alt=""></p><p>看一下_YYLinkedMap的接口的实现：</p><p>将节点插入到链表头部：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)insertNodeAtHead:(_YYLinkedMapNode *)node &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置该node的值</span></span><br><span class="line">    <span class="built_in">CFDictionarySetValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key), (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//增加开销和总缓存数量</span></span><br><span class="line">    _totalCost += node-&gt;_cost;</span><br><span class="line">    _totalCount++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_head) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果链表内已经存在头节点，则将这个头节点赋给当前节点的尾指针（原第一个节点变成了现第二个节点）</span></span><br><span class="line">        node-&gt;_next = _head;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将该节点赋给现第二个节点的头指针（此时_head指向的节点是先第二个节点）</span></span><br><span class="line">        _head-&gt;_prev = node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将该节点赋给链表的头结点指针（该节点变成了现第一个节点）</span></span><br><span class="line">        _head = node;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果链表内没有头结点，说明是空链表。说明是第一次插入，则将链表的头尾节点都设置为当前节点</span></span><br><span class="line">        _head = _tail = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要看懂节点操作的代码只要了解双向链表的特性即可。在双向链表中：</p><ul><li>每个节点都有两个分别指向前后节点的指针。所以说每个节点都知道它前一个节点和后一个节点是谁。</li><li>链表的头部节点指向它前面节点的指针为空；链表尾部节点指向它后侧节点的指针也为空。</li></ul><p>为了便于理解，我们可以把这个抽象概念类比于幼儿园手拉手的小朋友们：<br>每个小朋友的左手都拉着前面小朋友的右手；每个小朋友的右手都拉着后面小朋友的左手；<br>而且最前面的小朋友的左手和最后面的小朋友的右手都没有拉任何一个小朋友。</p><p>将某个节点移动到链表头部：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)bringNodeToHead:(_YYLinkedMapNode *)node &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果该节点已经是链表头部节点，则立即返回，不做任何操作</span></span><br><span class="line">    <span class="keyword">if</span> (_head == node) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_tail == node) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果该节点是链表的尾部节点</span></span><br><span class="line">        <span class="comment">//1. 将该节点的头指针指向的节点变成链表的尾节点（将倒数第二个节点变成倒数第一个节点，即尾部节点）</span></span><br><span class="line">        _tail = node-&gt;_prev;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 将新的尾部节点的尾部指针置空</span></span><br><span class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果该节点是链表头部和尾部以外的节点（中间节点）</span></span><br><span class="line">        <span class="comment">//1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针</span></span><br><span class="line">        node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针</span></span><br><span class="line">        node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将原头节点赋给该节点的尾指针（原第一个节点变成了现第二个节点）</span></span><br><span class="line">    node-&gt;_next = _head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将当前节点的头节点置空</span></span><br><span class="line">    node-&gt;_prev = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将现第二个节点的头结点指向当前节点（此时_head指向的节点是现第二个节点）</span></span><br><span class="line">    _head-&gt;_prev = node;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将该节点设置为链表的头节点</span></span><br><span class="line">    _head = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次看上面的代码我自己是懵逼的，不过如果结合上面小朋友拉手的例子就可以快一点理解。<br>如果要其中一个小朋友放在队伍的最前面，需要</p><ul><li>将原来这个小朋友前后的小朋友的手拉上。</li><li>然后将这个小朋友的右手和原来排在第一位的小朋友的左手拉上。</li></ul><p>上面说的比较简略，但是相信对大家理解整个过程会有帮助。</p><p>也可以再结合链表的图解来看一下：</p><p><img src="https://user-gold-cdn.xitu.io/2018/1/22/1611c66be5e027e5?w=1001&amp;h=333&amp;f=png&amp;s=34319" alt=""></p><p>读者同样可以利用这种思考方式理解下面这段代码：</p><p>移除链表中的某个节点：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeNode:(_YYLinkedMapNode *)node &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//除去该node的键对应的值</span></span><br><span class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(node-&gt;_key));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//减去开销和总缓存数量</span></span><br><span class="line">    _totalCost -= node-&gt;_cost;</span><br><span class="line">    _totalCount--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//节点操作</span></span><br><span class="line">    <span class="comment">//1. 将该node的头指针指向的节点赋给其尾指针指向的节点的头指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;_next) node-&gt;_next-&gt;_prev = node-&gt;_prev;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将该node的尾指针指向的节点赋给其头指针指向的节点的尾指针</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;_prev) node-&gt;_prev-&gt;_next = node-&gt;_next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 如果该node就是链表的头结点，则将该node的尾部指针指向的节点赋给链表的头节点（第二变成了第一）</span></span><br><span class="line">    <span class="keyword">if</span> (_head == node) _head = node-&gt;_next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 如果该node就是链表的尾节点，则将该node的头部指针指向的节点赋给链表的尾节点（倒数第二变成了倒数第一）</span></span><br><span class="line">    <span class="keyword">if</span> (_tail == node) _tail = node-&gt;_prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>移除并返回尾部的node:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (_YYLinkedMapNode *)removeTailNode &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果不存在尾节点，则返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (!_tail) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    _YYLinkedMapNode *tail = _tail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除尾部节点对应的值</span></span><br><span class="line">    <span class="built_in">CFDictionaryRemoveValue</span>(_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(_tail-&gt;_key));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//减少开销和总缓存数量</span></span><br><span class="line">    _totalCost -= _tail-&gt;_cost;</span><br><span class="line">    _totalCount--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_head == _tail) &#123;</span><br><span class="line">        <span class="comment">//如果链表的头尾节点相同，说明链表只有一个节点。将其置空</span></span><br><span class="line">        _head = _tail = <span class="literal">nil</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将链表的尾节指针指向的指针赋给链表的尾指针（倒数第二变成了倒数第一）</span></span><br><span class="line">        _tail = _tail-&gt;_prev;</span><br><span class="line">        <span class="comment">//将新的尾节点的尾指针置空</span></span><br><span class="line">        _tail-&gt;_next = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，现在了解了YYMemoryCache底层的节点操作的代码。现在来看一下YYMemoryCache是如何使用它们的。</p><h4 id="YYMemoryCache的属性和接口"><a href="#YYMemoryCache的属性和接口" class="headerlink" title="YYMemoryCache的属性和接口"></a>YYMemoryCache的属性和接口</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYMemoryCache</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Attribute</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存名称，默认为nil</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存总数量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存总开销</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> totalCost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Limit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数量上限，默认为NSUIntegerMax，也就是无上限</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> countLimit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开销上限，默认为NSUIntegerMax，也就是无上限</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> costLimit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存时间上限，默认为DBL_MAX，也就是无上限</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> ageLimit;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理超出上限之外的缓存的操作间隔时间，默认为5s</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSTimeInterval</span> autoTrimInterval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到内存警告时是否清理所有缓存，默认为YES</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldRemoveAllObjectsOnMemoryWarning;</span><br><span class="line"></span><br><span class="line"><span class="comment">//app进入后台是是否清理所有缓存，默认为YES</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> shouldRemoveAllObjectsWhenEnteringBackground;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收到内存警告的回调block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^didReceiveMemoryWarningBlock)(YYMemoryCache *cache);</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入后台的回调block</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span>(^didEnterBackgroundBlock)(YYMemoryCache *cache);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存清理是否在后台进行，默认为NO</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> releaseOnMainThread;</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓存清理是否异步执行，默认为YES</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">BOOL</span> releaseAsynchronously;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Access Methods</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//是否包含某个缓存</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取缓存对象</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入缓存对象</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入缓存对象，并添加对应的开销</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Trim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== 缓存清理接口 =========== </span></span><br><span class="line"><span class="comment">//清理缓存到指定个数</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存到指定开销</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br></pre></td></tr></table></figure><h4 id="YYMemoryCache的接口实现"><a href="#YYMemoryCache的接口实现" class="headerlink" title="YYMemoryCache的接口实现"></a>YYMemoryCache的接口实现</h4><p>在YYMemoryCache的初始化方法里，会实例化一个_YYLinkedMap的实例来赋给_lru这个成员变量。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">      ....</span><br><span class="line">      _lru = [_YYLinkedMap new];</span><br><span class="line">      ...</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  然后所有的关于缓存的操作，都要用到_lru这个成员变量，因为它才是在底层持有这些缓存（节点）的双向链表类。下面我们来看一下这些缓存操作接口的实现：</p>  <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//是否包含某个缓存对象</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从内置的字典中获得缓存对象</span></span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取某个缓存对象</span></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">//如果节点存在，则更新它的时间信息（最后一次访问的时间）</span></span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个缓存对象，开销默认为0</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    [<span class="keyword">self</span> setObject:object forKey:key withCost:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个缓存对象，并存入缓存开销</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>)key withCost:(<span class="built_in">NSUInteger</span>)cost &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!object) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeObjectForKey:key];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> now = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">//如果存在与传入的key值匹配的node，则更新该node的value,cost,time，并将这个node移到链表头部</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新总cost</span></span><br><span class="line">        _lru-&gt;_totalCost -= node-&gt;_cost;</span><br><span class="line">        _lru-&gt;_totalCost += cost;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新node</span></span><br><span class="line">        node-&gt;_cost = cost;</span><br><span class="line">        node-&gt;_time = now;</span><br><span class="line">        node-&gt;_value = object;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将node移动至链表头部</span></span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果不存在与传入的key值匹配的node，则新建一个node，将key,value,cost,time赋给它，并将这个node插入到链表头部</span></span><br><span class="line">        <span class="comment">//新建node,并赋值</span></span><br><span class="line">        node = [_YYLinkedMapNode new];</span><br><span class="line">        node-&gt;_cost = cost;</span><br><span class="line">        node-&gt;_time = now;</span><br><span class="line">        node-&gt;_key = key;</span><br><span class="line">        node-&gt;_value = object;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将node插入至链表头部</span></span><br><span class="line">        [_lru insertNodeAtHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果cost超过了限制，则进行删除缓存操作（从链表尾部开始删除，直到符合限制要求）</span></span><br><span class="line">    <span class="keyword">if</span> (_lru-&gt;_totalCost &gt; _costLimit) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">            [<span class="keyword">self</span> trimToCost:_costLimit];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果total count超过了限制，则进行删除缓存操作（从链表尾部开始删除，删除一次即可）</span></span><br><span class="line">    <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; _countLimit) &#123;</span><br><span class="line">        _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个缓存对象</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//内部调用了链表的removeNode：方法</span></span><br><span class="line">        [_lru removeNode:node];</span><br><span class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部调用了链表的removeAll方法</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    [_lru removeAll];</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现是针对缓存的查询，写入，获取操作的，接下来看一下缓存的清理策略。</p><h3 id="YYMemoryCache的缓存清理策略"><a href="#YYMemoryCache的缓存清理策略" class="headerlink" title="YYMemoryCache的缓存清理策略"></a>YYMemoryCache的缓存清理策略</h3><p>如上文所说，在YYCache中，缓存的清理可以从缓存总数量，缓存总开销，缓存距上一次的访问时间来清理缓存。而且每种维度的清理操作都可以分为自动和手动的方式来进行。</p><h4 id="缓存自动清理"><a href="#缓存自动清理" class="headerlink" title="缓存自动清理"></a>缓存自动清理</h4><p>缓存的自动清理功能在YYMemoryCache初始化之后就开始了，是一个递归调用的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始定期清理</span></span><br><span class="line">    [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归清理，相隔时间为_autoTrimInterval，在初始化之后立即执行</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimRecursively &#123;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) _<span class="keyword">self</span> = <span class="keyword">self</span>;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(_autoTrimInterval * <span class="built_in">NSEC_PER_SEC</span>)),</span><br><span class="line">                   </span><br><span class="line">        dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>), ^&#123;</span><br><span class="line">            </span><br><span class="line">        __<span class="keyword">strong</span> <span class="keyword">typeof</span>(_<span class="keyword">self</span>) <span class="keyword">self</span> = _<span class="keyword">self</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在后台进行清理操作</span></span><br><span class="line">        [<span class="keyword">self</span> _trimInBackground];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用自己，递归操作</span></span><br><span class="line">        [<span class="keyword">self</span> _trimRecursively];</span><br><span class="line">            </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理所有不符合限制的缓存，顺序为：cost，count，age</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimInBackground &#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(_queue, ^&#123;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span> _trimToCost:<span class="keyword">self</span>-&gt;_costLimit];</span><br><span class="line">        [<span class="keyword">self</span> _trimToCount:<span class="keyword">self</span>-&gt;_countLimit];</span><br><span class="line">        [<span class="keyword">self</span> _trimToAge:<span class="keyword">self</span>-&gt;_ageLimit];</span><br><span class="line">        </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeAllObjects];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> _trimToCount:count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost &#123;</span><br><span class="line">    [<span class="keyword">self</span> _trimToCost:cost];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age &#123;</span><br><span class="line">    [<span class="keyword">self</span> _trimToAge:age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，YYMemoryCache是按照缓存数量，缓存开销，缓存时间的顺序来自动清空缓存的。我们结合代码看一下它是如何按照缓存数量来清理缓存的（其他两种清理方式类似，暂不给出）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.m</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将内存缓存数量降至等于或小于传入的数量；如果传入的值为0，则删除全部内存缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)_trimToCount:(<span class="built_in">NSUInteger</span>)countLimit &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> finish = <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果传入的参数=0，则删除所有内存缓存</span></span><br><span class="line">    <span class="keyword">if</span> (countLimit == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        [_lru removeAll];</span><br><span class="line">        finish = <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_totalCount &lt;= countLimit) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//如果当前缓存的总数量已经小于或等于传入的数量，则直接返回YES，不进行清理</span></span><br><span class="line">        finish = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">if</span> (finish) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableArray</span> *holder = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    <span class="keyword">while</span> (!finish) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//==0的时候说明在尝试加锁的时候，获取锁成功，从而可以进行操作；否则等待10秒（但是不知道为什么是10s而不是2s，5s，等等）</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_trylock(&amp;_lock) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_lru-&gt;_totalCount &gt; countLimit) &#123;</span><br><span class="line">                _YYLinkedMapNode *node = [_lru removeTailNode];</span><br><span class="line">                <span class="keyword">if</span> (node) [holder addObject:node];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                finish = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            usleep(<span class="number">10</span> * <span class="number">1000</span>); <span class="comment">//10 ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder.count) &#123;</span><br><span class="line">        <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">        <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">            [holder count]; <span class="comment">// release in queue</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="缓存手动清理"><a href="#缓存手动清理" class="headerlink" title="缓存手动清理"></a>缓存手动清理</h4><p>其实上面这三种清理的方法在YYMemoryCache封装成了接口，所以用户也可以通过YYCache的memoryCache这个属性来手动清理相应维度上不符合传入标准的缓存：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =========== 缓存清理接口 =========== </span></span><br><span class="line"><span class="comment">//清理缓存到指定个数</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存到指定开销</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br></pre></td></tr></table></figure><p>看一下它们的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清理缓存到指定个数</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeAllObjects];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> _trimToCount:count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存到指定开销</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost &#123;</span><br><span class="line">    [<span class="keyword">self</span> _trimToCost:cost];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清理缓存时间小于指定时间的缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age &#123;</span><br><span class="line">    [<span class="keyword">self</span> _trimToAge:age];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="YYDiskCache"><a href="#YYDiskCache" class="headerlink" title="YYDiskCache"></a>YYDiskCache</h2><p>YYDiskCache负责处理容量大，相对低速的磁盘缓存。线程安全，支持异步操作。作为YYCache的第二级缓存，它与第一级缓存YYMemoryCache的相同点是：</p><ul><li>都具有查询，写入，读取，删除缓存的接口。</li><li>不直接操作缓存，也是间接地通过另一个类（YYKVStorage）来操作缓存。</li><li>它使用LRU算法来清理缓存。</li><li>支持按 cost，count 和 age 这三个维度来清理不符合标准的缓存。</li></ul><p>它与YYMemoryCache不同点是：</p><ul><li><ol><li>根据缓存数据的大小来采取不同的形式的缓存：</li></ol><ul><li>数据库sqlite: 针对小容量缓存，缓存的data和元数据都保存在数据库里。</li><li>文件+数据库的形式: 针对大容量缓存，缓存的data写在文件系统里，其元数据保存在数据库里。</li></ul></li><li><ol><li>除了 cost，count 和 age 三个维度之外，还添加了一个磁盘容量的维度。</li></ol></li></ul><p>这里需要说明的是：<br>对于上面的第一条：我看源码的时候只看出来有这两种缓存形式，但是从内部的缓存type枚举来看，其实是分为三种的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, YYKVStorageType) &#123;</span><br><span class="line">    </span><br><span class="line">    YYKVStorageTypeFile = <span class="number">0</span>,</span><br><span class="line">    YYKVStorageTypeSQLite = <span class="number">1</span>,</span><br><span class="line">    YYKVStorageTypeMixed = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>也就是说我只找到了第二，第三种缓存形式，而第一种纯粹的文件存储（YYKVStorageTypeFile）形式的实现我没有找到：当type为<br>YYKVStorageTypeFile和YYKVStorageTypeMixed的时候的缓存实现都是一致的：都是讲data存在文件里，将元数据放在数据库里面。</p><p>在YYDiskCache的初始化方法里，没有发现正确的将缓存类型设置为YYKVStorageTypeFile的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.m</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"YYDiskCache init error"</span> reason:<span class="string">@"YYDiskCache must be initialized with a path. Use 'initWithPath:' or 'initWithPath:inlineThreshold:' instead."</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:<span class="string">@""</span> inlineThreshold:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithPath:path inlineThreshold:<span class="number">1024</span> * <span class="number">20</span>]; <span class="comment">// 20KB</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line"></span><br><span class="line">   ...    </span><br><span class="line">    YYKVStorageType type;</span><br><span class="line">    <span class="keyword">if</span> (threshold == <span class="number">0</span>) &#123;</span><br><span class="line">        type = YYKVStorageTypeFile;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (threshold == <span class="built_in">NSUIntegerMax</span>) &#123;</span><br><span class="line">        type = YYKVStorageTypeSQLite;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        type = YYKVStorageTypeMixed;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出来，当给指定初始化方法<code>initWithPath:inlineThreshold:</code>的第二个参数传入0的时候，缓存类型才是YYKVStorageTypeFile。而且比较常用的初始化方法<code>initWithPath:</code>的实现里，是将20kb传入了指定初始化方法里，结果就是将type设置成了YYKVStorageTypeMixed。</p><p>而且我也想不出如果只有文件形式的缓存的话，其元数据如何保存。如果有读者知道的话，麻烦告知一下，非常感谢了~~</p><p>在本文暂时对于上面提到的”文件+数据库的形式”在下文统一说成文件缓存了。</p><p>在接口的设计上，YYDiskCache与YYMemoryCache是高度一致的，只不过因为有些时候大文件的访问可能会比较耗时，所以框架作者在保留了与YYMemoryCache一样的接口的基础上，还在原来的基础上添加了block回调，避免阻塞线程。来看一下YYDiskCache的接口(省略了注释)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.h</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="built_in">BOOL</span> contains))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)objectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)objectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key, <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt; _Nullable object))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">nullable</span> <span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key withBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSString</span> *key))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjects;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line">- (<span class="keyword">void</span>)removeAllObjectsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</span><br><span class="line">                                 endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCount;</span><br><span class="line">- (<span class="keyword">void</span>)totalCountWithBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> totalCount))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)totalCost;</span><br><span class="line">- (<span class="keyword">void</span>)totalCostWithBlock:(<span class="keyword">void</span>(^)(<span class="built_in">NSInteger</span> totalCost))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Trim</span></span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count;</span><br><span class="line">- (<span class="keyword">void</span>)trimToCount:(<span class="built_in">NSUInteger</span>)count withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost;</span><br><span class="line">- (<span class="keyword">void</span>)trimToCost:(<span class="built_in">NSUInteger</span>)cost withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age;</span><br><span class="line">- (<span class="keyword">void</span>)trimToAge:(<span class="built_in">NSTimeInterval</span>)age withBlock:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure><p>从上面的接口代码可以看出，YYDiskCache与YYMemoryCache在接口设计上是非常相似的。但是，YYDiskCache有一个非常重要的属性，它<strong>作为用sqlite做缓存还是用文件做缓存的分水岭</strong>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> inlineThreshold;</span><br></pre></td></tr></table></figure><p>这个属性的默认值是20480byte，也就是20kb。即是说，如果缓存数据的长度大于这个值，就使用文件存储；如果小于这个值，就是用sqlite存储。来看一下这个属性是如何使用的：</p><p>首先我们会在YYDiskCache的指定初始化方法里看到这个属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">   ...</span><br><span class="line">    _inlineThreshold = threshold;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里将_inlineThreshold赋值，也是唯一一次的赋值。然后在写入缓存的操作里判断写入缓存的大小是否大于这个临界值，如果是，则使用文件缓存：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>&lt;<span class="built_in">NSCoding</span>&gt;)object forKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">   </span><br><span class="line">   ...</span><br><span class="line">    <span class="built_in">NSString</span> *filename = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (_kv.type != YYKVStorageTypeSQLite) &#123;</span><br><span class="line">        <span class="comment">//如果长度大临界值，则生成文件名称，使得filename不为nil</span></span><br><span class="line">        <span class="keyword">if</span> (value.length &gt; _inlineThreshold) &#123;</span><br><span class="line">            filename = [<span class="keyword">self</span> _filenameForKey:key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Lock();</span><br><span class="line">    <span class="comment">//在该方法内部判断filename是否为nil，如果是，则使用sqlite进行缓存；如果不是，则使用文件缓存</span></span><br><span class="line">    [_kv saveItemWithKey:key value:value filename:filename extendedData:extendedData];</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们知道了YYDiskCache相对于YYMemoryCache最大的不同之处是缓存类型的不同。<br>细心的朋友会发现上面这个写入缓存的方法（saveItemWithKey:value:filename:extendedData:）实际上是属于_kv的。这个_kv就是上面提到的YYKVStorage的实例，它在YYDiskCache的初始化方法里被赋值：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYDiskCache.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    YYKVStorage *kv = [[YYKVStorage alloc] initWithPath:path type:type];</span><br><span class="line">    <span class="keyword">if</span> (!kv) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    _kv = kv;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，再举其他两个接口为例，内部也是调用了_kv的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    Lock();</span><br><span class="line">    <span class="built_in">BOOL</span> contains = [_kv itemExistsForKey:key];</span><br><span class="line">    Unlock();</span><br><span class="line">    <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    Lock();</span><br><span class="line">    [_kv removeItemForKey:key];</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以是时候来看一下YYKVStorage的接口和实现了：</p><h3 id="YYKVStorage"><a href="#YYKVStorage" class="headerlink" title="YYKVStorage"></a>YYKVStorage</h3><p>YYKVStorage实例负责保存和管理所有磁盘缓存。和YYMemoryCache里面的_YYLinkedMap将缓存封装成节点类_YYLinkedMapNode类似，YYKVStorage也将某个单独的磁盘缓存封装成了一个类，这个类就是YYKVStorageItem，它保存了某个缓存所对应的一些信息(key, value, 文件名，大小等等)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYKVStorageItem.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YYKVStorageItem</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *key;                <span class="comment">//键</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *value;                <span class="comment">//值</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *filename; <span class="comment">//文件名</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> size;                             <span class="comment">//值的大小，单位是byte</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> modTime;                          <span class="comment">//修改时间戳</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">int</span> accessTime;                       <span class="comment">//最后访问的时间戳</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSData</span> *extendedData; <span class="comment">//extended data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>既然在这里将缓存封装成了YYKVStorageItem实例，<strong>那么作为缓存的管理者，YYKVStorage就必然有操作YYKVStorageItem的接口</strong>了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYKVStorage.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个键值对，值为NSData对象</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个键值对，包括文件名以及data信息</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">                  value:(<span class="built_in">NSData</span> *)value</span><br><span class="line">               filename:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)filename</span><br><span class="line">           extendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Remove Items</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//移除某个键的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除多个键的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除大于参数size的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsLargerThanSize:(<span class="keyword">int</span>)size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除时间早于参数时间的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsEarlierThanTime:(<span class="keyword">int</span>)time;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除item，使得缓存总容量小于参数size</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitSize:(<span class="keyword">int</span>)maxSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除item，使得缓存数量小于参数size</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeItemsToFitCount:(<span class="keyword">int</span>)maxCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有的item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeAllItems;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有的item，附带进度与结束block</span></span><br><span class="line">- (<span class="keyword">void</span>)removeAllItemsWithProgressBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="keyword">int</span> removedCount, <span class="keyword">int</span> totalCount))progress</span><br><span class="line">                               endBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> error))end;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark - Get Items</span></span><br><span class="line"><span class="comment">//读取参数key对应的item</span></span><br><span class="line">- (<span class="keyword">nullable</span> YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数key对应的data</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)getItemValueForKey:(<span class="built_in">NSString</span> *)key;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数数组对应的item数组</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;YYKVStorageItem *&gt; *)getItemForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数数组对应的item字典</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSData</span> *&gt; *)getItemValueForKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)keys;</span><br></pre></td></tr></table></figure><p>大家最关心的应该是写入缓存的接口是如何实现的，下面重点讲一下写入缓存的接口：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写入某个item</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个键值对，值为NSData对象</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入某个键值对，包括文件名以及data信息</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">                  value:(<span class="built_in">NSData</span> *)value</span><br><span class="line">               filename:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)filename</span><br><span class="line">           extendedData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)extendedData;</span><br></pre></td></tr></table></figure><p>这三个接口都比较类似，上面的两个方法都会调用最下面参数最多的方法。在详细讲解写入缓存的代码之前，我先讲一下写入缓存的大致逻辑，有助于让大家理解整个YYDiskCache写入缓存的流程：</p><ol><li>首先判断传入的key和value是否符合要求，如果不符合要求，则立即返回NO，缓存失败。</li><li>再判断是否type==YYKVStorageTypeFile并且文件名为空字符串（或nil）：如果是，则立即返回NO，缓存失败。</li><li>判断filename是否为空字符串：<ol><li>如果不为空：写入文件，并将缓存的key，等信息写入数据库，但是不将key对应的data写入数据库。</li><li>如果为空：<ol><li>如果缓存类型为YYKVStorageTypeSQLite：将缓存文件删除<ol><li>如果缓存类型不为YYKVStorageTypeSQLite：则将缓存的key和对应的data等其他信息存入数据库。</li></ol></li></ol></li></ol></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)saveItem:(YYKVStorageItem *)item &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> saveItemWithKey:item.key value:item.value filename:item.filename extendedData:item.extendedData];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> saveItemWithKey:key value:value filename:<span class="literal">nil</span> extendedData:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)saveItemWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value filename:(<span class="built_in">NSString</span> *)filename extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span> || value.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (_type == YYKVStorageTypeFile &amp;&amp; filename.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (filename.length) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果文件名不为空字符串，说明要进行文件缓存</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _fileWriteWithName:filename data:value]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//写入元数据</span></span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:filename extendedData:extendedData]) &#123;</span><br><span class="line">            <span class="comment">//如果缓存信息保存失败，则删除对应的文件</span></span><br><span class="line">            [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果文件名为空字符串，说明不要进行文件缓存</span></span><br><span class="line">        <span class="keyword">if</span> (_type != YYKVStorageTypeSQLite) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果缓存类型不是数据库缓存，则查找出相应的文件名并删除</span></span><br><span class="line">            <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> _dbGetFilenameWithKey:key];</span><br><span class="line">            <span class="keyword">if</span> (filename) &#123;</span><br><span class="line">                [<span class="keyword">self</span> _fileDeleteWithName:filename];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存类型是数据库缓存，把元数据和value写入数据库</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> _dbSaveWithKey:key value:value fileName:<span class="literal">nil</span> extendedData:extendedData];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，在底层写入缓存的方法是<code>_dbSaveWithKey:value:fileName:extendedData:</code>，这个方法使用了两次:</p><ul><li>在以文件（和数据库）存储缓存时</li><li>在以数据库存储缓存时</li></ul><p>不过虽然调用了两次，我们可以从传入的参数是有差别的：第二次filename传了nil。那么我们来看一下<code>_dbSaveWithKey:value:fileName:extendedData:</code>内部是如何区分有无filename的情况的：</p><ul><li>当filename为空时，说明在外部没有写入该缓存的文件：则把data写入数据库里</li><li>当filename不为空时，说明在外部有写入该缓存的文件：则不把data也写入了数据库里</li></ul><p>下面结合代码看一下：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库存储</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)_dbSaveWithKey:(<span class="built_in">NSString</span> *)key value:(<span class="built_in">NSData</span> *)value fileName:(<span class="built_in">NSString</span> *)fileName extendedData:(<span class="built_in">NSData</span> *)extendedData &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//sql语句</span></span><br><span class="line">    <span class="built_in">NSString</span> *sql = <span class="string">@"insert or replace into manifest (key, filename, size, inline_data, modification_time, last_access_time, extended_data) values (?1, ?2, ?3, ?4, ?5, ?6, ?7);"</span>;</span><br><span class="line">    </span><br><span class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> timestamp = (<span class="keyword">int</span>)time(<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//key</span></span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//filename</span></span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">2</span>, fileName.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//size</span></span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">3</span>, (<span class="keyword">int</span>)value.length);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//inline_data</span></span><br><span class="line">    <span class="keyword">if</span> (fileName.length == <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果文件名长度==0，则将value存入数据库</span></span><br><span class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, value.bytes, (<span class="keyword">int</span>)value.length, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果文件名长度不为0，则不将value存入数据库</span></span><br><span class="line">        sqlite3_bind_blob(stmt, <span class="number">4</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//modification_time</span></span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">5</span>, timestamp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//last_access_time</span></span><br><span class="line">    sqlite3_bind_int(stmt, <span class="number">6</span>, timestamp);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//extended_data</span></span><br><span class="line">    sqlite3_bind_blob(stmt, <span class="number">7</span>, extendedData.bytes, (<span class="keyword">int</span>)extendedData.length, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@"%s line:%d sqlite insert error (%d): %s"</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>框架作者用数据库的一条记录来保存关于某个缓存的所有信息。<br>而且数据库的第四个字段是保存缓存对应的data的，从上面的代码可以看出当filename为空和不为空的时候的处理的差别。</p><p>上面的<code>sqlite3_stmt</code>可以看作是一个已经把sql语句解析了的、用sqlite自己标记记录的内部数据结构。<br>而sqlite3_bind_text和sqlite3_bind_int是绑定函数，可以看作是将变量插入到字段的操作。</p><p>OK，现在看完了写入缓存，我们再来看一下获取缓存的操作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYKVSorage.m</span></span><br><span class="line">- (YYKVStorageItem *)getItemForKey:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (key.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    YYKVStorageItem *item = [<span class="keyword">self</span> _dbGetItemWithKey:key excludeInlineData:<span class="literal">NO</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (item) &#123;</span><br><span class="line">        <span class="comment">//更新内存访问的时间</span></span><br><span class="line">        [<span class="keyword">self</span> _dbUpdateAccessTimeWithKey:key];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (item.filename) &#123;</span><br><span class="line">            <span class="comment">//如果有文件名，则尝试获取文件数据</span></span><br><span class="line">            item.value = [<span class="keyword">self</span> _fileReadWithName:item.filename];</span><br><span class="line">            <span class="comment">//如果此时获取文件数据失败，则删除对应的item</span></span><br><span class="line">            <span class="keyword">if</span> (!item.value) &#123;</span><br><span class="line">                [<span class="keyword">self</span> _dbDeleteItemWithKey:key];</span><br><span class="line">                item = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面这段代码我们可以看到获取YYKVStorageItem的实例的方法是<code>_dbGetItemWithKey:excludeInlineData:</code><br>我们来看一下它的实现：</p><ol><li>首先根据查找key的sql语句生成stmt</li><li>然后将传入的key与该stmt进行绑定</li><li>最后通过这个stmt来查找出与该key对应的有关该缓存的其他数据并生成item。</li></ol><p>来看一下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (YYKVStorageItem *)_dbGetItemWithKey:(<span class="built_in">NSString</span> *)key excludeInlineData:(<span class="built_in">BOOL</span>)excludeInlineData &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *sql = excludeInlineData ? <span class="string">@"select key, filename, size, modification_time, last_access_time, extended_data from manifest where key = ?1;"</span> : <span class="string">@"select key, filename, size, inline_data, modification_time, last_access_time, extended_data from manifest where key = ?1;"</span>;</span><br><span class="line">    sqlite3_stmt *stmt = [<span class="keyword">self</span> _dbPrepareStmt:sql];</span><br><span class="line">    <span class="keyword">if</span> (!stmt) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    sqlite3_bind_text(stmt, <span class="number">1</span>, key.UTF8String, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    YYKVStorageItem *item = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">int</span> result = sqlite3_step(stmt);</span><br><span class="line">    <span class="keyword">if</span> (result == SQLITE_ROW) &#123;</span><br><span class="line">        <span class="comment">//传入stmt来生成YYKVStorageItem实例</span></span><br><span class="line">        item = [<span class="keyword">self</span> _dbGetItemFromStmt:stmt excludeInlineData:excludeInlineData];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (result != SQLITE_DONE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_errorLogsEnabled) <span class="built_in">NSLog</span>(<span class="string">@"%s line:%d sqlite query error (%d): %s"</span>, __FUNCTION__, __LINE__, result, sqlite3_errmsg(_db));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到最终生成YYKVStorageItem实例的是通过<code>_dbGetItemFromStmt:excludeInlineData:</code>来实现的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (YYKVStorageItem *)_dbGetItemFromStmt:(sqlite3_stmt *)stmt excludeInlineData:(<span class="built_in">BOOL</span>)excludeInlineData &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提取数据</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *key = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, i++);</span><br><span class="line">    <span class="keyword">char</span> *filename = (<span class="keyword">char</span> *)sqlite3_column_text(stmt, i++);</span><br><span class="line">    <span class="keyword">int</span> size = sqlite3_column_int(stmt, i++);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断excludeInlineData</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *inline_data = excludeInlineData ? <span class="literal">NULL</span> : sqlite3_column_blob(stmt, i);</span><br><span class="line">    <span class="keyword">int</span> inline_data_bytes = excludeInlineData ? <span class="number">0</span> : sqlite3_column_bytes(stmt, i++);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> modification_time = sqlite3_column_int(stmt, i++);</span><br><span class="line">    <span class="keyword">int</span> last_access_time = sqlite3_column_int(stmt, i++);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">void</span> *extended_data = sqlite3_column_blob(stmt, i);</span><br><span class="line">    <span class="keyword">int</span> extended_data_bytes = sqlite3_column_bytes(stmt, i++);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数据赋给item的属性</span></span><br><span class="line">    YYKVStorageItem *item = [YYKVStorageItem new];</span><br><span class="line">    <span class="keyword">if</span> (key) item.key = [<span class="built_in">NSString</span> stringWithUTF8String:key];</span><br><span class="line">    <span class="keyword">if</span> (filename &amp;&amp; *filename != <span class="number">0</span>) item.filename = [<span class="built_in">NSString</span> stringWithUTF8String:filename];</span><br><span class="line">    item.size = size;</span><br><span class="line">    <span class="keyword">if</span> (inline_data_bytes &gt; <span class="number">0</span> &amp;&amp; inline_data) item.value = [<span class="built_in">NSData</span> dataWithBytes:inline_data length:inline_data_bytes];</span><br><span class="line">    item.modTime = modification_time;</span><br><span class="line">    item.accessTime = last_access_time;</span><br><span class="line">    <span class="keyword">if</span> (extended_data_bytes &gt; <span class="number">0</span> &amp;&amp; extended_data) item.extendedData = [<span class="built_in">NSData</span> dataWithBytes:extended_data length:extended_data_bytes];</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码分为两个部分：</p><ul><li>获取数据库里每一个字段对应的数据</li><li>将数据赋给YYKVStorageItem的实例</li></ul><p>需要注意的是：</p><ol><li>字符串类型需要使用<code>stringWithUTF8String:</code>来转成NSString类型。</li><li>这里面会判断<code>excludeInlineData</code>：<ul><li>如果为TRUE，就提取存入的data数据</li><li>如果为FALSE，就不提取</li></ul></li></ol><h2 id="保证线程安全的方案"><a href="#保证线程安全的方案" class="headerlink" title="保证线程安全的方案"></a>保证线程安全的方案</h2><p>我相信对于某个设计来说，它的产生一定是基于某种个特定问题下的某个场景的</p><p>由上文可以看出：</p><ul><li>YYMemoryCache 使用了 pthread_mutex 线程锁（互斥锁）来确保线程安全</li><li>YYDiskCache 则选择了更适合它的 dispatch_semaphore。</li></ul><h3 id="内存缓存操作的互斥锁"><a href="#内存缓存操作的互斥锁" class="headerlink" title="内存缓存操作的互斥锁"></a>内存缓存操作的互斥锁</h3><p>在YYMemoryCache中，是使用互斥锁来保证线程安全的。<br>首先在YYMemoryCache的初始化方法中得到了互斥锁，并在它的所有接口里都加入了互斥锁来保证线程安全，包括setter，getter方法和缓存操作的实现。举几个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSUInteger</span>)totalCost &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="built_in">NSUInteger</span> totalCost = _lru-&gt;_totalCost;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> totalCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setReleaseOnMainThread:(<span class="built_in">BOOL</span>)releaseOnMainThread &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _lru-&gt;_releaseOnMainThread = releaseOnMainThread;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)containsObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    <span class="built_in">BOOL</span> contains = <span class="built_in">CFDictionaryContainsKey</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    <span class="keyword">return</span> contains;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        <span class="comment">//如果节点存在，则更新它的时间信息（最后一次访问的时间）</span></span><br><span class="line">        node-&gt;_time = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line">        [_lru bringNodeToHead:node];</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> node ? node-&gt;_value : <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而且需要在dealloc方法中销毁这个锁头：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//销毁互斥锁</span></span><br><span class="line">    pthread_mutex_destroy(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="磁盘缓存使用信号量来代替锁"><a href="#磁盘缓存使用信号量来代替锁" class="headerlink" title="磁盘缓存使用信号量来代替锁"></a>磁盘缓存使用信号量来代替锁</h3><p>框架作者采用了信号量的方式来给<br>首先在初始化的时候实例化了一个信号量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">             inlineThreshold:(<span class="built_in">NSUInteger</span>)threshold &#123;</span><br><span class="line">    ...</span><br><span class="line">    _lock = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">    _queue = dispatch_queue_create(<span class="string">"com.ibireme.cache.disk"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>然后使用了宏来代替加锁解锁的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define Lock() dispatch_semaphore_wait(self-&gt;_lock, DISPATCH_TIME_FOREVER)</span></span><br><span class="line"><span class="meta">#define Unlock() dispatch_semaphore_signal(self-&gt;_lock)</span></span><br></pre></td></tr></table></figure><p>简单说一下信号量：</p><p>dispatch_semaphore是GCD用来同步的一种方式，与他相关的共有三个函数，分别是</p><ul><li>dispatch_semaphore_create：定义信号量</li><li>dispatch_semaphore_signal：使信号量+1</li><li>dispatch_semaphore_wait：使信号量-1</li></ul><p>当信号量为0时，就会做等待处理，这是其他线程如果访问的话就会让其等待。所以如果信号量在最开始的的时候被设置为1，那么就可以实现“锁”的功能：</p><ul><li>执行某段代码之前，执行dispatch_semaphore_wait函数，让信号量-1变为0，执行这段代码。</li><li>此时如果其他线程过来访问这段代码，就要让其等待。</li><li>当这段代码在当前线程结束以后，执行dispatch_semaphore_signal函数，令信号量再次+1，那么如果有正在等待的线程就可以访问了。</li></ul><p>需要注意的是：如果有多个线程等待，那么后来信号量恢复以后访问的顺序就是线程遇到dispatch_semaphore_wait的顺序。</p><p>这也就是信号量和互斥锁的一个区别：互斥量用于线程的互斥，信号线用于线程的同步。</p><ul><li><p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但<strong>互斥无法限制访问者对资源的访问顺序，即访问是无序的</strong>。</p></li><li><p>同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。也就是说使用信号量可以使多个线程有序访问某个资源。</p></li></ul><p>那么问题来了：为什么内存缓存使用的是互斥锁（pthread_mutex），而磁盘缓存使用的就是信号量（dispatch_semaphore）呢？</p><p>答案在框架作者的文章<a href="https://blog.ibireme.com/2015/10/26/yycache/" target="_blank" rel="noopener">YYCache 设计思路</a>里可以找到:</p><p>为什么内存缓存使用互斥锁（pthread_mutex）？</p><p>框架作者在最初使用的是自旋锁(OSSpinLock)作为内存缓存的线程锁，但是后来得知其不够安全，所以退而求其次，使用了pthread_mutex。</p><p>为什么磁盘缓存使用的是信号量（dispatch_semaphore）？</p><blockquote><p>dispatch_semaphore 是信号量，但当信号总量设为 1 时也可以当作锁来。在没有等待情况出现时，它的性能比 pthread_mutex 还要高，但一旦有等待情况出现时，性能就会下降许多。相对于 OSSpinLock 来说，它的优势在于等待时不会消耗 CPU 资源。对磁盘缓存来说，它比较合适。</p></blockquote><p>因为YYDiskCache在写入比较大的缓存时，可能会有比较长的等待时间，而dispatch_semaphore在这个时候是不消耗CPU资源的，所以比较适合。</p><h2 id="提高缓存性能的几个尝试"><a href="#提高缓存性能的几个尝试" class="headerlink" title="提高缓存性能的几个尝试"></a>提高缓存性能的几个尝试</h2><h3 id="选择合适的线程锁"><a href="#选择合适的线程锁" class="headerlink" title="选择合适的线程锁"></a>选择合适的线程锁</h3><p>可以参考上一部分YYMemoryCache 和YYDiskCache使用的不同的锁以及原因。</p><h3 id="选择合适的数据结构"><a href="#选择合适的数据结构" class="headerlink" title="选择合适的数据结构"></a>选择合适的数据结构</h3><p>在YYMemoryCache中，作者选择了双向链表来保存这些缓存节点。那么可以思考一下，为什么要用双向链表而不是单向链表或是数组呢？</p><ul><li><p>为什么不选择单向链表：单链表的节点只知道它后面的节点（只有指向后一节点的指针），而不知道前面的。所以如果想移动其中一个节点的话，其前后的节点不好做衔接。</p></li><li><p>为什么不选择数组：数组中元素在内存的排列是连续的，对于寻址操作非常便利；但是对于插入，删除操作很不方便，需要整体移动，移动的元素个数越多，代价越大。而链表恰恰相反，因为其节点的关联仅仅是靠指针，所以对于插入和删除操作会很便利，而寻址操作缺比较费时。由于在LRU策略中会有非常多的移动，插入和删除节点的操作，所以使用双向链表是比较有优势的。</p></li></ul><h3 id="选择合适的线程来操作不同的任务"><a href="#选择合适的线程来操作不同的任务" class="headerlink" title="选择合适的线程来操作不同的任务"></a>选择合适的线程来操作不同的任务</h3><p>无论缓存的自动清理和释放，作者默认把这些任务放到子线程去做：</p><p>看一下释放所有内存缓存的操作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeAll &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将开销，缓存数量置为0</span></span><br><span class="line">    _totalCost = <span class="number">0</span>;</span><br><span class="line">    _totalCount = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将链表的头尾节点置空</span></span><br><span class="line">    _head = <span class="literal">nil</span>;</span><br><span class="line">    _tail = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">CFDictionaryGetCount</span>(_dic) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CFMutableDictionaryRef</span> holder = _dic;</span><br><span class="line">        _dic = <span class="built_in">CFDictionaryCreateMutable</span>(<span class="built_in">CFAllocatorGetDefault</span>(), <span class="number">0</span>, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//是否在子线程操作</span></span><br><span class="line">        <span class="keyword">if</span> (_releaseAsynchronously) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = _releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="built_in">CFRelease</span>(holder); <span class="comment">// hold and release in specified queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(holder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>YYMemoryCacheGetReleaseQueue()</code>使用了内联函数，返回了低优先级的并发队列。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内联函数，返回优先级最低的全局并发队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">dispatch_queue_t</span> YYMemoryCacheGetReleaseQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择底层的类"><a href="#选择底层的类" class="headerlink" title="选择底层的类"></a>选择底层的类</h3><p>同样是字典实现，但是作者使用了更底层且快速的CFDictionary而没有用NSDictionary来实现。</p><h2 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h2><h3 id="禁用原生初始化方法并标明新定义的指定初始化方法"><a href="#禁用原生初始化方法并标明新定义的指定初始化方法" class="headerlink" title="禁用原生初始化方法并标明新定义的指定初始化方法"></a>禁用原生初始化方法并标明新定义的指定初始化方法</h3><p>YYCache有4个供外部调用的初始化接口，无论是对象方法还是类方法都需要传入一个字符串（名称或路径）。</p><p>而两个原生的初始化方法被框架作者禁掉了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init UNAVAILABLE_ATTRIBUTE;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new UNAVAILABLE_ATTRIBUTE;</span><br></pre></td></tr></table></figure><p>如果用户使用了上面两个初始化方法就会在编译期报错。</p><p>而剩下的四个可以使用的初始化方法中，有一个是指定初始化方法，被作者用<code>NS_DESIGNATED_INITIALIZER</code>标记了。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithPath:(<span class="built_in">NSString</span> *)path <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithName:(<span class="built_in">NSString</span> *)name;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)cacheWithPath:(<span class="built_in">NSString</span> *)path;</span><br></pre></td></tr></table></figure><p>指定初始化方法就是所有可使用的初始化方法都必须调用的方法。更详细的介绍可以参考我的下面两篇文章：</p><ul><li><a href="https://juejin.im/post/5940c8befe88c2006a468ea6" target="_blank" rel="noopener">iOS 代码规范</a>中讲解“类”的这一部分。</li><li><a href="https://juejin.im/post/5a4f3710f265da3e4d728239" target="_blank" rel="noopener">《Effective objc》干货三部曲（三）：技巧篇</a>中的第16条。</li></ul><h3 id="异步释放对象的技巧"><a href="#异步释放对象的技巧" class="headerlink" title="异步释放对象的技巧"></a>异步释放对象的技巧</h3><p>为了异步将某个对象释放掉，可以通过在GCD的block里面给它发个消息来实现。这个技巧在该框架中很常见，举一个删除一个内存缓存的例子：</p><p>首先将这个缓存的node类取出，然后异步将其释放掉。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!key) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_lock(&amp;_lock);</span><br><span class="line">    _YYLinkedMapNode *node = <span class="built_in">CFDictionaryGetValue</span>(_lru-&gt;_dic, (__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(key));</span><br><span class="line">    <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        [_lru removeNode:node];</span><br><span class="line">        <span class="keyword">if</span> (_lru-&gt;_releaseAsynchronously) &#123;</span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = _lru-&gt;_releaseOnMainThread ? dispatch_get_main_queue() : YYMemoryCacheGetReleaseQueue();</span><br><span class="line">            <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_lru-&gt;_releaseOnMainThread &amp;&amp; !pthread_main_np()) &#123;</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [node <span class="keyword">class</span>]; <span class="comment">//hold and release in queue</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了释放掉这个node对象，在一个异步执行的（主队列或自定义队列里）block里给其发送了<code>class</code>这个消息。不需要纠结这个消息具体是什么，他的目的是为了避免编译错误，因为我们无法在block里面硬生生地将某个对象写进去。</p><p>其实关于上面这一点我自己也有点拿不准，希望理解得比较透彻的同学能在下面留个言~ ^^</p><h3 id="内存警告和进入后台的监听"><a href="#内存警告和进入后台的监听" class="headerlink" title="内存警告和进入后台的监听"></a>内存警告和进入后台的监听</h3><p>YYCache默认在收到内存警告和进入后台时，自动清除所有内存缓存。所以在YYMemoryCache的初始化方法里，我们可以看到这两个监听的动作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YYMemoryCache.m</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//监听app生命周期</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidReceiveMemoryWarningNotification) name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(_appDidEnterBackgroundNotification) name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span> object:<span class="literal">nil</span>];</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现监听到消息后的处理方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存警告时，删除所有内存缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)_appDidReceiveMemoryWarningNotification &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didReceiveMemoryWarningBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.didReceiveMemoryWarningBlock(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldRemoveAllObjectsOnMemoryWarning) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeAllObjects];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//进入后台时，删除所有内存缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)_appDidEnterBackgroundNotification &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didEnterBackgroundBlock) &#123;</span><br><span class="line">        <span class="keyword">self</span>.didEnterBackgroundBlock(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.shouldRemoveAllObjectsWhenEnteringBackground) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeAllObjects];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断头文件的导入"><a href="#判断头文件的导入" class="headerlink" title="判断头文件的导入"></a>判断头文件的导入</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#if __has_include(<span class="meta-string">&lt;YYCache/YYCache.h&gt;</span>)</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYMemoryCache.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYDiskCache.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;YYCache/YYKVStorage.h&gt;</span></span></span><br><span class="line"><span class="meta">#elif __has_include(<span class="meta-string">&lt;YYWebImage/YYCache.h&gt;</span>)</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYMemoryCache.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYDiskCache.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;YYWebImage/YYKVStorage.h&gt;</span></span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YYMemoryCache.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YYDiskCache.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YYKVStorage.h"</span></span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><p>在这里作者使用__has_include来检查Frameworks是否引入某个类。<br>因为YYWebImage已经集成YYCache,所以如果导入过YYWebImage的话就无需重再导入YYCache了。</p><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><p>通过看该组件的源码，我收获的不仅有缓存设计的思路，还有：</p><ul><li>双向链表的概念以及相关操作</li><li>数据库的使用</li><li>互斥锁，信号量的使用</li><li>实现线程安全的方案</li><li>变量，方法的命名以及接口的设计</li></ul><p>相信读过这篇文章的你也会有一些收获~<br>如果能趁热打铁，下载一个<a href="https://github.com/ibireme/YYCache">YYCache</a>源码看就更好啦~</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/ibireme/YYCache&quot;&gt;YYCache&lt;/a&gt;是国内开发者&lt;a href=&quot;https://blog.ibireme.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ibireme&lt;/a&gt;开源的一个线程安全的高性能键值缓存组件，代码风格简洁清晰，在GitHub上已经有了1600+颗星。&lt;/p&gt;
&lt;p&gt;阅读它的源码有助于建立比较完整的缓存设计的思路，同时也能巩固一下双向链表，线程锁，数据库操作相关的知识。如果你还没有看过YYCache的源码，那么恭喜你，阅读此文会对理解YYCache的源码有比较大的帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>YTKNetwork源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/YTKNetwork%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/YTKNetwork源码解析/</id>
    <published>2018-02-02T16:18:02.000Z</published>
    <updated>2018-07-16T16:47:11.157Z</updated>
    
    <content type="html"><![CDATA[<p>对于iOS开发来说，就算是没有用过<a href="https://github.com/yuantiku/YTKNetwork">YTKNetwork框架</a>，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。<br>​<br>在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。</p><h1 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h1><hr><p>先上图：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKRequest架构图"></p><blockquote><p>在这里简单说明一下：</p><ol><li>YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 </li><li>YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。</li><li>我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。</li><li>YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。</li></ol></blockquote><p>OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。</p><a id="more"></a><h1 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2. 设计模式"></a>2. 设计模式</h1><hr><p>YTKNetwork框架采用的设计模式是<strong>命令模式（Command Pattern）</strong>。</p><p>首先看一下命令模式的定义：</p><blockquote><p>命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。<br>摘自：<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">《Head First 设计模式》</a></p></blockquote><p>看一下命令模式的类图：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-c5c7e9ff32b2e647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令模式类图.png"></p><p>图中英文的含义：</p><table><thead><tr><th>英文</th><th>中文</th></tr></thead><tbody><tr><td>Command</td><td>抽象命令类</td></tr><tr><td>ConcreteCommand</td><td>命令类的实现类（子类）</td></tr><tr><td>Invoker</td><td>调用者</td></tr><tr><td>Receiver</td><td>命令接收者（执行者)</td></tr><tr><td>Client</td><td>客户端</td></tr></tbody></table><p>详细介绍一下：</p><ol><li>命令模式的本质是对命令的封装，将发出命令的责任和执行命令的责任分割开。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li></ol><p>可能还是觉得有点抽象，在这里举一个<a href="https://www.amazon.cn/Head-First%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BC%97%E9%87%8C%E6%9B%BC/dp/B0011FBU34/ref=sr_1_1?ie=UTF8&amp;qid=1500104908&amp;sr=8-1&amp;keywords=head+first+%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">《Head First 设计模式》</a>里的例子，一个客人在餐厅点餐的过程：</p><ol><li>你将点的菜写在订单里，交给了服务员。</li><li>服务员将订单交给厨师。</li><li>厨师做好菜之后将做好的菜交给服务员。</li><li>最后服务员把菜递给你。</li></ol><p>在这里，命令就好比是订单，而你是命令的发起者。你的命令（订单）通过服务员（调用者）交给了命令的执行者（厨师）。<br>所以至于这道菜具体是谁做，怎么做，你是不知道的，你做的只是发出命令和接受结果。而且对于餐厅来说，厨师是可以随便换的，而你可能对此一无所知。反过来，厨师只需要好好把菜做好，至于是谁点的菜也不需要他考虑。</p><p>结合上面命令模式的类图以及餐厅点餐的例子，我们来理清一下YTKNetwork内部的职能</p><table><thead><tr><th>场景</th><th>Command</th><th>ConcreteCommand</th><th>Invoker</th><th>Receiver</th><th>Client</th></tr></thead><tbody><tr><td>餐厅</td><td>空白订单</td><td>填入菜名的订单</td><td>服务员</td><td>厨师</td><td>客人</td></tr><tr><td>YTKNetwork</td><td>YTKBaseRequest</td><td>CustomRequest</td><td>YTKNetworkAgent</td><td>AFNetworking</td><td>ViewController/ViewModel</td></tr></tbody></table><p>可以看到，YTKNetwork对命令模式的实现是很符合其设计标准的，它将请求的发起者和接收者分离开来(中间隔着调用者)，可以让我们随时更换接受者。</p><p>另外，因为封装了请求，我们既可以管理单个请求，也可以同时管理多个请求，甚至实现琏式请求的发送。关于多个请求的发送，我们也可以想象在餐厅里，你可以在吃的过程中还想起来要吃别的东西，例如点心，饮料之类的，你就可以填多个订单（当然也可以写在一起）交给服务员。</p><p>相信到这里，大家应该对YTKNetwork的设计与架构有了足够的认识了，下面进入到真正的源码解析，我们结合一下它的代码来看一下YTKNetwork是如何实现和管理网络请求的。</p><h1 id="3-源码解析"><a href="#3-源码解析" class="headerlink" title="3. 源码解析"></a>3. 源码解析</h1><hr><p>在真正讲解源码之前，我先详细说一下各个类的职责:</p><h2 id="3-1-责任介绍"><a href="#3-1-责任介绍" class="headerlink" title="3.1 责任介绍"></a>3.1 责任介绍</h2><table><thead><tr><th>类名</th><th>职责</th></tr></thead><tbody><tr><td>YTKBaseRequest</td><td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td></tr><tr><td>YTKBaseRequest</td><td>所有请求类的基类。持有NSURLSessionTask实例，responseData，responseObject，error等重要数据，提供一些需要子类实现的与网络请求相关的方法，处理回调的代理和block，命令YTKNetworkAgent发起网络请求。</td></tr><tr><td>YTKRequest</td><td>YTKBaseRequest的子类。负责缓存的处理：请求前查询缓存；请求后写入缓存。</td></tr><tr><td>YTKNetworkConfig</td><td>被YTKRequest和YTKNetworkAgent访问。负责所有请求的全局配置，例如baseUrl和CDNUrl等等。</td></tr><tr><td>YTKNetworkPrivate</td><td>提供JSON验证，appVersion等辅助性的方法；给YTKBaseRequest增加一些分类。</td></tr><tr><td>YTKNetworkAgent</td><td>真正发起请求的类。负责发起请求，结束请求，并持有一个字典来存储正在执行的请求。</td></tr><tr><td>YTKBatchRequest</td><td>可以发起批量请求，持有一个数组来保存所有的请求类。在请求执行后遍历这个数组来发起请求，如果其中有一个请求返回失败，则认定本组请求失败。</td></tr><tr><td>YTKBatchRequestAgent</td><td>负责管理多个YTKBatchRequest实例，持有一个数组来保存YTKBatchRequest。支持添加和删除YTKBatchRequest实例。</td></tr><tr><td>YTKChainRequest</td><td>可以发起链式请求，持有一个数组来保存所有的请求类。当某个请求结束后才能发起下一个请求，如果其中有一个请求返回失败，则认定本请求链失败。</td></tr><tr><td>YTKChainRequestAgent</td><td>负责管理多个YTKChainRequestAgent实例，持有一个数组来保存YTKChainRequest。支持添加和删除YTKChainRequest实例。</td></tr></tbody></table><p>OK，现在知道了YTKNetwork内部的责任分配，下面我们先从单个请求的全部流程（配置，发起，结束）来看一下YTKNetwork都做了什么。</p><h2 id="3-2-单个请求"><a href="#3-2-单个请求" class="headerlink" title="3.2 单个请求"></a>3.2 单个请求</h2><h3 id="3-21-单个请求的配置"><a href="#3-21-单个请求的配置" class="headerlink" title="3.21 单个请求的配置"></a>3.21 单个请求的配置</h3><p><a href="https://github.com/yuantiku/YTKNetwork/blob/master/Docs/BasicGuide_cn.md">官方的教程</a>建议我们将请求的全局配置是在AppDelegate.m文件里，设定baseUrl以及cdnUrl等参数。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application </span><br><span class="line">   didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">   YTKNetworkConfig *config = [YTKNetworkConfig sharedConfig];</span><br><span class="line">   config.baseUrl = <span class="string">@"http://yuantiku.com"</span>;</span><br><span class="line">   config.cdnUrl = <span class="string">@"http://fen.bi"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要新建一个注册的请求，则需要创建一个继承于YTKRequest的注册接口的类RegisterApi，并将针对该请求参数配置好：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RegisterApi.h</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"YTKRequest.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RegisterApi</span> : <span class="title">YTKRequest</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// RegisterApi.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"RegisterApi.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RegisterApi</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_username;</span><br><span class="line">    <span class="built_in">NSString</span> *_password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化的时候将两个参数值传入</span></span><br><span class="line">- (<span class="keyword">id</span>)initWithUsername:(<span class="built_in">NSString</span> *)username password:(<span class="built_in">NSString</span> *)password &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _username = username;</span><br><span class="line">        _password = password;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要和baseUrl拼接的地址</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)requestUrl &#123;</span><br><span class="line">    <span class="comment">// “ http://www.yuantiku.com ” 在 YTKNetworkConfig 中设置，这里只填除去域名剩余的网址信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"/iphone/register"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求方法，某人是GET</span></span><br><span class="line">- (YTKRequestMethod)requestMethod &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求体</span></span><br><span class="line">- (<span class="keyword">id</span>)requestArgument &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">        <span class="string">@"username"</span>: _username,</span><br><span class="line">        <span class="string">@"password"</span>: _password</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>现在我们知道如何配置全局的参数和针对某个请求的参数了，接下来看一下单个请求是如何发起的。</p><h3 id="3-22-单个请求的发起"><a href="#3-22-单个请求的发起" class="headerlink" title="3.22 单个请求的发起"></a>3.22 单个请求的发起</h3><p>还是刚才的注册API，在实例化以后，直接调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法）就可以发起它：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LoginViewController.m</span></span><br><span class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</span><br><span class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</span><br><span class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</span><br><span class="line">        [api startWithCompletionBlockWithSuccess:^(YTKBaseRequest *request) &#123;</span><br><span class="line">            <span class="comment">// 你可以直接在这里使用 self</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</span><br><span class="line">        &#125; failure:^(YTKBaseRequest *request) &#123;</span><br><span class="line">            <span class="comment">// 你可以直接在这里使用 self</span></span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是以block的形式回调，YTKNetwork也支持代理的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LoginViewController.m</span></span><br><span class="line">- (<span class="keyword">void</span>)loginButtonPressed:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.UserNameTextField.text;</span><br><span class="line">    <span class="built_in">NSString</span> *password = <span class="keyword">self</span>.PasswordTextField.text;</span><br><span class="line">    <span class="keyword">if</span> (username.length &gt; <span class="number">0</span> &amp;&amp; password.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        RegisterApi *api = [[RegisterApi alloc] initWithUsername:username password:password];</span><br><span class="line">        api.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [api start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"succeed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有两点需要注意的是：</p><ol><li>必须给自定义请求类（RegisterApi）调用<code>startWithCompletionBlockWithSuccess:failure</code>方法（或<code>start</code>方法），才能真正发起请求。</li><li>在同时设置了回调代理和回调block的情况下，首先回调的是回调代理方法，然后再走回调block。</li></ol><p>知道了YTKRequest请求是如何在外部发起的，我们现在从<code>startWithCompletionBlockWithSuccess:failure</code>方法开始，来看一下YTKNetwork都做了什么：</p><p>首先来到YTKBaseRequest类（因为最早是由它定义的该方法）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseRequest.m</span></span><br><span class="line"><span class="comment">//传入成功和失败的block,并保存起来</span></span><br><span class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</span><br><span class="line">                                    failure:(YTKRequestCompletionBlock)failure &#123;</span><br><span class="line">    <span class="comment">//保存成功和失败的回调block，便于将来调用</span></span><br><span class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    <span class="comment">//发起请求</span></span><br><span class="line">    [<span class="keyword">self</span> start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存成功和失败的block</span></span><br><span class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(YTKRequestCompletionBlock)success</span><br><span class="line">                              failure:(YTKRequestCompletionBlock)failure &#123;</span><br><span class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</span><br><span class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当保存完成功和失败的block以后，调用<code>start</code>方法，于是来到了YTKRequest类（注意，虽然YTKBaseRequest也实现了<code>start</code>方法，但是由于YTKRequest类是它的子类并也实现了<code>start</code>方法，所以这里最先走的是YTKRequest类的<code>start</code>方法）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 到这里，说明一定能拿到可用的缓存，可以直接回调了（因为一定能拿到可用的缓存，所以一定是调用成功的block和代理）</span></span><br><span class="line">    _dataFromCache = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5. 回调之前的操作</span></span><br><span class="line">        <span class="comment">//5.1 缓存处理</span></span><br><span class="line">        [<span class="keyword">self</span> requestCompletePreprocessor];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></span><br><span class="line">        [<span class="keyword">self</span> requestCompleteFilter];</span><br><span class="line">        </span><br><span class="line">        YTKRequest *strongSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6. 执行回调</span></span><br><span class="line">        <span class="comment">//6.1 请求完成的代理</span></span><br><span class="line">        [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.2 请求成功的block</span></span><br><span class="line">        <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">            strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></span><br><span class="line">        [strongSelf clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们之前说过YTKRequest负责缓存的相关处理，所以在上面这个<code>start</code>方法里，它做的是请求之前缓存的查询和检查工作:</p><ul><li>如果忽略缓存，或者缓存获取失败，调用<code>startWithoutCache</code>方法（参考1-3的情况），发起请求。</li><li>如果能成功获取到缓存，则直接回调（参考4-7的情况）。</li></ul><p>我们来看一下每一步的具体实现：</p><ol><li><code>ignoreCache</code>属性是用户手动设置的，如果用户强制忽略缓存，则无论是否缓存是否存在，直接发送请求。</li><li><code>resumableDownloadPath</code>是断点下载路径，如果该路径不为空，说明有未完成的下载任务，则直接发送请求继续下载。</li><li><code>loadCacheWithError：</code>方法验证了加载缓存是否成功的方法（返回值为YES，说明可以加载缓存；反之亦然），看一下具体实现：</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)loadCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存时间小于0，则返回（缓存时间默认为-1，需要用户手动设置，单位是秒）</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheTime userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache time"</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否有缓存的元数据，如果没有，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheMetadata]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidMetadata userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid metadata. Cache may not exist"</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缓存，再验证是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateCacheWithError:error]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有缓存，而且有效，再验证是否能取出来</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheData]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorInvalidCacheData userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid cache data"</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先讲一下什么是元数据：元数据是指数据的数据，在这里描述了缓存数据本身的一些特征：包括版本号，缓存时间，敏感信息等等， 稍后会做详细介绍。</p><p>我们来看一下上面关于缓存的元数据的获取方法：<code>loadCacheMetadata</code>方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)loadCacheMetadata &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheMetadataFilePath];</span><br><span class="line">    <span class="built_in">NSFileManager</span> * fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="comment">//将序列化之后被保存在磁盘里的文件反序列化到当前对象的属性cacheMetadata</span></span><br><span class="line">            _cacheMetadata = [<span class="built_in">NSKeyedUnarchiver</span> unarchiveObjectWithFile:path];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            YTKLog(<span class="string">@"Load cache metadata failed, reason = %@"</span>, exception.reason);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cacheMetadata（YTKCacheMetadata） 是当前reqeust类用来保存缓存元数据的属性。<br>YTKCacheMetadata类被定义在YTKRequest.m文件里面：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">YTKCacheMetadata</span> : <span class="title">NSObject</span>&lt;<span class="title">NSSecureCoding</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">long</span> <span class="keyword">long</span> version;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *sensitiveDataString;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSStringEncoding</span> stringEncoding;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *appVersionString;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>它描述的是缓存的版本号，敏感信息，创建时间，app版本等信息，并支持序列化处理，可以保存在磁盘里。<br>因此，<code>loadCacheMetadata</code>方法的目的是将之前被序列化保存的缓存元数据信息反序列化，赋给自身的<code>cacheMetadata</code>属性上。</p><p>现在获取了缓存的元数据并赋给了自身的cacheMetadata属性上，那么接下来就要逐一验证元数据里的各项信息是否符合要求，在下面的validateCacheWithError：里面验证：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateCacheWithError:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否大于过期时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *creationDate = <span class="keyword">self</span>.cacheMetadata.creationDate;</span><br><span class="line">    <span class="built_in">NSTimeInterval</span> duration = -[creationDate timeIntervalSinceNow];</span><br><span class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">0</span> || duration &gt; [<span class="keyword">self</span> cacheTimeInSeconds]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorExpired userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache expired"</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存的版本号是否符合</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> cacheVersionFileContent = <span class="keyword">self</span>.cacheMetadata.version;</span><br><span class="line">    <span class="keyword">if</span> (cacheVersionFileContent != [<span class="keyword">self</span> cacheVersion]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache version mismatch"</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 敏感信息是否符合</span></span><br><span class="line">    <span class="built_in">NSString</span> *sensitiveDataString = <span class="keyword">self</span>.cacheMetadata.sensitiveDataString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentSensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">    <span class="keyword">if</span> (sensitiveDataString || currentSensitiveDataString) &#123;</span><br><span class="line">        <span class="comment">// If one of the strings is nil, short-circuit evaluation will trigger</span></span><br><span class="line">        <span class="keyword">if</span> (sensitiveDataString.length != currentSensitiveDataString.length || ![sensitiveDataString isEqualToString:currentSensitiveDataString]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorSensitiveDataMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Cache sensitive data mismatch"</span>&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// app的版本是否符合</span></span><br><span class="line">    <span class="built_in">NSString</span> *appVersionString = <span class="keyword">self</span>.cacheMetadata.appVersionString;</span><br><span class="line">    <span class="built_in">NSString</span> *currentAppVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">    <span class="keyword">if</span> (appVersionString || currentAppVersionString) &#123;</span><br><span class="line">        <span class="keyword">if</span> (appVersionString.length != currentAppVersionString.length || ![appVersionString isEqualToString:currentAppVersionString]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestCacheErrorDomain code:YTKRequestCacheErrorAppVersionMismatch userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"App version mismatch"</span>&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每项元数据信息都能通过，再在<code>loadCacheData</code>方法里面验证缓存是否能被取出来：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)loadCacheData &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheFilePath];</span><br><span class="line">    <span class="built_in">NSFileManager</span> *fileManager = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([fileManager fileExistsAtPath:path isDirectory:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:path];</span><br><span class="line">        _cacheData = data;</span><br><span class="line">        _cacheString = [[<span class="built_in">NSString</span> alloc] initWithData:_cacheData encoding:<span class="keyword">self</span>.cacheMetadata.stringEncoding];</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.responseSerializerType) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</span><br><span class="line">                <span class="comment">// Do nothing.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</span><br><span class="line">                _cacheJSON = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:_cacheData options:(<span class="built_in">NSJSONReadingOptions</span>)<span class="number">0</span> error:&amp;error];</span><br><span class="line">                <span class="keyword">return</span> error == <span class="literal">nil</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                _cacheXML = [[<span class="built_in">NSXMLParser</span> alloc] initWithData:_cacheData];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果通过了最终的考验，则说明当前请求对应的缓存是符合各项要求并可以被成功取出，也就是可以直接进行回调了。</p><p>当确认缓存可以成功取出后，手动设置<code>dataFromCache</code>属性为 YES，说明当前的请求结果是来自于缓存，而没有通过网络请求。</p><p>然后在真正回调之前做了如下处理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m：</span></span><br><span class="line">- (<span class="keyword">void</span>)start&#123;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 回调之前的操作</span></span><br><span class="line">    <span class="comment">//5.1 缓存处理</span></span><br><span class="line">    [<span class="keyword">self</span> requestCompletePreprocessor];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.2 用户可以在这里进行真正回调前的操作</span></span><br><span class="line">    [<span class="keyword">self</span> requestCompleteFilter];</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.1：<code>requestCompletePreprocessor</code>方法:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m：</span></span><br><span class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列ytkrequest_cache_writing_queue进行）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</span><br><span class="line">            <span class="comment">//保存响应数据到缓存</span></span><br><span class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//保存响应数据到缓存</span></span><br><span class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m：</span></span><br><span class="line"><span class="comment">//保存响应数据到缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                <span class="comment">// New data will always overwrite old data.</span></span><br><span class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</span><br><span class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</span><br><span class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</span><br><span class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到, <code>requestCompletePreprocessor</code>方法的任务是将响应数据保存起来，也就是做缓存。但是，缓存的保存有两个条件，一个是需要<code>cacheTimeInSeconds</code>方法返回正整数（缓存时间，单位是秒，后续会详细说明）；另一个条件是<code>isDataFromCache</code>方法返回NO。<br>但是我们知道，如果缓存可用，就会将这个属性设置为YES，所以走到这里的时候，就不做缓存了。</p></blockquote><p>接着看下5.2：<code>requestCompleteFilter</code>方法则是需要用户自己提供具体实现的，专门作为回调成功之前的一些处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)requestCompleteFilter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里，回调之前的处理都结束了，下面来看一下在缓存可用的情况下的回调：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)start&#123;</span><br><span class="line">   </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//6. 执行回调</span></span><br><span class="line">    <span class="comment">//6.1 请求完成的代理</span></span><br><span class="line">    [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//6.2 请求成功的block</span></span><br><span class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">         strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></span><br><span class="line">    [strongSelf clearCompletionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 ，这里面同时存在两种回调：代理的回调和block的回调。先执行的是代理的回调，然后执行的是block的回调。而且在回调结束之后，YTKNetwork会帮助我们清空回调的block：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</span><br><span class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>注意，在用户同时实现了代理和block的情况下，二者都会被调用。</p></blockquote><p>到这里，我们了解了YTKNetwork在网络请求之前是如何验证缓存，以及在缓存有效的情况下是如何回调的。</p><p>反过来，如果缓存无效（或忽略缓存）时，需要立即请求网络。那么我们现在来看一看在这个时候YTKNetwork都做了什么：</p><p>仔细看一下上面的<code>start</code>方法，我们会发现，如果缓存不满足条件时，会直接调用<code>startWithoutCache</code>方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)start&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. 如果忽略缓存 -&gt; 请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.ignoreCache) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 如果存在下载未完成的文件 -&gt; 请求</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.resumableDownloadPath) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获取缓存失败 -&gt; 请求</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> loadCacheWithError:<span class="literal">nil</span>]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> startWithoutCache];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么在<code>startWithoutCache</code>方法里都做了什么呢？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)startWithoutCache &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 清除缓存</span></span><br><span class="line">    [<span class="keyword">self</span> clearCacheVariables];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 调用父类的发起请求</span></span><br><span class="line">    [<span class="keyword">super</span> start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除当前请求对应的所有缓存</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCacheVariables &#123;</span><br><span class="line">    _cacheData = <span class="literal">nil</span>;</span><br><span class="line">    _cacheXML = <span class="literal">nil</span>;</span><br><span class="line">    _cacheJSON = <span class="literal">nil</span>;</span><br><span class="line">    _cacheString = <span class="literal">nil</span>;</span><br><span class="line">    _cacheMetadata = <span class="literal">nil</span>;</span><br><span class="line">    _dataFromCache = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，首先清除了关于缓存的所有数据，然后调用父类的<code>start</code>方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseRequest.m:</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 告诉Accessories即将回调了（其实是即将发起请求）</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 令agent添加请求并发起请求，在这里并不是组合关系，agent只是一个单例</span></span><br><span class="line">    [[YTKNetworkAgent sharedAgent] addRequest:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步里的Accessories是一些遵从<ytkrequestaccessory>代理的对象。这个代理定义了一些用来追踪请求状况的方法。它被定义在了YTKBaseRequest.h文件里：</ytkrequestaccessory></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来跟踪请求的状态的代理。</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">YTKRequestAccessory</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  Inform the accessory that the request is about to start.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  @param request The corresponding request.</span></span><br><span class="line">- (<span class="keyword">void</span>)requestWillStart:(<span class="keyword">id</span>)request;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  Inform the accessory that the request is about to stop. This method is called</span></span><br><span class="line"><span class="comment">///  before executing `requestFinished` and `successCompletionBlock`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  @param request The corresponding request.</span></span><br><span class="line">- (<span class="keyword">void</span>)requestWillStop:(<span class="keyword">id</span>)request;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  Inform the accessory that the request has already stoped. This method is called</span></span><br><span class="line"><span class="comment">///  after executing `requestFinished` and `successCompletionBlock`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">///  @param request The corresponding request.</span></span><br><span class="line">- (<span class="keyword">void</span>)requestDidStop:(<span class="keyword">id</span>)request;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>所以只要某个对象遵从了这个代理，就可以追踪到请求将要开始，将要结束，已经结束的状态。</p><p>接着看一下第二步：YTKNetworkAgent把当前的请求对象添加到了自己身上并发送请求。来看一下它的具体实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 获取task</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> * __autoreleasing requestSerializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户自定义的requestURL</span></span><br><span class="line">    <span class="built_in">NSURLRequest</span> *customUrlRequest= [request buildCustomUrlRequest];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (customUrlRequest) &#123;</span><br><span class="line">        </span><br><span class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></span><br><span class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            <span class="comment">//响应的统一处理</span></span><br><span class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        request.requestTask = dataTask;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></span><br><span class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化失败，则认定为请求失败</span></span><br><span class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</span><br><span class="line">        <span class="comment">//请求失败的处理</span></span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>(request.requestTask != <span class="literal">nil</span>, <span class="string">@"requestTask should not be nil"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级的映射</span></span><br><span class="line">    <span class="comment">// !!Available on iOS 8 +</span></span><br><span class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</span><br><span class="line">                <span class="comment">/*!!fall through*/</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retain request</span></span><br><span class="line">    YTKLog(<span class="string">@"Add request: %@"</span>, <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 将request放入保存请求的字典中，taskIdentifier为key，request为值</span></span><br><span class="line">    [<span class="keyword">self</span> addRequestToRecord:request];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 开始task</span></span><br><span class="line">    [request.requestTask resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法挺长的，但是请不要被吓到，它总共分为三个部分：</p><ul><li>第一部分是获取当前请求对应的task并赋给request的<code>requestTask</code>属性（以后提到的request，都为用户自定义的当前请求类的实例）。</li><li>第二部分是把request放入专门用来保存请求的字典中，key为taskIdentifier。</li><li>第三部分是启动task。</li></ul><p>下面我来依次讲解每个部分：</p><p><strong>第一部分：获取当前请求对应的task并赋给request</strong>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (customUrlRequest) &#123;</span><br><span class="line">        </span><br><span class="line">        __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//如果存在用户自定义request，则直接走AFNetworking的dataTaskWithRequest:方法</span></span><br><span class="line">        dataTask = [_manager dataTaskWithRequest:customUrlRequest completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">            <span class="comment">//统一处理请求响应</span></span><br><span class="line">            [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        request.requestTask = dataTask;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果用户没有自定义url，则直接走这里</span></span><br><span class="line">        request.requestTask = [<span class="keyword">self</span> sessionTaskForRequest:request error:&amp;requestSerializationError];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里判断了用户是否自定义了request：</p><ol><li>如果是，则直接调用AFNetworking的dataTaskWithRequest:方法。</li><li>如果不是，则调用YTKRequest自己的生成task的方法。</li></ol><p>第一种情况就不说了，因为AF帮我们做好了。在这里看一下第二种情况，<code>sessionTaskForRequest: error :</code>方法内部：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line"><span class="comment">//根据不同请求类型，序列化类型，和请求参数来返回NSURLSessionTask</span></span><br><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 获得请求类型（GET，POST等）</span></span><br><span class="line">    YTKRequestMethod method = [request requestMethod];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获得请求url</span></span><br><span class="line">    <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 获得请求参数</span></span><br><span class="line">    <span class="keyword">id</span> param = request.requestArgument;</span><br><span class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 获得request serializer</span></span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 根据不同的请求类型来返回对应的task</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodGET:</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (request.resumableDownloadPath) &#123;</span><br><span class="line">                <span class="comment">//下载任务</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> downloadTaskWithDownloadPath:request.resumableDownloadPath requestSerializer:requestSerializer URLString:url parameters:param progress:request.resumableDownloadProgressBlock error:error];</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//普通get请求</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"GET"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPOST:</span><br><span class="line">            <span class="comment">//POST请求</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"POST"</span> requestSerializer:requestSerializer URLString:url parameters:param constructingBodyWithBlock:constructingBlock error:error];</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodHEAD:</span><br><span class="line">            <span class="comment">//HEAD请求</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"HEAD"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPUT:</span><br><span class="line">            <span class="comment">//PUT请求</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PUT"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodDELETE:</span><br><span class="line">            <span class="comment">//DELETE请求</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"DELETE"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> YTKRequestMethodPATCH:</span><br><span class="line">            <span class="comment">//PATCH请求</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@"PATCH"</span> requestSerializer:requestSerializer URLString:url parameters:param error:error];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这个方法最后的switch语句可以看出，这个方法的作用是返回当前request的NSURLSessionTask的实例。而且最终生成NSURLSessionTask实例的方法都是通过<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>这个私有方法来实现的。在讲解这个关键的私有方法之前，先来逐步讲解一下这个私有方法需要的每个参数的获取方法：</p><ol><li>获得请求类型（GET，POST等）：</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  YTKRequestMethod method = [request requestMethod];</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>requestMethod</code>方法最初在YTKBaseRequest里面已经实现了，默认返回了YTKRequestMethodGET。</p><p>它的枚举类型在YTKBaseRequest.h里面定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseRequest.h</span></span><br><span class="line"><span class="comment">///  HTTP Request method.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestMethod) &#123;</span><br><span class="line">    YTKRequestMethodGET = <span class="number">0</span>,</span><br><span class="line">    YTKRequestMethodPOST,</span><br><span class="line">    YTKRequestMethodHEAD,</span><br><span class="line">    YTKRequestMethodPUT,</span><br><span class="line">    YTKRequestMethodDELETE,</span><br><span class="line">    YTKRequestMethodPATCH,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>用户可以根据实际的需求在自定义request类里面重写这个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RegisterAPI.m</span></span><br><span class="line">- (YTKRequestMethod)requestMethod &#123;</span><br><span class="line">    <span class="keyword">return</span> YTKRequestMethodPOST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.获得请求url：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">NSString</span> *url = [<span class="keyword">self</span> buildRequestUrl:request];</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回当前请求url</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)buildRequestUrl:(YTKBaseRequest *)request &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户自定义的url（不包括在YTKConfig里面设置的base_url）</span></span><br><span class="line">    <span class="built_in">NSString</span> *detailUrl = [request requestUrl];</span><br><span class="line">    <span class="built_in">NSURL</span> *temp = [<span class="built_in">NSURL</span> URLWithString:detailUrl];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存在host和scheme的url立即返回正确</span></span><br><span class="line">    <span class="keyword">if</span> (temp &amp;&amp; temp.host &amp;&amp; temp.scheme) &#123;</span><br><span class="line">        <span class="keyword">return</span> detailUrl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果需要过滤url，则过滤</span></span><br><span class="line">    <span class="built_in">NSArray</span> *filters = [_config urlFilters];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKUrlFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">        detailUrl = [f filterUrl:detailUrl withRequest:request];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *baseUrl;</span><br><span class="line">    <span class="keyword">if</span> ([request useCDN]) &#123;</span><br><span class="line">        <span class="comment">//如果使用CDN，在当前请求没有配置CDN地址的情况下，返回全局配置的CDN</span></span><br><span class="line">        <span class="keyword">if</span> ([request cdnUrl].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            baseUrl = [request cdnUrl];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            baseUrl = [_config cdnUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果使用baseUrl，在当前请求没有配置baseUrl，返回全局配置的baseUrl</span></span><br><span class="line">        <span class="keyword">if</span> ([request baseUrl].length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            baseUrl = [request baseUrl];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            baseUrl = [_config baseUrl];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果末尾没有/，则在末尾添加一个／</span></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:baseUrl];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (baseUrl.length &gt; <span class="number">0</span> &amp;&amp; ![baseUrl hasSuffix:<span class="string">@"/"</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@""</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSURL</span> URLWithString:detailUrl relativeToURL:url].absoluteString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.获得请求参数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">      <span class="comment">//获取用户提供的请求参数</span></span><br><span class="line">    <span class="keyword">id</span> param = request.requestArgument;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取用户提供的构造请求体的block（默认是没有的）</span></span><br><span class="line">    AFConstructingBlock constructingBlock = [request constructingBodyBlock];</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，requestArgument是一个get方法，需要用户自己定义请求体，例如在RegisterAPI里面就定义了两个请求参数：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RegisterApi.m</span></span><br><span class="line">- (<span class="keyword">id</span>)requestArgument &#123;</span><br><span class="line">    <span class="keyword">return</span> @&#123;</span><br><span class="line">        <span class="string">@"username"</span>: _username,</span><br><span class="line">        <span class="string">@"password"</span>: _password</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.获得request serializer</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//4. 获得request serializer</span></span><br><span class="line">   AFHTTPRequestSerializer *requestSerializer = [<span class="keyword">self</span> requestSerializerForRequest:request];</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (AFHTTPRequestSerializer *)requestSerializerForRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    AFHTTPRequestSerializer *requestSerializer = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//HTTP or JSON</span></span><br><span class="line">    <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeHTTP) &#123;</span><br><span class="line">        requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.requestSerializerType == YTKRequestSerializerTypeJSON) &#123;</span><br><span class="line">        requestSerializer = [AFJSONRequestSerializer serializer];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    requestSerializer.timeoutInterval = [request requestTimeoutInterval];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否允许数据服务</span></span><br><span class="line">    requestSerializer.allowsCellularAccess = [request allowsCellularAccess];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前请求需要验证</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *authorizationHeaderFieldArray = [request requestAuthorizationHeaderFieldArray];</span><br><span class="line">    <span class="keyword">if</span> (authorizationHeaderFieldArray != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [requestSerializer setAuthorizationHeaderFieldWithUsername:authorizationHeaderFieldArray.firstObject</span><br><span class="line">                                                          password:authorizationHeaderFieldArray.lastObject];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前请求需要自定义 HTTPHeaderField</span></span><br><span class="line">    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSString</span> *&gt; *headerFieldValueDictionary = [request requestHeaderFieldValueDictionary];</span><br><span class="line">    <span class="keyword">if</span> (headerFieldValueDictionary != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *httpHeaderField <span class="keyword">in</span> headerFieldValueDictionary.allKeys) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *value = headerFieldValueDictionary[httpHeaderField];</span><br><span class="line">            [requestSerializer setValue:value forHTTPHeaderField:httpHeaderField];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> requestSerializer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个方法通过传入的request实例，根据它的一些配置（用户提供）来获取AFHTTPRequestSerializer的实例。</p><p>到现在为止，获取NSURLSessionTask实例的几个参数都拿到了，剩下的就是调用<code>dataTaskWithHTTPMethod:requestSerializer:URLString:parameters:error:</code>方法来获取NSURLSessionTask实例了。我们来看一下这个方法的具体实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> dataTaskWithHTTPMethod:method requestSerializer:requestSerializer URLString:URLString parameters:parameters constructingBodyWithBlock:<span class="literal">nil</span> error:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最终返回NSURLSessionDataTask实例</span></span><br><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               requestSerializer:(AFHTTPRequestSerializer *)requestSerializer</span><br><span class="line">                                       URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                      parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                       constructingBodyWithBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="keyword">id</span> &lt;AFMultipartFormData&gt; formData))block</span><br><span class="line">                                           error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据有无构造请求体的block的情况来获取request</span></span><br><span class="line">    <span class="keyword">if</span> (block) &#123;</span><br><span class="line">        request = [requestSerializer multipartFormRequestWithMethod:method URLString:URLString parameters:parameters constructingBodyWithBlock:block error:error];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        request = [requestSerializer requestWithMethod:method URLString:URLString parameters:parameters error:error];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得request以后来获取dataTask</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [_manager dataTaskWithRequest:request</span><br><span class="line">                           completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                               <span class="comment">//响应的统一处理</span></span><br><span class="line">                               [<span class="keyword">self</span> handleRequestResult:dataTask responseObject:responseObject error:_error];</span><br><span class="line">                           &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法，上面的方法调用了下面的来获取最终的NSURLSessionDataTask实例。</p><p>OK，现在我们已经知道了NSURLSessionDataTask实例是如何获取的，再来看一下在<code>addRequest：</code>方法里接下来做的是对序列化失败的处理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//序列化失败</span></span><br><span class="line">    <span class="keyword">if</span> (requestSerializationError) &#123;</span><br><span class="line">        <span class="comment">//请求失败的处理</span></span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestSerializationError];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>requestDidFailWithRequest:方法专门处理请求失败的情况，因为它被包含在统一处理请求回调的方法中，所以在稍后会在讲解统一处理请求回调的方法的时候再详细讲解这个方法。</p><p>继续往下走，到了优先级的映射部分：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 优先级的映射</span></span><br><span class="line">    <span class="comment">// !!Available on iOS 8 +</span></span><br><span class="line">    <span class="keyword">if</span> ([request.requestTask respondsToSelector:<span class="keyword">@selector</span>(priority)]) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (request.requestPriority) &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityHigh:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityLow:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> YTKRequestPriorityDefault:</span><br><span class="line">                <span class="comment">/*!!fall through*/</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                request.requestTask.priority = <span class="built_in">NSURLSessionTaskPriorityDefault</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>requestPriority是YTKBaseRequest的一个枚举属性，它的枚举在YTKBaseRequest.h里面被定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, YTKRequestPriority) &#123;</span><br><span class="line">    YTKRequestPriorityLow = <span class="number">-4</span>L,</span><br><span class="line">    YTKRequestPriorityDefault = <span class="number">0</span>,</span><br><span class="line">    YTKRequestPriorityHigh = <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在这里，将用户设置的YTKRequestPriority映射到NSURLSessionTask的priority上。</p><p>到这里，我们拿到了task的实例并设置好了优先级，紧接着就是<code>addRequest:</code>方法里的第二个部分：<br>YTKNetworkAgent将request实例放在了一个字典中，保存起来：</p><p><strong>第二部分：把request放入专门用来保存请求的字典中，key为taskIdentifier：</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//将request实例放入保存请求的字典中，taskIdentifier为key，request为值</span></span><br><span class="line">  [<span class="keyword">self</span> addRequestToRecord:request];</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addRequestToRecord:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    Lock();</span><br><span class="line">    _requestsRecord[@(request.requestTask.taskIdentifier)] = request;</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#define Lock() pthread_mutex_lock(&amp;_lock)</span></span><br><span class="line"><span class="meta">#define Unlock() pthread_mutex_unlock(&amp;_lock)</span></span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到，在添加前和添加后是进行了加锁和解锁的处理的。而且request实例被保存的时候，将其task的identifier作为key来保存。</p></blockquote><p>在当前的request被保存以后，就到了最后一步，正式发起请求：</p><p><strong>第三部分：启动task</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="built_in">NSURLSessionTask</span> *)sessionTaskForRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">   </span><br><span class="line">   [request.requestTask resume];</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到现在为止，我们了解了YTKNetwork里面，一个请求开始之前做的事情：查找可用缓存，生成NSURLSessionTask实例，获取url，requestSerializer，将request放到YTKNetworkAgent的一个字典里等等（详细流程会在稍后给出）。</p><p>那么接下来我们看一下YTKNetwork是如何处理请求的回调的。</p><p>眼尖的同学们可能会注意到，在获取NSURLSessionTask实例的时候，出现了两次“响应的统一处理”的注释，大家可以搜索这个注释就可以找到这个方法：<code>handleRequestResult:responseObject:error:</code>。这个方法负责的是对请求回调的处理，当然包括了成功和失败的情况。我们来看一下在这个方法里都做了什么：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line"><span class="comment">//统一处理请求结果，包括成功和失败的情况</span></span><br><span class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 获取task对应的request</span></span><br><span class="line">    Lock();</span><br><span class="line">    YTKBaseRequest *request = _requestsRecord[@(task.taskIdentifier)];</span><br><span class="line">    Unlock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不存在对应的request，则立即返回</span></span><br><span class="line">    <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    。。。</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 获取request对应的response</span></span><br><span class="line">    request.responseObject = responseObject;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 获取responseObject，responseData和responseString</span></span><br><span class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//3.1 获取 responseData</span></span><br><span class="line">        request.responseData = responseObject;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.2 获取responseString</span></span><br><span class="line">        request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:responseObject encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line"></span><br><span class="line">         <span class="comment">//3.3 获取responseObject（或responseJSONObject）</span></span><br><span class="line">        <span class="comment">//根据返回的响应的序列化的类型来得到对应类型的响应</span></span><br><span class="line">        <span class="keyword">switch</span> (request.responseSerializerType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeHTTP:</span><br><span class="line">                <span class="comment">// Default serializer. Do nothing.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeJSON:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.jsonResponseSerializer responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                request.responseJSONObject = request.responseObject;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> YTKResponseSerializerTypeXMLParser:</span><br><span class="line">                request.responseObject = [<span class="keyword">self</span>.xmlParserResponseSerialzier responseObjectForResponse:task.response data:request.responseData error:&amp;serializationError];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4. 判断是否有错误，将错误对象赋值给requestError，改变succeed的布尔值。目的是根据succeed的值来判断到底是进行成功的回调还是失败的回调</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="comment">//如果该方法传入的error不为nil</span></span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = error;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="comment">//如果序列化失败了</span></span><br><span class="line">        succeed = <span class="literal">NO</span>;</span><br><span class="line">        requestError = serializationError;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//即使没有error而且序列化通过，也要验证request是否有效</span></span><br><span class="line">        succeed = [<span class="keyword">self</span> validateResult:request error:&amp;validationError];</span><br><span class="line">        requestError = validationError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></span><br><span class="line">    <span class="keyword">if</span> (succeed) &#123;</span><br><span class="line">        <span class="comment">//请求成功的处理</span></span><br><span class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//请求失败的处理</span></span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//6. 回调完成的处理</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">//6.1 在字典里移除当前request</span></span><br><span class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">         <span class="comment">//6.2 清除所有block</span></span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单讲解一下上面的代码：</p><ul><li>首先通过task的identifier值从YTKNetworkAgent保存的字典里获取对应的请求。</li><li>然后将获得的responseObject进行处理，将处理后获得的responseObject，responseData和responseString赋值给当前的请求实例request。</li><li>再根据这些值的获取情况来判断最终回调的成败（改变succeed的值）。</li><li>最后根据succeed的值来进行成功和失败的回调。</li></ul><p>这里先重点介绍一下是如何判断json的有效性的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line"><span class="comment">//判断code是否符合范围和json的有效性</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateResult:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 判断code是否在200~299之间</span></span><br><span class="line">    <span class="built_in">BOOL</span> result = [request statusCodeValidator];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidStatusCode userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid status code"</span>&#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. result 存在的情况判断json是否有效</span></span><br><span class="line">    <span class="keyword">id</span> json = [request responseJSONObject];</span><br><span class="line">    <span class="keyword">id</span> validator = [request jsonValidator];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (json &amp;&amp; validator) &#123;</span><br><span class="line">        <span class="comment">//通过json和validator来判断json是否有效</span></span><br><span class="line">        result = [YTKNetworkUtils validateJSON:json withValidator:validator];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果json无效</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                *error = [<span class="built_in">NSError</span> errorWithDomain:YTKRequestValidationErrorDomain code:YTKRequestValidationErrorInvalidJSONFormat userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:<span class="string">@"Invalid JSON format"</span>&#125;];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里，首先，用<code>statusCodeValidator</code>方法判断响应的code是否在正确的范围:<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseReqiest.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)statusCodeValidator &#123;</span><br><span class="line">    <span class="built_in">NSInteger</span> statusCode = [<span class="keyword">self</span> responseStatusCode];</span><br><span class="line">    <span class="keyword">return</span> (statusCode &gt;= <span class="number">200</span> &amp;&amp; statusCode &lt;= <span class="number">299</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">NSInteger</span>)responseStatusCode &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.response.statusCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后再判断json的有效性：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkUtils.m</span></span><br><span class="line"><span class="comment">//判断json的有效性</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)validateJSON:(<span class="keyword">id</span>)json withValidator:(<span class="keyword">id</span>)jsonValidator &#123;</span><br><span class="line">    <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]] &amp;&amp;</span><br><span class="line">        [jsonValidator isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> * dict = json;</span><br><span class="line">        <span class="built_in">NSDictionary</span> * validator = jsonValidator;</span><br><span class="line">        <span class="built_in">BOOL</span> result = <span class="literal">YES</span>;</span><br><span class="line">        <span class="built_in">NSEnumerator</span> * enumerator = [validator keyEnumerator];</span><br><span class="line">        <span class="built_in">NSString</span> * key;</span><br><span class="line">        <span class="keyword">while</span> ((key = [enumerator nextObject]) != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = dict[key];</span><br><span class="line">            <span class="keyword">id</span> format = validator[key];</span><br><span class="line">            <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]</span><br><span class="line">                || [value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                result = [<span class="keyword">self</span> validateJSON:value withValidator:format];</span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ([value isKindOfClass:format] == <span class="literal">NO</span> &amp;&amp;</span><br><span class="line">                    [value isKindOfClass:[<span class="built_in">NSNull</span> <span class="keyword">class</span>]] == <span class="literal">NO</span>) &#123;</span><br><span class="line">                    result = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] &amp;&amp;</span><br><span class="line">               [jsonValidator isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> * validatorArray = (<span class="built_in">NSArray</span> *)jsonValidator;</span><br><span class="line">        <span class="keyword">if</span> (validatorArray.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">NSArray</span> * array = json;</span><br><span class="line">            <span class="built_in">NSDictionary</span> * validator = jsonValidator[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> item <span class="keyword">in</span> array) &#123;</span><br><span class="line">                <span class="built_in">BOOL</span> result = [<span class="keyword">self</span> validateJSON:item withValidator:validator];</span><br><span class="line">                <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([json isKindOfClass:jsonValidator]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，YTKNetworkUtils这个类是在YTKNetworkPirvate里面定义的，YTKNetworkPirvate里面有一些工具类的方法，在后面还会遇到。</p><p>在验证返回的JSON数据是否有效以后，就可以进行回调了：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//5. 根据succeed的布尔值来调用相应的处理</span></span><br><span class="line">    <span class="keyword">if</span> (succeed) &#123;</span><br><span class="line">        <span class="comment">//请求成功的处理</span></span><br><span class="line">        [<span class="keyword">self</span> requestDidSucceedWithRequest:request];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//请求失败的处理</span></span><br><span class="line">        [<span class="keyword">self</span> requestDidFailWithRequest:request error:requestError];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 回调完成的处理</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="comment">//6.1 在字典里移除当前request</span></span><br><span class="line">        [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">         <span class="comment">//6.2 清除所有block</span></span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先来分别看一下请求成功的处理和失败的处理：</p><p>请求成功的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line"><span class="comment">//请求成功：主要负责将结果写入缓存&amp;回调成功的代理和block</span></span><br><span class="line">- (<span class="keyword">void</span>)requestDidSucceedWithRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//写入缓存 </span></span><br><span class="line">        [request requestCompletePreprocessor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></span><br><span class="line">        [request toggleAccessoriesWillStopCallBack];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在真正的回调之前做的处理,用户自定义</span></span><br><span class="line">        [request requestCompleteFilter];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有代理，则调用成功的代理</span></span><br><span class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [request.delegate requestFinished:request];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果传入了成功回调的代码，则调用</span></span><br><span class="line">        <span class="keyword">if</span> (request.successCompletionBlock) &#123;</span><br><span class="line">            request.successCompletionBlock(request);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//告诉Accessories请求已经结束了</span></span><br><span class="line">        [request toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我么可以看到，在请求成功以后，第一个做的是写入缓存，我们来看一下<code>requestCompletePreprocessor</code>方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)requestCompletePreprocessor &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> requestCompletePreprocessor];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否异步将responseData写入缓存（写入缓存的任务放在专门的队列进行）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.writeCacheAsynchronously) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">dispatch_async</span>(ytkrequest_cache_writing_queue(), ^&#123;</span><br><span class="line">            <span class="comment">//写入缓存文件</span></span><br><span class="line">            [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//写入缓存文件</span></span><br><span class="line">        [<span class="keyword">self</span> saveResponseDataToCacheFile:[<span class="keyword">super</span> responseData]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写入缓存文件</span></span><br><span class="line">- (<span class="keyword">void</span>)saveResponseDataToCacheFile:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> cacheTimeInSeconds] &gt; <span class="number">0</span> &amp;&amp; ![<span class="keyword">self</span> isDataFromCache]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (data != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                <span class="comment">// 1. 保存request的responseData到cacheFilePath</span></span><br><span class="line">                [data writeToFile:[<span class="keyword">self</span> cacheFilePath] atomically:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 2. 保存request的metadata到cacheMetadataFilePath</span></span><br><span class="line">                YTKCacheMetadata *metadata = [[YTKCacheMetadata alloc] init];</span><br><span class="line">                metadata.version = [<span class="keyword">self</span> cacheVersion];</span><br><span class="line">                metadata.sensitiveDataString = ((<span class="built_in">NSObject</span> *)[<span class="keyword">self</span> cacheSensitiveData]).description;</span><br><span class="line">                metadata.stringEncoding = [YTKNetworkUtils stringEncodingWithRequest:<span class="keyword">self</span>];</span><br><span class="line">                metadata.creationDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">                metadata.appVersionString = [YTKNetworkUtils appVersionString];</span><br><span class="line">                [<span class="built_in">NSKeyedArchiver</span> archiveRootObject:metadata toFile:[<span class="keyword">self</span> cacheMetadataFilePath]];</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                YTKLog(<span class="string">@"Save cache failed, reason = %@"</span>, exception.reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先看一下写入缓存操作的执行条件：当<code>cacheTimeInSeconds</code>方法返回大于0并且<code>isDataFromCache</code>为NO的时候会进行写入缓存。</p><p><code>cacheTimeInSeconds</code>方法返回的是缓存保存的时间，它最初定义在YTKBaseRquest里面，默认返回是-1：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseRequest.m</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)cacheTimeInSeconds &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以说YTKNetwork默认是不进行缓存的，如果用户需要做缓存，则需要在自定义的request类里面返回一个大于0的整数，这个整数的单位是秒。</p><p><code>isDataFromCache</code>属性在上面讲解发送请求部分里的查询缓存的步骤里有介绍。在这里再强调一下：<code>isDataFromCache</code>的默认值是NO。在请求发起之前，-<br>查询缓存的时候：</p><ul><li>如果发现缓存不可用（或忽略缓存），则立即发送请求，这个时候，isDataFromCache的值不做更改，仍然是NO。</li><li>如果发现缓存可用（在不忽略缓存的情况下），就要将isDataFromCache属性设置为YES，说明将不需要发送请求，直接在里获取数据了。</li></ul><p>即是说，如果发送了请求，则<code>isDataFromCache</code>一定是NO的，那么在上面这个判断里面，(!isDataFromCache)就一定为YES了。</p><p>因此，如果用户设置了缓存保存的时间，在请求返回成功后，就会写入缓存。</p><p>我们接着往下看，对于缓存，YTKNetwork保存的是两种缓存：<br>第一种是纯粹的NSData类型的实例。第二种是描述当前NSData实例的元数据YTKCacheMetadata的实例，从它的属性来看，分为这几种：</p><ol><li>缓存的版本，默认返回为0，用户可以自定义。</li><li>敏感数据，类型为id，默认返回nil，用户可以自定义。</li><li>NSString的编码格式，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li><li>元数据的创建时间。</li><li>app的版本号，在YTKNetworkPrivate内的YTKNetworkUtils实现。</li></ol><p>在将元数据的实例的这些属性都被赋值以后，将元数据实例序列化写入磁盘中。保存的路径通过<code>cacheMetadataFilePath</code>方法获取。</p><p>现在知道了YTKRequest的缓存内容，我们来看一下这两种缓存的位置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKRequest.m</span></span><br><span class="line"><span class="comment">//纯NSData数据缓存的文件名</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheFileName &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *requestUrl = [<span class="keyword">self</span> requestUrl];</span><br><span class="line">    <span class="built_in">NSString</span> *baseUrl = [YTKNetworkConfig sharedConfig].baseUrl;</span><br><span class="line">    <span class="keyword">id</span> argument = [<span class="keyword">self</span> cacheFileNameFilterForRequestArgument:[<span class="keyword">self</span> requestArgument]];</span><br><span class="line">    <span class="built_in">NSString</span> *requestInfo = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Method:%ld Host:%@ Url:%@ Argument:%@"</span>,</span><br><span class="line">                             (<span class="keyword">long</span>)[<span class="keyword">self</span> requestMethod], baseUrl, requestUrl, argument];</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFileName = [YTKNetworkUtils md5StringFromString:requestInfo];</span><br><span class="line">    <span class="keyword">return</span> cacheFileName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//纯NSData数据的缓存位置</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheFilePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheFileName = [<span class="keyword">self</span> cacheFileName];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheFileName];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//元数据的缓存位置</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheMetadataFilePath &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *cacheMetadataFileName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@.metadata"</span>, [<span class="keyword">self</span> cacheFileName]];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> cacheBasePath];</span><br><span class="line">    path = [path stringByAppendingPathComponent:cacheMetadataFileName];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建用户保存所有YTKNetwork缓存的文件夹</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)cacheBasePath &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取全路径</span></span><br><span class="line">    <span class="built_in">NSString</span> *pathOfLibrary = [<span class="built_in">NSSearchPathForDirectoriesInDomains</span>(<span class="built_in">NSLibraryDirectory</span>, <span class="built_in">NSUserDomainMask</span>, <span class="literal">YES</span>) objectAtIndex:<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *path = [pathOfLibrary stringByAppendingPathComponent:<span class="string">@"LazyRequestCache"</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// YTKCacheDirPathFilterProtocol定义了用户可以自定义存储位置的代理方法</span></span><br><span class="line">    <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt;&gt; *filters = [[YTKNetworkConfig sharedConfig] cacheDirPathFilters];</span><br><span class="line">    <span class="keyword">if</span> (filters.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span>&lt;YTKCacheDirPathFilterProtocol&gt; f <span class="keyword">in</span> filters) &#123;</span><br><span class="line">            path = [f filterCacheDirPath:path withRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建文件夹</span></span><br><span class="line">    [<span class="keyword">self</span> createDirectoryIfNeeded:path];</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，纯NSData数据缓存的文件名包含了请求方法（GET,POST..），baseURL，requestURL，请求参数拼接的字符串再进行md5加密而成。</p><p>而元数据的的文件名则在纯NSData数据缓存的文件名后面加上了.metadata后缀。</p><p>为了更形象地看到这两种缓存，我将缓存的保存时间设置为200秒之后再请求一次，然后打开文件夹找到了它们：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-6c5f41fbe2993059.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存和缓存元数据的文件"></p><p>而且我们也确认了保存所有YTKNetwork缓存的文件夹的名字为LazyRequestCache。</p><p>OK，现在我们知道了在请求成功回调后的缓存写入，接下来看一下是如何回调的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)handleRequestResult:(<span class="built_in">NSURLSessionTask</span> *)task responseObject:(<span class="keyword">id</span>)responseObject error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    YTKRequest *strongSelf = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6. 执行回调</span></span><br><span class="line">    <span class="comment">//6.1 请求完成的代理</span></span><br><span class="line">    [strongSelf.delegate requestFinished:strongSelf];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.2 请求成功的block</span></span><br><span class="line">    <span class="keyword">if</span> (strongSelf.successCompletionBlock) &#123;</span><br><span class="line">        strongSelf.successCompletionBlock(strongSelf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7. 把成功和失败的block都设置为nil，避免循环引用</span></span><br><span class="line">    [strongSelf clearCompletionBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到,代理的回调是先于block的回调的。而且在block回调结束以后，会立即调用<code>clearCompletionBlock</code>方法将block清空。该方法的实现是在YTKBaseRequest里：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)clearCompletionBlock &#123;</span><br><span class="line">    <span class="comment">// 清空请求结束的block，避免循环引用</span></span><br><span class="line">    <span class="keyword">self</span>.successCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.failureCompletionBlock = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们知道了请求成功的处理，那么再来看一下请求失败时的处理：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line"><span class="comment">//请求失败</span></span><br><span class="line">- (<span class="keyword">void</span>)requestDidFailWithRequest:(YTKBaseRequest *)request error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">    </span><br><span class="line">    request.error = error;</span><br><span class="line">    YTKLog(<span class="string">@"Request %@ failed, status code = %ld, error = %@"</span>,</span><br><span class="line">           <span class="built_in">NSStringFromClass</span>([request <span class="keyword">class</span>]), (<span class="keyword">long</span>)request.responseStatusCode, error.localizedDescription);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 储存未完成的下载数据</span></span><br><span class="line">    <span class="built_in">NSData</span> *incompleteDownloadData = error.userInfo[<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</span><br><span class="line">    <span class="keyword">if</span> (incompleteDownloadData) &#123;</span><br><span class="line">        [incompleteDownloadData writeToURL:[<span class="keyword">self</span> incompleteDownloadTempPathForDownloadPath:request.resumableDownloadPath] atomically:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load response from file and clean up if download task failed.</span></span><br><span class="line">    <span class="comment">//如果下载任务失败，则取出对应的响应文件并清空</span></span><br><span class="line">    <span class="keyword">if</span> ([request.responseObject isKindOfClass:[<span class="built_in">NSURL</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = request.responseObject;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//isFileURL：是否是文件，如果是，则可以再isFileURL获取；&amp;&amp;后面是再次确认是否存在改url对应的文件</span></span><br><span class="line">        <span class="keyword">if</span> (url.isFileURL &amp;&amp; [[<span class="built_in">NSFileManager</span> defaultManager] fileExistsAtPath:url.path]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将url的data和string赋给request</span></span><br><span class="line">            request.responseData = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">            request.responseString = [[<span class="built_in">NSString</span> alloc] initWithData:request.responseData encoding:[YTKNetworkUtils stringEncodingWithRequest:request]];</span><br><span class="line"></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtURL:url error:<span class="literal">nil</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清空request</span></span><br><span class="line">        request.responseObject = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">//请求失败的预处理，YTK没有定义，需要用户定义</span></span><br><span class="line">        [request requestFailedPreprocessor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//告诉Accessories请求就要停止了</span></span><br><span class="line">        [request toggleAccessoriesWillStopCallBack];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在真正的回调之前做的处理</span></span><br><span class="line">        [request requestFailedFilter];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果有代理，就调用代理</span></span><br><span class="line">        <span class="keyword">if</span> (request.delegate != <span class="literal">nil</span>) &#123;</span><br><span class="line">            [request.delegate requestFailed:request];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果传入了失败回调的block代码，就调用block</span></span><br><span class="line">        <span class="keyword">if</span> (request.failureCompletionBlock) &#123;</span><br><span class="line">            request.failureCompletionBlock(request);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//告诉Accessories请求已经停止了</span></span><br><span class="line">        [request toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法里，首先判断了当前任务是否为下载任务，如果是，则储存当前已经下载好的data到<code>resumableDownloadPath</code>里面。而如果下载任务失败，则将其对应的在本地保存的路径上的文件清空。</p><p>到这里，我已经把单个请求从配置，发送，响应，回调的步骤都讲解完了。为了帮助大家理解整个过程，这里提供了整个的流程图：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-eab27afc98b324bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="YTKNetwork流程图"></p><p>我们说YTKNetworkAgent是请求的发送者，既然有发送，也就会有取消等操作，这就不得不提它的另外两个接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.h</span></span><br><span class="line"><span class="comment">///  取消某个request</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  取消所有添加的request</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllRequests;</span><br></pre></td></tr></table></figure></p><p>首先我们看下取消某个request这个方法的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line"><span class="comment">///  取消某个request</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelRequest:(YTKBaseRequest *)request &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request != <span class="literal">nil</span>);</span><br><span class="line">    <span class="comment">//获取request的task，并取消</span></span><br><span class="line">    [request.requestTask cancel];</span><br><span class="line">    <span class="comment">//从字典里移除当前request</span></span><br><span class="line">    [<span class="keyword">self</span> removeRequestFromRecord:request];</span><br><span class="line">    <span class="comment">//清理所有block</span></span><br><span class="line">    [request clearCompletionBlock];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从字典里移除某request</span></span><br><span class="line">- (<span class="keyword">void</span>)removeRequestFromRecord:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    Lock();</span><br><span class="line">    [_requestsRecord removeObjectForKey:@(request.requestTask.taskIdentifier)];</span><br><span class="line">    YTKLog(<span class="string">@"Request queue size = %zd"</span>, [_requestsRecord count]);</span><br><span class="line">    Unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取消所有在字典里添加的request：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKNetworkAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllRequests &#123;</span><br><span class="line">    Lock();</span><br><span class="line">    <span class="built_in">NSArray</span> *allKeys = [_requestsRecord allKeys];</span><br><span class="line">    Unlock();</span><br><span class="line">    <span class="keyword">if</span> (allKeys &amp;&amp; allKeys.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *copiedKeys = [allKeys <span class="keyword">copy</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSNumber</span> *key <span class="keyword">in</span> copiedKeys) &#123;</span><br><span class="line">            Lock();</span><br><span class="line">            YTKBaseRequest *request = _requestsRecord[key];</span><br><span class="line">            Unlock();</span><br><span class="line">            <span class="comment">//stop每个请求</span></span><br><span class="line">            [request stop];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个stop方法是在YTKBaseRequest里面定义的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBaseRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//告诉Accessories将要回调了</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空代理</span></span><br><span class="line">    <span class="keyword">self</span>.delegate = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用agent的取消某个request的方法</span></span><br><span class="line">    [[YTKNetworkAgent sharedAgent] cancelRequest:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//告诉Accessories回调完成了</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>OK，看到这里，相信你对YTKNetwork单个请求的流程有了比较好的了解了，下面我们来看一下YTKNetwork的高级功能：批量请求和链式请求。</p><h2 id="3-3-批量请求和链式请求"><a href="#3-3-批量请求和链式请求" class="headerlink" title="3.3 批量请求和链式请求"></a>3.3 批量请求和链式请求</h2><p>YTKNetwork支持的批量请求有两种：</p><ol><li>批量请求：多个请求几乎同时发起。</li><li>链式请求：当前个请求结束后才能发起下一个请求。</li></ol><p>其实无论是批量请求，还是链式请求，我们都可以想到很可能是用一个数组将这些请求管理了起来。那么具体是如何实现的呢？</p><p>我们首先来看一下YTKNetwork是如何实现批量请求的。</p><h3 id="3-31批量请求"><a href="#3-31批量请求" class="headerlink" title="3.31批量请求"></a>3.31批量请求</h3><p>YTKNetwork 使用YTKBatchRequest类来发送无序的批量请求，它需要用一个含有YTKRequest子类的数组来初始化，并将这个数组保存起来赋给它的<code>_requestArray</code>实例变量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBatchRequest.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRequestArray:(<span class="built_in">NSArray</span>&lt;YTKRequest *&gt; *)requestArray &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//保存为属性</span></span><br><span class="line">        _requestArray = [requestArray <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//批量请求完成的数量初始化为0</span></span><br><span class="line">        _finishedCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//类型检查，所有元素都必须为YTKRequest或的它的子类，否则强制初始化失败</span></span><br><span class="line">        <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</span><br><span class="line">            <span class="keyword">if</span> (![req isKindOfClass:[YTKRequest <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                YTKLog(<span class="string">@"Error, request item must be YTKRequest instance."</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化以后，我们就可以调用<code>start</code>方法来发起当前YTKBatchRequest实例所管理的所有请求了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBatchRequest.m</span></span><br><span class="line"><span class="comment">//batch请求开始</span></span><br><span class="line">- (<span class="keyword">void</span>)startWithCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</span><br><span class="line">                                    failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</span><br><span class="line">    [<span class="keyword">self</span> setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    [<span class="keyword">self</span> start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置成功和失败的block</span></span><br><span class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))success</span><br><span class="line">                              failure:(<span class="keyword">void</span> (^)(YTKBatchRequest *batchRequest))failure &#123;</span><br><span class="line">    <span class="keyword">self</span>.successCompletionBlock = success;</span><br><span class="line">    <span class="keyword">self</span>.failureCompletionBlock = failure;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果batch里第一个请求已经成功结束，则不能再start</span></span><br><span class="line">    <span class="keyword">if</span> (_finishedCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        YTKLog(<span class="string">@"Error! Batch request has already started."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最开始设定失败的request为nil</span></span><br><span class="line">    _failedRequest = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用YTKBatchRequestAgent来管理当前的批量请求</span></span><br><span class="line">    [[YTKBatchRequestAgent sharedAgent] addBatchRequest:<span class="keyword">self</span>];</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历所有request，并开始请求</span></span><br><span class="line">    <span class="keyword">for</span> (YTKRequest * req <span class="keyword">in</span> _requestArray) &#123;</span><br><span class="line">        req.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [req clearCompletionBlock];</span><br><span class="line">        [req start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们可以看出：<br>1.在至少完成了其中一个请求以后，调用当前YTKBatchRequest实例的<code>start</code>方法会立即返回，否则可以无限制start。<br>2.YTKBatchRequest的实例是需要在发起请求之前，要被添加在YTKBatchRequestAgent里的数组里：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBatchRequestAgent.m</span></span><br><span class="line">- (<span class="keyword">void</span>)addBatchRequest:(YTKBatchRequest *)request &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        [_requestArray addObject:request];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.因为是批量发送请求，所以在这里是遍历YTKBatchRequest实例的<code>_requestArray</code>并逐一发送请求。因为已经封装好了单个的请求，所以在这里直接start就好了。</p><p>发起请求以后，在每个请求回调的代理方法里，来判断这次批量请求是否成功。</p><p>YTKRequest子类成功的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBatchRequest.m</span></span><br><span class="line"><span class="meta">#pragma mark - Network Request Delegate</span></span><br><span class="line">- (<span class="keyword">void</span>)requestFinished:(YTKRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//某个request成功后，首先让_finishedCount + 1</span></span><br><span class="line">    _finishedCount++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果_finishedCount等于_requestArray的个数，则判定当前batch请求成功</span></span><br><span class="line">    <span class="keyword">if</span> (_finishedCount == _requestArray.count) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用即将结束的代理</span></span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用请求成功的代理</span></span><br><span class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFinished:)]) &#123;</span><br><span class="line">            [_delegate batchRequestFinished:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用批量请求成功的block</span></span><br><span class="line">        <span class="keyword">if</span> (_successCompletionBlock) &#123;</span><br><span class="line">            _successCompletionBlock(<span class="keyword">self</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//清空成功和失败的block</span></span><br><span class="line">        [<span class="keyword">self</span> clearCompletionBlock];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//调用请求结束的代理</span></span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></span><br><span class="line">        [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，在某个请求的回调成功以后，会让成功计数+1。在+1以后，如果成功计数和当前批量请求数组里元素的个数相等，则判定当前批量请求成功，并进行当前批量请求的成功回调。</p><p>接下来我们看一下某个请求失败的处理：</p><p>YTKReques子类失败的回调：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKBatchRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)requestFailed:(YTKRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    _failedRequest = request;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用即将结束的代理</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//停止batch里所有的请求</span></span><br><span class="line">    <span class="keyword">for</span> (YTKRequest *req <span class="keyword">in</span> _requestArray) &#123;</span><br><span class="line">        [req stop];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用请求失败的代理</span></span><br><span class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(batchRequestFailed:)]) &#123;</span><br><span class="line">        [_delegate batchRequestFailed:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用请求失败的block</span></span><br><span class="line">    <span class="keyword">if</span> (_failureCompletionBlock) &#123;</span><br><span class="line">        _failureCompletionBlock(<span class="keyword">self</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空成功和失败的block</span></span><br><span class="line">    [<span class="keyword">self</span> clearCompletionBlock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用请求结束的代理</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从YTKBatchRequestAgent里移除当前的batch</span></span><br><span class="line">    [[YTKBatchRequestAgent sharedAgent] removeBatchRequest:<span class="keyword">self</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里不难看出，当前批量请求里面只要有一个request失败了，则判定当前批量请求失败。<br>而当前批量请求失败的回调（代理和block）会传入这个失败的request的实例。而且这个失败的request会先被赋给_failedRequest这个实例变量里。</p><p>总的来说，YTKBatchRequest类用一个数组来保存当前批量请求所要处理的所有request实例。而且用一个成功计数来判定当前批量请求整体是否成功。而当前批量请求的失败则是由这些request实例里面第一个失败的实例导致的：只要有一个request回调失败了，则立即停止其他的所有请求并调用当前批量请求的失败回调。</p><p>现在讲完了批量请求的处理，我们接下来看一下链式请求的处理。</p><h3 id="3-32链式请求"><a href="#3-32链式请求" class="headerlink" title="3.32链式请求"></a>3.32链式请求</h3><p>和批量请求类似，处理链式请求的类是YTKChainRequest，并且用YTKChainRequestAgent单例来管理YTKChainRequest的实例。</p><p>但是和批量请求不同的是，YTKChainRequest实例的初始化是不需要传入一个含有request的数组的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKChainRequest.m</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//下一个请求的index</span></span><br><span class="line">        _nextRequestIndex = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//保存链式请求的数组</span></span><br><span class="line">        _requestArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//保存回调的数组</span></span><br><span class="line">        _requestCallbackArray = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//空回调，用来填充用户没有定义的回调block</span></span><br><span class="line">        _emptyCallback = ^(YTKChainRequest *chainRequest, YTKBaseRequest *baseRequest) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是它提供了添加和删除request的接口：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKChainRequest.m</span></span><br><span class="line"><span class="comment">//在当前chain添加request和callback</span></span><br><span class="line">- (<span class="keyword">void</span>)addRequest:(YTKBaseRequest *)request callback:(YTKChainCallback)callback &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//保存当前请求</span></span><br><span class="line">    [_requestArray addObject:request];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [_requestCallbackArray addObject:callback];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//之所以特意弄一个空的callback，是为了避免在用户没有给当前request的callback传值的情况下，造成request数组和callback数组的不对称</span></span><br><span class="line">        [_requestCallbackArray addObject:_emptyCallback];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，在给YTKChainRequest实例添加request实例的同时，还可以传入回调的block。当然也可以不传，但是为了保持request数组和callback数组的对称性（因为回调的时候是需要根据request数组里的index来获取callback数组里对应的callback的），YTKNetwork给我们提供了一个空的block。</p><p>我们接着看一下链式请求的发起：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKChainRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    <span class="comment">//如果第1个请求已经结束，就不再重复start了</span></span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        YTKLog(<span class="string">@"Error! Chain request has already started."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果请求队列数组里面还有request，则取出并start</span></span><br><span class="line">    <span class="keyword">if</span> ([_requestArray count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStartCallBack];</span><br><span class="line">        <span class="comment">//取出当前request并start</span></span><br><span class="line">        [<span class="keyword">self</span> startNextRequest];</span><br><span class="line">        <span class="comment">//在当前的_requestArray添加当前的chain（YTKChainRequestAgent允许有多个chain）</span></span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] addChainRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        YTKLog(<span class="string">@"Error! Chain request array is empty."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，YTKChainRequest用<code>_nextRequestIndex</code>来保存下一个请求的index，它的默认值是0。而它的值的累加是在当前请求结束后，发起下面的请求之前进行的。所以说，如果已经完成了请求队列里的第一个请求，就无法在启动当前的请求队列了，会立即返回。</p><p>这里<code>startNextRequest</code>方法比较重要：在判断请求队列数组里面还有request的话，就会调用这个方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKChainRequest.m</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)startNextRequest &#123;</span><br><span class="line">    <span class="keyword">if</span> (_nextRequestIndex &lt; [_requestArray count]) &#123;</span><br><span class="line">        YTKBaseRequest *request = _requestArray[_nextRequestIndex];</span><br><span class="line">        _nextRequestIndex++;</span><br><span class="line">        request.delegate = <span class="keyword">self</span>;</span><br><span class="line">        [request clearCompletionBlock];</span><br><span class="line">        [request start];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法有两个作用：</p><ol><li>第一个作用是判断是否能进行下一个request（如果index 大于或等于 request数组的count的话就不能在request数组里取出request，因为会造成数组越界）</li><li>第二个作用是如果可以进行下一个request，则发起该request。并将<code>_nextRequestIndex</code>+1。</li></ol><p>所以和批量请求不同的是，链式请求的请求队列是可以变动的，用户可以无限制地添加请求。只要请求队列里面有请求存在，则YTKChainRequest就会继续发送它们。</p><p>现在我们知道了YTKChainRequest的发送，接下来看一下回调部分:</p><p>和YTKBatchRequest相同的是，YTKChainRequest也实现了YTKRequest的代理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//某个request请求成功的代理的实现</span></span><br><span class="line"><span class="comment">//YTKChainRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)requestFinished:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 取出当前的request和callback，进行回调</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</span><br><span class="line">    YTKChainCallback callback = _requestCallbackArray[currentRequestIndex];</span><br><span class="line">    callback(<span class="keyword">self</span>, request);<span class="comment">//注意：这个回调只是当前request的回调，而不是当前chain全部完成的回调。当前chain的回调在下面</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 如果不能再继续请求了，说明当前成功的request已经是chain里最后一个request，也就是说当前chain里所有的回调都成功了，即这个chain请求成功了。</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> startNextRequest]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">        <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFinished:)]) &#123;</span><br><span class="line">            [_delegate chainRequestFinished:<span class="keyword">self</span>];</span><br><span class="line">            [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，在某个request回调成功以后，会根据当前请求的index（_nextRequestIndex-1）来获取其对应的block并调用。接着，再调用<code>startNextRequest</code>方法来判断当前的YTKChainRequest的请求队列里面是否还有其他的请求了：</p><ul><li>如果没有了，则调用当前YTKChainRequest的最终成功的回调。</li><li>如果还有，则发起接下来的request（按顺序）。</li></ul><p>接下来我们再看一下某个request失败的代理的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKChainRequest.m</span></span><br><span class="line"><span class="comment">//某个reqeust请求失败的代理</span></span><br><span class="line">- (<span class="keyword">void</span>)requestFailed:(YTKBaseRequest *)request &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果当前 chain里的某个request失败了，则判定当前chain失败。调用当前chain失败的回调</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line">    <span class="keyword">if</span> ([_delegate respondsToSelector:<span class="keyword">@selector</span>(chainRequestFailed:failedBaseRequest:)]) &#123;</span><br><span class="line">        [_delegate chainRequestFailed:<span class="keyword">self</span> failedBaseRequest:request];</span><br><span class="line">        [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前的request请求失败了，则判定当前链式请求是失败的，则立即调用当前链式请求的失败回调。</p><p>现在我们知道了链式请求的请求和回调，再来看一下链式请求的终止：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKChainRequest.m</span></span><br><span class="line"><span class="comment">//终止当前的chain</span></span><br><span class="line">- (<span class="keyword">void</span>)stop &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先调用即将停止的callback</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesWillStopCallBack];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//然后stop当前的请求，再清空chain里所有的请求和回掉block</span></span><br><span class="line">    [<span class="keyword">self</span> clearRequest];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在YTKChainRequestAgent里移除当前的chain</span></span><br><span class="line">    [[YTKChainRequestAgent sharedAgent] removeChainRequest:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后调用已经结束的callback</span></span><br><span class="line">    [<span class="keyword">self</span> toggleAccessoriesDidStopCallBack];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>stop</code>方法是可以在外部调用的，所以用户可以随时终止当前链式请求的进行。它首先调用<code>clearReuqest</code>方法，将当前request停止，再将请求队列数组和callback数组清空。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YTKChainRequest.m</span></span><br><span class="line">- (<span class="keyword">void</span>)clearRequest &#123;</span><br><span class="line">    <span class="comment">//获取当前请求的index</span></span><br><span class="line">    <span class="built_in">NSUInteger</span> currentRequestIndex = _nextRequestIndex - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (currentRequestIndex &lt; [_requestArray count]) &#123;</span><br><span class="line">        YTKBaseRequest *request = _requestArray[currentRequestIndex];</span><br><span class="line">        [request stop];</span><br><span class="line">    &#125;</span><br><span class="line">    [_requestArray removeAllObjects];</span><br><span class="line">    [_requestCallbackArray removeAllObjects];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在YTKChainRequestAgent单例里面，将自己移除掉。</p><h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4. 最后的话"></a>4. 最后的话</h1><hr><p>不知不觉写了好多，请原谅我一如既往啰嗦的风格~</p><p>阅读这个框架的源码我的收获是：加深了对命令模式，对Block的理解，知道了一个网络请求都需要什么元素组成，知道了网络缓存该怎么设计，也知道了链式请求怎么设计等等。</p><p>我还记得当初听说YTKNetwork能发起链式请求的时候觉得毫无思路的感觉，不过现在应该没什么问题了。</p><p>所以说多阅读源码对技术水平的提升是很有帮助的，除了能增多对本语言API的了解，其实更有意义的是它能让你接触到一些新的设计和解决问题的办法，这些都是脱离某个语言本身的东西，也是作为一名程序员所必不可少的东西。</p><p>希望这篇文章能对读者们有所帮助~</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于iOS开发来说，就算是没有用过&lt;a href=&quot;https://github.com/yuantiku/YTKNetwork&quot;&gt;YTKNetwork框架&lt;/a&gt;，应该也见过，听过了。它是猿题库技术团队开源的一个网络请求框架，内部封装了AFNetworking。它把每个请求实例化，管理它的生命周期，也可以管理多个请求。&lt;br&gt;​&lt;br&gt;在正式讲解源码之前，我会先讲一下该框架所用的架构和设计模式。我总觉得对架构和设计有一定的了解的话，会有助于对源码的理解。&lt;/p&gt;
&lt;h1 id=&quot;1-架构&quot;&gt;&lt;a href=&quot;#1-架构&quot; class=&quot;headerlink&quot; title=&quot;1. 架构&quot;&gt;&lt;/a&gt;1. 架构&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;先上图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-054321f909402be5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;YTKRequest架构图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这里简单说明一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;YTKNetwork框架将每一个请求实例化，YTKBaseRequest是所有请求类的基类，YTKRequest是它的子类。所以如果我们想要发送一个请求，则需要创建并实例化一个继承于YTKRequest的自定义的请求类（CustomRequest）并发送请求。 &lt;/li&gt;
&lt;li&gt;YTKNetworkAgent是一个单例，负责管理所有的请求类（例如CustomRequest）。当CustomRequest发送请求以后，会把自己放在YTKNetworkAgent持有的一个字典里，让其管理自己。&lt;/li&gt;
&lt;li&gt;我们说YTKNetwork封装了AFNetworking，实际上是YTKNetworkAgent封装了AFNetworking，由它负责AFNetworking请求的发送和AFNetworking的回调处理。所以如果我们想更换一个第三方网络请求库，就可以在这里更换一下。而YTKRequest更多的是只是负责缓存的处理。&lt;/li&gt;
&lt;li&gt;YTKNetworkConfig与YTKPriviate的具体职能现在不做介绍，会在后文给出。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK，现在我们知道了YTKNetwork中类与类之间的关系以及关键类的大致职能，接下来我会告诉你YTKNetwork为什么会采用这种关系来架构，以及采用这种架构会有什么好处。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>VVeboTableView源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/VVeboTableView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/VVeboTableView源码解析/</id>
    <published>2018-02-02T16:17:55.000Z</published>
    <updated>2018-07-16T16:47:05.245Z</updated>
    
    <content type="html"><![CDATA[<p>这次分享一个关于性能优化的源码。</p><p>我们知道<code>UITabelView</code>在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，<code>UITabelView</code>的性能将直接影响这个app的性能。</p><p>如果<code>UITabelView</code>里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。</p><p>但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。</p><p>最近在看一些iOS性能优化的文章，我找到了<a href="https://github.com/johnil/VVeboTableViewDemo">VVeboTableView</a>这个框架。严格来说这个不属于框架，而是作者用自己的方式优化<code>UITableView</code>的一个实现。</p><p>作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？</p><p>看了源码之后，我把作者的思路整理了出来：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png" alt="优化思路图"></p><p>下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。</p><a id="more"></a><h2 id="1-减少CPU／GPU计算量"><a href="#1-减少CPU／GPU计算量" class="headerlink" title="1. 减少CPU／GPU计算量"></a>1. 减少CPU／GPU计算量</h2><h3 id="1-1-cell的重用机制"><a href="#1-1-cell的重用机制" class="headerlink" title="1.1 cell的重用机制"></a>1.1 cell的重用机制</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//cell重用</span></span><br><span class="line">    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cell==<span class="literal">nil</span>) &#123;</span><br><span class="line">        cell = [[VVeboTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:<span class="string">@"cell"</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制</span></span><br><span class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</span><br><span class="line">    <span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这部分就不赘述了，相信大家都可以掌握。</p><h3 id="1-2-将cell高度和-cell里的控件的frame缓存在model里"><a href="#1-2-将cell高度和-cell里的控件的frame缓存在model里" class="headerlink" title="1.2 将cell高度和 cell里的控件的frame缓存在model里"></a>1.2 将cell高度和 cell里的控件的frame缓存在model里</h3><p>这一步我们需要在字典转模型里统一计算(不需要看代码细节，只需要知道这里在模型里保存了需要保存的控件的frame和整个cell的高度即可)：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadData&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> temp) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSDictionary</span> *user = dict[<span class="string">@"user"</span>];</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSDictionary</span> *retweet = [dict valueForKey:<span class="string">@"retweeted_status"</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (retweet) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">            ...</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</span><br><span class="line">                <span class="built_in">CGSize</span> size = [subData[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_SUBCONTENT) lineSpace:<span class="number">5</span>];</span><br><span class="line">                <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</span><br><span class="line">                subData[<span class="string">@"textRect"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_BIG, width, sizeHeight)];</span><br><span class="line">                sizeHeight += SIZE_GAP_BIG;</span><br><span class="line">                <span class="keyword">if</span> (subData[<span class="string">@"pic_urls"</span>] &amp;&amp; [subData[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</span><br><span class="line">                &#125;</span><br><span class="line">                sizeHeight += SIZE_GAP_BIG;</span><br><span class="line">                subData[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            data[<span class="string">@"subData"</span>] = subData;</span><br><span class="line">           </span><br><span class="line">        </span><br><span class="line">            <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</span><br><span class="line">            <span class="built_in">CGSize</span> size = [data[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_CONTENT) lineSpace:<span class="number">5</span>];</span><br><span class="line">            <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</span><br><span class="line">            ...</span><br><span class="line">            sizeHeight += SIZE_GAP_TOP+SIZE_AVATAR+SIZE_GAP_BIG;</span><br><span class="line">            <span class="keyword">if</span> (data[<span class="string">@"pic_urls"</span>] &amp;&amp; [data[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [data valueForKey:<span class="string">@"subData"</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (subData) &#123;</span><br><span class="line">                sizeHeight += SIZE_GAP_BIG;</span><br><span class="line">                <span class="built_in">CGRect</span> frame = [subData[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</span><br><span class="line">                ...</span><br><span class="line">                sizeHeight += frame.size.height;</span><br><span class="line">                data[<span class="string">@"subData"</span>] = subData;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            sizeHeight += <span class="number">30</span>;</span><br><span class="line">            data[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</span><br><span class="line">        &#125;</span><br><span class="line">        [datas addObject:data];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取高度缓存</span></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *dict = datas[indexPath.row];</span><br><span class="line">    <span class="keyword">float</span> height = [dict[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>].size.height;</span><br><span class="line">    <span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以看到，作者根据帖子类型的不同：原贴(subData)的存在与否），来逐渐叠加cell的高度。</p><p>而缓存的控件的frame，我们在下面讲解绘制cell的代码里详细介绍。</p><h3 id="1-3-减少cell内部控件的层级"><a href="#1-3-减少cell内部控件的层级" class="headerlink" title="1.3 减少cell内部控件的层级"></a>1.3 减少cell内部控件的层级</h3><p>我们先来看一下一个带有原贴的转发贴的布局：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_3.png" alt="布局"></p><p>可能有小伙伴会将上中下这三个部分各自封装成一个view，再通过每个view来管理各自的子view。但是这个框架的作者却将它们都排列到一层上。</p><p>减少了子view的层级，有助于减少cpu对各种约束的计算。这在子view的数量，层级都很多的情况下对cpu的压力会减轻很多。</p><h3 id="1-4-通过覆盖圆角图片来实现头像的圆角效果"><a href="#1-4-通过覆盖圆角图片来实现头像的圆角效果" class="headerlink" title="1.4 通过覆盖圆角图片来实现头像的圆角效果"></a>1.4 通过覆盖圆角图片来实现头像的圆角效果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头像，frame固定</span></span><br><span class="line">avatarView = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];<span class="comment">//[[VVeboAvatarView alloc] initWithFrame:avatarRect];</span></span><br><span class="line">avatarView.frame = <span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_TOP, SIZE_AVATAR, SIZE_AVATAR);</span><br><span class="line">avatarView.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</span><br><span class="line">avatarView.hidden = <span class="literal">NO</span>;</span><br><span class="line">avatarView.tag = <span class="built_in">NSIntegerMax</span>;</span><br><span class="line">avatarView.clipsToBounds = <span class="literal">YES</span>;</span><br><span class="line">[<span class="keyword">self</span>.contentView addSubview:avatarView];</span><br><span class="line"><span class="comment">//覆盖在头像上面的图片，制造圆角效果：frame</span></span><br><span class="line">cornerImage = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, SIZE_AVATAR+<span class="number">5</span>, SIZE_AVATAR+<span class="number">5</span>)];</span><br><span class="line">cornerImage.center = avatarView.center;</span><br><span class="line">cornerImage.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"corner_circle@2x.png"</span>];</span><br><span class="line">cornerImage.tag = <span class="built_in">NSIntegerMax</span>;</span><br><span class="line">[<span class="keyword">self</span>.contentView addSubview:cornerImage];</span><br></pre></td></tr></table></figure><p>在这里，作者没有使用任何复杂的技术来实现图片的圆角（使用layer或者裁剪图片），只是将一张圆角颜色和cell背景色一致的图片覆盖在了原来的头像上，实现了圆角的效果（但是这个方法不太适用于有多个配色方案的app）。</p><h2 id="2-按需加载cell"><a href="#2-按需加载cell" class="headerlink" title="2. 按需加载cell"></a>2. 按需加载cell</h2><p>上文提到过，<code>UITableView</code>持有一个<code>needLoadArr</code>数组，它保存着需要刷新的cell的<code>NSIndexPath</code>。</p><p>我们先来看一下<code>needLoadArr</code>是如何使用的：</p><h3 id="2-1-在cellForRow-方法里只加载可见cell"><a href="#2-1-在cellForRow-方法里只加载可见cell" class="headerlink" title="2.1 在cellForRow:方法里只加载可见cell"></a>2.1 在cellForRow:方法里只加载可见cell</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    ...</span><br><span class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)drawCell:(VVeboTableViewCell *)cell withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *data = [datas objectAtIndex:indexPath.row];    </span><br><span class="line">    ...</span><br><span class="line">    cell.data = data;</span><br><span class="line">    <span class="comment">//当前的cell的indexPath不在needLoadArr里面，不用绘制</span></span><br><span class="line">    <span class="keyword">if</span> (needLoadArr.count&gt;<span class="number">0</span>&amp;&amp;[needLoadArr indexOfObject:indexPath]==<span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        [cell clear];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//将要滚动到顶部，不绘制</span></span><br><span class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//真正绘制cell的代码</span></span><br><span class="line">    [cell draw];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"><a href="#2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引" class="headerlink" title="2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"></a>2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引</h3><p>知道了如何使用<code>needLoadArr</code>，我们看一下<code>needLoadArr</code>里面的元素师如何添加和删除。</p><h4 id="添加元素NSIndexPath"><a href="#添加元素NSIndexPath" class="headerlink" title="添加元素NSIndexPath"></a>添加元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//targetContentOffset ： 停止后的contentOffset</span></span><br><span class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当前可见第一行row的index</span></span><br><span class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置最小跨度，当滑动的速度很快，超过这个跨度时候执行按需加载</span></span><br><span class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//快速滑动(跨度超过了8个cell)</span></span><br><span class="line">    <span class="keyword">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//某个区域里的单元格的indexPath</span></span><br><span class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</span><br><span class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (velocity.y&lt;<span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//向上滚动</span></span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//超过倒数第3个</span></span><br><span class="line">            <span class="keyword">if</span> (indexPath.row+<span class="number">3</span>&lt;datas.count) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//向下滚动</span></span><br><span class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp firstObject];</span><br><span class="line">            <span class="comment">//超过正数第3个</span></span><br><span class="line">            <span class="keyword">if</span> (indexPath.row&gt;<span class="number">3</span>) &#123;</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</span><br><span class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加arr里的内容到needLoadArr的末尾</span></span><br><span class="line">        [needLoadArr addObjectsFromArray:arr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>知道了如何向<code>needLoadArr</code>里添加元素，现在看一下何时（重置）清理这个array：</p><h4 id="移除元素NSIndexPath"><a href="#移除元素NSIndexPath" class="headerlink" title="移除元素NSIndexPath"></a>移除元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户触摸时第一时间加载内容</span></span><br><span class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!scrollToToping) &#123;</span><br><span class="line">        [needLoadArr removeAllObjects];</span><br><span class="line">        [<span class="keyword">self</span> loadContent];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</span><br><span class="line">    [needLoadArr removeAllObjects];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将要滚动到顶部</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)scrollViewShouldScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</span><br><span class="line">    scrollToToping = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//停止滚动</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</span><br><span class="line">    scrollToToping = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> loadContent];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//滚动到了顶部</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</span><br><span class="line">    scrollToToping = <span class="literal">NO</span>;</span><br><span class="line">    [<span class="keyword">self</span> loadContent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，当手指触碰到tableview时 和 开始拖动tableview的时候就要清理这个数组。</p><p>而且在手指触碰到tableview时和 tableview停止滚动后就会执行<code>loadContent</code>方法，用来加载可见区域的cell。</p><p><code>loadContent</code>方法的具体实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)loadContent&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//正在滚动到顶部</span></span><br><span class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//可见cell数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.indexPathsForVisibleRows.count&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//触摸的时候刷新可见cell</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.visibleCells&amp;&amp;<span class="keyword">self</span>.visibleCells.count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> temp <span class="keyword">in</span> [<span class="keyword">self</span>.visibleCells <span class="keyword">copy</span>]) &#123;</span><br><span class="line">            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;</span><br><span class="line">            [cell draw];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里注意一下，tableview的<code>visibleCells</code>属性是可见的cell的数组。</p><h2 id="3-异步处理cell"><a href="#3-异步处理cell" class="headerlink" title="3. 异步处理cell"></a>3. 异步处理cell</h2><p>在讲解cell是如何显示出来之前，我们大致看一下这个cell都有哪些控件：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_4.png" alt="控件名称"></p><p>了解到控件的名称，位置之后，我们看一下作者是如何布局这些控件的：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_2.png" alt="控件布局"><br>在上面可以大致看出来，除了需要异步网络加载的头像(avatarView)和帖子图片(multiPhotoScrollView)，作者都将这些控件画在了一张图上面（postBgView）。</p><p>而且我们可以看到，在postBgView上面需要异步显示的内容分为四种：</p><ol><li>UIImageView：本地图片（comments, more,reposts）。</li><li>UIView：背景，分割线(topLine)。</li><li>NSString：name，from字符串。</li><li>Label：原贴的detailLabel 和 当前贴的 label。</li></ol><p>下面结合代码来讲解这四种绘制：</p><p>首先看一下cell内部的核心绘制方法：</p><p>现在我们来看一下cell绘制的核心方法,draw方法:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将cell的主要内容绘制到图片上</span></span><br><span class="line">- (<span class="keyword">void</span>)draw&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//drawed = YES说明正在绘制，则立即返回。因为绘制是异步的，所以在开始绘制之后需要立即设为yes，防止重复绘制</span></span><br><span class="line">    <span class="keyword">if</span> (drawed) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//标记当前的绘制</span></span><br><span class="line">    <span class="built_in">NSInteger</span> flag = drawColorFlag;</span><br><span class="line">    </span><br><span class="line">    drawed = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取整个cell的frame，已经换存在模型里了</span></span><br><span class="line">        <span class="built_in">CGRect</span> rect = [_data[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开启图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">YES</span>, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取图形上下文</span></span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//背景颜色</span></span><br><span class="line">        [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//通过rect填充背景颜色</span></span><br><span class="line">        <span class="built_in">CGContextFillRect</span>(context, rect);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果有原帖（说明当前贴是转发贴）</span></span><br><span class="line">        <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</span><br><span class="line">            </span><br><span class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">243</span>/<span class="number">255.0</span> green:<span class="number">243</span>/<span class="number">255.0</span> blue:<span class="number">243</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</span><br><span class="line">            <span class="built_in">CGRect</span> subFrame = [_data[<span class="string">@"subData"</span>][<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</span><br><span class="line">            <span class="built_in">CGContextFillRect</span>(context, subFrame);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//原帖上面的分割线</span></span><br><span class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</span><br><span class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, subFrame.origin.y, rect.size.width, <span class="number">.5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</span><br><span class="line">            <span class="keyword">float</span> x = leftX;</span><br><span class="line">            <span class="keyword">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class="number">6</span>))/<span class="number">2</span><span class="number">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class="number">-5</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//绘制名字</span></span><br><span class="line">            [_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</span><br><span class="line">                             andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</span><br><span class="line">                                andHeight:rect.size.height];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//绘制名字下面的info</span></span><br><span class="line">            y += SIZE_FONT_NAME+<span class="number">5</span>;</span><br><span class="line">            <span class="keyword">float</span> fromX = leftX;</span><br><span class="line">            <span class="keyword">float</span> size = [<span class="built_in">UIScreen</span> screenWidth]-leftX;</span><br><span class="line">            <span class="built_in">NSString</span> *from = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@  %@"</span>, _data[<span class="string">@"time"</span>], _data[<span class="string">@"from"</span>]];</span><br><span class="line">            </span><br><span class="line">            [from drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE)</span><br><span class="line">                   andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</span><br><span class="line">                      andHeight:rect.size.height andWidth:size];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//评论角</span></span><br><span class="line">            <span class="built_in">CGRect</span> countRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30</span>, [<span class="built_in">UIScreen</span> screenWidth], <span class="number">30</span>);</span><br><span class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</span><br><span class="line">            <span class="built_in">CGContextFillRect</span>(context, countRect);</span><br><span class="line">            <span class="keyword">float</span> alpha = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">float</span> x = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT<span class="number">-10</span>;</span><br><span class="line">            <span class="built_in">NSString</span> *comments = _data[<span class="string">@"comments"</span>];</span><br><span class="line">            <span class="keyword">if</span> (comments) &#123;</span><br><span class="line">                <span class="built_in">CGSize</span> size = [comments sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</span><br><span class="line">                </span><br><span class="line">                x -= size.width;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//图片文字</span></span><br><span class="line">                [comments drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</span><br><span class="line">                                andFont:FontWithSize(<span class="number">12</span>)</span><br><span class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</span><br><span class="line">                              andHeight:rect.size.height];</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//评论图片（bundle里的图片）</span></span><br><span class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</span><br><span class="line">                </span><br><span class="line">                commentsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, [<span class="built_in">UIScreen</span> screenWidth]-x+<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line">                x -= <span class="number">20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//转发角</span></span><br><span class="line">            <span class="built_in">NSString</span> *reposts = _data[<span class="string">@"reposts"</span>];</span><br><span class="line">            <span class="keyword">if</span> (reposts) &#123;</span><br><span class="line">                <span class="built_in">CGSize</span> size = [reposts sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</span><br><span class="line">                </span><br><span class="line">                x -= MAX(size.width, <span class="number">5</span>)+SIZE_GAP_BIG;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//转发文字</span></span><br><span class="line">                [reposts drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</span><br><span class="line">                                andFont:FontWithSize(<span class="number">12</span>)</span><br><span class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</span><br><span class="line">                 </span><br><span class="line">                             andHeight:rect.size.height];</span><br><span class="line">               </span><br><span class="line">                <span class="comment">//转发图片（bundle里的图片）</span></span><br><span class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_repost.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">11</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</span><br><span class="line">                repostsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, commentsRect.origin.x-x, <span class="number">50</span>);</span><br><span class="line">                x -= <span class="number">20</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更多角</span></span><br><span class="line">            [<span class="string">@"•••"</span> drawInContext:context</span><br><span class="line">                     withPosition:<span class="built_in">CGPointMake</span>(SIZE_GAP_LEFT, <span class="number">8</span>+countRect.origin.y)</span><br><span class="line">                          andFont:FontWithSize(<span class="number">11</span>)</span><br><span class="line">                     andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">.5</span>]</span><br><span class="line">                        andHeight:rect.size.height];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//绘制原帖底部的分割线</span></span><br><span class="line">            <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</span><br><span class="line">                [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</span><br><span class="line">                <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30.5</span>, rect.size.width, <span class="number">.5</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将整个contex转化为图片，赋给背景imageview</span></span><br><span class="line">        <span class="built_in">UIImage</span> *temp = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag==drawColorFlag) &#123;</span><br><span class="line">                postBGView.frame = rect;</span><br><span class="line">                postBGView.image = <span class="literal">nil</span>;</span><br><span class="line">                postBGView.image = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制两个label的text</span></span><br><span class="line">    [<span class="keyword">self</span> drawText];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加载帖子里的网路图片，使用SDWebImage</span></span><br><span class="line">    [<span class="keyword">self</span> loadThumb];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面抽出每一种绘制内容的代码，分别讲解：</p><h3 id="3-1-异步加载网络图片"><a href="#3-1-异步加载网络图片" class="headerlink" title="3.1 异步加载网络图片"></a>3.1 异步加载网络图片</h3><p>关于网络图片的异步加载和缓存，作者使用了第三方框架：<code>SDWebImage</code>。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setData:(<span class="built_in">NSDictionary</span> *)data&#123;</span><br><span class="line">    _data = data;</span><br><span class="line">    [avatarView setBackgroundImage:<span class="literal">nil</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    <span class="keyword">if</span> ([data valueForKey:<span class="string">@"avatarUrl"</span>]) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:[data valueForKey:<span class="string">@"avatarUrl"</span>]];</span><br><span class="line">        [avatarView sd_setBackgroundImageWithURL:url forState:<span class="built_in">UIControlStateNormal</span> placeholderImage:<span class="literal">nil</span> options:SDWebImageLowPriority];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于<code>SDWebImage</code>，我相信大家都不会陌生，我前一阵写了一篇源码解析，有兴趣的话可以看一下：<a href="http://www.jianshu.com/p/93696717b4a3" target="_blank" rel="noopener">SDWebImage源码解析</a>。</p><h3 id="3-2-异步绘制本地图片"><a href="#3-2-异步绘制本地图片" class="headerlink" title="3.2 异步绘制本地图片"></a>3.2 异步绘制本地图片</h3><p>本地图片的绘制，只需要提供图片在bundle内部的名字和frame就可以绘制：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</span><br></pre></td></tr></table></figure><p>###3.3  异步绘制UIView</p><p>对于<code>UIView</code>的绘制，我们只需要知道要绘制的<code>UIView</code>的frame和颜色即可：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//背景颜色</span></span><br><span class="line">[[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</span><br><span class="line">        </span><br><span class="line"><span class="comment">//通过rect填充背景颜色</span></span><br><span class="line"><span class="built_in">CGContextFillRect</span>(context, rect);</span><br></pre></td></tr></table></figure><p>讲到现在，就剩下了关于文字的绘制，包括脱离了UILabel的纯文本的绘制和UILabel里文本的绘制，我们先说一下关于简单的纯NSString的绘制：</p><h3 id="3-4-异步绘制NSString"><a href="#3-4-异步绘制NSString" class="headerlink" title="3.4  异步绘制NSString"></a>3.4  异步绘制NSString</h3><p>作者通过传入字符串的字体，颜色和行高，以及位置就实现了纯文本的绘制：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制名字</span></span><br><span class="line">[_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</span><br><span class="line">                 andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</span><br><span class="line">             andHeight:rect.size.height];</span><br></pre></td></tr></table></figure><p>这个方法是作者在<code>NSString</code>的一个分类里自定义的，我们看一下它的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)context withPosition:(<span class="built_in">CGPoint</span>)p andFont:(<span class="built_in">UIFont</span> *)font andTextColor:(<span class="built_in">UIColor</span> *)color andHeight:(<span class="keyword">float</span>)height andWidth:(<span class="keyword">float</span>)width&#123;    </span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(width, font.pointSize+<span class="number">10</span>);    </span><br><span class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);    </span><br><span class="line">    <span class="comment">//移动坐标系统，所有点的y增加了height</span></span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,height);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//缩放坐标系统，所有点的x乘以1.0，所有的点的y乘以-1.0</span></span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//文字颜色</span></span><br><span class="line">    <span class="built_in">UIColor</span>* textColor = color;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成CTFont</span></span><br><span class="line">    <span class="built_in">CTFontRef</span> font1 = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)font.fontName, font.pointSize,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于创建CTParagraphStyleRef的一些基本数据</span></span><br><span class="line">    <span class="built_in">CGFloat</span> minimumLineHeight = font.pointSize,maximumLineHeight = minimumLineHeight+<span class="number">10</span>, linespace = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByTruncatingTail;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//左对齐</span></span><br><span class="line">    <span class="built_in">CTTextAlignment</span> alignment = kCTLeftTextAlignment;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//创建CTParagraphStyleRef</span></span><br><span class="line">    <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</span><br><span class="line">        &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</span><br><span class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</span><br><span class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</span><br><span class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</span><br><span class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</span><br><span class="line">        &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</span><br><span class="line">    &#125;,<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//设置属性字典；对象，key</span></span><br><span class="line">    <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</span><br><span class="line">                                (__bridge <span class="keyword">id</span>)font1,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</span><br><span class="line">                                textColor.CGColor,kCTForegroundColorAttributeName,</span><br><span class="line">                                style,kCTParagraphStyleAttributeName,</span><br><span class="line">                                <span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成path，添加到cgcontex上</span></span><br><span class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</span><br><span class="line">    <span class="built_in">CGPathAddRect</span>(path,<span class="literal">NULL</span>,<span class="built_in">CGRectMake</span>(p.x, height-p.y-size.height,(size.width),(size.height)));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成CF属性字符串</span></span><br><span class="line">    <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="keyword">self</span> attributes:attributes];</span><br><span class="line">    <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)attributedStr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从attributedString拿到ctframesetter</span></span><br><span class="line">    <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从framesetter拿到 core text 的 ctframe</span></span><br><span class="line">    <span class="built_in">CTFrameRef</span> ctframe = <span class="built_in">CTFramesetterCreateFrame</span>(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="built_in">CFAttributedStringGetLength</span>(attributedString)),path,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将ctframe绘制到context里面</span></span><br><span class="line">    <span class="built_in">CTFrameDraw</span>(ctframe,context);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为不是对象类型，需要释放</span></span><br><span class="line">    <span class="built_in">CGPathRelease</span>(path);</span><br><span class="line">    <span class="built_in">CFRelease</span>(font1);</span><br><span class="line">    <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">    <span class="built_in">CFRelease</span>(ctframe);</span><br><span class="line">    [[attributedStr mutableString] setString:<span class="string">@""</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//恢复context坐标系统</span></span><br><span class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>, height);</span><br><span class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，作者根据文字的起点，颜色，字体大小和行高，使用Core Text，将文字绘制在了传入的context上面。</p><h3 id="3-5-异步绘制UILabel"><a href="#3-5-异步绘制UILabel" class="headerlink" title="3.5 异步绘制UILabel"></a>3.5 异步绘制UILabel</h3><p>而对于<code>UILabel</code>里面的绘制，作者也采取了类似的方法：</p><p>首先看一下在cell实现文件里，关于绘制label文字方法的调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将文本内容绘制到图片上，也是异步绘制</span></span><br><span class="line">- (<span class="keyword">void</span>)drawText&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果发现label或detailLabel不存在，则重新add一次</span></span><br><span class="line">    <span class="keyword">if</span> (label==<span class="literal">nil</span>||detailLabel==<span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addLabel];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入frame</span></span><br><span class="line">    label.frame = [_data[<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</span><br><span class="line">    <span class="comment">//异步绘制text</span></span><br><span class="line">    [label setText:_data[<span class="string">@"text"</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果存在原帖</span></span><br><span class="line">    <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        detailLabel.frame = [[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</span><br><span class="line">        <span class="comment">//异步绘制text</span></span><br><span class="line">        [detailLabel setText:[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"text"</span>]];</span><br><span class="line">        detailLabel.hidden = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，对于帖子而言，是否存在原贴（当前贴是否是转发贴）是不固定的，所以需要在判断之后，用<code>hidden</code>属性来控制相应控件的隐藏和显示，而不是用<code>addSubView</code>的方法。</p><p>这里的label是作者自己封装的<code>VVeboLabel</code>。它具有高亮显示点击，利用正则表达式区分不同类型的特殊文字（话题名，用户名，网址，emoji）的功能。</p><p>简单介绍一下这个封装好的label：</p><ul><li>继承于<code>UIView</code>,可以响应用户点击，在初始化之后，<code>_textAlignment</code>,<code>_textColor</code>,<code>_font</code>,<code>_lienSpace</code>属性都会被初始化。</li><li>使用Core Text绘制文字。</li><li>持有两种UIImageView，用来显示默认状态和高亮状态的图片（将字符串绘制成图片）。</li><li>保存了四种特殊文字的颜色，用正则表达式识别以后，给其着色。</li></ul><p>这里讲一下这个label的<code>setText:</code>方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用coretext将文本绘制到图片。</span></span><br><span class="line">- (<span class="keyword">void</span>)setText:(<span class="built_in">NSString</span> *)text&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//labelImageView 普通状态时的imageview</span></span><br><span class="line">    <span class="comment">//highlightImageView 高亮状态时的iamgeview</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制标记，初始化时赋一个随机值；clear之后更新一个随机值</span></span><br><span class="line">    <span class="built_in">NSInteger</span> flag = drawFlag;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否正在高亮（在点击label的时候设置为yes，松开的时候设置为NO）</span></span><br><span class="line">    <span class="built_in">BOOL</span> isHighlight = highlighting;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSString</span> *temp = text;</span><br><span class="line">        _text = text;</span><br><span class="line">        <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.frame.size;</span><br><span class="line">        size.height += <span class="number">10</span>;</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, ![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]], <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="keyword">if</span> (context==<span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.backgroundColor set];</span><br><span class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">        <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</span><br><span class="line">        <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Determine default text color</span></span><br><span class="line">        <span class="built_in">UIColor</span>* textColor = <span class="keyword">self</span>.textColor;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Set line height, font, color and break mode</span></span><br><span class="line">        <span class="built_in">CGFloat</span> minimumLineHeight = <span class="keyword">self</span>.font.pointSize,maximumLineHeight = minimumLineHeight, linespace = <span class="keyword">self</span>.lineSpace;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CTFontRef</span> font = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)<span class="keyword">self</span>.font.fontName, <span class="keyword">self</span>.font.pointSize,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByWordWrapping;</span><br><span class="line">        <span class="built_in">CTTextAlignment</span> alignment = <span class="built_in">CTTextAlignmentFromUITextAlignment</span>(<span class="keyword">self</span>.textAlignment);</span><br><span class="line">        <span class="comment">//Apply paragraph settings</span></span><br><span class="line">        <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</span><br><span class="line">            &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</span><br><span class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</span><br><span class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</span><br><span class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</span><br><span class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</span><br><span class="line">            &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</span><br><span class="line">        &#125;,<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//属性字典</span></span><br><span class="line">        <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:(__bridge <span class="keyword">id</span>)font,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</span><br><span class="line">                                    textColor.CGColor,kCTForegroundColorAttributeName,</span><br><span class="line">                                    style,kCTParagraphStyleAttributeName,</span><br><span class="line">                                    <span class="literal">nil</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿到CFAttributedStringRef</span></span><br><span class="line">        <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:text attributes:attributes];</span><br><span class="line">        <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)[<span class="keyword">self</span> highlightText:attributedStr];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//根据attributedStringRef 获取CTFramesetterRef</span></span><br><span class="line">        <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">5</span>,(size.width),(size.height<span class="number">-5</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//根据 framesetter 和 attributedString 绘制text</span></span><br><span class="line">            [<span class="keyword">self</span> drawFramesetter:framesetter attributedString:attributedStr textRange:<span class="built_in">CFRangeMake</span>(<span class="number">0</span>, text.length) inRect:rect context:context];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//恢复context</span></span><br><span class="line">            <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</span><br><span class="line">            <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</span><br><span class="line">            <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//截取当前图片</span></span><br><span class="line">            <span class="built_in">UIImage</span> *screenShotimage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">            <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">CFRelease</span>(font);</span><br><span class="line">                <span class="built_in">CFRelease</span>(framesetter);</span><br><span class="line">                [[attributedStr mutableString] setString:<span class="string">@""</span>];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (drawFlag==flag) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (isHighlight) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//高亮状态：把图片付给highlightImageView</span></span><br><span class="line">                        <span class="keyword">if</span> (highlighting) &#123;</span><br><span class="line">                            highlightImageView.image = <span class="literal">nil</span>;</span><br><span class="line">                            <span class="keyword">if</span> (highlightImageView.width!=screenShotimage.size.width) &#123;</span><br><span class="line">                                highlightImageView.width = screenShotimage.size.width;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (highlightImageView.height!=screenShotimage.size.height) &#123;</span><br><span class="line">                                highlightImageView.height = screenShotimage.size.height;</span><br><span class="line">                            &#125;</span><br><span class="line">                            highlightImageView.image = screenShotimage;</span><br><span class="line">                        &#125;</span><br><span class="line">                    </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//非高亮状态，把图片付给labelImageView</span></span><br><span class="line">                        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (labelImageView.width!=screenShotimage.size.width) &#123;</span><br><span class="line">                                labelImageView.width = screenShotimage.size.width;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (labelImageView.height!=screenShotimage.size.height) &#123;</span><br><span class="line">                                labelImageView.height = screenShotimage.size.height;</span><br><span class="line">                            &#125;</span><br><span class="line">                            highlightImageView.image = <span class="literal">nil</span>;</span><br><span class="line">                            labelImageView.image = <span class="literal">nil</span>;</span><br><span class="line">                            labelImageView.image = screenShotimage;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"><span class="comment">//                    [self debugDraw];//绘制可触摸区域</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个被作者封装好的Label里面还有很多其他的方法，比如用正则表达式高亮显示特殊字符串等等。</p><p>关于tableView的优化，作者做了很多处理，使得这种显示内容比较丰富的cell在4s真机上好不卡顿，非常值得学习。</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次分享一个关于性能优化的源码。&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;UITabelView&lt;/code&gt;在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，&lt;code&gt;UITabelView&lt;/code&gt;的性能将直接影响这个app的性能。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;UITabelView&lt;/code&gt;里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。&lt;/p&gt;
&lt;p&gt;但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。&lt;/p&gt;
&lt;p&gt;最近在看一些iOS性能优化的文章，我找到了&lt;a href=&quot;https://github.com/johnil/VVeboTableViewDemo&quot;&gt;VVeboTableView&lt;/a&gt;这个框架。严格来说这个不属于框架，而是作者用自己的方式优化&lt;code&gt;UITableView&lt;/code&gt;的一个实现。&lt;/p&gt;
&lt;p&gt;作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;看了源码之后，我把作者的思路整理了出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png&quot; alt=&quot;优化思路图&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/SDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/SDWebImage源码解析/</id>
    <published>2018-02-02T16:17:50.000Z</published>
    <updated>2018-07-16T16:47:00.154Z</updated>
    
    <content type="html"><![CDATA[<p>相信对于广大的iOS开发者，对<a href="https://github.com/rs/SDWebImage">SDWebImage</a>并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。</p><p>在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>] placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>] completed:^(<span class="built_in">UIImage</span> * _Nullable image, <span class="built_in">NSError</span> * _Nullable error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> * _Nullable imageURL) &#123;</span><br><span class="line">        </span><br><span class="line">        imageview.image = image;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图片加载完成"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure><p>而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//图片下载完成后直接显示下载后的图片</span></span><br><span class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>]];</span><br></pre></td></tr></table></figure><p>在最开始先简单介绍这个框架：</p><p>这个框架的核心类是<code>SDWebImageManger</code>，在外部有<code>UIImageView+WebCache</code> 和 <code>UIButton+WebCache</code> 为下载图片的操作提供接口。内部有<code>SDWebImageManger</code>负责处理和协调 <code>SDWebImageDownloader</code> 和 <code>SDWebImageCache</code>：<code>SDWebImageDownloader</code>负责具体的下载任务，<code>SDWebImageCache</code>负责关于缓存的工作：添加，删除，查询缓存。</p><p>首先我们大致看一下这个框架的调用流程图：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage"></p><p>从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。</p><p>OK～基本流程大概清楚了，我们看一下每个层具体实现吧～</p><a id="more"></a><hr><p>##UIKit层</p><p>该框架最外层的类是<code>UIImageView +WebCache</code>，我们将图片的URL，占位图片直接给这个类。下面是这个类的公共接口：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  UIImageView + WebCache.h ============== //</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder;</span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options;</span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><p>可以看出，这个类提供的接口非常灵活，可以根据我们自己的需求来调用其中某一个方法，而这些方法到最后都会走到：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                   options:(SDWebImageOptions)options</span><br><span class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><p>而这个方法里面，调用的是<code>UIView+WebCache</code>分类的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></span><br><span class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</span><br><span class="line">                           options:(SDWebImageOptions)options</span><br><span class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</span><br><span class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</span><br><span class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</span><br></pre></td></tr></table></figure><blockquote><p>为什么不是UIImageView+WebCache而要上一层到UIView的分类里呢？<br>因为SDWebImage框架也支持UIButton的下载图片等方法，所以需要在它们的父类：UIView里面统一一个下载方法。</p></blockquote><p>简单看一下这个方法的实现（省略的代码用…代替）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//valid key：UIImageView || UIButton</span></span><br><span class="line">   <span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line">   <span class="comment">//UIView+WebCacheOperation 的 operationDictionary</span></span><br><span class="line">   <span class="comment">//下面这行代码是保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突</span></span><br><span class="line">   [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">   <span class="comment">//添加临时的占位图（在不延迟添加占位图的option下）</span></span><br><span class="line">   <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">       dispatch_main_async_safe(^&#123;</span><br><span class="line">           [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;    </span><br><span class="line">   <span class="comment">//如果url存在</span></span><br><span class="line">   <span class="keyword">if</span> (url) &#123;     </span><br><span class="line">      ...</span><br><span class="line">       __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//SDWebImageManager下载图片</span></span><br><span class="line">       <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</span><br><span class="line">         </span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">//dispatch_main_sync_safe : 保证block能在主线程进行</span></span><br><span class="line">           dispatch_main_async_safe(^&#123;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">if</span> (!sself) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;               </span><br><span class="line">               <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</span><br><span class="line">                    <span class="comment">//image，而且不自动替换 placeholder image</span></span><br><span class="line">                   completedBlock(image, error, cacheType, url);</span><br><span class="line">                   <span class="keyword">return</span>;                    </span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                   <span class="comment">//存在image，需要马上替换 placeholder image</span></span><br><span class="line">                   [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">                   [sself sd_setNeedsLayout];                </span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;                    </span><br><span class="line">                   <span class="comment">//没有image，在图片下载完之后显示 placeholder image</span></span><br><span class="line">                   <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</span><br><span class="line">                       [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">                       [sself sd_setNeedsLayout];</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;                </span><br><span class="line">               <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</span><br><span class="line">                   completedBlock(image, error, cacheType, url);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;];</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行</span></span><br><span class="line">       [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];        </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">//如果url不存在，就在completedBlock里传入error（url为空）</span></span><br><span class="line">       dispatch_main_async_safe(^&#123;</span><br><span class="line">           [<span class="keyword">self</span> sd_removeActivityIndicator];</span><br><span class="line">           <span class="keyword">if</span> (completedBlock) &#123;</span><br><span class="line">               <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</span><br><span class="line">               completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得一提的是，在这一层，使用一个字典<code>operationDictionary</code>专门用作存储操作的缓存，随时添加，删除操作任务。<br>而这个字典是<code>UIView+WebCacheOperation</code>分类的关联对象，它的存取方法使用运行时来操作：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  UIView+WebCacheOperation.m ============== //</span></span><br><span class="line"> <span class="comment">//获取关联对象：operations（用来存放操作的字典）</span></span><br><span class="line">- (SDOperationsDictionary *)operationDictionary &#123;</span><br><span class="line">    SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</span><br><span class="line">    <span class="comment">//存放操作的字典</span></span><br><span class="line">    <span class="keyword">if</span> (operations) &#123;</span><br><span class="line">        <span class="keyword">return</span> operations;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//如果没有，就新建一个</span></span><br><span class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];    </span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    <span class="keyword">return</span> operations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么不直接在<code>UIImageView+WebCache</code>里直接关联这个对象呢？我觉得这里作者应该是遵从面向对象的<strong>单一职责原则（SRP：Single responsibility principle）</strong>，就连类都要履行这个职责，何况分类呢？这里作者专门创造一个分类<code>UIView+WebCacheOperation</code>来管理操作缓存（字典）。</p></blockquote><p>到这里，<code>UIKit</code>层上面的东西都讲完了，现在开始正式讲解工具层。</p><h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>上文提到过，<code>SDWebImageManager</code>同时管理<code>SDImageCache</code>和<code>SDWebImageDownloader</code>两个类，它是这一层的<strong>老大哥</strong>。在下载任务开始的时候，<code>SDWebImageManager</code>首先访问<code>SDImageCache</code>来查询是否存在缓存，如果有缓存，直接返回缓存的图片。如果没有缓存，就命令<code>SDWebImageDownloader</code>来下载图片，下载成功后，存入缓存，显示图片。以上是<code>SDWebImageManager</code>大致的工作流程。</p><p>在详细讲解<code>SDWebImageManager</code>是如何下载图片之前，我们先看一下这个类的几个重要的属性：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  SDWebImageManager.h ============== //</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDImageCache *imageCache;<span class="comment">//管理缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDWebImageDownloader <span class="comment">//下载器*imageDownloader;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSURL</span> *&gt; *failedURLs;<span class="comment">//记录失效url的名单</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDWebImageCombinedOperation *&gt; *runningOperations;<span class="comment">//记录当前正在执行的操作</span></span><br></pre></td></tr></table></figure><p><code>SDWebImageManager</code>下载图片的方法只有一个：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[SDWebImageManager.sharedManager loadImageWithURL:options:progress:completed:]</span><br></pre></td></tr></table></figure><p>看一下这个方法的具体实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  SDWebImageManager.m ============== //</span></span><br><span class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                     options:(SDWebImageOptions)options</span><br><span class="line">                                    progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                   completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</span><br><span class="line">     ...                             </span><br><span class="line">    <span class="comment">//在SDImageCache里查询是否存在缓存的图片</span></span><br><span class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;        </span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片） || （代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片）</span></span><br><span class="line">        <span class="keyword">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;            </span><br><span class="line">            <span class="comment">//1. 存在缓存图片 &amp;&amp; 即使有缓存图片也要下载更新图片</span></span><br><span class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</span><br><span class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 2. 如果不存在缓存图片</span></span><br><span class="line">            ...            </span><br><span class="line">            <span class="comment">//开启下载器下载</span></span><br><span class="line">            <span class="comment">//subOperationToken 用来标记当前的下载任务，便于被取消</span></span><br><span class="line">            SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</span><br><span class="line">                    <span class="comment">// 1. 如果任务被取消，则什么都不做，避免和其他的completedBlock重复</span></span><br><span class="line">                </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//2. 如果有错误</span></span><br><span class="line">                    <span class="comment">//2.1 在completedBlock里传入error</span></span><br><span class="line">                    [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url];</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.2 在错误url名单中添加当前的url</span></span><br><span class="line">                    <span class="keyword">if</span> (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></span><br><span class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></span><br><span class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></span><br><span class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></span><br><span class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></span><br><span class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></span><br><span class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</span><br><span class="line">                        </span><br><span class="line">                       <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</span><br><span class="line">                            [<span class="keyword">self</span>.failedURLs addObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//3. 下载成功</span></span><br><span class="line">                    <span class="comment">//3.1 如果需要下载失败后重新下载，则将当前url从失败url名单里移除</span></span><br><span class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</span><br><span class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</span><br><span class="line">                            [<span class="keyword">self</span>.failedURLs removeObject:url];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//3.2 进行缓存</span></span><br><span class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);                   </span><br><span class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">//（即使缓存存在，也要刷新图片） &amp;&amp; 缓存图片 &amp;&amp; 不存在下载后的图片：不做操作</span></span><br><span class="line">                                           </span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</span><br><span class="line">                        </span><br><span class="line">          <span class="comment">//（下载图片成功 &amp;&amp; （没有动图||处理动图） &amp;&amp; （下载之后，缓存之前处理图片）               dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span></span><br><span class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</span><br><span class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</span><br><span class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></span><br><span class="line">                                <span class="comment">//缓存图片</span></span><br><span class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//将图片传入completedBlock</span></span><br><span class="line">                            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//(图片下载成功并结束)</span></span><br><span class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</span><br><span class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"> <span class="comment">//如果完成，从当前运行的操作列表里移除当前操作</span></span><br><span class="line">                <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//取消的block</span></span><br><span class="line">            operation.cancelBlock = ^&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">//取消当前的token</span></span><br><span class="line">                [<span class="keyword">self</span>.imageDownloader cancel:subOperationToken];</span><br><span class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">                <span class="comment">//从当前运行的操作列表里移除当前操作</span></span><br><span class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</span><br><span class="line">            &#125;;</span><br><span class="line">        </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//存在缓存图片</span></span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;            </span><br><span class="line">            <span class="comment">//调用完成的block</span></span><br><span class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];            </span><br><span class="line">            <span class="comment">//删去当前的的下载操作（线程安全）</span></span><br><span class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];        </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            <span class="comment">//没有缓存的图片，而且下载被代理终止了</span></span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">// 调用完成的block</span></span><br><span class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:<span class="literal">YES</span> url:url];            </span><br><span class="line">            <span class="comment">//删去当前的下载操作</span></span><br><span class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看完了<code>SDWebImageManager</code>的回调处理，我们分别看一下<br><code>SDImageCache</code>和<code>SDWebImageDownloader</code>内部具体是如何工作的。首先看一下<code>SDImageCache</code>：</p><h3 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSCache</span> *memCache;<span class="comment">//内存缓存</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;<span class="comment">//磁盘缓存路径</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;<span class="comment">//</span></span><br><span class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> <span class="comment">//ioQueue唯一子线程;</span></span><br></pre></td></tr></table></figure><h4 id="核心方法：查询缓存"><a href="#核心方法：查询缓存" class="headerlink" title="核心方法：查询缓存"></a>核心方法：查询缓存</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;   </span><br><span class="line">    <span class="keyword">if</span> (!key) &#123;</span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//================查看内存的缓存=================//</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];    </span><br><span class="line">    <span class="comment">// 如果存在，直接调用block，将image，data，CaheType传进去</span></span><br><span class="line">    <span class="keyword">if</span> (image) &#123;    </span><br><span class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;        </span><br><span class="line">        <span class="comment">//如果是gif，就拿到data，后面要传到doneBlock里。不是gif就传nil</span></span><br><span class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</span><br><span class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">//因为图片有缓存可供使用，所以不用实例化NSOperation，直接范围nil</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//================查看磁盘的缓存=================//</span></span><br><span class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];    </span><br><span class="line">    <span class="comment">//唯一的子线程：self.ioQueue</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;        </span><br><span class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</span><br><span class="line">            <span class="comment">// 在用之前就判断operation是否被取消了，作者考虑的非常严谨</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;            </span><br><span class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</span><br><span class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];            </span><br><span class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</span><br><span class="line">                  <span class="comment">// cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。</span></span><br><span class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);                </span><br><span class="line">                <span class="comment">//存入内存缓存中</span></span><br><span class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (doneBlock) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;<span class="comment">//下载队列</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *lastAddedOperation;<span class="comment">//最后添加的下载操作</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) Class operationClass;<span class="comment">//操作类</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, SDWebImageDownloaderOperation *&gt; *URLOperations;<span class="comment">//操作数组</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDHTTPHeadersMutableDictionary *HTTPHeaders;<span class="comment">//HTTP请求头</span></span><br><span class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;<span class="comment">//用来阻塞前面的下载线程（串行化）</span></span><br></pre></td></tr></table></figure><h4 id="核心方法：下载图片"><a href="#核心方法：下载图片" class="headerlink" title="核心方法：下载图片"></a>核心方法：下载图片</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                                   options:(SDWebImageDownloaderOptions)options</span><br><span class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</span><br><span class="line">        </span><br><span class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</span><br><span class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</span><br><span class="line">            timeoutInterval = <span class="number">15.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建下载请求</span></span><br><span class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</span><br><span class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</span><br><span class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</span><br><span class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建下载操作：SDWebImageDownloaderOperation用于请求网络资源的操作，它是一个 NSOperation 的子类</span></span><br><span class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</span><br><span class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//url证书</span></span><br><span class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</span><br><span class="line">            operation.credential = sself.urlCredential;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</span><br><span class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//优先级</span></span><br><span class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</span><br><span class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在下载队列里添加下载操作，执行下载操作</span></span><br><span class="line">        [sself.downloadQueue addOperation:operation];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果后进先出</span></span><br><span class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</span><br><span class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></span><br><span class="line">            <span class="comment">//addDependency:参数opertaion倍添加到NSOperationQueue后，只有等该opertion结束后才能执行其他的operation，实现了后进先出</span></span><br><span class="line">            [sself.lastAddedOperation addDependency:operation];</span><br><span class="line">            sself.lastAddedOperation = operation;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> operation;</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面还有一个<code>addProgressCallback: progressBlock: completedBlock: forURL: createCallback:</code>方法，用来保存<code>progressBlock</code>和<code>completedBlock</code>。我们看一下这个方法的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></span><br><span class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</span><br><span class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</span><br><span class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// url 用来作为回调字典的key，如果为空，立即返回失败 </span></span><br><span class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __block SDWebImageDownloadToken *token = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//串行化前面所有的操作</span></span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;    </span><br><span class="line">        <span class="comment">//当前下载操作中取出SDWebImageDownloaderOperation实例</span></span><br><span class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];        </span><br><span class="line">        <span class="keyword">if</span> (!operation) &#123;</span><br><span class="line">        <span class="comment">//如果没有，就初始化它</span></span><br><span class="line">            operation = createCallback();</span><br><span class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</span><br><span class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</span><br><span class="line">            </span><br><span class="line">            operation.completionBlock = ^&#123;</span><br><span class="line">              SDWebImageDownloaderOperation *soperation = woperation;</span><br><span class="line">              <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</span><br><span class="line">              <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</span><br><span class="line">                  [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</span><br><span class="line">              &#125;;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</span><br><span class="line">        <span class="comment">//这里 downloadOperationCancelToken 默认是一个字典，存放 progressBlock 和 completedBlock</span></span><br><span class="line">        token = [SDWebImageDownloadToken new];</span><br><span class="line">        token.url = url;</span><br><span class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里真正保存两个block的方法是<code>addHandlersForProgress: completed:</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</span><br><span class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</span><br><span class="line">    <span class="comment">//实例化一个SDCallbacksDictionary，存放一个progressBlock 和 completedBlock</span></span><br><span class="line">    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</span><br><span class="line">    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.barrierQueue, ^&#123;</span><br><span class="line">        <span class="comment">//添加到缓存中 self.callbackBlocks</span></span><br><span class="line">        [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里<code>SDWebImage</code>的核心方法都讲解完毕了，其他没有讲到的部分以后会慢慢添加上去。</p><h2 id="最后看一下一些比较零散的知识点："><a href="#最后看一下一些比较零散的知识点：" class="headerlink" title="最后看一下一些比较零散的知识点："></a>最后看一下一些比较零散的知识点：</h2><hr><h4 id="1-运行时存取关联对象："><a href="#1-运行时存取关联对象：" class="headerlink" title="1. 运行时存取关联对象："></a>1. 运行时存取关联对象：</h4><p><strong>存：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"><span class="comment">//将operations对象关联给self，地址为&amp;loadOperationKey，语义是OBJC_ASSOCIATION_RETAIN_NONATOMIC。</span></span><br></pre></td></tr></table></figure><p><strong>取：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</span><br><span class="line"><span class="comment">//将operations对象通过地址&amp;loadOperationKey从self里取出来</span></span><br></pre></td></tr></table></figure><h4 id="2-数组的写操作需要加锁（多线程访问，避免覆写）"><a href="#2-数组的写操作需要加锁（多线程访问，避免覆写）" class="headerlink" title="2. 数组的写操作需要加锁（多线程访问，避免覆写）"></a>2. 数组的写操作需要加锁（多线程访问，避免覆写）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给self.runningOperations加锁</span></span><br><span class="line"><span class="comment">//self.runningOperations数组的添加操作</span></span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//self.runningOperations数组的删除操作</span></span><br><span class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</span><br><span class="line">        <span class="keyword">if</span> (operation) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.runningOperations removeObject:operation];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-确保在主线程的宏："><a href="#3-确保在主线程的宏：" class="headerlink" title="3. 确保在主线程的宏："></a>3. 确保在主线程的宏：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dispatch_main_async_safe(^&#123;</span><br><span class="line">  <span class="comment">//将下面这段代码放在主线程中</span></span><br><span class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义：</span></span><br><span class="line"><span class="meta">#define dispatch_main_async_safe(block)\</span></span><br><span class="line">    <span class="keyword">if</span> (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == <span class="number">0</span>) &#123;\</span><br><span class="line">        block();\</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;\</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), block);\</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure><h4 id="4-设置不能为nil的参数"><a href="#4-设置不能为nil的参数" class="headerlink" title="4. 设置不能为nil的参数"></a>4. 设置不能为nil的参数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</span><br><span class="line">        _imageCache = cache;</span><br><span class="line">        _imageDownloader = downloader;</span><br><span class="line">        _failedURLs = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _runningOperations = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果在参数里添加了nonnull关键字，那么编译器就可以检查传入的参数是否为nil，如果是，则编译器会有警告</p></blockquote><h4 id="5-容错，强制转换类型"><a href="#5-容错，强制转换类型" class="headerlink" title="5. 容错，强制转换类型"></a>5. 容错，强制转换类型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</span><br><span class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在传入的参数为NSString时（但是方法参数要求是NSURL），自动转换为NSURL</p></blockquote><hr><p>貌似还有图片解码等内容没有详细看，以后会逐渐补充哒～</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信对于广大的iOS开发者，对&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。&lt;/p&gt;
&lt;p&gt;在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;] placeholderImage:[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;placeholder&quot;&lt;/span&gt;] completed:^(&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; * _Nullable image, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nullable error, SDImageCacheType cacheType, &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; * _Nullable imageURL) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        imageview.image = image;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;图片加载完成&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//图片下载完成后直接显示下载后的图片&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;]];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在最开始先简单介绍这个框架：&lt;/p&gt;
&lt;p&gt;这个框架的核心类是&lt;code&gt;SDWebImageManger&lt;/code&gt;，在外部有&lt;code&gt;UIImageView+WebCache&lt;/code&gt; 和 &lt;code&gt;UIButton+WebCache&lt;/code&gt; 为下载图片的操作提供接口。内部有&lt;code&gt;SDWebImageManger&lt;/code&gt;负责处理和协调 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 和 &lt;code&gt;SDWebImageCache&lt;/code&gt;：&lt;code&gt;SDWebImageDownloader&lt;/code&gt;负责具体的下载任务，&lt;code&gt;SDWebImageCache&lt;/code&gt;负责关于缓存的工作：添加，删除，查询缓存。&lt;/p&gt;
&lt;p&gt;首先我们大致看一下这个框架的调用流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SDWebImage&quot;&gt;&lt;/p&gt;
&lt;p&gt;从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。&lt;/p&gt;
&lt;p&gt;OK～基本流程大概清楚了，我们看一下每个层具体实现吧～&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PNChart源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/PNChart%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/PNChart源码解析/</id>
    <published>2018-02-02T16:17:45.000Z</published>
    <updated>2018-07-16T16:46:54.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一. 框架介绍"></a>一. 框架介绍</h2><p><a href="https://github.com/kevinzhow/PNChart">PNChart</a>是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。</p><p>该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类<code>PNGenericChart</code>,第二层就是所有类型的图表。提供一张图来直观感受一下：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png" alt="层级图"></p><blockquote><p>在这张图里，需要注意以下几点：</p><ol><li>带箭头的线和不带箭头的线的区别。</li><li><code>Data</code>类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有<code>Data</code>类，因为饼状图没有多组数据，而折线图<code>LineChart</code>是支持多组数据的，所以有<code>Data</code>类。</li><li><code>Item</code>类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。</li><li><code>BarChart</code>类里面的每一根柱子都是<code>PNBar</code>的实例（该类型的图表不在本篇讲解的范围之内）。</li></ol></blockquote><a id="more"></a><p>今天就来介绍一下该框架里的折线图的源码。上文提到过，该框架的折线图是支持多组数据的，也就是在同一张图表上显示多条折线。先带大家看一下效果图：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_2.png" alt="折线图"></p><p>折线图在效果上还是很简洁美观的，如果现在的你还不知道如何使用<code>CAShapeLayer</code>和<code>UIBezierPath</code>画图并附加动画效果，那么本篇源码解析非常适合你。</p><p>阅读本文之后，你可以掌握有关图形绘制的相关知识，也可以掌握自定义各种图形（<code>UIView</code>）的方法，而且你也应该有能力作出这样的图表，甚至更好！</p><p>在开始讲解之前，我先粗略介绍一下利用<code>CAShapeLayer</code>画图的过程。这个过程有三个大前提：</p><ul><li>因为<code>UIView</code>是对<code>CALayer</code>的封装，所以我们可以通过改变<code>UIView</code>所持有的<code>layer</code>属性来直接改变<code>UIView</code>的显示效果。</li><li><code>CAShapeLayer</code>是<code>CALayer</code>的子类。</li><li><code>CAShapeLayer</code>的使用是依赖于<code>UIBezierPath</code>的。<code>UIBezierPath</code>就是“路径”，可以理解为形状。不难理解，想象一下，如果我们想画一个图形，那么这个图形的形状（包括颜色）是必不可少的，而这个角色，就需要<code>UIBezierPath</code>来充当。</li></ul><p>那么了这三个大前提，我们就可以知道如何画图了：</p><ol><li>实例化一个<code>UIBezierPath</code>，并赋给<code>CAShapeLayer</code>实例的<code>path</code>属性。</li><li>将这个<code>CAShapeLayer</code>的实例添加到<code>UIView</code>的<code>layer</code>上。</li></ol><p>简单的代码演示上述过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">...自定义path...</span><br><span class="line"><span class="built_in">CAShapeLayer</span> *shapLayer = [<span class="built_in">CAShapeLayer</span> alloc] init];</span><br><span class="line">shapLayer.path = path;</span><br><span class="line">[<span class="keyword">self</span>.view.layer addSubLayer:shapeLayer];</span><br></pre></td></tr></table></figure></p><p>现在大致了解了画图的过程，我们来看一下该框架的作者是如何实现一个折线图的吧！</p><h2 id="二-源码解析"><a href="#二-源码解析" class="headerlink" title="二. 源码解析"></a>二. 源码解析</h2><p>首先看一下整个绘制折线图的步骤：</p><ol><li>图表的初始化。</li><li>获取横轴和纵轴的数据。</li><li>计算折线上所有拐点的x，y值。</li><li>计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）。</li><li>生成每个拐点上面的Label（可有可无）。</li><li>计算每条线段的贝塞尔曲线（UIBezierPath）。</li><li>将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</li><li>绘制所有折线（所有线段+所有圆圈）。</li><li>添加动画(可有可无)。</li><li>绘制x，y坐标轴。</li></ol><p>在集合代码具体讲解之前，我们要清楚三点（非常非常重要）：</p><ol><li>此折线图框架是可以设置拐点的样式的:可以设置为没有样式，也可以设置有样式：圆圈，方块，三角形。<ul><li>如果没有样式，则是简单的线段与线段的连接，在拐点处没有任何其他控件。</li><li>如果是有样式的，那么这条折线里的每条线段（在本篇文章里统一说成线段）之间是<strong>分离的</strong>，因为线段中间有一个拐点控件。本篇文章介绍的是圆圈样式（如上图所示，拐点控件是一个圆圈）。</li></ul></li><li>上文提到过，该折线图框架可以在一张图表里同时显示多条折线，也就是可以设置多组数据（一条折线对应一组数据）。因此，上面的3，4，5，6，7项都是用各自不同的一个数组保存的，数组里的每一个元素对应一条折线的数据。</li><li>既然同一个张图表可以显示多条折线：<ul><li>那么有些属性就是这些折线共有的，比如横坐标的value，这些属性保存在<code>PNLineChart</code>的实例里面。</li><li>有些属性是每条折线私有的，比如每条折线的颜色，纵坐标value等等，这些属性保存在<code>PNLineChartData</code>里面。每一条折线对应一个<code>PNLineChartData</code>实例。这些实例汇总到一个数组里面，这个数组由<code>PNLineChart</code>的实例管理。</li></ul></li></ol><p>在充分了解了这三点之后，我们结合一下代码来看一下具体的实现：</p><h3 id="1-图表的初始化"><a href="#1-图表的初始化" class="headerlink" title="1. 图表的初始化"></a>1. 图表的初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setupDefaultValues];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setupDefaultValues &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> setupDefaultValues];</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//四个内边距</span></span><br><span class="line">    _chartMarginLeft = <span class="number">25.0</span>;</span><br><span class="line">    _chartMarginRight = <span class="number">25.0</span>;</span><br><span class="line">    _chartMarginTop = <span class="number">25.0</span>;</span><br><span class="line">    _chartMarginBottom = <span class="number">25.0</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//真正绘制图表的画布（CavanWidth）的宽高</span></span><br><span class="line">    _chartCavanWidth = <span class="keyword">self</span>.frame.size.width - _chartMarginLeft - _chartMarginRight;</span><br><span class="line">    _chartCavanHeight = <span class="keyword">self</span>.frame.size.height - _chartMarginBottom - _chartMarginTop;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面这段代码我刻意省去了其他一些基本的设置，突出了图表布局的设置。</p><p>布局的设置是图表绘制的前提，因为在最开始的时候，就应该计算出“画布”，也就是图表内容（不包括坐标轴和坐标label）的具体大小和位置（内边距以内的部分）。</p><p>在这里，我们需要获取真正绘制图表的画布的宽高(<code>_chartCavanWidth</code>和<code>_chartCavanHeight</code>)。而且，要留意的是<code>_chartMarginLeft</code>在将来是要用作y轴Label的宽度，而<code>_chartMarginBottom</code>在将来是要用作x轴Label的高度的。</p></blockquote><p>用一张图直观看一下：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_4.png" alt="整个控件的大小和画布的大小"></p><h3 id="2-获取横轴和纵轴的数据"><a href="#2-获取横轴和纵轴的数据" class="headerlink" title="2. 获取横轴和纵轴的数据"></a>2. 获取横轴和纵轴的数据</h3><p>现在画布的位置和大小确定了，我们可以来看一下折线图是怎么画的了。<br>整个图表的绘制都基于三组数据（也可以是两组，为什么是两组，我稍后会给出解释），在讲解该框架是如何利用这些数据之前，我们来看一下这些数据是如何传进图表的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//设置x轴的数据</span></span><br><span class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</span><br><span class="line"><span class="comment">//设置y轴的数据</span></span><br><span class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</span><br><span class="line">                             <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</span><br><span class="line">                             ]</span><br><span class="line"> ];</span><br><span class="line"><span class="comment">// Line Chart</span></span><br><span class="line"><span class="comment">//设置每个点的y值</span></span><br><span class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</span><br><span class="line">PNLineChartData *data = [PNLineChartData new];</span><br><span class="line">data.pointLabelColor = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line">data.color = PNTwitterColor;</span><br><span class="line">data.alpha = <span class="number">0.5</span>f;</span><br><span class="line">data.itemCount = dataArray.count;</span><br><span class="line">data.inflexionPointStyle = PNLineChartPointStyleCircle;</span><br><span class="line"><span class="comment">//这个block的作用是将上面的dataArray里的每一个值传给line chart。</span></span><br><span class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</span><br><span class="line">    <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//因为只有一条折线，所以只有一组数据</span></span><br><span class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</span><br><span class="line"><span class="comment">//绘制图表</span></span><br><span class="line">[<span class="keyword">self</span>.lineChart strokeChart];</span><br><span class="line"><span class="comment">//设置代理，响应点击</span></span><br><span class="line"><span class="keyword">self</span>.lineChart.delegate = <span class="keyword">self</span>;</span><br><span class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.lineChart];</span><br></pre></td></tr></table></figure><p>上面的代码我可以略去了很多多余的设置，目的是突出图表数据的设置。</p><p>不难看出，这里有三个数据传给了lineChart：</p><p>1.x轴的数据：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</span><br></pre></td></tr></table></figure><blockquote><p>这段代码调用之后，实现了：</p><ol><li>根据传入的xLabel数组里元素的数量，内容宽度(<code>_chartCavanWidth</code>)和下边距（<code>_chartMarginBottom</code>），计算每个xlabel的size。</li><li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的xLabel（包括内容，位置）并显示出来，最后保存在<code>_xChartLabels</code>里面。</li></ol></blockquote><p>2.y轴的数据：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</span><br><span class="line">                <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</span><br><span class="line">                ]</span><br><span class="line">    ];</span><br></pre></td></tr></table></figure><blockquote><p>这段代码调用之后，实现了：</p><ol><li>根据传入的yLabel数组里元素的数量，内容高度(<code>_chartCavanHeight</code>)和左边距(<code>_chartMarginLeft</code>)，计算出每个ylabel的size。</li><li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的yLabel（包括内容，位置）并显示出来，最后保存在<code>_yChartLabels</code>里面。</li></ol></blockquote><p>3.一条折线上每个点的实际值：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</span><br><span class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line">        <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</span><br><span class="line">        <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</span><br></pre></td></tr></table></figure><blockquote><p>着重讲一下block：为什么不直接把这个数组(<code>dataArray</code>)作为line chart的属性传进去呢？我认为作者是想提供一个接口给用户一个自己转化y值的机会。</p><p>像上文所说的，这里1，2是属于<code>lineChart</code>的数据，它适用于这张图表上所有的折线的。而3是属于某一条折线的。</p><p>现在回答一下为什么可以只传入两组数据：因为y轴数据可以由每个点的实际值数组得出。可以简单想一下，我们可以获取这些真实值里面的最大值，然后将它n等分，就自然得到了y轴数据了。</p></blockquote><p>我们已经布局了x轴和y轴的所有label，现在开始真正计算图表的数据了。</p><blockquote><p>注意：下面要介绍的3，4，5，6项都是在同一方法中计算出来，为了避免代码过长，我将每个部分分解开来做出解释。因为在同一方法里，所以这些涉及到for循环的语句是一致的。</p><p>整个图表的绘制都是依赖于数据的处理，所以3，4，5，6项也是理解该框架的一个关键！</p></blockquote><p>首先，我们需要计算每个数据点（拐点）的准确位置：</p><h3 id="3-计算折线上所有拐点的x，y值。"><a href="#3-计算折线上所有拐点的x，y值。" class="headerlink" title="3. 计算折线上所有拐点的x，y值。"></a>3. 计算折线上所有拐点的x，y值。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历图表里每条折线</span></span><br><span class="line"><span class="comment">//还记得chartData属性么？它是用来保存多组折线的数据的，在这里只有一个折线，所以这个循环只循环一次）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</span><br><span class="line">   <span class="comment">//保存每条折线上的所有点的CGPoint  </span></span><br><span class="line">   <span class="built_in">NSMutableArray</span> *linePointsArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    <span class="comment">//遍历每条折线里的每个点    </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//传入index，获取y值(调用的是上文提到的block)</span></span><br><span class="line">        yValue = chartData.getData(i).y;</span><br><span class="line">        <span class="comment">//当前点的x： _chartMarginLeft + _xLabelWidth / 2.0为0坐标，每多一个点就多一个_xLabelWidth</span></span><br><span class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) (i * _xLabelWidth + _chartMarginLeft + _xLabelWidth / <span class="number">2.0</span>);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//当前点的y：根据当前点的值和当前点所在的数组里的最大值的比例 以及 图表的总高度，算出当前点在图表里的y坐标</span></span><br><span class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>)[<span class="keyword">self</span> yValuePositionInLineChart:yValue];</span><br><span class="line">        <span class="comment">//保存所有拐点的坐标</span></span><br><span class="line">        [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//保存多条折线的CGPoint（这里只有一条折线，所以该数组只有一个元素）</span></span><br><span class="line">  [pathPoints addObject:[linePointsArray <span class="keyword">copy</span>]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里需要注意两点：</p><ol><li>这里的<code>pathPoints</code>对应的是<code>lineChart</code>的<code>_pathPoints</code>属性。它是一个二维数组，保存每条折线上所有点的<code>CGPoint</code>。</li><li>y值的计算：是需要从y的真实值转化为这个拐点在图表里的y坐标，转化方法的实现(仔细看几遍就懂了)：</li></ol></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)yValuePositionInLineChart:(<span class="built_in">CGFloat</span>)y &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> innerGrade;<span class="comment">//真实的最大值与最小值的差 与 当前点与最小值的差 的比值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!(_yValueMax - _yValueMin)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//特殊情况：当_yValueMax和_yValueMin相等的时候</span></span><br><span class="line">        innerGrade = <span class="number">0.5</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        innerGrade = ((<span class="built_in">CGFloat</span>) y - _yValueMin) / (_yValueMax - _yValueMin);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//innerGrade 与画布的高度（_chartCavanHeight）相乘，就能得出在画布中的高度</span></span><br><span class="line">    <span class="keyword">return</span> _chartCavanHeight - (innerGrade * _chartCavanHeight) - (_yLabelHeight / <span class="number">2</span>) + _chartMarginTop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"><a href="#4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）" class="headerlink" title="4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"></a>4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历图表里每条折线</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</span><br><span class="line">    <span class="comment">//每条折线所有圆圈的贝塞尔曲线</span></span><br><span class="line">    <span class="built_in">UIBezierPath</span> *pointPath = [<span class="built_in">UIBezierPath</span> bezierPath];    </span><br><span class="line">    <span class="comment">//inflexionWidth默认是6,是两个线段中间的距离（因为中间有一个圈圈，所以需要定一个距离）</span></span><br><span class="line">    <span class="built_in">CGFloat</span> inflexionWidth = chartData.inflexionPointWidth;</span><br><span class="line">    <span class="comment">//遍历每条折线里的每个点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;  </span><br><span class="line">        <span class="comment">//1. 计算圆圈的rect：已当前点为中心，以inflexionWidth为半径</span></span><br><span class="line">        <span class="built_in">CGRect</span> circleRect = <span class="built_in">CGRectMake</span>(x - inflexionWidth / <span class="number">2</span>, y - inflexionWidth / <span class="number">2</span>, inflexionWidth, inflexionWidth);    </span><br><span class="line">        <span class="comment">//2. 计算圆圈的中心：由圆圈的x，y和inflexionWidth算出</span></span><br><span class="line">        <span class="built_in">CGPoint</span> circleCenter = <span class="built_in">CGPointMake</span>(circleRect.origin.x + (circleRect.size.width / <span class="number">2</span>), circleRect.origin.y + (circleRect.size.height / <span class="number">2</span>));</span><br><span class="line">        <span class="comment">//3.1 移动到圆圈的右中部</span></span><br><span class="line">        [pointPath moveToPoint:<span class="built_in">CGPointMake</span>(circleCenter.x + (inflexionWidth / <span class="number">2</span>), circleCenter.y)];        </span><br><span class="line">        <span class="comment">//3.2 画线（圆形）</span></span><br><span class="line">        [pointPath addArcWithCenter:circleCenter radius:inflexionWidth / <span class="number">2</span> startAngle:<span class="number">0</span> endAngle:(<span class="built_in">CGFloat</span>) (<span class="number">2</span> * M_PI) clockwise:<span class="literal">YES</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存到pointsPath数组里</span></span><br><span class="line">    [pointsPath insertObject:pointPath atIndex:lineIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里，<code>pointsPath</code>对应的是<code>lineChart</code>的<code>_pointsPath</code>属性。它是一个一维数组，保存每条折线上的圆圈贝塞尔曲线（UIBezierPath）。</p></blockquote><h3 id="5-生成每个拐点上面的Label（可有可无）"><a href="#5-生成每个拐点上面的Label（可有可无）" class="headerlink" title="5. 生成每个拐点上面的Label（可有可无）"></a>5. 生成每个拐点上面的Label（可有可无）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历图表里每条折线</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</span><br><span class="line">    <span class="comment">//遍历每条折线里的每一段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (chartData.showPointLabel) &#123;</span><br><span class="line">            [gradePathArray addObject:[<span class="keyword">self</span> createPointLabelFor:chartData.getData(i).rawY pointCenter:circleCenter width:inflexionWidth withChartData:chartData]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，在这里，这些label的实现是通过一个<code>CATextLayer</code>实现的，并不是生成一个个<code>Label</code>放在数组里保存，具体实现方法如下：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CATextLayer</span> *)createPointLabelFor:(<span class="built_in">CGFloat</span>)grade pointCenter:(<span class="built_in">CGPoint</span>)pointCenter width:(<span class="built_in">CGFloat</span>)width withChartData:(PNLineChartData *)chartData &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//grade：提供textLayer显示的数值</span></span><br><span class="line">    <span class="comment">//pointCenter：根据pointCenter算出textLayer的x，y</span></span><br><span class="line">    <span class="comment">//width：根据width得到textLayer的总宽度</span></span><br><span class="line">    <span class="comment">//chartData：获取chartData里保存的textLayer上应该保存的字体大小和颜色</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CATextLayer</span> *textLayer = [[<span class="built_in">CATextLayer</span> alloc] init];</span><br><span class="line">    [textLayer setAlignmentMode:kCAAlignmentCenter];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置textLayer的背景色</span></span><br><span class="line">    [textLayer setForegroundColor:[chartData.pointLabelColor <span class="built_in">CGColor</span>]];</span><br><span class="line">    [textLayer setBackgroundColor:<span class="keyword">self</span>.backgroundColor.CGColor];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置textLayer的字体大小和颜色</span></span><br><span class="line">    <span class="keyword">if</span> (chartData.pointLabelFont != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [textLayer setFont:(__bridge <span class="built_in">CFTypeRef</span>) (chartData.pointLabelFont)];</span><br><span class="line">        textLayer.fontSize = [chartData.pointLabelFont pointSize];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置textLayer的高度</span></span><br><span class="line">    <span class="built_in">CGFloat</span> textHeight = (<span class="built_in">CGFloat</span>) (textLayer.fontSize * <span class="number">1.1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> textWidth = width * <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">CGFloat</span> textStartPosY;</span><br><span class="line">    </span><br><span class="line">    textStartPosY = pointCenter.y - textLayer.fontSize;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.layer addSublayer:textLayer];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置textLayer的文字显示格式</span></span><br><span class="line">    <span class="keyword">if</span> (chartData.pointLabelFormat != <span class="literal">nil</span>) &#123;</span><br><span class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:chartData.pointLabelFormat, grade]];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:_yLabelFormat, grade]];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置textLayer的位置和scale（1x，2x，3x）</span></span><br><span class="line">    [textLayer setFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, textWidth, textHeight)];</span><br><span class="line">    [textLayer setPosition:<span class="built_in">CGPointMake</span>(pointCenter.x, textStartPosY)];</span><br><span class="line">    textLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> textLayer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-计算每条线段的贝塞尔曲线（UIBezierPath）"><a href="#6-计算每条线段的贝塞尔曲线（UIBezierPath）" class="headerlink" title="6. 计算每条线段的贝塞尔曲线（UIBezierPath）"></a>6. 计算每条线段的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历图表里每条折线</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每一条线段的贝塞尔曲线（UIBezierPath），用数组装起来</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//chartPath（二维数组）：保存所有折线上所有线段的贝塞尔曲线。现在只有一条折线，所以只有一个元素</span></span><br><span class="line">    [chartPath insertObject:progressLines atIndex:lineIndex];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//progressLinePaths的每个元素是一个字典，字典里存放每一条线段的端点（from，to）</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *&gt; *progressLinePaths = [<span class="built_in">NSMutableArray</span> new];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> last_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> last_y = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历每条折线里的每一段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//x，y的算法参考上文第三项</span></span><br><span class="line">            <span class="comment">// 计算index为0以后的点的位置</span></span><br><span class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) sqrt(pow(x - last_x, <span class="number">2</span>) + pow(y - last_y, <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">float</span> last_x1 = last_x + (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</span><br><span class="line">            <span class="keyword">float</span> last_y1 = last_y + (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</span><br><span class="line">            <span class="keyword">float</span> x1 = x - (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</span><br><span class="line">            <span class="keyword">float</span> y1 = y - (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//当前线段的端点</span></span><br><span class="line">            from = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(last_x1, last_y1)];</span><br><span class="line">            to = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x1, y1)];</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(from != <span class="literal">nil</span> &amp;&amp; to != <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">//保存每一段的端点</span></span><br><span class="line">                [progressLinePaths addObject:@&#123;<span class="string">@"from"</span>: from,  <span class="string">@"to"</span>:to&#125;];</span><br><span class="line">                <span class="comment">//保存所有的端点</span></span><br><span class="line">                [lineStartEndPointsArray addObject:from];</span><br><span class="line">                [lineStartEndPointsArray addObject:to];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保存所有折点的坐标</span></span><br><span class="line">            [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</span><br><span class="line">            <span class="comment">//将当前的x转化为下一个点的last_x（y也一样）</span></span><br><span class="line">            last_x = x;</span><br><span class="line">            last_y = y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pointsOfPath：保存所有折线里的所有线段两端的端点</span></span><br><span class="line">    [pointsOfPath addObject:[lineStartEndPointsArray <span class="keyword">copy</span>]];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据每一条线段的两个端点，成生每条线段的贝塞尔曲线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *calculatedRanges =</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">            [currentProgressLine moveToPoint:[range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>]];</span><br><span class="line">            [currentProgressLine addLineToPoint:[range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>]];</span><br><span class="line">            [progressLines addObject:currentProgressLine];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"><a href="#7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。" class="headerlink" title="7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"></a>7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</h3><h4 id="7-1-所有线段的layer："><a href="#7-1-所有线段的layer：" class="headerlink" title="7.1 所有线段的layer："></a>7.1 所有线段的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)populateChartLines &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历每条线段</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = <span class="keyword">self</span>.chartPath[lineIndex];</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//_chartLineArray:二维数组，装载每个chartData对应的一个数组。这个数组的元素是这一条折线上所有线段对应的CAShapeLayer</span></span><br><span class="line">        [<span class="keyword">self</span>.chartLineArray[lineIndex] removeAllObjects];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSUInteger</span> progressLineIndex = <span class="number">0</span>;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历含有UIBezierPath对象元素的数组。在每个循环里新建一个CAShapeLayer对象，将UIBezierPath赋给它。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *progressLinePath <span class="keyword">in</span> progressLines) &#123;</span><br><span class="line">            </span><br><span class="line">            PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</span><br><span class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">            </span><br><span class="line">            ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将当前线段的UIBezierPath赋给当前线段的CAShapeLayer</span></span><br><span class="line">            chartLine.path = progressLinePath.CGPath;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//添加layer</span></span><br><span class="line">            [<span class="keyword">self</span>.layer addSublayer:chartLine];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//保存当前线段的layer</span></span><br><span class="line">            [<span class="keyword">self</span>.chartLineArray[lineIndex] addObject:chartLine];</span><br><span class="line">            progressLineIndex++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-所有圆圈的layer："><a href="#7-2-所有圆圈的layer：" class="headerlink" title="7.2 所有圆圈的layer："></a>7.2 所有圆圈的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)recreatePointLayers &#123;</span><br><span class="line">- </span><br><span class="line">    <span class="keyword">for</span> (PNLineChartData *chartData <span class="keyword">in</span> _chartData) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// create as many chart line layers as there are data-lines</span></span><br><span class="line">        [<span class="keyword">self</span>.chartLineArray addObject:[<span class="built_in">NSMutableArray</span> new]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create point</span></span><br><span class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = [<span class="built_in">CAShapeLayer</span> layer];</span><br><span class="line">        pointLayer.strokeColor = [[chartData.color colorWithAlphaComponent:chartData.alpha] <span class="built_in">CGColor</span>];</span><br><span class="line">        pointLayer.lineCap = kCALineCapRound;</span><br><span class="line">        pointLayer.lineJoin = kCALineJoinBevel;</span><br><span class="line">        pointLayer.fillColor = <span class="literal">nil</span>;</span><br><span class="line">        pointLayer.lineWidth = chartData.lineWidth;</span><br><span class="line">        [<span class="keyword">self</span>.layer addSublayer:pointLayer];</span><br><span class="line">        [<span class="keyword">self</span>.chartPointArray addObject:pointLayer];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里并没有将所有圆圈的<code>UIBezierPath</code>赋给对应的<code>layer</code>，而是在下一步，绘图的时候做的。</p></blockquote><h3 id="8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画"><a href="#8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画" class="headerlink" title="8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画"></a>8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)strokeChart &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绘制所有折线（所有线段+所有圆圈）</span></span><br><span class="line">    <span class="comment">// 遍历所有折线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</span><br><span class="line">       </span><br><span class="line">        PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前折线的所有线段的CAShapeLayer</span></span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">CAShapeLayer</span> *&gt; *chartLines =<span class="keyword">self</span>.chartLineArray[lineIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前折线的所有圆圈的CAShapeLayer</span></span><br><span class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = (<span class="built_in">CAShapeLayer</span> *) <span class="keyword">self</span>.chartPointArray[lineIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//开始绘制折线</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="keyword">self</span>.frame.size);</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前折线的所有线段的UIBezierPath</span></span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = _chartPath[lineIndex];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//当前折线的所有圆圈的UIBezierPath</span></span><br><span class="line">        <span class="built_in">UIBezierPath</span> *pointPath = _pointPath[lineIndex];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.2将圆圈的UIBezierPath赋给了圆圈的CAShapeLayer</span></span><br><span class="line">        pointLayer.path = pointPath.CGPath;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加动画</span></span><br><span class="line">        [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; progressLines.count; index++) &#123;</span><br><span class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = chartLines[index];</span><br><span class="line">            <span class="comment">//chartLine strokeColor is already set. no need to override here</span></span><br><span class="line">            [chartLine addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</span><br><span class="line">            chartLine.strokeEnd = <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if you want cancel the point animation, comment this code, the point will show immediately</span></span><br><span class="line">        <span class="keyword">if</span> (chartData.inflexionPointStyle != PNLineChartPointStyleNone) &#123;</span><br><span class="line">            [pointLayer addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交动画</span></span><br><span class="line">        [<span class="built_in">CATransaction</span> commit];</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制完毕</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意两点：</p><blockquote><p>1.如果想给layer添加动画，只需要实例化一个animation（在这里是<code>CABasicAnimation</code>）并调用layer的<code>addAnimation:</code>方法即可。我们看一下关于<code>CABasicAnimation</code>的实例化代码：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CABasicAnimation</span> *)pathAnimation &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.displayAnimated &amp;&amp; !_pathAnimation) &#123;</span><br><span class="line">        _pathAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</span><br><span class="line">        <span class="comment">//持续时间</span></span><br><span class="line">        _pathAnimation.duration = <span class="number">1.0</span>;</span><br><span class="line">         <span class="comment">//类型</span></span><br><span class="line">        _pathAnimation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</span><br><span class="line">        _pathAnimation.fromValue = @<span class="number">0.0</span>f;</span><br><span class="line">        _pathAnimation.toValue = @<span class="number">1.0</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">self</span>.displayAnimated) &#123;</span><br><span class="line">        _pathAnimation = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _pathAnimation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>2.在这里调用了<code>setNeedsDisplay</code>方法之后，会调用<code>drawRect：</code>方法，在这个方法里，完成了x，y坐标轴的绘制：</p></blockquote><h3 id="10-绘制x，y坐标轴"><a href="#10-绘制x，y坐标轴" class="headerlink" title="10.绘制x，y坐标轴"></a>10.绘制x，y坐标轴</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制坐标轴和背景竖线</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isShowCoordinateAxis) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGFloat</span> yAxisOffset = <span class="number">10.</span>f;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsPopContext</span>();</span><br><span class="line">        <span class="built_in">UIGraphicsPushContext</span>(ctx);</span><br><span class="line">        <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="keyword">self</span>.axisWidth);</span><br><span class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="keyword">self</span>.axisColor <span class="built_in">CGColor</span>]);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGFloat</span> xAxisWidth = <span class="built_in">CGRectGetWidth</span>(rect) - (_chartMarginLeft + _chartMarginRight) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> yAxisHeight = _chartMarginBottom + _chartCavanHeight;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制xy轴</span></span><br><span class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, yAxisHeight);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</span><br><span class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制y轴的箭头</span></span><br><span class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset - <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset + <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制x轴的箭头</span></span><br><span class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight - <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</span><br><span class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight + <span class="number">3</span>);</span><br><span class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//绘制x轴和y轴的label</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.showLabel) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 绘制x轴的小分割线</span></span><br><span class="line">            <span class="built_in">CGPoint</span> point;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</span><br><span class="line">                point = <span class="built_in">CGPointMake</span>(<span class="number">2</span> * _chartMarginLeft + (i * _xLabelWidth), _chartMarginBottom + _chartCavanHeight);</span><br><span class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y - <span class="number">2</span>);</span><br><span class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x, point.y);</span><br><span class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 绘制y轴的小分割线</span></span><br><span class="line">            <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</span><br><span class="line">                point = <span class="built_in">CGPointMake</span>(_chartMarginBottom + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</span><br><span class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</span><br><span class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x + <span class="number">2</span>, point.y);</span><br><span class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">11</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制y轴单位</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.yUnit length]) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.yUnit withWidth:<span class="number">30.</span>f font:font].height;</span><br><span class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(_chartMarginLeft + <span class="number">10</span> + <span class="number">5</span>, <span class="number">0</span>, <span class="number">30.</span>f, height);</span><br><span class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.yUnit inRect:drawRect font:font color:<span class="keyword">self</span>.yLabelColor];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制x轴的单位</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.xUnit length]) &#123;</span><br><span class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.xUnit withWidth:<span class="number">30.</span>f font:font].height;</span><br><span class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, _chartMarginBottom + _chartCavanHeight - height / <span class="number">2</span>, <span class="number">25.</span>f, height);</span><br><span class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.xUnit inRect:drawRect font:font color:<span class="keyword">self</span>.xLabelColor];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//绘制竖线</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.showYGridLines) &#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="built_in">CGFloat</span> yAxisOffset = _showLabel ? <span class="number">10.</span>f : <span class="number">0.0</span>f;</span><br><span class="line">        <span class="built_in">CGPoint</span> point;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//每一条竖线的跨度</span></span><br><span class="line">        <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//颜色</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.yGridLinesColor) &#123;</span><br><span class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, <span class="keyword">self</span>.yGridLinesColor.CGColor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> lightGrayColor].CGColor);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//绘制每一条竖线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; _yLabelNum; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//拿到起点</span></span><br><span class="line">            point = <span class="built_in">CGPointMake</span>(_chartMarginLeft + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//将画笔移动到起点</span></span><br><span class="line">            <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//设置线的属性</span></span><br><span class="line">            <span class="built_in">CGFloat</span> dash[] = &#123;<span class="number">6</span>, <span class="number">5</span>&#125;;</span><br><span class="line">            <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">0.5</span>);</span><br><span class="line">            <span class="built_in">CGContextSetLineCap</span>(ctx, kCGLineCapRound);</span><br><span class="line">            <span class="built_in">CGContextSetLineDash</span>(ctx, <span class="number">0.0</span>, dash, <span class="number">2</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//设置这条线的终点</span></span><br><span class="line">            <span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, point.y);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//画线</span></span><br><span class="line">            <span class="built_in">CGContextStrokePath</span>(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，一张完整的图表就可以画出来了。但是当前绘制的图表的折线都是直线，在上面还展示了一张曲线图。那么如果想绘制带有曲线的折线图应该怎么做呢？对，就是在贝塞尔曲线上下功夫。</p><p>当我们获取了所有线段的端点数组后，我们可以通过他们绘制弯曲的贝塞尔曲线（注意：该方法是对应上面对第6项的下半部分:生成每一个线段对贝塞尔曲线）：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//_showSmoothLines是用来控制是否绘制曲线折线的开关属性</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.showSmoothLines &amp;&amp; chartData.itemCount &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</span><br><span class="line">            <span class="built_in">CGPoint</span> segmentP1 = [range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">            <span class="built_in">CGPoint</span> segmentP2 = [range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">            </span><br><span class="line">            [currentProgressLine moveToPoint:segmentP1];</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGPoint</span> midPoint = [PNLineChart midPointBetweenPoint1:segmentP1 andPoint2:segmentP2];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//以每条线段以中间点为分割点，分成两组。每一组形成柔和的外凸曲线，而不是内凹</span></span><br><span class="line">            [currentProgressLine addQuadCurveToPoint:midPoint</span><br><span class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP1]];</span><br><span class="line">            </span><br><span class="line">            [currentProgressLine addQuadCurveToPoint:segmentP2</span><br><span class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP2]];</span><br><span class="line">            </span><br><span class="line">            [progressLines addObject:currentProgressLine];</span><br><span class="line">            [progressLineColors addObject:range[<span class="string">@"color"</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意一下生成弯曲的贝塞尔曲线的方法：<code>controlPointBetweenPoint1:andPoint2</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回的点的x：是两点的中间；返回的点的y：与第二个点保持一致</span></span><br><span class="line">+ (<span class="built_in">CGPoint</span>)controlPointBetweenPoint1:(<span class="built_in">CGPoint</span>)point1 andPoint2:(<span class="built_in">CGPoint</span>)point2 &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线段两端的中间点</span></span><br><span class="line">    <span class="built_in">CGPoint</span> controlPoint = [<span class="keyword">self</span> midPointBetweenPoint1:point1 andPoint2:point2];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//末端点 和  中间点y的差</span></span><br><span class="line">    <span class="built_in">CGFloat</span> diffY = abs((<span class="keyword">int</span>) (point2.y - controlPoint.y));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (point1.y &lt; point2.y)</span><br><span class="line">    <span class="comment">//如果前端点更高</span></span><br><span class="line">        controlPoint.y += diffY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (point1.y &gt; point2.y)</span><br><span class="line">    <span class="comment">//如果后端点更高</span></span><br><span class="line">        controlPoint.y -= diffY;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> controlPoint;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，这样一来，直线的曲线图还有曲线的曲线图就大概掌握了。不过还差一个东西，就是图表对点击的响应。</p><p>我们需要思考一下：既然一张图表里可以显示多条折线，所以，当手指点击图表上的点以后，应该同时返回两个数据：</p><ol><li>点击了哪条折线上的这个点。</li><li>点击了这条折线上的哪个点。</li></ol><p>该框架的作者很好地完成了这两个任务，我们来看一下他是如何实现的：</p><h3 id="响应点击的代理方法"><a href="#响应点击的代理方法" class="headerlink" title="响应点击的代理方法"></a>响应点击的代理方法</h3><h4 id="点击了哪条折线的判断"><a href="#点击了哪条折线的判断" class="headerlink" title="点击了哪条折线的判断"></a>点击了哪条折线的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// Get the point user touched</span></span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSArray</span> *linePointsArray = _endPointsOfPath[p];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历每个端点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</span><br><span class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Closest distance from point to line</span></span><br><span class="line">            <span class="comment">//触摸点到线段的距离</span></span><br><span class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) fabs(((p2.x - p1.x) * (touchPoint.y - p1.y)) - ((p1.x - touchPoint.x) * (p1.y - p2.y)));</span><br><span class="line">            distance /= hypot(p2.x - p1.x, p1.y - p2.y);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果距离小于5，则判断为“点击了当前的线段”，剩下的工作是判断具体点击了哪一条线段</span></span><br><span class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">5.0</span>) &#123;</span><br><span class="line">                <span class="comment">// Conform to delegate parameters, figure out what bezier path this CGPoint belongs to.</span></span><br><span class="line">                <span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *paths <span class="keyword">in</span> _chartPath) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *path <span class="keyword">in</span> paths) &#123;</span><br><span class="line">                        <span class="comment">//如果当前点处于UIBezierPath曲线上</span></span><br><span class="line">                        <span class="built_in">BOOL</span> pointContainsPath = <span class="built_in">CGPathContainsPoint</span>(path.CGPath, <span class="literal">NULL</span>, p1, <span class="literal">NO</span>);</span><br><span class="line">                        <span class="keyword">if</span> (pointContainsPath) &#123;</span><br><span class="line">                            <span class="comment">//点击了某一条折线</span></span><br><span class="line">                            [_delegate userClickedOnLinePoint:touchPoint lineIndex:lineIndex];</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    lineIndex++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="点击了哪个点的判断"><a href="#点击了哪个点的判断" class="headerlink" title="点击了哪个点的判断"></a>点击了哪个点的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchKeyPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="comment">// Get the point user touched</span></span><br><span class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</span><br><span class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *linePointsArray = _pathPoints[p];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历所有的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</span><br><span class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//获取到前一点的距离和后一点的距离</span></span><br><span class="line">            <span class="keyword">float</span> distanceToP1 = (<span class="keyword">float</span>) fabs(hypot(touchPoint.x - p1.x, touchPoint.y - p1.y));</span><br><span class="line">            <span class="keyword">float</span> distanceToP2 = (<span class="keyword">float</span>) hypot(touchPoint.x - p2.x, touchPoint.y - p2.y);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">float</span> distance = MIN(distanceToP1, distanceToP2);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果较小的距离小于10，则判定为点击了某个点</span></span><br><span class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">10.0</span>) &#123;</span><br><span class="line">                <span class="comment">//点击了某一条折线上的某个点</span></span><br><span class="line">                [_delegate userClickedOnLineKeyPoint:touchPoint</span><br><span class="line">                                           lineIndex:p</span><br><span class="line">                                          pointIndex:(distance == distanceToP2 ? i + <span class="number">1</span> : i)];</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下就完整了，一个带有响应功能的图表就做好啦！</p><h3 id="关于自定义UIView"><a href="#关于自定义UIView" class="headerlink" title="关于自定义UIView"></a>关于自定义UIView</h3><p>这里只是将图表的<code>layer</code>加在了<code>UIView</code>的layer上，那如果想完全自定义view的话，只需将图表的<code>layer</code>完全赋给<code>UIView</code>的layer即可，这样一来，想要画出任意形状的<code>UIView</code>都可以。</p><hr><h2 id="三-最后的话"><a href="#三-最后的话" class="headerlink" title="三. 最后的话"></a>三. 最后的话</h2><p>关于图表的绘制，相对贝塞尔曲线与<code>CALayer</code>来说，数据的处理是一个比较麻烦的点。但是一旦学会了折线图的绘制，了解了绘图原理，那么其他类型的图表就可以触类旁通。</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-框架介绍&quot;&gt;&lt;a href=&quot;#一-框架介绍&quot; class=&quot;headerlink&quot; title=&quot;一. 框架介绍&quot;&gt;&lt;/a&gt;一. 框架介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kevinzhow/PNChart&quot;&gt;PNChart&lt;/a&gt;是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。&lt;/p&gt;
&lt;p&gt;该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类&lt;code&gt;PNGenericChart&lt;/code&gt;,第二层就是所有类型的图表。提供一张图来直观感受一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png&quot; alt=&quot;层级图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这张图里，需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带箭头的线和不带箭头的线的区别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data&lt;/code&gt;类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有&lt;code&gt;Data&lt;/code&gt;类，因为饼状图没有多组数据，而折线图&lt;code&gt;LineChart&lt;/code&gt;是支持多组数据的，所以有&lt;code&gt;Data&lt;/code&gt;类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Item&lt;/code&gt;类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BarChart&lt;/code&gt;类里面的每一根柱子都是&lt;code&gt;PNBar&lt;/code&gt;的实例（该类型的图表不在本篇讲解的范围之内）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MJRefresh源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/MJRefresh%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/MJRefresh 源码解析/</id>
    <published>2018-02-02T16:17:40.000Z</published>
    <updated>2018-07-16T16:46:47.506Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a>是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。</p><p>该框架的结构设计得很清晰，使用一个基类<code>MJRefreshComponent</code>来做一些基本的设定，然后通过继承的方式，让<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png" alt="框架组织结构图"></p><a id="more"></a><p>首先来看一下该控件的基类：MJRefreshComponent：</p><h2 id="MJRefreshComponent"><a href="#MJRefreshComponent" class="headerlink" title="MJRefreshComponent"></a>MJRefreshComponent</h2><p>这个类作为该控件几类，涵盖了基类所具备的成份：状态，回调block等，大致分成下面这5种职能：</p><h3 id="有哪些职能"><a href="#有哪些职能" class="headerlink" title="有哪些职能?"></a>有哪些职能?</h3><ol><li>声明控件的所有状态。</li><li>声明控件的回调函数。</li><li>添加监听。</li><li>提供刷新，停止刷新接口。</li><li>提供子类需要实现的方法。</li></ol><h3 id="职能如何实现？"><a href="#职能如何实现？" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><h4 id="1-声明控件的所有状态"><a href="#1-声明控件的所有状态" class="headerlink" title="1. 声明控件的所有状态"></a>1. 声明控件的所有状态</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 刷新控件的状态 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, MJRefreshState) &#123;</span><br><span class="line">    <span class="comment">/** 普通闲置状态 */</span></span><br><span class="line">    MJRefreshStateIdle = <span class="number">1</span>,</span><br><span class="line">    <span class="comment">/** 松开就可以进行刷新的状态 */</span></span><br><span class="line">    MJRefreshStatePulling,</span><br><span class="line">    <span class="comment">/** 正在刷新中的状态 */</span></span><br><span class="line">    MJRefreshStateRefreshing,</span><br><span class="line">    <span class="comment">/** 即将刷新的状态 */</span></span><br><span class="line">    MJRefreshStateWillRefresh,</span><br><span class="line">    <span class="comment">/** 所有数据加载完毕，没有更多的数据了 */</span></span><br><span class="line">    MJRefreshStateNoMoreData</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-声明控件的回调函数"><a href="#2-声明控件的回调函数" class="headerlink" title="2. 声明控件的回调函数"></a>2. 声明控件的回调函数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 进入刷新状态的回调 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentRefreshingBlock)();</span><br><span class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentbeginRefreshingCompletionBlock)();</span><br><span class="line"><span class="comment">/** 结束刷新后的回调 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentEndRefreshingCompletionBlock)();</span><br></pre></td></tr></table></figure><h4 id="3-添加监听"><a href="#3-添加监听" class="headerlink" title="3. 添加监听"></a>3. 添加监听</h4><p>监听的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addObservers</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset options:options context:<span class="literal">nil</span>];<span class="comment">//contentOffset属性</span></span><br><span class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize options:options context:<span class="literal">nil</span>];<span class="comment">//contentSize属性</span></span><br><span class="line">    <span class="keyword">self</span>.pan = <span class="keyword">self</span>.scrollView.panGestureRecognizer;</span><br><span class="line">    [<span class="keyword">self</span>.pan addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState options:options context:<span class="literal">nil</span>];<span class="comment">//UIPanGestureRecognizer 的state属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于监听的处理：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 遇到这些情况就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个就算看不见也需要处理</span></span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewContentSizeDidChange:change];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看不见</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hidden) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewContentOffsetDidChange:change];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> scrollViewPanStateDidChange:change];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-提供刷新，停止刷新接口"><a href="#4-提供刷新，停止刷新接口" class="headerlink" title="4. 提供刷新，停止刷新接口"></a>4. 提供刷新，停止刷新接口</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark 进入刷新状态</span></span><br><span class="line">- (<span class="keyword">void</span>)beginRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.beginRefreshingCompletionBlock = completionBlock;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> beginRefreshing];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)beginRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class="line">        <span class="keyword">self</span>.alpha = <span class="number">1.0</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">self</span>.pullingPercent = <span class="number">1.0</span>;</span><br><span class="line">    <span class="comment">// 只要正在刷新，就完全显示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.window) &#123;</span><br><span class="line">        <span class="comment">//将状态切换为正在刷新</span></span><br><span class="line">        <span class="keyword">self</span>.state = MJRefreshStateRefreshing;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 预防正在刷新中时，调用本方法使得header inset回置失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateRefreshing) &#123;</span><br><span class="line">            <span class="comment">//将状态切换为即将刷新</span></span><br><span class="line">            <span class="keyword">self</span>.state = MJRefreshStateWillRefresh;</span><br><span class="line">            <span class="comment">// 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</span></span><br><span class="line">            [<span class="keyword">self</span> setNeedsDisplay];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark 结束刷新状态</span></span><br><span class="line">- (<span class="keyword">void</span>)endRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.state = MJRefreshStateIdle;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)endRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.endRefreshingCompletionBlock = completionBlock;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> endRefreshing];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#pragma mark 是否正在刷新</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isRefreshing</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == MJRefreshStateRefreshing || <span class="keyword">self</span>.state == MJRefreshStateWillRefresh;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交给子类实现的方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 摆放子控件frame */</span></span><br><span class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br></pre></td></tr></table></figure><h4 id="5-提供子类需要实现的方法"><a href="#5-提供子类需要实现的方法" class="headerlink" title="5. 提供子类需要实现的方法"></a>5. 提供子类需要实现的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#pragma mark - 交给子类们去实现</span></span><br><span class="line"><span class="comment">/** 初始化 */</span></span><br><span class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 摆放子控件frame */</span></span><br><span class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br><span class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</span><br></pre></td></tr></table></figure><p>从上面等结构图可以看出，紧接着这个基类，下面分为<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>,这里顺着<code>MJRefreshHeader</code>这个分支向下展开：</p><h2 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h2><p><code>MJRefreshHeader</code>继承于<code>MJRefreshComponent</code>，它做了这几件事：</p><h3 id="有哪些职能？"><a href="#有哪些职能？" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol><li>初始化。</li><li>设置header高度。</li><li>重新调整y值。</li><li>根据<code>contentOffset</code>的变化，来切换状态（默认状态，可以刷新的状态，正在刷新的状态），实现方法是：<code>scrollViewContentOffsetDidChange:</code>。</li><li>在切换状态时，执行相应的操作。实现方法是：<code>setState:</code>。</li></ol><h3 id="职能如何实现？-1"><a href="#职能如何实现？-1" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化</p><p>初始化有两种方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    <span class="comment">//传入block</span></span><br><span class="line">    cmp.refreshingBlock = refreshingBlock;</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingTarget:(<span class="keyword">id</span>)target refreshingAction:(SEL)action</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    <span class="comment">//设置self.refreshingTarget 和 self.refreshingAction</span></span><br><span class="line">    [cmp setRefreshingTarget:target refreshingAction:action];</span><br><span class="line">    <span class="keyword">return</span> cmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-设置header高度"><a href="#2-设置header高度" class="headerlink" title="2. 设置header高度"></a>2. 设置header高度</h4><p>通过重写<code>prepare</code>方法来设置header的高度：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置用于在NSUserDefaults里存储时间的key</span></span><br><span class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置header的高度</span></span><br><span class="line">    <span class="keyword">self</span>.mj_h = MJRefreshHeaderHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-重新调整y值"><a href="#3-重新调整y值" class="headerlink" title="3. 重新调整y值"></a>3. 重新调整y值</h4><p>通过重写<code>placeSubviews</code>方法来重新调整y值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)placeSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> placeSubviews];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)</span></span><br><span class="line">    <span class="keyword">self</span>.mj_y = - <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.ignoredScrollViewContentInsetTop;</span><br><span class="line">    <span class="comment">//self.ignoredScrollViewContentInsetTop 如果是10，那么就向上移动10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="4-状态切换的代码："><a href="#4-状态切换的代码：" class="headerlink" title="4. 状态切换的代码："></a>4. 状态切换的代码：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> scrollViewContentOffsetDidChange:change];</span><br><span class="line">    <span class="comment">// 正在刷新的状态</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateRefreshing) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.window == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//- self.scrollView.mj_offsetY：-（-54-64）= 118 ： 刷新的时候，偏移量是不动的。偏移量 = 状态栏 + 导航栏 + header的高度</span></span><br><span class="line">        <span class="comment">//_scrollViewOriginalInset.top：64 （状态栏 + 导航栏）</span></span><br><span class="line">        <span class="comment">//insetT 取二者之间大的那一个</span></span><br><span class="line">        <span class="built_in">CGFloat</span> insetT = - <span class="keyword">self</span>.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - <span class="keyword">self</span>.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//118</span></span><br><span class="line">        insetT = insetT &gt; <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top ? <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top : insetT;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置contentInset</span></span><br><span class="line">        <span class="keyword">self</span>.scrollView.mj_insetT = insetT;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 记录刷新的时候的偏移量 -54 = 64 - 118</span></span><br><span class="line">        <span class="keyword">self</span>.insetTDelta = _scrollViewOriginalInset.top - insetT;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳转到下一个控制器时，contentInset可能会变</span></span><br><span class="line">     _scrollViewOriginalInset = <span class="keyword">self</span>.scrollView.contentInset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录当前的contentOffset</span></span><br><span class="line">    <span class="built_in">CGFloat</span> offsetY = <span class="keyword">self</span>.scrollView.mj_offsetY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 头部控件刚好全部出现的offsetY,默认是-64（20 + 44）</span></span><br><span class="line">    <span class="built_in">CGFloat</span> happenOffsetY = - <span class="keyword">self</span>.scrollViewOriginalInset.top;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向上滚动，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (offsetY &gt; happenOffsetY) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从普通 到 即将刷新 的临界距离</span></span><br><span class="line">    <span class="built_in">CGFloat</span> normal2pullingOffsetY = happenOffsetY - <span class="keyword">self</span>.mj_h;<span class="comment">// -64 - 54 = -118</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//下拉的百分比：下拉的距离与header高度的比值</span></span><br><span class="line">    <span class="built_in">CGFloat</span> pullingPercent = (happenOffsetY - offsetY) / <span class="keyword">self</span>.mj_h;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollView.isDragging) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//记录当前下拉的百分比</span></span><br><span class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</span><br><span class="line">            <span class="comment">// 如果当前为默认状态 &amp;&amp; 下拉的距离大于临界距离（将tableview下拉得很低），则将状态切换为可以刷新</span></span><br><span class="line">            <span class="keyword">self</span>.state = MJRefreshStatePulling;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</span><br><span class="line">            <span class="comment">// 如果当前状态为可以刷新 &amp;&amp; 下拉的距离小于临界距离，则将状态切换为默认</span></span><br><span class="line">            <span class="keyword">self</span>.state = MJRefreshStateIdle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling) &#123;<span class="comment">// 即将刷新 &amp;&amp; 手松开</span></span><br><span class="line">        <span class="comment">// 手松开 &amp;&amp; 状态为可以刷新（MJRefreshStatePulling）时 开始刷新</span></span><br><span class="line">        [<span class="keyword">self</span> beginRefreshing];        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pullingPercent &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//手松开后，默认状态时，恢复self.pullingPercent</span></span><br><span class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意三点：</p><ol><li>这里的状态有三种：默认状态（MJRefreshStateIdle），可以刷新的状态（MJRefreshStatePulling）以及正在刷新的状态（MJRefreshStateRefreshing）。</li><li>状态切换的因素有两个：一个是下拉的距离是否超过临界值，另一个是 手指是否离开屏幕。</li><li>注意:<strong>可以刷新的状态</strong>和<strong>正在刷新的状态</strong>是不同的。因为在手指还贴在屏幕的时候是不能进行刷新的。所以即使在下拉的距离超过了临界距离（状态栏 + 导航栏 + header高度），如果手指没有离开屏幕，那么也不能马上进行刷新，而是将状态切换为：可以刷新。一旦手指离开了屏幕，马上将状态切换为正在刷新。 </li></ol></blockquote><p>这里提供一张图来体现三个状态的不同：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_2.png" alt="三个状态"></p><h4 id="5-状态切换时的相应操作："><a href="#5-状态切换时的相应操作：" class="headerlink" title="5. 状态切换时的相应操作："></a>5. 状态切换时的相应操作：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//============== 设置状态为默认状态 =============//</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果当前不是正在刷新就返回，因为这个方法主要针对从正在刷新状态（oldstate）到默认状态</span></span><br><span class="line">        <span class="keyword">if</span> (oldState != MJRefreshStateRefreshing) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//刷新完成后，保存刷新完成的时间</span></span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:[<span class="built_in">NSDate</span> date] forKey:<span class="keyword">self</span>.lastUpdatedTimeKey];</span><br><span class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 恢复inset和offset</span></span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//118 -&gt; 64（剪去了header的高度）</span></span><br><span class="line">            <span class="keyword">self</span>.scrollView.mj_insetT += <span class="keyword">self</span>.insetTDelta;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 自动调整透明度</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.isAutomaticallyChangeAlpha) <span class="keyword">self</span>.alpha = <span class="number">0.0</span>;</span><br><span class="line">            </span><br><span class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">self</span>.pullingPercent = <span class="number">0.0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.endRefreshingCompletionBlock) &#123;</span><br><span class="line">                <span class="comment">//调用刷新完成的block</span></span><br><span class="line">                <span class="keyword">self</span>.endRefreshingCompletionBlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</span><br><span class="line">        </span><br><span class="line">         <span class="comment">//============== 设置状态为正在刷新状态 =============//</span></span><br><span class="line">         <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            </span><br><span class="line">             [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class="line">               </span><br><span class="line">                <span class="built_in">CGFloat</span> top = <span class="keyword">self</span>.scrollViewOriginalInset.top + <span class="keyword">self</span>.mj_h;<span class="comment">//64 + 54 (都是默认的高度)</span></span><br><span class="line">                <span class="comment">// 重新设置contentInset，top = 118</span></span><br><span class="line">                <span class="keyword">self</span>.scrollView.mj_insetT = top;</span><br><span class="line">                <span class="comment">// 设置滚动位置</span></span><br><span class="line">                [<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, -top) animated:<span class="literal">NO</span>];</span><br><span class="line">                 </span><br><span class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                <span class="comment">//调用进行刷新的block</span></span><br><span class="line">                [<span class="keyword">self</span> executeRefreshingCallback];</span><br><span class="line">            &#125;];</span><br><span class="line">         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要注意两点：</p><ol><li>这里状态的切换，主要围绕着两种：默认状态和正在刷新状态。也就是针对<strong>开始刷新</strong>和<strong>结束刷新</strong>这两个切换点。</li><li>从正在刷新状态状态切换为默认状态时（结束刷新），需要记录刷新结束的时间。因为header里面有一个默认的label是用来显示上次刷新的时间的。</li></ol></blockquote><h2 id="MJRefreshStateHeader"><a href="#MJRefreshStateHeader" class="headerlink" title="MJRefreshStateHeader"></a>MJRefreshStateHeader</h2><p>这个类是<code>MJRefreshHeader</code>类的子类，它做了两件事：</p><h3 id="有哪些职能？-1"><a href="#有哪些职能？-1" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol><li>简单布局了<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>。</li><li>根据控件状态的切换（默认状态，正在刷新状态），实现了这两个label显示的文字的切换。</li></ol><p>给一张图，让大家直观感受一下这两个控件：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_3.png" alt="两个Label"></p><h3 id="职能如何实现？-2"><a href="#职能如何实现？-2" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>这个类通过覆盖父类三个方法来实现上述两个实现：</p><h4 id="方法1：prepare方法"><a href="#方法1：prepare方法" class="headerlink" title="方法1：prepare方法"></a>方法1：prepare方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化间距</span></span><br><span class="line">    <span class="keyword">self</span>.labelLeftInset = MJRefreshLabelLeftInset;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化文字</span></span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];</span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];</span><br><span class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里，将每一个状态对应的提示文字放入一个字典里面,key是状态的NSNumber形式</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (title == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">self</span>.stateTitles[@(state)] = title;</span><br><span class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(<span class="keyword">self</span>.state)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：placeSubviews方法"><a href="#方法2：placeSubviews方法" class="headerlink" title="方法2：placeSubviews方法"></a>方法2：placeSubviews方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)placeSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> placeSubviews];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> noConstrainsOnStatusLabel = <span class="keyword">self</span>.stateLabel.constraints.count == <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果更新时间label是隐藏的，则让状态label撑满整个header</span></span><br><span class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) <span class="keyword">self</span>.stateLabel.frame = <span class="keyword">self</span>.bounds;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果更新时间label不是隐藏的，根据约束设置更新时间label和状态label（高度各占一半）</span></span><br><span class="line">        <span class="built_in">CGFloat</span> stateLabelH = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) &#123;</span><br><span class="line">            <span class="keyword">self</span>.stateLabel.mj_x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">self</span>.stateLabel.mj_y = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">self</span>.stateLabel.mj_w = <span class="keyword">self</span>.mj_w;</span><br><span class="line">            <span class="keyword">self</span>.stateLabel.mj_h = stateLabelH;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新时间label</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.constraints.count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y = stateLabelH;</span><br><span class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_w = <span class="keyword">self</span>.mj_w;</span><br><span class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_h = <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里主要是对<code>lastUpdatedTimeLabel</code>和<code>stateLabel</code>进行布局。要注意<code>lastUpdatedTimeLabel</code>隐藏的情况。</p></blockquote><h4 id="方法3-setState-方法"><a href="#方法3-setState-方法" class="headerlink" title="方法3: setState:方法"></a>方法3: setState:方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置状态文字</span></span><br><span class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(state)];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新设置key（重新显示时间）</span></span><br><span class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = <span class="keyword">self</span>.lastUpdatedTimeKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里，根据传入的state的不同，在<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>里切换相应的文字。</p><ul><li><code>stateLabel</code>里的文字直接从<code>stateTitles</code>字典里取出即可。</li><li><code>lastUpdatedTimeLabel</code>里的文字需要通过一个方法来取出即可：</li></ul></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setLastUpdatedTimeKey:(<span class="built_in">NSString</span> *)lastUpdatedTimeKey</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> setLastUpdatedTimeKey:lastUpdatedTimeKey];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果label隐藏了，就不用再处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据key，从NSUserDefaults获取对应的NSData型时间</span></span><br><span class="line">    <span class="built_in">NSDate</span> *lastUpdatedTime = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:lastUpdatedTimeKey];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果有block，从block里拿来时间，这应该是用户自定义显示时间格式的渠道</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeText) &#123;</span><br><span class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = <span class="keyword">self</span>.lastUpdatedTimeText(lastUpdatedTime);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果没有block，就按照下面的默认方法显示时间格式</span></span><br><span class="line">    <span class="keyword">if</span> (lastUpdatedTime) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得了上次更新时间</span></span><br><span class="line">        <span class="comment">// 1.获得年月日</span></span><br><span class="line">        <span class="built_in">NSCalendar</span> *calendar = [<span class="keyword">self</span> currentCalendar];</span><br><span class="line">        <span class="built_in">NSUInteger</span> unitFlags = <span class="built_in">NSCalendarUnitYear</span>| <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitDay</span> |<span class="built_in">NSCalendarUnitHour</span> |<span class="built_in">NSCalendarUnitMinute</span>;</span><br><span class="line">        <span class="built_in">NSDateComponents</span> *cmp1 = [calendar components:unitFlags fromDate:lastUpdatedTime];</span><br><span class="line">        <span class="built_in">NSDateComponents</span> *cmp2 = [calendar components:unitFlags fromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.格式化日期</span></span><br><span class="line">        <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        <span class="built_in">BOOL</span> isToday = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">if</span> ([cmp1 day] == [cmp2 day]) &#123;</span><br><span class="line">            <span class="comment">//今天，省去年月日</span></span><br><span class="line">            formatter.dateFormat = <span class="string">@" HH:mm"</span>;</span><br><span class="line">            isToday = <span class="literal">YES</span>;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([cmp1 year] == [cmp2 year]) &#123; <span class="comment">// 今年</span></span><br><span class="line">            <span class="comment">//今年，省去年，显示月日</span></span><br><span class="line">            formatter.dateFormat = <span class="string">@"MM-dd HH:mm"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//其他，年月日都显示</span></span><br><span class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSString</span> *time = [formatter stringFromDate:lastUpdatedTime];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3.显示日期</span></span><br><span class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@%@"</span>,</span><br><span class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</span><br><span class="line">                                          isToday ? [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderDateTodayText] : <span class="string">@""</span>,</span><br><span class="line">                                          time];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有获得上次更新时间（应该是第一次更新或者多次更新，之前的更新都失败了）</span></span><br><span class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>,</span><br><span class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</span><br><span class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderNoneLastDateText]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里注意两点：</p><ol><li>作者通过使用block来让用户自己定义日期现实的格式，如果用户没有自定义，就使用作者提供的默认格式。</li><li>在默认格式的设置里，判断了是否是今日，是否是今年的情况。在以后设计显示时间的labe的时候可以借鉴一下。</li></ol></blockquote><h2 id="MJRefreshNormalHeader"><a href="#MJRefreshNormalHeader" class="headerlink" title="MJRefreshNormalHeader"></a>MJRefreshNormalHeader</h2><h3 id="有哪些职能？-2"><a href="#有哪些职能？-2" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>MJRefreshNormalHeader 继承于 MJRefreshStateHeader，它主要做了两件事：</p><ol><li>它在MJRefreshStateHeader上添加了<code>_arrowView</code>和<code>loadingView</code>。</li><li>布局了这两个view并在Refresh控件的状态切换的时候改变这两个view的样式。</li></ol><p>还是给一张图来直观感受一下这两个view：</p><p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_4.png" alt="两个view"></p><h3 id="职能如何实现？-3"><a href="#职能如何实现？-3" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>同MJRefreshStateHeader一样，也是重写了父类的三个方法：</p><h4 id="方法1：prepare"><a href="#方法1：prepare" class="headerlink" title="方法1：prepare"></a>方法1：prepare</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.activityIndicatorViewStyle = <span class="built_in">UIActivityIndicatorViewStyleGray</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法2：placeSubviews"><a href="#方法2：placeSubviews" class="headerlink" title="方法2：placeSubviews"></a>方法2：placeSubviews</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)placeSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> placeSubviews];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 首先将箭头的中心点x设为header宽度的一半</span></span><br><span class="line">    <span class="built_in">CGFloat</span> arrowCenterX = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.stateLabel.hidden) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</span><br><span class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</span><br><span class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在stateLabel里的文字宽度和更新时间里的文字宽度里取较宽的</span></span><br><span class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</span><br><span class="line">        <span class="comment">//根据self.labelLeftInset和textWidth向左移动中心点x</span></span><br><span class="line">        arrowCenterX -= textWidth / <span class="number">2</span> + <span class="keyword">self</span>.labelLeftInset;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//中心点y永远设置为header的高度的一半</span></span><br><span class="line">    <span class="built_in">CGFloat</span> arrowCenterY = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得了最终的center，而这个center同时适用于arrowView和loadingView，因为二者是不共存的。</span></span><br><span class="line">    <span class="built_in">CGPoint</span> arrowCenter = <span class="built_in">CGPointMake</span>(arrowCenterX, arrowCenterY);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 箭头</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.arrowView.constraints.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//控件大小等于图片大小</span></span><br><span class="line">        <span class="keyword">self</span>.arrowView.mj_size = <span class="keyword">self</span>.arrowView.image.size;</span><br><span class="line">        <span class="keyword">self</span>.arrowView.center = arrowCenter;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 菊花</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.loadingView.constraints.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.loadingView.center = arrowCenter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//arrowView的色调与stateLabel的字体颜色一致</span></span><br><span class="line">    <span class="keyword">self</span>.arrowView.tintColor = <span class="keyword">self</span>.stateLabel.textColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在这里注意一点：因为<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>是上下并排分布的，而<code>arrowView</code>或<code>loadingView</code>是在这二者的左边，所以为了避免这两组重合，在计算<code>arrowView</code>或<code>loadingView</code>的center的时候，需要获取<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>两个控件的宽度并比较大小，将较大的一个作为两个label的‘最宽距离’，再计算center，这样一来就不会重合了。<br>而对于如何计算宽度，作者给出了一个方案，大家可以在以后的实践中使用：</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)mj_textWith &#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> stringWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.text.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="meta">#if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span></span><br><span class="line">        stringWidth =[<span class="keyword">self</span>.text</span><br><span class="line">                      boundingRectWithSize:size</span><br><span class="line">                      options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></span><br><span class="line">                      attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:<span class="keyword">self</span>.font&#125;</span><br><span class="line">                      context:<span class="literal">nil</span>].size.width;</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line">        </span><br><span class="line">        stringWidth = [<span class="keyword">self</span>.text sizeWithFont:<span class="keyword">self</span>.font</span><br><span class="line">                             constrainedToSize:size</span><br><span class="line">                                 lineBreakMode:<span class="built_in">NSLineBreakByCharWrapping</span>].width;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stringWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法3-setState"><a href="#方法3-setState" class="headerlink" title="方法3: setState:"></a>方法3: setState:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据状态更新arrowView和loadingView的显示</span></span><br><span class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//1. 设置为默认状态</span></span><br><span class="line">        <span class="keyword">if</span> (oldState == MJRefreshStateRefreshing) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1.1 从正在刷新状态中切换过来</span></span><br><span class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">            </span><br><span class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</span><br><span class="line">                <span class="comment">//隐藏菊花</span></span><br><span class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">0.0</span>;</span><br><span class="line">                </span><br><span class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果执行完动画发现不是idle状态，就直接返回，进入其他状态</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateIdle) <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//菊花停止旋转</span></span><br><span class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>;</span><br><span class="line">                [<span class="keyword">self</span>.loadingView stopAnimating];</span><br><span class="line">                <span class="comment">//显示箭头</span></span><br><span class="line">                <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</span><br><span class="line">            &#125;];</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.2 从其他状态中切换过来</span></span><br><span class="line">            [<span class="keyword">self</span>.loadingView stopAnimating];</span><br><span class="line">            <span class="comment">//显示箭头并设置为初始状态</span></span><br><span class="line">            <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</span><br><span class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class="line">                <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStatePulling) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. 设置为可以刷新状态</span></span><br><span class="line">        [<span class="keyword">self</span>.loadingView stopAnimating];</span><br><span class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</span><br><span class="line">            <span class="comment">//箭头倒立</span></span><br><span class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformMakeRotation</span>(<span class="number">0.000001</span> - M_PI);</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. 设置为正在刷新状态</span></span><br><span class="line">        <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>; <span class="comment">// 防止refreshing -&gt; idle的动画完毕动作没有被执行</span></span><br><span class="line">        <span class="comment">//菊花旋转</span></span><br><span class="line">        [<span class="keyword">self</span>.loadingView startAnimating];</span><br><span class="line">        <span class="comment">//隐藏arrowView</span></span><br><span class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们已经从<code>MJRefreshComponent</code>到<code>MJRefreshNormalHeader</code>的实现过程看了一遍。可以看出，作者将<code>prepare</code>,<code>placeSubviews</code>以及<code>setState：</code>方法作为基类的方法，让下面的子类去一层一层实现。</p><p>而每一层的子类，根据自身的职责，分别按照自己的方式来实现这三个方法：</p><ul><li><code>MJRefreshHeader</code>: 负责header的高度和调整header自身在外部的位置。</li><li><code>MJRefreshStateHeader</code>:负责header内部的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>的布局和不同状态下内部文字的显示。</li><li><code>MJRefreshNormalHeader</code>:负责header内部的<code>loadingView</code>以及<code>arrowView</code>的布局和不同状态下的显示。</li></ul><p>这样做的好处是，如果想要增加某种类型的header，只要在某一层上做文章即可。例如该框架里的<code>MJRefreshGifHeader</code>,它和<code>MJRefreshNormalHeader</code>属于同一级，都是继承于<code>MJRefreshStateHeader</code>。因为二者都具有相同形式的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>，唯一不同的就是左侧的部分：</p><ul><li><code>MJRefreshNormalHeader</code>的左侧是箭头。</li><li><code>MJRefreshGifHeader</code>的左侧则是一个gif动画。</li></ul><p>还是提供一张图来直观感受一下：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_5.png" alt="normalHeader 与 gifHeader"></p><p>下面我们来看一下的实现：</p><h2 id="MJRefreshGifHeader"><a href="#MJRefreshGifHeader" class="headerlink" title="MJRefreshGifHeader"></a>MJRefreshGifHeader</h2><p>它提供了两个接口，是用来设置不同状态下使用的图片数组的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images duration:(<span class="built_in">NSTimeInterval</span>)duration forState:(MJRefreshState)state </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (images == <span class="literal">nil</span>) <span class="keyword">return</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置不同状态下的图片组和持续时间</span></span><br><span class="line">    <span class="keyword">self</span>.stateImages[@(state)] = images; </span><br><span class="line">    <span class="keyword">self</span>.stateDurations[@(state)] = @(duration); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 根据图片设置控件的高度 */</span> </span><br><span class="line">    <span class="built_in">UIImage</span> *image = [images firstObject]; </span><br><span class="line">    <span class="keyword">if</span> (image.size.height &gt; <span class="keyword">self</span>.mj_h) &#123; </span><br><span class="line">        <span class="keyword">self</span>.mj_h = image.size.height; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images forState:(MJRefreshState)state </span><br><span class="line">&#123; </span><br><span class="line">   <span class="comment">//如果没有传入duration，则根据图片的多少来计算</span></span><br><span class="line">    [<span class="keyword">self</span> setImages:images duration:images.count * <span class="number">0.1</span> forState:state]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有哪些职能？-3"><a href="#有哪些职能？-3" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>然后，和<code>MJRefreshNormalHeader</code>一样，它也重写了基类提供的三个方法来实现显示gif图片的职能。</p><h3 id="职能如何实现？-4"><a href="#职能如何实现？-4" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化和label的间距<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)prepare</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> prepare];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化间距</span></span><br><span class="line">    <span class="keyword">self</span>.labelLeftInset = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>####2. 根据label的宽度和存在与否设置gif的位置<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)placeSubviews</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> placeSubviews];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果约束存在，就立即返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.gifView.constraints.count) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.gifView.frame = <span class="keyword">self</span>.bounds;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden &amp;&amp; <span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel都在隐藏状态，将gif剧中显示</span></span><br><span class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeCenter</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel中至少一个存在，则根据label的宽度设置gif的位置</span></span><br><span class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeRight</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</span><br><span class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</span><br><span class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</span><br><span class="line">        <span class="keyword">self</span>.gifView.mj_w = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span> - textWidth * <span class="number">0.5</span> - <span class="keyword">self</span>.labelLeftInset;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-根据传入状态的不同来设置动画"><a href="#3-根据传入状态的不同来设置动画" class="headerlink" title="3. 根据传入状态的不同来设置动画"></a>3. 根据传入状态的不同来设置动画</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</span><br><span class="line">&#123;</span><br><span class="line">    MJRefreshCheckState</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. 如果传进来的状态是可以刷新和正在刷新</span></span><br><span class="line">        <span class="built_in">NSArray</span> *images = <span class="keyword">self</span>.stateImages[@(state)];</span><br><span class="line">        <span class="keyword">if</span> (images.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (images.count == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//1.1 单张图片</span></span><br><span class="line">            <span class="keyword">self</span>.gifView.image = [images lastObject];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1.2 多张图片</span></span><br><span class="line">            <span class="keyword">self</span>.gifView.animationImages = images;</span><br><span class="line">            <span class="keyword">self</span>.gifView.animationDuration = [<span class="keyword">self</span>.stateDurations[@(state)] doubleValue];</span><br><span class="line">            [<span class="keyword">self</span>.gifView startAnimating];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</span><br><span class="line">        <span class="comment">//2.如果传进来的状态是默认状态</span></span><br><span class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Footer类是用来处理上拉加载的，实现原理和下拉刷新很类似，在这里先不介绍了～</p><p>总的来说，该框架设计得非常工整：通过一个基类来定义一些状态和一些需要子类实现的接口。通过一层一层地继承，让每一层的子类各司其职，只完成真正属于自己的任务，提高了框架的可定制性，而且对于功能的扩展和bug的追踪也很有帮助，非常值得我们参考与借鉴。</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot;&gt;MJRefresh&lt;/a&gt;是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。&lt;/p&gt;
&lt;p&gt;该框架的结构设计得很清晰，使用一个基类&lt;code&gt;MJRefreshComponent&lt;/code&gt;来做一些基本的设定，然后通过继承的方式，让&lt;code&gt;MJRefreshHeader&lt;/code&gt;和&lt;code&gt;MJRefreshFooter&lt;/code&gt;分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png&quot; alt=&quot;框架组织结构图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MBProgressHUD源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/MBProgressHUD源码解析/</id>
    <published>2018-02-02T16:17:34.000Z</published>
    <updated>2018-07-16T16:46:42.492Z</updated>
    
    <content type="html"><![CDATA[<p>听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的<strong>读好源码Project</strong>。</p><p>从哪个框架开始呢？我想到了<code>SDWebImage</code>，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～</p><a id="more"></a><p>找着找着就找到了<code>MBProgressHUD</code>，这个框架只有两个文件，一个头文件和一个实现文件，很适合我现在的水平（对于一个没怎么读过源码的选手），于是就撸起了袖子开始了。</p><p>连查知识点带记笔记一共花了大概3个小时（虽然文件很少，但是里面好多东西都不知道[捂脸]）。整体说来，收获还是比较大的，除了一些零碎的语法之外，框架作者对于代码结构的设计和各种情况的考虑还是很出色的，很值得学习，而且我在下文也有介绍。</p><p>这篇总结主要分三个部分来介绍这个框架：</p><ol><li>核心Public API</li><li>方法调用流程图</li><li>方法内部实现</li></ol><p>不多说了，开始吧～</p><h2 id="1-核心Public-API"><a href="#1-核心Public-API" class="headerlink" title="1. 核心Public API"></a>1. 核心Public API</h2><h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDMode mode;<span class="comment">//HUD的类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDAnimation animationType <span class="built_in">UI_APPEARANCE_SELECTOR</span>;<span class="comment">//动画类型</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> graceTime;<span class="comment">//show函数触发到显示HUD的时间段</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> minShowTime;<span class="comment">//HUD显示的最短时间</span></span><br></pre></td></tr></table></figure><h3 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在某个view上添加HUD并显示</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 注意：显示之前，先去掉在当前view上显示的HUD。这个做法很严谨，我们将这个方案抽象出来：如果一个模型是这样的：我们需要将A加入到B中，但是需求上B里面只允许只有一个A。那么每次将A添加到B之前，都要先判断当前的b里面是否有A，如果有，则移除。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 找到某个view上最上层的HUD并隐藏它。</span></span><br><span class="line"><span class="comment"> * 如果返回值是YES的话，就表明HUD被找到而且被移除了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在某个view上找到最上层的HUD并返回它。</span></span><br><span class="line"><span class="comment"> * 返回值可以是空，所以返回值的关键字为：nullable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="keyword">nullable</span> MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view;</span><br></pre></td></tr></table></figure><h3 id="对象方法："><a href="#对象方法：" class="headerlink" title="对象方法："></a>对象方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个HUD的便利构造函数，用某个view来初始化HUD：这个view的bounds就是HUD的bounds</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithView:(<span class="built_in">UIView</span> *)view;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 显示HUD，有无动画。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 隐藏HUD，有无动画。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 在delay的时间过后隐藏HUD，有无动画。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</span><br></pre></td></tr></table></figure><p>看完了这些比较主要的API，我们看一下方法调用的流程图：</p><h2 id="2-方法调用流程图："><a href="#2-方法调用流程图：" class="headerlink" title="2. 方法调用流程图："></a>2. 方法调用流程图：</h2><p>总体来说，这个第三方框架的接口还是比较整齐的，可以大致上分为两类：显示（show）和隐藏（hide）。而且无论是调用显示方法还是隐藏方法，最终都会走到私有方法<code>animateIn:withType: completion:</code>里（前提是附加动画效果）。可以看一下方法调用的流程图：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-fe3f0f393bcc3b9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法调用流程图"></p><p>看完方法调用的结构之后，我们来具体看一下方法内部是如何实现的：</p><h2 id="3-方法内部实现："><a href="#3-方法内部实现：" class="headerlink" title="3. 方法内部实现："></a>3. 方法内部实现：</h2><p>在讲解API之前，有必要先介绍一下HUD使用的三个Timer。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *graceTimer; <span class="comment">//执行一次：在show方法触发后到HUD真正显示之前,前提是设定了graceTime，默认为0</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *minShowTimer;<span class="comment">//执行一次：在HUD显示后到HUD被隐藏之前</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *hideDelayTimer;<span class="comment">//执行一次：在HUD被隐藏的方法触发后到真正隐藏之前</span></span><br></pre></td></tr></table></figure><ul><li>graceTimer：用来推迟HUD的显示。如果设定了graceTime，那么HUD会在<code>show</code>方法触发后的graceTime时间后显示。它的意义是：如果任务完成所消耗的时间非常短并且短于graceTime，则HUD就不会出现了，避免HUD一闪而过的差体验。</li><li>minShowTimer：如果设定了minShowTime，就会在<code>hide</code>方法触发后判断任务执行的时间是否短于minShowTime。因此即使任务在minShowTime之前完成了，HUD也不会立即消失，它会在走完minShowTime之后才消失，这应该也是避免HUD一闪而过的情况。</li><li>hideDelayTimer：用来推迟HUD的隐藏。如果设定了delayTime，那么在触发<code>hide</code>方法后HUD也不会立即隐藏，它会在走完delayTime之后才隐藏。</li></ul><p>这三者的关系可以由下面这张图来体现（并没有包含所有的情况）：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-c9f49bfcec64dd0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三种timer"></p><p>下面开始分别讲解<code>show</code>系列的方法和<code>hide</code>系列的方法。</p><h3 id="show系列方法"><a href="#show系列方法" class="headerlink" title="show系列方法"></a>show系列方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    MBProgressHUD *hud = [[<span class="keyword">self</span> alloc] initWithView:view];<span class="comment">// 接着调用 [self initWithFrame:view.bounds]：根据传进来的view的frame来设定自己的frame</span></span><br><span class="line">    hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;<span class="comment">//removeFromSuperViewOnHide 应该是一个标记，表明HUD自己处于“应该被移除的状态”</span></span><br><span class="line">    [view addSubview:hud];<span class="comment">//在view上将自己的实例添加上去</span></span><br><span class="line">    [hud showAnimated:animated];</span><br><span class="line">    <span class="keyword">return</span> hud;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用showAnimated：</span></span><br><span class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    MBMainThreadAssert();</span><br><span class="line">    [<span class="keyword">self</span>.minShowTimer invalidate];<span class="comment">//取消当前的minShowTimer</span></span><br><span class="line">     <span class="keyword">self</span>.useAnimation = animated;<span class="comment">//设置animated状态</span></span><br><span class="line">     <span class="keyword">self</span>.finished = <span class="literal">NO</span>;<span class="comment">//添加标记：表明当前任务仍在进行</span></span><br><span class="line">    <span class="comment">// 如果设定了graceTime，就要推迟HUD的显示</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.graceTime &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.graceTime target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleGraceTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">        <span class="keyword">self</span>.graceTimer = timer;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ... otherwise show the HUD immediately</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//self.graceTimer触发的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)handleGraceTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</span><br><span class="line">    <span class="comment">// Show the HUD only if the task is still running</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.hasFinished) &#123;</span><br><span class="line">        [<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//所有的show方法最终都会走到这个方法</span></span><br><span class="line">- (<span class="keyword">void</span>)showUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="comment">// Cancel any previous animations : 移走所有的动画</span></span><br><span class="line">    [<span class="keyword">self</span>.bezelView.layer removeAllAnimations];</span><br><span class="line">    [<span class="keyword">self</span>.backgroundView.layer removeAllAnimations];</span><br><span class="line">    <span class="comment">// Cancel any scheduled hideDelayed: calls :取消delay的timer</span></span><br><span class="line">    [<span class="keyword">self</span>.hideDelayTimer invalidate];</span><br><span class="line">    <span class="comment">//记忆开始的时间</span></span><br><span class="line">    <span class="keyword">self</span>.showStarted = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="keyword">self</span>.alpha = <span class="number">1.</span>f;</span><br><span class="line">    <span class="comment">// Needed in case we hide and re-show with the same NSProgress object attached.</span></span><br><span class="line">    [<span class="keyword">self</span> setNSProgressDisplayLinkEnabled:<span class="literal">YES</span>];</span><br><span class="line">    <span class="keyword">if</span> (animated) &#123;        </span><br><span class="line">        [<span class="keyword">self</span> animateIn:<span class="literal">YES</span> withType:<span class="keyword">self</span>.animationType completion:<span class="literal">NULL</span>];   </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//方法弃用警告</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line">        <span class="keyword">self</span>.bezelView.alpha = <span class="keyword">self</span>.opacity;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        <span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到，无论是类方法的show方法，还是对象方法的show方法，而且无论是触发了<code>graceTimer</code>还是没有触发，最后都会走到<code>showUsingAnimation:</code>方法来让HUD显示出来。</p></blockquote><p>这里补充讲解一下NSProgress的监听方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setNSProgressDisplayLinkEnabled:(<span class="built_in">BOOL</span>)enabled &#123;</span><br><span class="line">    <span class="comment">// 这里使用 CADisplayLink 来刷新progress的变化。因为如果使用kvo机制来监听的话可能会非常消耗主线程（因为频率可能非常快）。</span></span><br><span class="line">    <span class="keyword">if</span> (enabled &amp;&amp; <span class="keyword">self</span>.progressObject) &#123;</span><br><span class="line">        <span class="comment">// Only create if not already active.</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.progressObjectDisplayLink) &#123;</span><br><span class="line">            <span class="keyword">self</span>.progressObjectDisplayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateProgressFromProgressObject)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不刷新</span></span><br><span class="line">        <span class="keyword">self</span>.progressObjectDisplayLink = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。 CADisplayLink以特定模式注册到runloop后， 每当屏幕显示内容刷新结束的时候，runloop就会向 CADisplayLink指定的target发送一次指定的selector消息，  CADisplayLink类对应的selector就会被调用一次。<br>参考文章：<a href="http://www.tuicool.com/articles/meMVR3" target="_blank" rel="noopener">Core Animation系列之CADisplayLink</a></p></blockquote><h3 id="hide系列方法"><a href="#hide系列方法" class="headerlink" title="hide系列方法"></a>hide系列方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    MBProgressHUD *hud = [<span class="keyword">self</span> HUDForView:view];<span class="comment">//获取当前view的最前为止的HUD</span></span><br><span class="line">    <span class="keyword">if</span> (hud != <span class="literal">nil</span>) &#123;</span><br><span class="line">        hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;</span><br><span class="line">        [hud hideAnimated:animated];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">+ (MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view &#123;   </span><br><span class="line">    <span class="built_in">NSEnumerator</span> *subviewsEnum = [view.subviews reverseObjectEnumerator]; <span class="comment">//倒叙排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> subviewsEnum) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([subview isKindOfClass:<span class="keyword">self</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> (MBProgressHUD *)subview;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    MBMainThreadAssert();</span><br><span class="line">    [<span class="keyword">self</span>.graceTimer invalidate];</span><br><span class="line">     <span class="keyword">self</span>.useAnimation = animated;</span><br><span class="line">     <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</span><br><span class="line">     <span class="comment">//如果设定了HUD最小显示时间，那就需要判断最小显示时间和已经经过的时间的大小</span></span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</span><br><span class="line">        <span class="built_in">NSTimeInterval</span> interv = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:<span class="keyword">self</span>.showStarted];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果最小显示时间比较大，则暂时不触发HUD的隐藏，而是启动一个timer，再经过二者的时间差的时间之后再触发隐藏</span></span><br><span class="line">        <span class="keyword">if</span> (interv &lt; <span class="keyword">self</span>.minShowTime) &#123;</span><br><span class="line">            <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:(<span class="keyword">self</span>.minShowTime - interv) target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleMinShowTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">            <span class="keyword">self</span>.minShowTimer = timer;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//如果最小显示时间比较小，则立即将HUD隐藏</span></span><br><span class="line">    [<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//self.minShowTimer触发的方法</span></span><br><span class="line">- (<span class="keyword">void</span>)handleMinShowTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)hideUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">    <span class="keyword">if</span> (animated &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</span><br><span class="line">        <span class="comment">//隐藏时，将showStarted设为nil</span></span><br><span class="line">        <span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</span><br><span class="line">        [<span class="keyword">self</span> animateIn:<span class="literal">NO</span> withType:<span class="keyword">self</span>.animationType completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">            [<span class="keyword">self</span> done];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.bezelView.alpha = <span class="number">0.</span>f;</span><br><span class="line">        <span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</span><br><span class="line">        [<span class="keyword">self</span> done];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到，无论是类方法的<code>hide</code>方法，还是对象方法的<code>hide</code>方法，而且无论是触发还是没有触发<code>minShowTimer</code>,最终都会走到<code>hideUsingAnimation</code>这个方法里。</p></blockquote><p>而无论是<code>show</code>方法，还是<code>hide</code>方法，在设定animated属性为YES的前提下，最终都会走到<code>animateIn: withType: completion:</code>方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)animateIn:(<span class="built_in">BOOL</span>)animatingIn withType:(MBProgressHUDAnimation)type completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completion &#123;</span><br><span class="line">    <span class="comment">// Automatically determine the correct zoom animation type</span></span><br><span class="line">    <span class="keyword">if</span> (type == MBProgressHUDAnimationZoom) &#123;</span><br><span class="line">        type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//()内代表x和y方向缩放倍数</span></span><br><span class="line">    <span class="built_in">CGAffineTransform</span> small = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line">    <span class="built_in">CGAffineTransform</span> large = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.5</span>f, <span class="number">1.5</span>f);</span><br><span class="line">    <span class="comment">// 设定初始状态</span></span><br><span class="line">    <span class="built_in">UIView</span> *bezelView = <span class="keyword">self</span>.bezelView;</span><br><span class="line">    <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</span><br><span class="line">        bezelView.transform = small;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</span><br><span class="line">        bezelView.transform = large;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建动画任务</span></span><br><span class="line">    dispatch_block_t animations = ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (animatingIn) &#123;</span><br><span class="line">            bezelView.transform = <span class="built_in">CGAffineTransformIdentity</span>;<span class="comment">//重置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</span><br><span class="line">            bezelView.transform = large;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</span><br><span class="line">            bezelView.transform = small;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line">        bezelView.alpha = animatingIn ? <span class="keyword">self</span>.opacity : <span class="number">0.</span>f;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">       <span class="comment">//如果animatingIn是true，就是show方法，否则是hide方法</span></span><br><span class="line">        <span class="keyword">self</span>.backgroundView.alpha = animatingIn ? <span class="number">1.</span>f : <span class="number">0.</span>f;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// Spring animations are nicer, but only available on iOS 7+</span></span><br><span class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV</span></span><br><span class="line">    <span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;</span><br><span class="line">        <span class="comment">//执行动画 &gt;= iOS7</span></span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> usingSpringWithDamping:<span class="number">1.</span>f initialSpringVelocity:<span class="number">0.</span>f options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>除了一些细节上的语法之外，我觉得该框架有几个地方值得我们借鉴：</p><ol><li>暴露出来的API最终都会走到同一个私有方法里。</li><li>将真正显示的时间的前后加上缓冲的时间（graceTimer 和 hideDelayTimer），可以提高可定制性和稳定性。</li><li>如果有两个方法是矛盾的，并且可以同时调用，就需要在全局设置一个属性来判断当前的状态（removeFromSuperViewOnHide属性，finished属性）</li><li>使用CADisplayLink来刷新更新频率可能很高的view。</li><li>使用NSAssert来捕获各种异常。</li></ol><p>就这样大致写完了，没有怎么读过第三方框架的源码，所以第一次可能显得稍许不足。有不好的地方还希望多多指点哈～</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的&lt;strong&gt;读好源码Project&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从哪个框架开始呢？我想到了&lt;code&gt;SDWebImage&lt;/code&gt;，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JSONModel源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/JSONModel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/JSONModel源码解析/</id>
    <published>2018-02-02T16:17:27.000Z</published>
    <updated>2018-07-16T16:46:37.927Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列的<a href="http://www.jianshu.com/nb/9137726" target="_blank" rel="noopener">源码解析</a>分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。</p><p>想来想去，还是从<a href="https://github.com/jsonmodel/jsonmodel">JSONModel</a>开始吧～</p><p>首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。</p><p>该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。</p><a id="more"></a><p>在讲解源码之前，有必要先给不会使用JSONModel的同学们通过实际的例子来介绍一下它的使用方法（而且后面的源码解析部分也是结合这些例子给出的，因为结合例子有助于加快理解）：</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="1-最基本的使用"><a href="#1-最基本的使用" class="headerlink" title="1. 最基本的使用"></a>1. 最基本的使用</h2><p>第一种就是单纯地传入一个字典，并转换成模型：<br>首先我们需要定义我们自己的模型类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sex;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>然后再使用字典来转换为模型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</span><br><span class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</span><br><span class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</span><br><span class="line">                        <span class="string">@"gender"</span>:<span class="string">@"male"</span>,</span><br><span class="line">                      &#125;;</span><br><span class="line"> <span class="built_in">NSError</span> *error;</span><br><span class="line"> Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;Person&gt; </span><br><span class="line">   [name]: Jack</span><br><span class="line">   [sex]: male</span><br><span class="line">   [gender]: <span class="number">23</span></span><br><span class="line">&lt;/Person&gt;</span><br></pre></td></tr></table></figure></p><p>可以看出来，该框架的使用非常方便，一行代码就将模型转换好了。<br>但是该框架的功能远不止这些：</p><h2 id="2-转换属性名称"><a href="#2-转换属性名称" class="headerlink" title="2. 转换属性名称"></a>2. 转换属性名称</h2><p>有的时候，传入的字典里的key发生了变化（比如接口重构之类的原因），但是我们前端这边已经写好的模型属性可能不容易被修改（因为业务逻辑很复杂什么的），所以这个时候，最好有一个转化的功能。</p><p>在这里举个例子：原来字典里的<code>gender</code>这个key变成了<code>sex</code>，这就需要我们定义一个转换的mapper（<code>JSONKeyMapper</code>）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">+ (JSONKeyMapper *)keyMapper</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[JSONKeyMapper alloc] initWithModelToJSONDictionary:@&#123;</span><br><span class="line">                                                                  <span class="string">@"gender"</span>: <span class="string">@"sex"</span>,                                                             &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样一来，<code>JSONKeyMapper</code>就会自动帮我们做转换。<br>为了验证效果，我们修改一下传入的字典里的<code>gender</code>字段为<code>sex</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</span><br><span class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</span><br><span class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</span><br><span class="line">                        <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</span><br><span class="line">                      &#125;;</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</span><br></pre></td></tr></table></figure></p><p>再看一下输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person&gt; </span><br><span class="line">   [name]: Jack</span><br><span class="line">   [age]: <span class="number">23</span></span><br><span class="line">   [gender]: male</span><br><span class="line">&lt;/Person&gt;</span><br></pre></td></tr></table></figure><p>没有受到传入字典里key值的变化的影响，是吧？</p><h2 id="3-自定义错误"><a href="#3-自定义错误" class="headerlink" title="3. 自定义错误"></a>3. 自定义错误</h2><p>除了一些框架里自己处理的错误（比如传入的对象不是字典等），框架的作者也允许我们自己定义属于我们自己的错误。</p><p>比如，当<code>age</code>对应的数值小于25的时候，打印出<code>Too young!</code>,并阻止模型的转换：</p><p>首先，我们在模型的实现文件里添加：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)validate:(<span class="built_in">NSError</span> **)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">super</span> validate:error])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.age &lt; <span class="number">25</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Too young!"</span> code:<span class="number">10</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">        <span class="built_in">NSError</span> *errorLog = *error;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,errorLog.domain);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看一下结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] Too young!</span><br><span class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] (null)</span><br></pre></td></tr></table></figure></p><p>打印了错误，而且模型也没有被转换。</p><h2 id="4-模型嵌套"><a href="#4-模型嵌套" class="headerlink" title="4. 模型嵌套"></a>4. 模型嵌套</h2><p>有的时候，我们需要在模型里加一个数组，而这个数组里面的元素是另一个对象：这就涉及到了模型的嵌套。</p><p>举个例子，我们让上面的<code>Person</code>对象含有一个数组<code>Friends</code>，它里面的元素是对象<code>Friend</code>，也就是好友信息。若要实现模型的嵌套，我们只需在原来的模型类里增加一个协议<code>Friend</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"JSONModel.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Friend</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Friend</span> : <span class="title">JSONModel</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;Friend&gt; *friends;<span class="comment">//数组，嵌套模型</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>而且要在<code>Person</code>的实现文件里加上这一段代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Friend</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p><p>注意！如果不添加，则会令程序崩溃。</p><p>最后，在使用的时候，我们只需将持有一个数组的字典里传入即可：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[</span><br><span class="line">                      @&#123;</span><br><span class="line">                        <span class="string">@"name"</span>:<span class="string">@"Peter"</span>,</span><br><span class="line">                        <span class="string">@"age"</span>:@<span class="number">35</span>,</span><br><span class="line">                        &#125;,</span><br><span class="line">                   ];</span><br><span class="line">    </span><br><span class="line"> <span class="built_in">NSDictionary</span> *dict = @&#123;</span><br><span class="line">                           <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</span><br><span class="line">                           <span class="string">@"age"</span>:@<span class="number">23</span>,</span><br><span class="line">                           <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</span><br><span class="line">                           <span class="string">@"friends"</span>:array,<span class="comment">//朋友列表（模型嵌套）</span></span><br><span class="line">                         &#125;;</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person);</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Person&gt; </span><br><span class="line">   [age]: <span class="number">23</span></span><br><span class="line">   [gender]: male</span><br><span class="line">   [friends]: (</span><br><span class="line">       <span class="string">"&lt;Friend&gt; \n   [name]: Peter\n   [age]: 35\n&lt;/Friend&gt;"</span></span><br><span class="line">   )</span><br><span class="line">   [name]: Jack</span><br><span class="line">&lt;/Person&gt;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，person对象里含有一个数组，这个数组只有一个元素，对应着上面字典里的array里的信息。</p><p>OK，这样一来，大家已经可以掌握该框架的主要用法了，现在开始详细讲解代码：</p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>本篇源码解析主要围绕着<code>initWithDictionary:error:</code>来展开，在这一个方法里作者做到了所有的容错和模型的转化。</p><p>按照老规矩，先上流程图：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-94b356eeb7b560e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字典-&gt;模型"></p><p>该流程图对应的方法实现是：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>**)err</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法1. 参数为nil</span></span><br><span class="line">    <span class="keyword">if</span> (!dict) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法2. 参数不是nil，但也不是字典</span></span><br><span class="line">    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法3. 初始化</span></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">//初始化失败</span></span><br><span class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO）</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span>.__keyMapper error:err]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法5. 核心方法：字典的key与模型的属性的映射</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span>.__keyMapper validation:<span class="literal">YES</span> error:err]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法7. 终于通过了！成功返回model</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，</p><ul><li>方法1-4:都是对错误的发现与处理。</li><li>方法5:是真正的mapping。</li><li>方法6:是作者给用户自己定义错误的方法，如果复合了用户自己定义的错误，那么即使mapping成功了，也要返回nil。<br>-方法7:成功返回模型对象。</li></ul><p>在讲解代码之前，有必要先了解一下JSONModel所持有的一些数据：</p><ul><li><p><strong>关联对象kClassPropertiesKey</strong>:(用来保存所有属性信息的NSDictionary)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       age = <span class="string">"@property primitive age (Setters = [])"</span>;</span><br><span class="line">      name = <span class="string">"@property NSString* name (Standard JSON type, Setters = [])"</span>;</span><br><span class="line">    gender = <span class="string">"@property NSString* gender (Standard JSON type, Setters = [])"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关联对象kClassRequiredPropertyNamesKey</strong>：(用来保存所有属性的名称NSSet)</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;(</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    gender</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>关联对象kMapperObjectKey</strong>：(用来保存JSONKeyMapper)：自定义的mapper，具体的使用方法在上面的例子中可以看到。</p></li></ul><ul><li><strong>JSONModelClassProperty</strong>：封装的jsonmodel的一个属性，它包含了对应属性的名字（name：gender），类型（type：NSString），是否是JSONModel支持的类型（isStandardJSONType：YES/NO），是否是可变对象（isMutable:YES/NO）等属性。</li></ul><p>再大致讲解一下整个的流程：<br>首先，在这个模型类的对象被初始化的时候，遍历自身到所有的父类（直到JSONModel为止），获取所有的属性，并将其保存在一个字典里。获取传入字典的所有key，将这些key与保存的所有属性进行匹配。如果匹配成功，则进行kvc赋值。</p><p>OK，现在从上到下逐步讲解上段代码：</p><p>首先，在<code>load</code>方法里，定义了该框架支持的类型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">+(<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</span><br><span class="line">        <span class="keyword">@autoreleasepool</span> &#123;           </span><br><span class="line">            <span class="comment">//兼容的对象属性</span></span><br><span class="line">            allowedJSONTypes = @[</span><br><span class="line">                [<span class="built_in">NSString</span> <span class="keyword">class</span>], [<span class="built_in">NSNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSDecimalNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>], [<span class="built_in">NSDictionary</span> <span class="keyword">class</span>], [<span class="built_in">NSNull</span> <span class="keyword">class</span>], <span class="comment">//immutable JSON classes</span></span><br><span class="line">                [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>] <span class="comment">//mutable JSON classes</span></span><br><span class="line">            ];</span><br><span class="line">            <span class="comment">//兼容的基本类型属性</span></span><br><span class="line">            allowedPrimitiveTypes = @[</span><br><span class="line">                <span class="string">@"BOOL"</span>, <span class="string">@"float"</span>, <span class="string">@"int"</span>, <span class="string">@"long"</span>, <span class="string">@"double"</span>, <span class="string">@"short"</span>,</span><br><span class="line">                <span class="comment">//and some famous aliases</span></span><br><span class="line">                <span class="string">@"NSInteger"</span>, <span class="string">@"NSUInteger"</span>,</span><br><span class="line">                <span class="string">@"Block"</span></span><br><span class="line">            ];</span><br><span class="line">            <span class="comment">//转换器</span></span><br><span class="line">            valueTransformer = [[JSONValueTransformer alloc] init];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//自己的类型</span></span><br><span class="line">            JSONModelClass = <span class="built_in">NSClassFromString</span>(<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们看一下从方法3的init方法开始，作者都做了什么：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">id</span>)init</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> __setup__];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)__setup__</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//只有第一次实例化时，才执行</span></span><br><span class="line">    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kClassPropertiesKey)) &#123;</span><br><span class="line">        [<span class="keyword">self</span> __inspectProperties];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果存在自定义的mapper，则将它保存在关联对象里面，key是kMapperObjectKey</span></span><br><span class="line">    <span class="keyword">id</span> mapper = [[<span class="keyword">self</span> <span class="keyword">class</span>] keyMapper];</span><br><span class="line">    <span class="keyword">if</span> ( mapper &amp;&amp; !objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kMapperObjectKey) ) &#123;</span><br><span class="line">        objc_setAssociatedObject(</span><br><span class="line">                                 <span class="keyword">self</span>.class,</span><br><span class="line">                                 &amp;kMapperObjectKey,</span><br><span class="line">                                 mapper,</span><br><span class="line">                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></span><br><span class="line">                                 );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，这里的<code>__inspectProperties:</code>方法是该框架的核心方法之一：它的任务是保存了所有需要赋值的属性。用作在将来与传进来字典进行映射：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)__inspectProperties</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//    最终保存所有属性的字典，形式为：</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        age = "@property primitive age (Setters = [])";</span></span><br><span class="line"><span class="comment">//        friends = "@property NSArray*&lt;Friend&gt; friends (Standard JSON type, Setters = [])";</span></span><br><span class="line"><span class="comment">//        gender = "@property NSString* gender (Standard JSON type, Setters = [])";</span></span><br><span class="line"><span class="comment">//        name = "@property NSString* name (Standard JSON type, Setters = [])";</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="built_in">NSMutableDictionary</span>* propertyIndex = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//获取当前的类名</span></span><br><span class="line">    Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];    </span><br><span class="line">    <span class="built_in">NSScanner</span>* scanner = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSString</span>* propertyType = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// 循环条件：当class 是 JSONModel自己的时候终止</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">class</span> != [JSONModel <span class="keyword">class</span>]) &#123;        </span><br><span class="line">        <span class="comment">//属性的个数</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</span><br><span class="line">        <span class="comment">//获得属性列表（所有@property声明的属性）</span></span><br><span class="line">        objc_property_t *properties = class_copyPropertyList(<span class="keyword">class</span>, &amp;propertyCount);</span><br><span class="line">        <span class="comment">//遍历所有的属性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</span><br><span class="line">            <span class="comment">//获得属性名称</span></span><br><span class="line">            objc_property_t property = properties[i];<span class="comment">//获得当前的属性</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);<span class="comment">//name（C字符串）            </span></span><br><span class="line">            <span class="comment">//JSONModel里的每一个属性，都被封装成一个JSONModelClassProperty对象</span></span><br><span class="line">            JSONModelClassProperty* p = [[JSONModelClassProperty alloc] init];</span><br><span class="line">            p.name = @(propertyName);<span class="comment">//propertyName:属性名称，例如：name，age，gender</span></span><br><span class="line">            <span class="comment">//获得属性类型</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *attrs = property_getAttributes(property);</span><br><span class="line">            <span class="built_in">NSString</span>* propertyAttributes = @(attrs);</span><br><span class="line">            <span class="comment">// T@\"NSString\",C,N,V_name</span></span><br><span class="line">            <span class="comment">// Tq,N,V_age</span></span><br><span class="line">            <span class="comment">// T@\"NSString\",C,N,V_gender</span></span><br><span class="line">            <span class="comment">// T@"NSArray&lt;Friend&gt;",&amp;,N,V_friends            </span></span><br><span class="line">            <span class="built_in">NSArray</span>* attributeItems = [propertyAttributes componentsSeparatedByString:<span class="string">@","</span>];</span><br><span class="line">            <span class="comment">//说明是只读属性，不做任何操作</span></span><br><span class="line">            <span class="keyword">if</span> ([attributeItems containsObject:<span class="string">@"R"</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//to next property</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//检查出是布尔值</span></span><br><span class="line">            <span class="keyword">if</span> ([propertyAttributes hasPrefix:<span class="string">@"Tc,"</span>]) &#123;</span><br><span class="line">                p.structName = <span class="string">@"BOOL"</span>;<span class="comment">//使其变为结构体</span></span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="comment">//实例化一个scanner</span></span><br><span class="line">            scanner = [<span class="built_in">NSScanner</span> scannerWithString: propertyAttributes];</span><br><span class="line">            [scanner scanUpToString:<span class="string">@"T"</span> intoString: <span class="literal">nil</span>];</span><br><span class="line">            [scanner scanString:<span class="string">@"T"</span> intoString:<span class="literal">nil</span>];</span><br><span class="line">            <span class="comment">//http://blog.csdn.net/kmyhy/article/details/8258858           </span></span><br><span class="line">            <span class="keyword">if</span> ([scanner scanString:<span class="string">@"@\""</span> intoString: &amp;propertyType]) &#123;                </span><br><span class="line">                 <span class="comment">//属性是一个对象</span></span><br><span class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@"\"&lt;"</span>]</span><br><span class="line">                                        intoString:&amp;propertyType];<span class="comment">//propertyType -&gt; NSString                </span></span><br><span class="line">                p.type = <span class="built_in">NSClassFromString</span>(propertyType);<span class="comment">// p.type = @"NSString"</span></span><br><span class="line">                p.isMutable = ([propertyType rangeOfString:<span class="string">@"Mutable"</span>].location != <span class="built_in">NSNotFound</span>); <span class="comment">//判断是否是可变的对象</span></span><br><span class="line">                p.isStandardJSONType = [allowedJSONTypes containsObject:p.type];<span class="comment">//是否是该框架兼容的类型</span></span><br><span class="line">                <span class="comment">//存在协议(数组，也就是嵌套模型)</span></span><br><span class="line">                <span class="keyword">while</span> ([scanner scanString:<span class="string">@"&lt;"</span> intoString:<span class="literal">NULL</span>]) &#123;</span><br><span class="line">                    <span class="built_in">NSString</span>* protocolName = <span class="literal">nil</span>;</span><br><span class="line">                    [scanner scanUpToString:<span class="string">@"&gt;"</span> intoString: &amp;protocolName];</span><br><span class="line">                    <span class="keyword">if</span> ([protocolName isEqualToString:<span class="string">@"Optional"</span>]) &#123;</span><br><span class="line">                        p.isOptional = <span class="literal">YES</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Index"</span>]) &#123;</span><br><span class="line"><span class="meta">#pragma GCC diagnostic push</span></span><br><span class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></span><br><span class="line">                        p.isIndex = <span class="literal">YES</span>;</span><br><span class="line"><span class="meta">#pragma GCC diagnostic pop</span></span><br><span class="line">                        objc_setAssociatedObject(</span><br><span class="line">                                                 <span class="keyword">self</span>.class,</span><br><span class="line">                                                 &amp;kIndexPropertyNameKey,</span><br><span class="line">                                                 p.name,</span><br><span class="line">                                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></span><br><span class="line">                                                 );</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Ignore"</span>]) &#123;</span><br><span class="line">                        p = <span class="literal">nil</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        p.protocol = protocolName;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//到最接近的&gt;为止</span></span><br><span class="line">                    [scanner scanString:<span class="string">@"&gt;"</span> intoString:<span class="literal">NULL</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ([scanner scanString:<span class="string">@"&#123;"</span> intoString: &amp;propertyType])                </span><br><span class="line">                <span class="comment">//属性是结构体</span></span><br><span class="line">                [scanner scanCharactersFromSet:[<span class="built_in">NSCharacterSet</span> alphanumericCharacterSet]</span><br><span class="line">                                    intoString:&amp;propertyType];</span><br><span class="line">                p.isStandardJSONType = <span class="literal">NO</span>;</span><br><span class="line">                p.structName = propertyType;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//属性是基本类型：Tq,N,V_age</span></span><br><span class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@","</span>]</span><br><span class="line">                                        intoString:&amp;propertyType];</span><br><span class="line">                <span class="comment">//propertyType:q</span></span><br><span class="line">                propertyType = valueTransformer.primitivesNames[propertyType];              </span><br><span class="line">                <span class="comment">//propertyType:long</span></span><br><span class="line">                <span class="comment">//基本类型数组</span></span><br><span class="line">                <span class="keyword">if</span> (![allowedPrimitiveTypes containsObject:propertyType]) &#123;</span><br><span class="line">                    <span class="comment">//类型不支持</span></span><br><span class="line">                    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"JSONModelProperty type not allowed"</span></span><br><span class="line">                                                   reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Property type of %@.%@ is not supported by JSONModel."</span>, <span class="keyword">self</span>.class, p.name]</span><br><span class="line">                                                 userInfo:<span class="literal">nil</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">NSString</span> *nsPropertyName = @(propertyName);            </span><br><span class="line">            <span class="comment">//可选的</span></span><br><span class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsOptional:nsPropertyName])&#123;</span><br><span class="line">                p.isOptional = <span class="literal">YES</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可忽略的</span></span><br><span class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsIgnored:nsPropertyName])&#123;</span><br><span class="line">                p = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//集合类</span></span><br><span class="line">            Class customClass = [[<span class="keyword">self</span> <span class="keyword">class</span>] classForCollectionProperty:nsPropertyName];            </span><br><span class="line">            <span class="keyword">if</span> (customClass) &#123;</span><br><span class="line">                p.protocol = <span class="built_in">NSStringFromClass</span>(customClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//忽略block</span></span><br><span class="line">            <span class="keyword">if</span> ([propertyType isEqualToString:<span class="string">@"Block"</span>]) &#123;</span><br><span class="line">                p = <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果字典里不存在，则添加到属性字典里（终于添加上去了。。。）</span></span><br><span class="line">            <span class="keyword">if</span> (p &amp;&amp; ![propertyIndex objectForKey:p.name]) &#123;</span><br><span class="line">                [propertyIndex setValue:p forKey:p.name];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//setter 和 getter</span></span><br><span class="line">            <span class="keyword">if</span> (p)</span><br><span class="line">            &#123;   <span class="comment">//name -&gt;Name</span></span><br><span class="line">                <span class="built_in">NSString</span> *name = [p.name stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:[p.name substringToIndex:<span class="number">1</span>].uppercaseString];</span><br><span class="line">                <span class="comment">// getter</span></span><br><span class="line">                SEL <span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"JSONObjectFor%@"</span>, name]);</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>])</span><br><span class="line">                    p.customGetter = <span class="keyword">getter</span>;</span><br><span class="line">                <span class="comment">// setters</span></span><br><span class="line">                p.customSetters = [<span class="built_in">NSMutableDictionary</span> new];</span><br><span class="line">                SEL genericSetter = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@WithJSONObject:"</span>, name]);</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:genericSetter])</span><br><span class="line">                    p.customSetters[<span class="string">@"generic"</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;genericSetter objCType:<span class="keyword">@encode</span>(SEL)];</span><br><span class="line">                <span class="keyword">for</span> (Class type <span class="keyword">in</span> allowedJSONTypes)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">NSString</span> *<span class="keyword">class</span> = <span class="built_in">NSStringFromClass</span>([JSONValueTransformer classByResolvingClusterClasses:type]);</span><br><span class="line">                    <span class="keyword">if</span> (p.customSetters[<span class="keyword">class</span>])</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    SEL <span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@With%@:"</span>, name, <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">setter</span>])</span><br><span class="line">                        p.customSetters[<span class="keyword">class</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;<span class="keyword">setter</span> objCType:<span class="keyword">@encode</span>(SEL)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        free(properties);</span><br><span class="line">        <span class="comment">//再指向自己的父类，知道等于JSONModel才停止</span></span><br><span class="line">        <span class="keyword">class</span> = [<span class="keyword">class</span> superclass];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后保存所有当前类，JSONModel的所有的父类的属性</span></span><br><span class="line">    objc_setAssociatedObject(</span><br><span class="line">                             <span class="keyword">self</span>.class,</span><br><span class="line">                             &amp;kClassPropertiesKey,</span><br><span class="line">                             [propertyIndex <span class="keyword">copy</span>],</span><br><span class="line">                             OBJC_ASSOCIATION_RETAIN</span><br><span class="line">                             );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>需要注意几点：</p><ol><li>作者利用一个<code>while</code>函数，获取当前类和当前类的除JSONModel的所有父类的属性保存在一个字典中。在将来用于和传入的字典进行映射。</li><li>作者用<code>JSONModelClassProperty</code>类封装了JSONModel的每一个属性。这个类有两个重要的属性：一个是<code>name</code>，它是属性的名称(例如gender)。另一个是<code>type</code>，它是属性的类型（例如NSString）。</li><li>作者将属性分为了如下几个类型：<ol><li>对象（不含有协议）。</li><li>对象（含有协议，属于模型嵌套）。</li><li>基本数据类型。</li><li>结构体。</li></ol></li></ol></blockquote><p>我们来看一下方法4的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)__doesDictionary:(<span class="built_in">NSDictionary</span>*)dict matchModelWithKeyMapper:(JSONKeyMapper*)keyMapper error:(<span class="built_in">NSError</span>**)err</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拿到字典里所有的key</span></span><br><span class="line">    <span class="built_in">NSArray</span>* incomingKeysArray = [dict allKeys];    </span><br><span class="line">    <span class="comment">//返回保存所有属性名称的数组(name,age,gender...)</span></span><br><span class="line">    <span class="built_in">NSMutableSet</span>* requiredProperties = [<span class="keyword">self</span> __requiredPropertyNames].mutableCopy;    </span><br><span class="line">    <span class="comment">//从array拿到set</span></span><br><span class="line">    <span class="built_in">NSSet</span>* incomingKeys = [<span class="built_in">NSSet</span> setWithArray: incomingKeysArray];</span><br><span class="line">    <span class="comment">//如果用户自定义了mapper，则进行转换</span></span><br><span class="line">    <span class="keyword">if</span> (keyMapper || globalKeyMapper) &#123;</span><br><span class="line">        <span class="built_in">NSMutableSet</span>* transformedIncomingKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity: requiredProperties.count];</span><br><span class="line">        <span class="built_in">NSString</span>* transformedName = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//便利需要转换的属性列表</span></span><br><span class="line">        <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</span><br><span class="line">            <span class="comment">//被转换成的属性名称 gender（模型内） -&gt; sex（字典内）</span></span><br><span class="line">            transformedName = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</span><br><span class="line">            <span class="comment">//拿到sex以后，查看传入的字典里是否有sex对应的值</span></span><br><span class="line">            <span class="keyword">id</span> value;</span><br><span class="line">            <span class="keyword">@try</span> &#123;</span><br><span class="line">                value = [dict valueForKeyPath:transformedName];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">                value = dict[transformedName];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果值存在，则将sex添加到传入的keys数组中</span></span><br><span class="line">            <span class="keyword">if</span> (value) &#123;</span><br><span class="line">                [transformedIncomingKeys addObject: property.name];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        incomingKeys = transformedIncomingKeys;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查看当前的model的属性的集合是否大于传入的属性集合，如果是，则返回错误。</span></span><br><span class="line">    <span class="comment">//也就是说模型类里的属性是不能多于传入字典里的key的，例如：</span></span><br><span class="line">    <span class="keyword">if</span> (![requiredProperties isSubsetOfSet:incomingKeys]) &#123;</span><br><span class="line">        <span class="comment">//获取多出来的属性</span></span><br><span class="line">        [requiredProperties minusSet:incomingKeys];</span><br><span class="line">        <span class="comment">//not all required properties are in - invalid input</span></span><br><span class="line">        JMLog(<span class="string">@"Incoming data was invalid [%@ initWithDictionary:]. Keys missing: %@"</span>, <span class="keyword">self</span>.class, requiredProperties);</span><br><span class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMissingKeys:requiredProperties];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不需要了，释放掉</span></span><br><span class="line">    incomingKeys= <span class="literal">nil</span>;</span><br><span class="line">    requiredProperties= <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里需要需要注意的：</p><ol><li>model类里面定义的属性集合是不能大于传入的字典里的key集合的。</li><li>如果存在了用户自定义的mapper，则需要按照用户的定义来进行转换。<br>（在这里是奖gender转换为了sex）。</li></ol></blockquote><p>最后来看一下本框架第二个核心代码(上面的方法5)，也就是真正从字典里获取值并赋给当前模型对象的实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">-(<span class="built_in">BOOL</span>)__importDictionary:(<span class="built_in">NSDictionary</span>*)dict withKeyMapper:(JSONKeyMapper*)keyMapper validation:(<span class="built_in">BOOL</span>)validation error:(<span class="built_in">NSError</span>**)err</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//遍历保存的所有属性的字典</span></span><br><span class="line">    <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</span><br><span class="line">        <span class="comment">//将属性的名称拿过来，作为key，用这个key来查找传进来的字典里对应的值</span></span><br><span class="line">        <span class="built_in">NSString</span>* jsonKeyPath = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</span><br><span class="line">        <span class="comment">//用来保存从字典里获取的值</span></span><br><span class="line">        <span class="keyword">id</span> jsonValue;        </span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            jsonValue = [dict valueForKeyPath: jsonKeyPath];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            jsonValue = dict[jsonKeyPath];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//字典不存在对应的key</span></span><br><span class="line">        <span class="keyword">if</span> (isNull(jsonValue)) &#123;</span><br><span class="line">            <span class="comment">//如果这个key是可以不存在的</span></span><br><span class="line">            <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;            </span><br><span class="line">            <span class="comment">//如果这个key是必须有的，则返回错误</span></span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Value of required model key %@ is null"</span>, property.name];</span><br><span class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</span><br><span class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">//获取 取到的值的类型</span></span><br><span class="line">        Class jsonValueClass = [jsonValue <span class="keyword">class</span>];</span><br><span class="line">        <span class="built_in">BOOL</span> isValueOfAllowedType = <span class="literal">NO</span>;</span><br><span class="line">        <span class="comment">//查看是否是本框架兼容的属性类型</span></span><br><span class="line">        <span class="keyword">for</span> (Class allowedType <span class="keyword">in</span> allowedJSONTypes) &#123;</span><br><span class="line">            <span class="keyword">if</span> ( [jsonValueClass isSubclassOfClass: allowedType] ) &#123;</span><br><span class="line">                isValueOfAllowedType = <span class="literal">YES</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">//如果不兼容，则返回NO，mapping失败</span></span><br><span class="line">        <span class="keyword">if</span> (isValueOfAllowedType==<span class="literal">NO</span>) &#123;</span><br><span class="line">            <span class="comment">//type not allowed</span></span><br><span class="line">            JMLog(<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass));</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass)];</span><br><span class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</span><br><span class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是兼容的类型：</span></span><br><span class="line">        <span class="keyword">if</span> (property) &#123;</span><br><span class="line">            <span class="comment">// 查看是否有自定义setter，并设置</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __customSetValue:jsonValue forProperty:property]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            <span class="comment">// 基本类型</span></span><br><span class="line">            <span class="keyword">if</span> (property.type == <span class="literal">nil</span> &amp;&amp; property.structName==<span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">//kvc赋值</span></span><br><span class="line">                <span class="keyword">if</span> (jsonValue != [<span class="keyword">self</span> valueForKey:property.name]) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果传来的值是空，即使当前的属性对应的值不是空，也要将空值赋给它</span></span><br><span class="line">            <span class="keyword">if</span> (isNull(jsonValue)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> valueForKey:property.name] != <span class="literal">nil</span>) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setValue:<span class="literal">nil</span> forKey: property.name];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1. 属性本身是否是jsonmodel类型</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __isJSONModelSubClass:property.type]) &#123;</span><br><span class="line">                <span class="comment">//通过自身的转模型方法，获取对应的值</span></span><br><span class="line">                JSONModelError* initErr = <span class="literal">nil</span>;</span><br><span class="line">                <span class="keyword">id</span> value = [[property.type alloc] initWithDictionary: jsonValue error:&amp;initErr];</span><br><span class="line">                <span class="keyword">if</span> (!value) &#123;               </span><br><span class="line">                    <span class="comment">//如果该属性不是必须的，则略过</span></span><br><span class="line">                    <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//如果该属性是必须的，则返回错误</span></span><br><span class="line">                    <span class="keyword">if</span>((err != <span class="literal">nil</span>) &amp;&amp; (initErr != <span class="literal">nil</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        *err = [initErr errorByPrependingKeyPathComponent:property.name];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                &#125;            </span><br><span class="line">                <span class="comment">//当前的属性值为空，则赋值</span></span><br><span class="line">                <span class="keyword">if</span> (![value isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setValue:value forKey: property.name];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果不是jsonmodel的类型，则可能是一些普通的类型：NSArray，NSString。。。</span></span><br><span class="line">                <span class="comment">// 是否是模型嵌套（带有协议）</span></span><br><span class="line">                <span class="keyword">if</span> (property.protocol) &#123;</span><br><span class="line">                    <span class="comment">//转化为数组，这个数组就是例子中的friends属性。</span></span><br><span class="line">                    jsonValue = [<span class="keyword">self</span> __transform:jsonValue forProperty:property error:err];</span><br><span class="line">                   </span><br><span class="line">                    <span class="keyword">if</span> (!jsonValue) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((err != <span class="literal">nil</span>) &amp;&amp; (*err == <span class="literal">nil</span>)) &#123;</span><br><span class="line">                            <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Failed to transform value, but no error was set during transformation. (%@)"</span>, property];</span><br><span class="line">                            JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</span><br><span class="line">                            *err = [dataErr errorByPrependingKeyPathComponent:property.name];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 对象类型</span></span><br><span class="line">                <span class="keyword">if</span> (property.isStandardJSONType &amp;&amp; [jsonValue isKindOfClass: property.type]) &#123;</span><br><span class="line">                    <span class="comment">//可变类型</span></span><br><span class="line">                    <span class="keyword">if</span> (property.isMutable) &#123;</span><br><span class="line">                        jsonValue = [jsonValue mutableCopy];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//赋值</span></span><br><span class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</span><br><span class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前的值的类型与对应的属性的类型不一样的时候，需要查看用户是否自定义了转换器（例如从NSSet到NSArray转换：- (NSSet *)NSSetFromNSArray:(NSArray *)array）</span></span><br><span class="line">                <span class="keyword">if</span> (</span><br><span class="line">                    (![jsonValue isKindOfClass:property.type] &amp;&amp; !isNull(jsonValue))</span><br><span class="line">                    ||</span><br><span class="line">                    <span class="comment">//the property is mutable</span></span><br><span class="line">                    property.isMutable</span><br><span class="line">                    ||</span><br><span class="line">                    <span class="comment">//custom struct property</span></span><br><span class="line">                    property.structName</span><br><span class="line">                    ) &#123;</span><br><span class="line">                    <span class="comment">// searched around the web how to do this better</span></span><br><span class="line">                    <span class="comment">// but did not find any solution, maybe that's the best idea? (hardly)</span></span><br><span class="line">                    Class sourceClass = [JSONValueTransformer classByResolvingClusterClasses:[jsonValue <span class="keyword">class</span>]];</span><br><span class="line">                    <span class="comment">//JMLog(@"to type: [%@] from type: [%@] transformer: [%@]", p.type, sourceClass, selectorName);</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//build a method selector for the property and json object classes</span></span><br><span class="line">                    <span class="built_in">NSString</span>* selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@From%@:"</span>,</span><br><span class="line">                                              (property.structName? property.structName : property.type), <span class="comment">//target name</span></span><br><span class="line">                                              sourceClass]; <span class="comment">//source name</span></span><br><span class="line">                    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</span><br><span class="line">                    <span class="comment">//查看自定义的转换器是否存在</span></span><br><span class="line">                    <span class="built_in">BOOL</span> foundCustomTransformer = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</span><br><span class="line">                        foundCustomTransformer = <span class="literal">YES</span>;                        </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//try for hidden custom transformer</span></span><br><span class="line">                        selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"__%@"</span>,selectorName];</span><br><span class="line">                        selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</span><br><span class="line">                        <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</span><br><span class="line">                            foundCustomTransformer = <span class="literal">YES</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果存在自定义转换器，则进行转换</span></span><br><span class="line">                    <span class="keyword">if</span> (foundCustomTransformer) &#123;                        </span><br><span class="line">                        IMP imp = [valueTransformer methodForSelector:selector];</span><br><span class="line">                        <span class="keyword">id</span> (*func)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)imp;</span><br><span class="line">                        jsonValue = func(valueTransformer, selector, jsonValue);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</span><br><span class="line">                            [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];                        </span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;                       </span><br><span class="line">                        <span class="comment">//没有自定义转换器，返回错误</span></span><br><span class="line">                        <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ type not supported for %@.%@"</span>, property.type, [<span class="keyword">self</span> <span class="keyword">class</span>], property.name];</span><br><span class="line">                        JSONModelError* dataErr = [JSONModelError errorInvalidDataWithTypeMismatch:msg];</span><br><span class="line">                        *err = [dataErr errorByPrependingKeyPathComponent:property.name];</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 3.4) handle "all other" cases (if any)</span></span><br><span class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</span><br><span class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是：</p><ul><li>作者在最后给属性赋值的时候使用的是kvc的<code>setValue:ForKey:</code>的方法。</li><li>作者判断了模型里的属性的类型是否是JSONModel的子类，可见作者的考虑是非常周全的。</li><li>整个框架看下来，有很多的地方涉及到了错误判断，作者将将错误类型单独抽出一个类（<code>JSONModelError</code>），里面支持的错误类型很多，可以侧面反应作者思维之缜密。而且这个做法也可以在我们写自己的框架或者项目中使用。</li></ul></blockquote><p>错误判断的一个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSONModelError.m</span></span><br><span class="line">+(<span class="keyword">id</span>)errorInvalidDataWithMessage:(<span class="built_in">NSString</span>*)message</span><br><span class="line">&#123;</span><br><span class="line">    message = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Invalid JSON data: %@"</span>, message];</span><br><span class="line">    <span class="keyword">return</span> [JSONModelError errorWithDomain:JSONModelErrorDomain</span><br><span class="line">                                      code:kJSONModelErrorInvalidData</span><br><span class="line">                                  userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:message&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>夸了作者这么多，唯一我个人不太喜欢的地方就是if语句下只有一行的时候，作者不喜欢加上大括号：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</span><br><span class="line">    [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</span><br></pre></td></tr></table></figure></p><p>但是我觉得应该加的：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])&#123;</span><br><span class="line">  [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ul><li>作者用NSScanner来扫描字符串，将从类结构体里拿过来的属性的描述字符串<code>T@\&quot;NSString\&quot;,C,N,V_name</code>中扫描出了类型：<code>NSString</code>。</li><li>作者两次用到了NSSet：当集合里的元素顺序不重要的时候，优先考虑用NSSet。</li></ul><p>总的来说这个框架的难度还是不大的，但可能因为是第一次阅读不涉及UIVIiew的框架，感觉有些枯燥，不过慢慢习惯就好啦～</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列的&lt;a href=&quot;http://www.jianshu.com/nb/9137726&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源码解析&lt;/a&gt;分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。&lt;/p&gt;
&lt;p&gt;想来想去，还是从&lt;a href=&quot;https://github.com/jsonmodel/jsonmodel&quot;&gt;JSONModel&lt;/a&gt;开始吧～&lt;/p&gt;
&lt;p&gt;首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。&lt;/p&gt;
&lt;p&gt;该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>详解iOS多图下载的缓存机制</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E8%AF%A6%E8%A7%A3iOS%E5%A4%9A%E5%9B%BE%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/详解iOS多图下载的缓存机制/</id>
    <published>2018-02-02T16:17:12.000Z</published>
    <updated>2018-07-16T16:46:19.502Z</updated>
    
    <content type="html"><![CDATA[<p>做iOS开发也有半年多了，想想自己对一些第三方库还只是停留在简单运用的阶段，感觉心慌慌的。于是决定用一个月的时间深入了解一些好的第三方库。</p><p>第一个想到了SDWebImage，这个库很不错，几乎每个iOS项目都会有它的影子，因为它很完美地解决了下载图片并显示的处理逻辑。那么深究它之前，笔者准备先了解一下多图下载的缓存机制，因为它和SDWebImage的方案类似。</p><p>有一个多图缓存机制的教程是来自李明杰小码哥的，笔者觉得讲得挺不错的，于是就花了2个小时好好学习了一下。</p><a id="more"></a><h1 id="1-需求点是什么？"><a href="#1-需求点是什么？" class="headerlink" title="1.需求点是什么？"></a>1.需求点是什么？</h1><hr><p>这里所说的<strong>多图下载</strong>，就是要在tableview的每一个cell里显示一张图片,而且这些图片都需要从网上下载。</p><h1 id="2-容易遇到的问题"><a href="#2-容易遇到的问题" class="headerlink" title="2.容易遇到的问题"></a>2.容易遇到的问题</h1><hr><p>如果不知道或不使用<strong>异步操作</strong>和<strong>缓存机制</strong>，那么写出来的代码很可能会是这样：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cell.textLabel.text = app.name;</span><br><span class="line">cell.detailTextLabel.text = app.download;</span><br><span class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:app.url];</span><br><span class="line">cell.imageView.image = [<span class="built_in">UIImage</span> imageWithData:imageData];</span><br></pre></td></tr></table></figure><p>这样写有什么后果呢？</p><h4 id="后果1：不可避免的卡顿（因为没有异步下载操作）"><a href="#后果1：不可避免的卡顿（因为没有异步下载操作）" class="headerlink" title="后果1：不可避免的卡顿（因为没有异步下载操作）"></a>后果1：不可避免的卡顿（因为没有异步下载操作）</h4><blockquote><p>dataWithContentsOfURL：是耗时操作，将其放在主线程会造成卡顿。如果图片很多，图片很大，而且网络情况不好的话肯定会卡出翔！</p></blockquote><h4 id="后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）"><a href="#后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）" class="headerlink" title="后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）"></a>后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）</h4><blockquote><p>由于没有缓存机制，即使下载完成并显示了当前cell的图片，但是当该cell再一次需要显示的时候还是会下载它所对应的图片：耗费了下载流量，而且还导致重复操作。</p></blockquote><p>很显然，要达到Tableview滚动的<strong>如丝滑般的享受</strong>必须二者兼得才可以，具体怎么做呢？</p><h1 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h1><hr><h4 id="1-先看一下解决方案的流程图"><a href="#1-先看一下解决方案的流程图" class="headerlink" title="1.先看一下解决方案的流程图"></a>1.先看一下解决方案的流程图</h4><p>小码哥将他的解决方案在PPT里用流程图画了出来，笔者觉得很不错，但是颜值略低（毕竟人家是一心搞技术，没时间在意这些外在的东西），笔者理了理思路，自己重新画了一张（好看么？）：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-addf3137097c3912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多图下载解决方案流程图"></p><p>要想快速看懂此图，需要先了解该流程所需的所有数据源：</p><p><strong>1. 图片的URL</strong>：因为每张图片对应的URL都是唯一的，所以我们可以通过它来建立<strong>图片缓存</strong>和<strong>下载操作的缓存</strong>的键，以及拼接<strong>沙盒缓存</strong>的路径字符串。<br><strong>2. 图片缓存（字典）</strong>：存放于内存中；键为图片的URL，值为UIImage对象。作用：读取速度快，直接使用UIImage对象。<br><strong>3. 下载操作缓存（字典）</strong>：存放与内存中，键为图片的URL，值为NSBlockOperation对象。作用：用来避免对于同一张图片还要开启多个下载线程。<br><strong>4. 沙盒缓存(文件路径对应NSData)</strong>：存放于磁盘中，位于Cache文件夹内，路径为“Cache/图片URL的最后的部分”，值为NSData对象（将UIImage转化为NSData才能写入磁盘里）。作用：程序断网，再次启动也可以直接在磁盘中拿到图片。</p><h4 id="2-再看一下解决方案的代码"><a href="#2-再看一下解决方案的代码" class="headerlink" title="2.再看一下解决方案的代码"></a>2.再看一下解决方案的代码</h4><p><strong>2.1图片缓存，下载操作缓存，沙盒缓存路径</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  存放所有下载完的图片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *images;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  存放所有的下载操作（key是url，value是operation对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *operations;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  拼接Cache文件夹的路径与url最后的部分，合并成唯一约定好的缓存路径</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#define CachedImageFile(url) [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:[url lastPathComponent]]</span></span><br></pre></td></tr></table></figure></p><p><strong>2.2 图片下载之前的查询缓存部分</strong>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先从images缓存中取出图片url对应的UIImage</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = <span class="keyword">self</span>.images[app.icon];</span><br><span class="line">    <span class="keyword">if</span> (image) &#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存在：说明图片已经下载成功，并缓存成功）</span></span><br><span class="line">        cell.imageView.image = image;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line"></span><br><span class="line">     <span class="comment">// 不存在：说明图片并未下载成功过，或者成功下载但是在images里缓存失败，需要在沙盒里寻找对于的图片</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 获得url对于的沙盒缓存路径</span></span><br><span class="line">        <span class="built_in">NSString</span> *file = CachedImageFile(app.icon);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先从沙盒中取出图片</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:file];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//data不为空，说明沙盒中存在这个文件</span></span><br><span class="line">            cell.imageView.image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 反之沙盒中不存在这个文件</span></span><br><span class="line">             <span class="comment">// 在下载之前显示占位图片</span></span><br><span class="line">            cell.imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 下载图片</span></span><br><span class="line">            [<span class="keyword">self</span> download:app.icon indexPath:indexPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>2.3 图片的下载部分</strong>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  下载图片</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  @param imageUrl 图片的url</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)download:(<span class="built_in">NSString</span> *)imageUrl indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 取出当前图片url对应的下载操作（operation对象）</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span>.operations[imageUrl];</span><br><span class="line">    <span class="keyword">if</span> (operation) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建操作，下载图片</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) appsVc = <span class="keyword">self</span>;</span><br><span class="line">    operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:imageUrl];</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url]; <span class="comment">// 下载</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data]; <span class="comment">// NSData -&gt; UIImage</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回到主线程</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</span><br><span class="line">                     </span><br><span class="line">            <span class="keyword">if</span> (image) &#123;</span><br><span class="line">                <span class="comment">// 如果存在图片（下载完成），存放图片到图片缓存字典中</span></span><br><span class="line">                appsVc.images[imageUrl] = image;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将图片存入沙盒中</span></span><br><span class="line">                <span class="comment">//1. 先将图片转化为NSData</span></span><br><span class="line">                <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//2.  再生成缓存路径            </span></span><br><span class="line">                [data writeToFile:CachedImageFile(imageUrl) atomically:<span class="literal">YES</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从字典中移除下载操作 (保证下载失败后，能重新下载)</span></span><br><span class="line">            [appsVc.operations removeObjectForKey:imageUrl];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 刷新当前表格，减少系统开销</span></span><br><span class="line">            [appsVc.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationNone</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加下载操作到队列中</span></span><br><span class="line">    [<span class="keyword">self</span>.queue addOperation:operation];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前下载操作添加到下载操作缓存中 (为了解决重复下载)</span></span><br><span class="line">    <span class="keyword">self</span>.operations[imageUrl] = operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-有哪些点是值得注意的？"><a href="#3-有哪些点是值得注意的？" class="headerlink" title="3. 有哪些点是值得注意的？"></a>3. 有哪些点是值得注意的？</h4><p>要说值得注意的地方，还是离不开对于缓存内容的添加和删除操作。</p><p><strong>3.1 关于图片缓存</strong>：<br>很简单，成功下载，拿到了图片，就将图片添加到图片缓存中；下载失败，什么都不做，反正没有图。在这种机制下，就没有删除缓存里某个图片项的情况，因为图片缓存永远不会出现重复添加多个相同图片的情况，缓存中只要有一张对应的图，就直接拿去用了，不会去再下载了。</p><p><strong>3.2 关于沙盒缓存</strong>：<br>同样地，对于沙盒缓存也是一个道理：有图就将其转化为NSData，写入磁盘，并对应唯一的路径，没有图就不写。所以即使是要下载相同的图片，因为当前url对应的沙盒路径已经存在文件了，所以直接拿就可以了，不会再下载。</p><p>但是！<br>下载操作缓存是不同的！</p><p><strong>3.3 关于下载操作缓存</strong><br>我们需要在下载回调完成后，立即将当前的下载操作从下载操作缓存中删去！<br>因为要避免下载失败后，无法再次下载的情况的发生！</p><p>为什么呢？<br>注意一下将下载操作加入到下载操作缓存的时机：<br>是在<strong>下载开始的那一刻</strong>而不是<strong>下载成功的那一刻</strong>！</p><p>如果在下载开始的那一刻加入到缓存中的话，这个缓存信息就包括两个情况：下载成功和下载失败：</p><ul><li><p>如果未来下载成功了，那么我们就不会来到判断当前下载操作是否在下载操作缓存这一步，在这之前直接就可以拿图去用了，下载操作是否存在下载操作缓存里并没有什么影响。</p></li><li><p>但是！如果未来下载失败了，那就肯定不会有对应的图片缓存和沙盒缓存，也就肯定会来到判断当前的下载操作是否在下载操作缓存里这一步。不幸的是，因为没有被删去，它是存在的。存在的话就不做任何其他操作，放任自流，导致曾经下载失败的图片永远不会再次下载。</p></li></ul><p>忘了那段代码了么？回看一下代码（看我多好）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span>.operations[imageUrl];</span><br><span class="line"> <span class="keyword">if</span> (operation) <span class="keyword">return</span>;<span class="comment">//转身就走，毫不留情</span></span><br></pre></td></tr></table></figure></p><p>因此，无论下载成功或是失败，在图片下载的回调里都要将当前的下载操作从下载操作队列中移走：用来保证如果下载失败了，就可以重新开启对应的下载操作进行下载，逻辑上更加严谨。</p><h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4.最后的话"></a>4.最后的话</h1><hr><p>异步+缓存这两个机制双剑合璧的话会对程序新能带来很大的改观。这应该app开发进阶的必经之路。</p><p>小码哥讲述的这套流程还算比较完整的了，更重要的还是学习其中的思想：</p><blockquote><ol><li><p>将缓存分级：内存缓存，沙盒缓存，下载操作缓存。</p></li><li><p>而且还要经常使用二分法，将我们的逻辑考虑得滴水不漏。<br>如果我们没有认识到将下载操作添加到下载操作缓存的时机是包含下载成功和下载失败两个情况，那么就不会考虑到即时要将下载操作从下载操作缓存中删去的操作，很容易引起bug。所以在以后的开发中，成功和失败两个情况都要考虑进去，也就是说有if一定要有else！</p></li></ol></blockquote><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做iOS开发也有半年多了，想想自己对一些第三方库还只是停留在简单运用的阶段，感觉心慌慌的。于是决定用一个月的时间深入了解一些好的第三方库。&lt;/p&gt;
&lt;p&gt;第一个想到了SDWebImage，这个库很不错，几乎每个iOS项目都会有它的影子，因为它很完美地解决了下载图片并显示的处理逻辑。那么深究它之前，笔者准备先了解一下多图下载的缓存机制，因为它和SDWebImage的方案类似。&lt;/p&gt;
&lt;p&gt;有一个多图缓存机制的教程是来自李明杰小码哥的，笔者觉得讲得挺不错的，于是就花了2个小时好好学习了一下。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（一）：iOS的MVC框架</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AiOS%E7%9A%84MVC%E6%A1%86%E6%9E%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（一）：iOS的MVC框架/</id>
    <published>2018-02-02T16:17:05.000Z</published>
    <updated>2018-07-16T16:46:07.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写在开头"><a href="#写在开头" class="headerlink" title="写在开头"></a>写在开头</h2><hr><p>入职iOS开发也有半年了，一直没有积极更新技术博客，感到甚是惭愧。虽然这期斯坦福公开课内容相对基础一些，但是笔者还是想把每一课的内容都总结一下然后分享出去，也算是对自己的锻炼以及对这一经典的课程致敬吧。</p><p>课程地址：<a href="http://open.163.com/special/opencourse/ios7.html" target="_blank" rel="noopener">斯坦福大学公开课：iOS 7应用开发</a></p><p>废话少说，开始！</p><a id="more"></a><h2 id="MVC架构介绍"><a href="#MVC架构介绍" class="headerlink" title="MVC架构介绍"></a>MVC架构介绍</h2><hr><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h3><ul><li><strong>视图</strong>(View)：构建UI的类；例如：按钮，标签，进度条等。</li><li><strong>模型</strong>(Model)：视图类所需要的数据；例如：表格需要显示的文字。</li><li><strong>控制器</strong>(Controller)：连接视图类和模型类，任务是使数据显示在屏幕上。例如：控制器将表格需要使用的数据“填入”表格视图中，将表格视图显示出来。</li></ul><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><ul><li><strong>控制器可以直接访问模型</strong>：将模型直接作为控制器的属性。</li><li><strong>控制器可以直接访问视图</strong>：将视图直接作为控制器的属性。</li><li><p><strong>模型与视图无法直接访问对方</strong>：二者完全解耦，不能引用对方，把对方设置为属性。</p></li><li><p><strong>视图到控制器的通信</strong>：</p><ol><li><p><strong>目标动作机制</strong>(target - action)：用户与视图交互触发控制器的方法。例如：点击按钮后实现视界面跳转，网络请求，刷新UI等。</p></li><li><p><strong>委托机制</strong>(delegate)：视图向控制器询问某些自己无法决定的事情，或是让控制器帮助自己做一些自己独立无法完成的事情。 因为控制器才是掌握全局的角色，很多时候视图是无法自己做决定的。例如：表格问控制器：我可以滚动么？然后控制器给予回答告知是否可以继续滚动。 如果表格的高度很小，那么就可以不让它滚动。但是如果表格的高度已经超过了屏幕的高度，这时候如果让它自作主张无法滚动久不好了。                                             </p></li><li><strong>数据源机制</strong>(dataSource):视图让控制器给它将要显示的数据。例如：音乐的数据存在于模型里，控制器访问模型，从模型里拿到数据后告诉视图如何显示出歌曲。</li></ol></li><li><p><strong>模型到控制器的通信</strong></p><ol><li><strong>广播机制</strong>(Notification)：控制器注册监听某模型数据变化的广播频道，当此模型数据变化后向该控制器发送广播，告知模型变化情况。</li><li><strong>KVO机制</strong>(Key-Value Observing)：模型作为控制器的属性，当模型属性被修改后，持有此模型属性的控制器就会收到通知。</li></ol></li></ul><p>下面一张图可以直观看出上述的通信方式。图片来自本课程配套的<a href="https://itunes.apple.com/WebObjects/MZStore.woa/wa/viewPodcast?id=480479762" target="_blank" rel="noopener">课件</a><br><img src="http://upload-images.jianshu.io/upload_images/859001-492c53ebbb43ad76.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS MVC架构"></p><h2 id="其他知识"><a href="#其他知识" class="headerlink" title="其他知识"></a>其他知识</h2><hr><h3 id="类文件类型："><a href="#类文件类型：" class="headerlink" title="类文件类型："></a>类文件类型：</h3><ul><li><strong>.h文件</strong>(头文件):公开API，其他类可以调用的方法，告诉其他类“我能做些什么：<strong>what I can do</strong>。</li><li><strong>.m文件</strong>(实现文件):非公开API，如何实现.h文件的方法，查看实现文件可以知道该类具体是如何实现公开API的方法的:<strong>how to do</strong>。</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><strong>strong</strong>：在堆中保持这个所指的东西，至少有一个强指针指向它，否则就会释放。</li><li><strong>weak</strong>：如果没有强指针指向它，清理指向的内存后，会被设置成nil指针。</li><li><strong>nonatomic</strong>：不能有两个线程同时设置该属性。</li></ul><h3 id="零散知识"><a href="#零散知识" class="headerlink" title="零散知识"></a>零散知识</h3><ul><li>所有对象都在堆里，OC会为我们管理这些内存。</li><li>访问实例变量，就是访问对象的实例数据。</li><li>OC里，可以先实现方法再声明。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><hr><p>第一讲里的内容比较基础，重点是介绍了MVC模型的通信机制，需要反复推敲并且在实际操作中<strong>严格遵守</strong>。因为只有这样做才能降低类之间的耦合性，写出易于维护和扩展的代码。</p><p>比如在模型类里是不能调用控制器的方法的，模型类只能被控制器调用并且当所拥有的数据改变后通知使用自己的控制器数据的改变。更不能直接给视图通知让视图自己更新UI。</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;写在开头&quot;&gt;&lt;a href=&quot;#写在开头&quot; class=&quot;headerlink&quot; title=&quot;写在开头&quot;&gt;&lt;/a&gt;写在开头&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;入职iOS开发也有半年了，一直没有积极更新技术博客，感到甚是惭愧。虽然这期斯坦福公开课内容相对基础一些，但是笔者还是想把每一课的内容都总结一下然后分享出去，也算是对自己的锻炼以及对这一经典的课程致敬吧。&lt;/p&gt;
&lt;p&gt;课程地址：&lt;a href=&quot;http://open.163.com/special/opencourse/ios7.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;斯坦福大学公开课：iOS 7应用开发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;废话少说，开始！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（四 五）：属性字符串Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%20%E4%BA%94%EF%BC%89%EF%BC%9A%E5%B1%9E%E6%80%A7%E5%AD%97%E7%AC%A6%E4%B8%B2Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（四 五）：属性字符串Demo/</id>
    <published>2018-02-02T16:16:23.000Z</published>
    <updated>2018-07-16T16:46:02.555Z</updated>
    
    <content type="html"><![CDATA[<p>本节课讲解了iOS框架里几个重要的知识点：动态绑定，控制器的生命周期，属性字符串等。最后演示了一个Demo用来讲解属性字符串的几个功能。</p><a id="more"></a><h1 id="动态绑定"><a href="#动态绑定" class="headerlink" title="动态绑定"></a>动态绑定</h1><hr><p>在OC的编译期，所有的指针都是id类型，只有在运行时，对象的类型才会被确定。</p><p>举个🌰 ：<br>在编译期，<code>NSString*</code> 实际上与id相同，但是加上去的好处是让编译器知道你至少是<strong>意图让该指针指向一个字符串</strong>。所以如果尝试发送非字符串消息给该指针，它会发出警告，但是不会提示错误，仍可以通过编译。但是如果在运行时就会“露馅”，因为此时如果向该对象发送非字符串消息时，就会引起崩溃。</p><p>再举个具体的🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSString *hellow = @&quot;hello&quot;;</span><br><span class="line">Ship *hellowShip = (Ship *)hello;</span><br><span class="line">[helloShip shoot];</span><br></pre></td></tr></table></figure><blockquote><p>编译器会认为<code>hellowShip</code>是<code>ship</code>类型，因此向<code>hellowShip</code>发送<code>shoot</code>消息时，在编译器期是可以通过的。<br>但是，<code>hellowShip</code>实际上指向的是字符串，所以会导致在运行时崩溃。</p></blockquote><p>所以就引出了<strong>类型保护机制</strong>用来确定对象的类型：</p><h1 id="类型保护机制"><a href="#类型保护机制" class="headerlink" title="类型保护机制"></a>类型保护机制</h1><hr><h3 id="没有添加类型保护机制："><a href="#没有添加类型保护机制：" class="headerlink" title="没有添加类型保护机制："></a>没有添加类型保护机制：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PlayingCard *otherCard = [otherCards firstObject];</span><br><span class="line">[otherCard play];</span><br></pre></td></tr></table></figure><blockquote><p>firstObject 方法返回的是id类型，这里需要保护机制确保取出的对象是<code>PlayingCard</code>的实例，以防止向其发送消息时导致程序崩溃。</p></blockquote><h3 id="添加了类型保护机制："><a href="#添加了类型保护机制：" class="headerlink" title="添加了类型保护机制："></a>添加了类型保护机制：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PlayingCard *otherCard = [otherCards firstObject];</span><br><span class="line"></span><br><span class="line">id card = [otherCards firstObjct];</span><br><span class="line">if ([card isKindOfClass:[PlayingCard class]])</span><br><span class="line">&#123;</span><br><span class="line">   PlayingCard *otherCard = (PlaytingCard *)card;</span><br><span class="line">   [otherCard play];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>我们可以看到<code>card</code>指针通过<code>isKindOfClass:</code>方法被确认了是<code>PlayingCard</code>类的实例，那么如果我们给<code>card</code>实例发送其消息时，就不会发生崩溃。反之，若<code>card</code>是其他类的实例，如果向其发送<code>card</code>类的消息就会非常危险！</p></blockquote><h1 id="NSRange"><a href="#NSRange" class="headerlink" title="NSRange"></a>NSRange</h1><hr><p>NSRange是一个表示“范围”的结构体，包括起点和长度,主要用于字符串。</p><p>常用方法：</p><h4 id="字符串所有的字符："><a href="#字符串所有的字符：" class="headerlink" title="字符串所有的字符："></a>字符串所有的字符：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *title = @&quot;好好学习天天向上&quot;;</span><br><span class="line">NSMakeRange(0, [title length])</span><br></pre></td></tr></table></figure><h4 id="判断某个字符串里包含某个字符："><a href="#判断某个字符串里包含某个字符：" class="headerlink" title="判断某个字符串里包含某个字符："></a>判断某个字符串里包含某个字符：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NSString *greeting = @&quot;hellow world&quot;;</span><br><span class="line">Nsstring *hi = @&quot;hi&quot;;</span><br><span class="line">NSRange r = [greeting rangeOfString:hi];</span><br><span class="line">if(r.location != NSNotFound)</span><br><span class="line">&#123;</span><br><span class="line">    NSLog(@&quot;Found&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="控制器生命周期"><a href="#控制器生命周期" class="headerlink" title="控制器生命周期"></a>控制器生命周期</h1><hr><p>在控制器(ViewController)的生命周期里，处于某个特定的时间点会执行某个特定的方法。通过在这些方法里之行某些特定的任务，可以正确地实现其应实现的功能。</p><h3 id="viewDidLoad"><a href="#viewDidLoad" class="headerlink" title="viewDidLoad"></a>viewDidLoad</h3><p>控制器的<code>viewDidLoad</code>方法在控制器的view为nil的时候被调用，在控制器的生命周期中只调用一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- （voidviewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">   [super viewDidLoad];    </span><br><span class="line">   </span><br><span class="line">   //可执行：</span><br><span class="line">   //1. 控制器的初始化数据</span><br><span class="line">   //2. 网络请求</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //不可执行：</span><br><span class="line">   //1. 视图形状的初始化信息</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="viewWillAppear"><a href="#viewWillAppear" class="headerlink" title="viewWillAppear:"></a>viewWillAppear:</h3><p>控制器的<code>viewWillAppear:</code>在UIViewController对象的视图即将加入窗口时调用。只要该控制器的view即将要出现，都会调用，在控制器的生命周期中可以调用多次。<br>而且，如果该方法被调用，就说明视图<strong>一定</strong>会出现在屏幕上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillAppear:animated];</span><br><span class="line">    </span><br><span class="line">    //可执行：</span><br><span class="line">    //1. 更新view离开界面后可能会改变的数据。</span><br><span class="line">    //2. view的几何变化。</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="viewWillDisappear"><a href="#viewWillDisappear" class="headerlink" title="viewWillDisappear:"></a>viewWillDisappear:</h3><p>控制器的<code>viewWillDisappear:</code>在UIViewController的view即将不显示的时候调用，在控制器的生命周期中可以调用多次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewWillDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    </span><br><span class="line">    //可执行：</span><br><span class="line">    //1. 记录滚动视图的偏移量(因为要记住滚动位置，便于下次查看)</span><br><span class="line">    //2. 存储数据，便于再次显示该控制器时使用。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="属性字符串Demo"><a href="#属性字符串Demo" class="headerlink" title="属性字符串Demo"></a>属性字符串Demo</h1><hr><h2 id="设计需求"><a href="#设计需求" class="headerlink" title="设计需求"></a>设计需求</h2><ul><li>布局为TextView下方有四个颜色按钮，再下方有添加轮廓按钮和去除轮廓按钮。</li><li>选中TextView的文本后，点击色彩按钮，选中的文本的颜色变成点击的色彩按钮的背景色。</li><li>选中TextView的文本后，点击添加轮廓，选中的文本增加了轮廓，再点击色彩按钮，轮廓变成了相应的颜色。</li><li>文本有轮廓的状态下，点击去除轮廓按钮，轮廓消失。</li><li>在设置选项来改变系统字体，再回到本Demo界面，字体会做相应改变。</li></ul><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-4660010abbea2854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="属性字符串效果图"></p><h2 id="知识点详解"><a href="#知识点详解" class="headerlink" title="知识点详解"></a>知识点详解</h2><h4 id="属性字符串的设置"><a href="#属性字符串的设置" class="headerlink" title="属性字符串的设置"></a>属性字符串的设置</h4><p>属性字符串分为不可变属性字符串<code>NSAttributedString</code>和<code>NSMutableAttributedString</code>。</p><p>设置属性字符串的一般步骤为：</p><ol><li>初始化可变属性字符串。</li><li>向其添加属性字典和制定属性字典被应用的范围。</li></ol><p>举个🌰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//1. 由现有字符串初始化可变属性字符串</span><br><span class="line">NSMutableAttributedString *title = [[NSMutableAttributedString alloc] initWithString:self.outLineButton.currentTitle];</span><br><span class="line"></span><br><span class="line">//2. 添加属性字典和范围</span><br><span class="line">[title setAttributes:@&#123;NSStrokeWidthAttributeName : @3,</span><br><span class="line">                      NSStrokeColorAttributeName  : self.outLineButton.tintColor&#125;</span><br><span class="line">                                             range: NSMakeRange(0, [title length])];</span><br><span class="line"></span><br><span class="line">//3. 将属性字符串赋给按钮的属性字符串属性</span><br><span class="line">[self.outLineButton setAttributedTitle:title forState:UIControlStateNormal];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设定选中的字都被设置为和点击的按钮一样的背景颜色</span><br><span class="line">[self.textView.textStorage  addAttribute:NSForegroundColorAttributeName value:sender.backgroundColor range:self.body.selectedRange];</span><br></pre></td></tr></table></figure><h4 id="关于按钮的操作"><a href="#关于按钮的操作" class="headerlink" title="关于按钮的操作"></a>关于按钮的操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取按钮的背景色</span><br><span class="line">self.button.backgroundColor</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//获取按钮当前的标题</span><br><span class="line">self.button.currentTitle</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//设定按钮当前的属性字符串标题</span><br><span class="line">[self.button setAttributedTitle:title forState:UIControlStateNormal];</span><br></pre></td></tr></table></figure><h4 id="属性字典里的key："><a href="#属性字典里的key：" class="headerlink" title="属性字典里的key："></a>属性字典里的key：</h4><ul><li><code>NSForegroundColorAttributeName</code>:属性字符串字符的颜色</li><li><code>NSStrokeColorAttributeName</code>:属性字符串字符轮廓的颜色</li><li><code>NSStrokeWidthAttributeName</code>:属性字符串字符轮廓的宽度</li></ul><h4 id="获取TextView被选中的范围"><a href="#获取TextView被选中的范围" class="headerlink" title="获取TextView被选中的范围"></a>获取TextView被选中的范围</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">self.textView.selectedRange</span><br></pre></td></tr></table></figure><h4 id="通知机制"><a href="#通知机制" class="headerlink" title="通知机制"></a>通知机制</h4><p>为了实现本Demo最后一个需求，我们需要监听系统字体何时被改变了。所以需要注册一个能收听“系统改变”广播的频道：</p><p>注册通知：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(prefredFontsChaged:) name:UIContentSizeCategoryDidChangeNotification object:nil];</span><br></pre></td></tr></table></figure><p>这样一来，当系统字体发生变化时，注册该频道的对象会收到通知并执行自定义的方法。<br>当改变系统字体的大小后，该类会收到通知，并调用<code>prefredFontsChaged:</code>方法，此时Demo上的字体也要做相应的改变：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)prefredFontsChaged: (NSNotification *)notification</span><br><span class="line">&#123;</span><br><span class="line">    //收到通知后，调用本地自定义的方法</span><br><span class="line">    [self userPreferredFonts];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)userPreferredFonts</span><br><span class="line">&#123;</span><br><span class="line">    //使用被改变后的系统字体</span><br><span class="line">    self.body.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];</span><br><span class="line">    self.headLine.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里，显然又是一个MVC的流程：系统字体(模型)被改变了，通过广播(通知)的机制来告诉控制器，然后控制器再调用更改View的方法。还记得在第一篇（详情请见：<a href="http://www.jianshu.com/p/eb58ab21080a" target="_blank" rel="noopener">斯坦福大学iOS开发公开课总结（一） ：iOS的MVC框架</a>）里强调的，从模型到控制器的通信是通过广播或KVO机制完成的么？</p></blockquote><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr><p>如果哪位小伙伴想拿到此Demo的代码请不要客气，在评论里留言即可。<br>而且十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p><p>本文为笔者原创，如需转载，请事先与笔者交涉~</p><h1 id="2016-7-12日更新："><a href="#2016-7-12日更新：" class="headerlink" title="2016.7.12日更新："></a>2016.7.12日更新：</h1><hr><p>笔者已经把目前为止整理的所有Demo(第二课到第十课)放入到了我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>仓库里。分为英文注释版和中文注释版(英文注释要少一点，嘿嘿)想要的小伙伴可以果断下载~ 如果有不知道怎么下载的小伙伴请联系我~</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本节课讲解了iOS框架里几个重要的知识点：动态绑定，控制器的生命周期，属性字符串等。最后演示了一个Demo用来讲解属性字符串的几个功能。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E4%B8%80%EF%BC%89%EF%BC%9A%E8%A1%A8%E6%A0%BC%E8%A7%86%E5%9B%BE%EF%BC%8CFlickr-%E7%85%A7%E7%89%87%E6%9F%A5%E7%9C%8B%E5%99%A8Demo/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（十一）：表格视图，Flickr-照片查看器Demo/</id>
    <published>2018-02-02T16:16:18.000Z</published>
    <updated>2018-07-16T16:45:55.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UITableview"><a href="#UITableview" class="headerlink" title="UITableview"></a>UITableview</h1><hr><p>UITableview是iOS软件中最常见的视图，用来以表格的形式显示数据。</p><h2 id="数据源方法"><a href="#数据源方法" class="headerlink" title="数据源方法"></a>数据源方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (NSInteger)numberOfRowsInSection:(NSInteger)section;//表格的总section数，默认为返回1，可以不实现</span><br><span class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; //返回当前section的行数，必须实现</span><br><span class="line">- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; //返回某section某row的cell，必须实现</span><br></pre></td></tr></table></figure><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//cell被点击是调用的方法</span><br></pre></td></tr></table></figure><h2 id="根据cell获得对应的indexPath"><a href="#根据cell获得对应的indexPath" class="headerlink" title="根据cell获得对应的indexPath"></a>根据cell获得对应的indexPath</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> NSIndexPath *indexPath = [self.tableView  indexPathForCell :sender];</span><br></pre></td></tr></table></figure><h2 id="UITableView-Spinner"><a href="#UITableView-Spinner" class="headerlink" title="UITableView Spinner"></a>UITableView Spinner</h2><p>顶部加载时显示的小圆圈动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl;</span><br><span class="line"></span><br><span class="line">- (void)beginRefreshing;</span><br><span class="line">- (void)endRefreshing;</span><br></pre></td></tr></table></figure></p><h2 id="模型改变，刷新表格"><a href="#模型改变，刷新表格" class="headerlink" title="模型改变，刷新表格"></a>模型改变，刷新表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)reloadData; //刷新全部表格：一般在模型大部分变化的时候才调用，在某个数据变化时不推荐使用</span><br><span class="line"></span><br><span class="line">- (void)reloadRowsAtIndexPaths:(NSArray&lt;NSIndexPath *&gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//只刷新某一个cell，在某行货少数行数据变化时推荐使用</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="Universal-Application"><a href="#Universal-Application" class="headerlink" title="Universal Application"></a>Universal Application</h1><hr><p>Universal Application通用应用是指既可以在iPhone上运行，也可以在iPad上运行的应用，它有两个故事版文件，一个是针对iphone的，另一个是针对ipad的。</p><p>iPad有两种独有的视图：</p><ol><li>Split View：拆分视图</li><li>Popover:弹窗</li></ol><p>识别是否是ipad<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL iPad  = ([&#123;UIDevice currentDevice] userInterfaceIdiom] == UIUserInterfaceIdiomPad)</span><br></pre></td></tr></table></figure></p><h1 id="UISplitViewController"><a href="#UISplitViewController" class="headerlink" title="UISplitViewController"></a>UISplitViewController</h1><hr><h2 id="UISplitViewController包括"><a href="#UISplitViewController包括" class="headerlink" title="UISplitViewController包括"></a>UISplitViewController包括</h2><ul><li>Master View Controller</li><li>Detail View Controller</li></ul><p>UISplitViewController是storyboard的最顶层，不能被加入到UIViewController里面</p><h2 id="获得SplitViewController："><a href="#获得SplitViewController：" class="headerlink" title="获得SplitViewController："></a>获得SplitViewController：</h2><p>返回当前UIViewcontroller所在的SplitViewController:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIViewController.h</span><br><span class="line"></span><br><span class="line">@property (strong) UISplitViewController  *splitViewController;</span><br></pre></td></tr></table></figure></p><h2 id="获得SplitViewController的master和detail："><a href="#获得SplitViewController的master和detail：" class="headerlink" title="获得SplitViewController的master和detail："></a>获得SplitViewController的master和detail：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (copy) NSArray *viewControllers;//0：master;1: detail</span><br></pre></td></tr></table></figure><h2 id="UISplitViewControllerDelegate"><a href="#UISplitViewControllerDelegate" class="headerlink" title="UISplitViewControllerDelegate"></a>UISplitViewControllerDelegate</h2><p>在awakeFromNib设置此代理,代理负责 控制master和detail何时出现</p><p>代理的几个方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)splitViewController:(UISplitViewController *)svc shouldHideViewController:(UIViewController *)vc inOrientation:(UIInterfaceOrientation)orientation&#123;</span><br><span class="line">           return NO; //永远不隐藏master，master和detail将一直在屏幕上显示，无论是横屏或竖屏 </span><br><span class="line">           return UIInterfaceOrientationIsPortrait(orientation);//竖屏不显示master 但是竖屏时左上角有按键可以显示master，但是</span><br><span class="line">不实现这个代理就不能出现按钮了。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在横屏或竖屏是否该隐藏master</p><h1 id="Popovers"><a href="#Popovers" class="headerlink" title="Popovers"></a>Popovers</h1><hr><p>Popover是弹窗控件，它的作用是控制另一个视图控制器弹出到屏幕上，也是ipad独有的控件。<br>因为ipad的面积比较大，所以有时可以只以弹窗的形式提供信息而不用跳转到下一页面。</p><p>注意：这个控件并没有继承UIViewController，是一个NSObject</p><h2 id="Popover的Segue是UIStroyboardPopoverSegue。"><a href="#Popover的Segue是UIStroyboardPopoverSegue。" class="headerlink" title="Popover的Segue是UIStroyboardPopoverSegue。"></a>Popover的Segue是<code>UIStroyboardPopoverSegue</code>。</h2><p>在Popover出现之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)prepareForSegue: (UIStoryboardSegue *)segue sender: (id)sender</span><br><span class="line">&#123;</span><br><span class="line">    if([segue isKindOfClass:[UIStroyboardPopoverSegue class]])&#123;</span><br><span class="line">        </span><br><span class="line">         UIPopoverController *popoverController = ((UIStroyboardPopoverSegue *)segue.)popoverController;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使Popover消失："><a href="#使Popover消失：" class="headerlink" title="使Popover消失："></a>使Popover消失：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)dismissPopoverAnimated:(BOOL)animated;</span><br></pre></td></tr></table></figure><p>默认情况下，点击外部任何的地方都能使它消失，除非我们给它指定即使点击也不会消失的<code>UIVIew</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (copy) NSArray *passthroughViews;</span><br></pre></td></tr></table></figure><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr><p>该Demo是同时适用iPad 和iPhone的，可惜笔者没有iPad，无法调试，于是只适配了iPhone，以后有机会会补上适配iPad的代码的。</p><h2 id="Demo需求"><a href="#Demo需求" class="headerlink" title="Demo需求"></a>Demo需求</h2><ul><li>第一个页面用表格显示从Flickr抓取的图片数据，只显示图片名和图片详情。</li><li>点击第一个页面的cell，跳转到图片详情页。</li><li>图片详情页显示具体的大图，可以伸缩，可以移动。</li></ul><h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-b0a8e98131ae59b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图"></p><h2 id="重要代码段"><a href="#重要代码段" class="headerlink" title="重要代码段"></a>重要代码段</h2><h4 id="1-获取Flickr上的数据"><a href="#1-获取Flickr上的数据" class="headerlink" title="1. 获取Flickr上的数据"></a>1. 获取Flickr上的数据</h4><p>Flickr提供了公共的接口提供了自家的照片，接口文件在本Demo里的<code>Flickr Fetcher</code>文件里，唯一注意的是需要申请<code>APIKEY</code>,<a href="[http://www.flickr.com/services/api/misc.api_keys.html](http://www.flickr.com/services/api/misc.api_keys.html">申请网址</a>)。</p><p>解析照片数据的过程是比较耗时的，所以需要分配到子线程来进行。获得数组后，在主线程将数组赋予当前类的属性里。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)fetchPhotos</span><br><span class="line">&#123;</span><br><span class="line">    self.photos = nil;</span><br><span class="line">    NSURL *url = [FlickrFetcher URLforRecentGeoreferencedPhotos];</span><br><span class="line"></span><br><span class="line">    //手动创建一个子线程</span><br><span class="line">    dispatch_queue_t fetchQ = dispatch_queue_create(&quot;flickr fetcher&quot;, NULL);</span><br><span class="line"></span><br><span class="line">    dispatch_async(fetchQ, ^&#123;</span><br><span class="line"></span><br><span class="line">        //获得json数据，比较耗时</span><br><span class="line">        NSData *jsonResults = [NSData dataWithContentsOfURL:url];</span><br><span class="line"></span><br><span class="line">        //获得字典</span><br><span class="line">        NSDictionary *propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:NULL];</span><br><span class="line">        NSArray *photos = [propertyListResults valueForKeyPath:FLICKR_RESULTS_PHOTOS];</span><br><span class="line">   </span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line"></span><br><span class="line">           //回到主线程     </span><br><span class="line">            self.photos = photos;</span><br><span class="line"></span><br><span class="line">        &#125;);    </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NULL是C指针，代表指向OC指针的指针没有指向任何对象</p></blockquote><p>什么是指向OC指针的指针？：&amp;error是指向error的指针<br>如果我们这样写，就可以获得error：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> NSError *error = nil;</span><br><span class="line"> NSDictionary *propertyListResults = [NSJSONSerialization JSONObjectWithData:jsonResults options:0 error:&amp;error];</span><br></pre></td></tr></table></figure></p><p>如果我们不关心error，就可以传NULL。</p><p>好了，现在我们获得了数据，需要刷新表格：</p><h4 id="2-刷新表格"><a href="#2-刷新表格" class="headerlink" title="2. 刷新表格"></a>2. 刷新表格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)setPhotos:(NSArray *)photos</span><br><span class="line">&#123;</span><br><span class="line">    _photos = photos;</span><br><span class="line">    [self.tableView reloadData];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只是刷新表格是不够的，还要实现<code>UITableView</code>的数据源方法来告诉<code>TableView</code>如何显示数据。（调用<code>reload</code>方法后会调用这些数据源方法）</p><h4 id="3-实现数据源方法"><a href="#3-实现数据源方法" class="headerlink" title="3. 实现数据源方法"></a>3. 实现数据源方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Table view data source</span><br><span class="line"></span><br><span class="line">- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123;</span><br><span class="line">    //只有一组</span><br><span class="line">     return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123;</span><br><span class="line">   //行数为图片的个数</span><br><span class="line">    return self.photos.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123;</span><br><span class="line"></span><br><span class="line">    //从重用池中拿到cell</span><br><span class="line">    UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;Flickr Photo Cell&quot; forIndexPath:indexPath];</span><br><span class="line"></span><br><span class="line">    //通过indexPath来获得在数据里对应的图片数据</span><br><span class="line">    NSDictionary *photoDict = self.photos[indexPath.row];</span><br><span class="line">    //设置主标题和副标题</span><br><span class="line"></span><br><span class="line">    cell.textLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_TITLE];</span><br><span class="line"></span><br><span class="line">    cell.detailTextLabel.text = [photoDict valueForKeyPath:FLICKR_PHOTO_DESCRIPTION];    </span><br><span class="line"></span><br><span class="line">    return cell;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-点击cell，实现跳转"><a href="#4-点击cell，实现跳转" class="headerlink" title="4. 点击cell，实现跳转"></a>4. 点击cell，实现跳转</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - Navigation</span><br><span class="line"></span><br><span class="line">// In a storyboard-based application, you will often want to do a little preparation before navigation</span><br><span class="line"></span><br><span class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;</span><br><span class="line"></span><br><span class="line">    if ([sender isKindOfClass:[UITableViewCell class]]) &#123;</span><br><span class="line"></span><br><span class="line">        NSIndexPath *indexPath = [self.tableView indexPathForCell:sender];    </span><br><span class="line"></span><br><span class="line">        if (indexPath) &#123;</span><br><span class="line">         </span><br><span class="line">            if ([segue.destinationViewController isKindOfClass:[ImageViewController class]]) &#123;</span><br><span class="line"></span><br><span class="line">                [self prepareImageViewController:segue.destinationViewController toDisplayPhoto:self.photos[indexPath.row]];                </span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)prepareImageViewController:(ImageViewController *)ivc toDisplayPhoto:(NSDictionary*)photo</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   //获得图像的URL传给ImageViewController</span><br><span class="line">    ivc.imageURL = [FlickrFetcher URLforPhoto:photo format:FlickrPhotoFormatLarge];</span><br><span class="line">   //导航栏的标题为图片的名字</span><br><span class="line">    ivc.title = [photo valueForKey:FLICKR_PHOTO_TITLE];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里的<code>ImageViewController</code>复用了<a href="http://www.jianshu.com/p/ddb4f528b334" target="_blank" rel="noopener">斯坦福大学iOS开发公开课总结（十） ：多线程，UIScrollView，图片浏览器Demo</a>里第二个页面。</p></blockquote><h4 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h4><p>每次跳转到图片详情页，将图片的原点设置在最左上端，并且大小恢复到该图片的原始大小</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (void)setImage:(UIImage *)image</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //重置缩放大小为1</span><br><span class="line">    self.scrollView.zoomScale = 1.0;</span><br><span class="line">    self.imageView.image = image;</span><br><span class="line">    [self.imageView sizeToFit];</span><br><span class="line"></span><br><span class="line">    //将视图框的原点设在左上角</span><br><span class="line">    self.imageView.frame = CGRectMake(0, 0, self.image.size.width, self.image.size.height);</span><br><span class="line"></span><br><span class="line">    self.scrollView.contentSize = self.image? self.image.size : CGSizeZero;</span><br><span class="line"></span><br><span class="line">    [self.spinner stopAnimating];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr><p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p><p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p><p>本文为笔者原创，如需转载，请事先与笔者交涉~</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UITableview&quot;&gt;&lt;a href=&quot;#UITableview&quot; class=&quot;headerlink&quot; title=&quot;UITableview&quot;&gt;&lt;/a&gt;UITableview&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;UITableview是iOS软件中最常见的视图，用来以表格的形式显示数据。&lt;/p&gt;
&lt;h2 id=&quot;数据源方法&quot;&gt;&lt;a href=&quot;#数据源方法&quot; class=&quot;headerlink&quot; title=&quot;数据源方法&quot;&gt;&lt;/a&gt;数据源方法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (NSInteger)numberOfRowsInSection:(NSInteger)section;//表格的总section数，默认为返回1，可以不实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView; //返回当前section的行数，必须实现&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (nullable __kindof UITableViewCell *)cellForRowAtIndexPath:(NSIndexPath *)indexPath; //返回某section某row的cell，必须实现&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;代理方法&quot;&gt;&lt;a href=&quot;#代理方法&quot; class=&quot;headerlink&quot; title=&quot;代理方法&quot;&gt;&lt;/a&gt;代理方法&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//cell被点击是调用的方法&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;根据cell获得对应的indexPath&quot;&gt;&lt;a href=&quot;#根据cell获得对应的indexPath&quot; class=&quot;headerlink&quot; title=&quot;根据cell获得对应的indexPath&quot;&gt;&lt;/a&gt;根据cell获得对应的indexPath&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt; NSIndexPath *indexPath = [self.tableView  indexPathForCell :sender];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;UITableView-Spinner&quot;&gt;&lt;a href=&quot;#UITableView-Spinner&quot; class=&quot;headerlink&quot; title=&quot;UITableView Spinner&quot;&gt;&lt;/a&gt;UITableView Spinner&lt;/h2&gt;&lt;p&gt;顶部加载时显示的小圆圈动画&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property (nonatomic, strong, nullable) UIRefreshControl *refreshControl;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)beginRefreshing;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)endRefreshing;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;模型改变，刷新表格&quot;&gt;&lt;a href=&quot;#模型改变，刷新表格&quot; class=&quot;headerlink&quot; title=&quot;模型改变，刷新表格&quot;&gt;&lt;/a&gt;模型改变，刷新表格&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;- (void)reloadData; //刷新全部表格：一般在模型大部分变化的时候才调用，在某个数据变化时不推荐使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;- (void)reloadRowsAtIndexPaths:(NSArray&amp;lt;NSIndexPath *&amp;gt; *)indexPaths withRowAnimation:(UITableViewRowAnimation)animation;//只刷新某一个cell，在某行货少数行数据变化时推荐使用&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2018/02/03/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E5%9B%9B%20%E5%8D%81%E4%BA%94%EF%BC%89%EF%BC%9ACoreLocation%EF%BC%8CMapKit%EF%BC%8C%E5%9C%A8%E5%9C%B0%E5%9B%BE%E4%B8%8A%E6%A0%87%E8%AF%86Flickr%E6%91%84%E5%BD%B1%E5%B8%88%E7%9A%84%E4%BD%9C%E5%93%81/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2018/02/03/斯坦福大学iOS开发公开课总结（十四 十五）：CoreLocation，MapKit，在地图上标识Flickr摄影师的作品/</id>
    <published>2018-02-02T16:16:13.000Z</published>
    <updated>2018-07-16T16:45:50.412Z</updated>
    
    <content type="html"><![CDATA[<p>本总结将第十四和十五课放在了一起，原因有二：第一是略去了ipad开发Demo的部分（因为笔者木有ipad，无法进行调试）。第二是两节课都讲解了关于地图框架的相关知识，故将二者放在一起总结。</p><p>在本篇总结的最后，会给大家讲解在地图上显示Flickr上摄影师的照片作品。</p><h1 id="Network-Activity-Indicator"><a href="#Network-Activity-Indicator" class="headerlink" title="Network Activity Indicator"></a>Network Activity Indicator</h1><hr><p>顾名思义，该控件叫做网络活动指示器。当app有网络活动时，可以让状态栏左边的小圆圈滚动用来提示用户当前的网络状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(nonatomic,getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible;</span><br></pre></td></tr></table></figure><p>如果设定为YES，状态栏上的小转轮就会转，反之亦然。</p><blockquote><p>注意：应用中的所有线程都可使用这个转轮，我们需要通过各种方法来向用户准确显示转轮的状态。</p></blockquote><a id="more"></a><h1 id="Core-Location"><a href="#Core-Location" class="headerlink" title="Core Location"></a>Core Location</h1><hr><p>通过该框架的基本类：<code>CLLocation</code>，我们能获得设备处于地球上的位置信息。</p><h2 id="Core-Location几个重要的属性："><a href="#Core-Location几个重要的属性：" class="headerlink" title="Core Location几个重要的属性："></a>Core Location几个重要的属性：</h2><h4 id="1-坐标属性"><a href="#1-坐标属性" class="headerlink" title="1. 坐标属性"></a>1. 坐标属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">CLLocationDegrees latitude;    //double value</span><br><span class="line">CLLocationDegrees longitude;   //double value</span><br><span class="line">&#125; CLLocationCoordinate2D;</span><br></pre></td></tr></table></figure><h4 id="2-高度"><a href="#2-高度" class="headerlink" title="2. 高度"></a>2. 高度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property(readonly, nonatomic) CLLocationDistance altitude; //单位是米</span><br></pre></td></tr></table></figure><h4 id="3-变化精度："><a href="#3-变化精度：" class="headerlink" title="3. 变化精度："></a>3. 变化精度：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property(readonly, nonatomic) CLLocationAccuracy horizontalAccuracy;//水平精度</span><br><span class="line">@property(readonly, nonatomic) CLLocationAccuracy verticalAccuracy;//高度精度</span><br></pre></td></tr></table></figure><p>如何获得CLLocation？<br>通过实例化<code>CLLocationManager</code>类，让其告诉它的代理当前设备所处的位置。<br>下面来介绍一下<code>CLLocationManager</code>:</p><h1 id="CLLocationManager"><a href="#CLLocationManager" class="headerlink" title="CLLocationManager"></a>CLLocationManager</h1><hr><h2 id="CLLocationManager的工作步骤："><a href="#CLLocationManager的工作步骤：" class="headerlink" title="CLLocationManager的工作步骤："></a>CLLocationManager的工作步骤：</h2><p>1.查看硬件是否支持位置更新。<br>2.实例化<code>CLLocationManager</code>让其告诉它的代理当前的位置。<br>3.设置位置更新的类型(精度)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@property(assign, nonatomic) CLLocationAccuracy desiredAccuracy; //期望的经度</span><br><span class="line">@property(assign, nonatomic) CLLocationDistance distanceFilter;  //更新到该距离之内不要告诉我更新了多少</span><br></pre></td></tr></table></figure><p>4.开始位置监控。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)startUpdatingLocation;//开始更新位置</span><br><span class="line">- (void)stopUpdatingLocation;//停止位置更新</span><br><span class="line">- (void)locationManager:(CLLocationManager *)manager didUpdateLocations:(NSArray&lt;CLLocation *&gt; *)locations;//位置更新的代理方法</span><br><span class="line">- (void)locationManager:(CLLocationManager *)manager didFailWithError:(NSError *)error;//更新失败</span><br></pre></td></tr></table></figure><h2 id="位置监控的类型："><a href="#位置监控的类型：" class="headerlink" title="位置监控的类型："></a>位置监控的类型：</h2><h4 id="1-基于精度的监控"><a href="#1-基于精度的监控" class="headerlink" title="1. 基于精度的监控"></a>1. 基于精度的监控</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extern const CLLocationAccuracy kCLLocationAccuracyBestForNavigation; //最精确，但是非常耗能</span><br><span class="line">extern const CLLocationAccuracy kCLLocationAccuracyBest;</span><br><span class="line">extern const CLLocationAccuracy kCLLocationAccuracyNearestTenMeters;</span><br><span class="line">extern const CLLocationAccuracy kCLLocationAccuracyHundredMeters;</span><br><span class="line">extern const CLLocationAccuracy kCLLocationAccuracyKilometer;</span><br><span class="line">extern const CLLocationAccuracy kCLLocationAccuracyThreeKilometers;</span><br></pre></td></tr></table></figure><blockquote><p>注意：精度越高，耗电量越大</p></blockquote><h4 id="2-位置发生重大变化时更新。"><a href="#2-位置发生重大变化时更新。" class="headerlink" title="2. 位置发生重大变化时更新。"></a>2. 位置发生重大变化时更新。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)startMonitoringSignificantLocationChanges;</span><br><span class="line">- (void)stopMonitoringSignificantLocationChanges ;</span><br></pre></td></tr></table></figure><p>该方法在前台和后台都能监控位置的变化，甚至关掉app后，也可以启动应用告诉用户位置更新:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</span><br><span class="line">    //如果``launchOptions``存在``UIApplicationLaunchOptionsLocationKey``，说明程序启动的原因是因为位置发生了重大变化</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-进入某个区域更新。"><a href="#3-进入某个区域更新。" class="headerlink" title="3. 进入某个区域更新。"></a>3. 进入某个区域更新。</h4><p>3.1设定一个圆形的区域，经过该区域的时候会更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)startMonitoringForRegion:(CLRegion *)region;</span><br><span class="line">- (void)requestStateForRegion:(CLRegion *)region;</span><br></pre></td></tr></table></figure><p>3.2 通过一个信标来监控</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@property (readonly, nonatomic) CLLocationDistance maximumRegionMonitoringDistance;//设置最大监控距离</span><br><span class="line"></span><br><span class="line">- (void)startRangingBeaconsInRegion:(CLBeaconRegion *)region;//设置信标</span><br></pre></td></tr></table></figure><h4 id="4-监控前进的方向"><a href="#4-监控前进的方向" class="headerlink" title="4. 监控前进的方向"></a>4. 监控前进的方向</h4><h1 id="MapKit"><a href="#MapKit" class="headerlink" title="MapKit"></a>MapKit</h1><hr><p>MapKit是用于显示地图的框架，它通过<code>MKMapView</code>来显示地图。<br>我们来看一下该框架中几个比较重要的元素：</p><h2 id="1-MKMapView"><a href="#1-MKMapView" class="headerlink" title="1. MKMapView"></a>1. MKMapView</h2><p>MKMapView就是用来显示地图的View。</p><p>MKMapView的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic) MKMapType mapType;// MKMapTypeStandard : 标准；MKMapTypeSatellite:卫星；MKMapTypeHybrid：叠加</span><br><span class="line">@property (nonatomic) BOOL showsUserLocation; //显示用户的地点</span><br><span class="line">@property (nonatomic, readonly, getter=isUserLocationVisible) BOOL userLocationVisible;</span><br><span class="line">//用户坐标是否可见</span><br><span class="line">@property (nonatomic, getter=isZoomEnabled) BOOL zoomEnabled; //是否可放大缩小</span><br><span class="line">@property (nonatomic, getter=isRotateEnabled) BOOL rotateEnabled; //是否可旋转</span><br><span class="line">@property (nonatomic, getter=isPitchEnabled) BOOL pitchEnabled; //3D效果</span><br></pre></td></tr></table></figure></p><h2 id="2-MKAnnotationView"><a href="#2-MKAnnotationView" class="headerlink" title="2. MKAnnotationView"></a>2. MKAnnotationView</h2><p>在<code>MKMapView</code>视图里，可以显示用于标注具体位置的“大头针” ，它是MapKit框架里的<code>AnnotationView</code>。</p><p>MKAnnotationView的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong, nullable) id &lt;MKAnnotation&gt; annotation;</span><br><span class="line">@property (nonatomic, strong, nullable) UIImage *image;//大头针的图像</span><br><span class="line">@property (strong, nonatomic, nullable) UIView *leftCalloutAccessoryView;//左附属对话框</span><br><span class="line">@property (strong, nonatomic, nullable) UIView *rightCalloutAccessoryView;//右附属对话框</span><br><span class="line">@property (nonatomic, getter=isDraggable) BOOL draggable //是否可拖动</span><br></pre></td></tr></table></figure></p><p>大头针被点击时调用的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view</span><br></pre></td></tr></table></figure></p><h2 id="3-id"><a href="#3-id" class="headerlink" title="3. id"></a>3. id<mkannotation></mkannotation></h2><p>AnnotationView的数据源就是：id<mkannotation>，任何遵从该协议的对象都可以成为AnnotationView的数据源，也就是说，任何遵守    <code>MKAnootation</code>协议的对象你都可以将其放入地图中。</mkannotation></p><p>我们先看一下在MKMapView里的关于MKAnnotation的属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, readonly) NSArray&lt;id&lt;MKAnnotation&gt;&gt; *annotations;//包含MapView所显示的所有Annotaion</span><br></pre></td></tr></table></figure></p><p>注意：annotations是只读的数组，只能添加或者删除。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)addAnnotation:(id &lt;MKAnnotation&gt;)annotation;</span><br><span class="line">- (void)addAnnotations:(NSArray&lt;id&lt;MKAnnotation&gt;&gt; *)annotations;</span><br><span class="line">- (void)removeAnnotation:(id &lt;MKAnnotation&gt;)annotation;</span><br><span class="line">- (void)removeAnnotations:(NSArray&lt;id&lt;MKAnnotation&gt;&gt; *)annotations;</span><br></pre></td></tr></table></figure><p>MKAnnotation协议的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@protocol MKAnnotation &lt;NSObject&gt;</span><br><span class="line">@property (nonatomic, readonly) CLLocationCoordinate2D coordinate; //坐标</span><br><span class="line"></span><br><span class="line">@optional</span><br><span class="line">@property (nonatomic, readonly, copy, nullable) NSString *title;//标题</span><br><span class="line">@property (nonatomic, readonly, copy, nullable) NSString *subtitle;//副标题</span><br><span class="line"></span><br><span class="line">- (void)setCoordinate:(CLLocationCoordinate2D)newCoordinate ;//设置坐标</span><br></pre></td></tr></table></figure><p>那么二者是如何关联的呢？<br>通过MKMapView的代理方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation</span><br><span class="line">&#123;</span><br><span class="line">    //提供一个 annotation，返回一个 MKAnnotationView</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-Callout-对话框"><a href="#4-Callout-对话框" class="headerlink" title="4. Callout(对话框)"></a>4. Callout(对话框)</h2><p>点击大头针（MKAnnotationView），会出现一个白底的对话框，它被叫做<code>callout</code>,可以设置它的主标题和副标题。另外还有左右附属实图，它们可以显示图片或者箭头，也可被点击。﻿</p><h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><hr><h2 id="Demo需求："><a href="#Demo需求：" class="headerlink" title="Demo需求："></a>Demo需求：</h2><ul><li>显示从flickr抓取的摄影师列表。</li><li>点击列表中的一项，打开地图，在当前摄影师所照照片的地点显示大头针。</li><li>点击其中的一个大头针，显示照片详情：缩略图和名称。</li><li>点击箭头按钮，滑入显示照片的页面，显示原始照片。</li></ul><h2 id="Demo效果图："><a href="#Demo效果图：" class="headerlink" title="Demo效果图："></a>Demo效果图：</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-269dd622430d4972.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="在地图显示照片拍摄位置"></p><h2 id="重要代码段和知识点："><a href="#重要代码段和知识点：" class="headerlink" title="重要代码段和知识点："></a>重要代码段和知识点：</h2><h4 id="1-更改Core-Data模型"><a href="#1-更改Core-Data模型" class="headerlink" title="1. 更改Core Data模型"></a>1. 更改Core Data模型</h4><p>在上一节课的基础上，我们需要在模型里的<code>Photo</code>实体添加经度和纬度的属性，还有大头针缩略图的URL属性。<br>在更新属性后，一定要重新生成对应该实体的类文件，并且要将原app删除，因为数据库前后是不兼容的。</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-0bf538fa1a08fe3d.gif?imageMogr2/auto-orient/strip" alt="更新模型"></p><h4 id="2-新建PhotosByPhotographerMapViewController-h，用来显示MKMapView"><a href="#2-新建PhotosByPhotographerMapViewController-h，用来显示MKMapView" class="headerlink" title="2. 新建PhotosByPhotographerMapViewController.h，用来显示MKMapView"></a>2. 新建PhotosByPhotographerMapViewController.h，用来显示<code>MKMapView</code></h4><p>因为要在地图上显示摄影师所照照片的位置，因此，该类的数据源来自摄影师模型：<code>Photographer</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">#import &quot;Photographer.h&quot;</span><br><span class="line">@interface PhotosByPhotographerMapViewController : UIViewController</span><br><span class="line">@property (nonatomic, strong) Photographer *photographer;//公共API：摄影师</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>``</p><p>#import “PhotosByPhotographerMapViewController.h”</p><p>#import <mapkit mapkit.h=""></mapkit></p><p>@interface PhotosByPhotographerMapViewController ()<mkmapviewdelegate><br>@property (strong, nonatomic) IBOutlet MKMapView <em>mapView;//地图view<br>@property (nonatomic,strong) NSArray </em>photosByPhotographer;//装入摄影师拥有的照片的数组<br>@end</mkmapviewdelegate></p><p>@implementation PhotosByPhotographerMapViewController<br>@end<br>``</p><h4 id="3-导入Mapkit的framework"><a href="#3-导入Mapkit的framework" class="headerlink" title="3. 导入Mapkit的framework"></a>3. 导入Mapkit的framework</h4><p>需要注意的是，除了要在类文件引用<code>&lt;MapKit/MapKit.h&gt;</code>框架以外，还要手动向项目中添加该框架：</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-8fb04dfbac7bbdd7.gif?imageMogr2/auto-orient/strip" alt="手动添加MapKit框架.gif"></p><h4 id="4-更新photographer和mapView后更新annotation："><a href="#4-更新photographer和mapView后更新annotation：" class="headerlink" title="4. 更新photographer和mapView后更新annotation："></a>4. 更新photographer和mapView后更新annotation：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)setMapView:(MKMapView *)mapView</span><br><span class="line">&#123;</span><br><span class="line">    _mapView = mapView;</span><br><span class="line"></span><br><span class="line">    //设置代理</span><br><span class="line">    self.mapView.delegate = self;</span><br><span class="line"></span><br><span class="line">    //更新</span><br><span class="line">    [self updateMapViewAnnotations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setPhotographer:(Photographer *)photographer</span><br><span class="line">&#123;</span><br><span class="line">    _photographer = photographer;</span><br><span class="line">    //导航栏标题</span><br><span class="line">    self.title = photographer.name;</span><br><span class="line">    //准备更新数组，要事先设置其为nil，否则不会生成新的</span><br><span class="line">    self.photosByPhotographer = nil;</span><br><span class="line">    [self updateMapViewAnnotations];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)updateMapViewAnnotations</span><br><span class="line">&#123;</span><br><span class="line">    [self.mapView removeAnnotations:self.mapView.annotations];</span><br><span class="line">    [self.mapView addAnnotations:self.photosByPhotographer];</span><br><span class="line">    [self.mapView showAnnotations:self.photosByPhotographer animated:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-自定义点击大头针后显示的view"><a href="#5-自定义点击大头针后显示的view" class="headerlink" title="5. 自定义点击大头针后显示的view"></a>5. 自定义点击大头针后显示的view</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (MKAnnotationView *)mapView:(MKMapView *)mapView viewForAnnotation:(id&lt;MKAnnotation&gt;)annotation</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    //类似UITableviewCell的复用</span><br><span class="line">    static NSString *reuseId = @&quot;PhotosByPhotographerMapViewController&quot;;    </span><br><span class="line"></span><br><span class="line">    MKPinAnnotationView *view = (MKPinAnnotationView*)[mapView dequeueReusableAnnotationViewWithIdentifier:reuseId];    </span><br><span class="line"></span><br><span class="line">    if (!view) &#123;</span><br><span class="line">        view = [[MKPinAnnotationView alloc] initWithAnnotation:annotation reuseIdentifier:reuseId];</span><br><span class="line">       //是否显示callout</span><br><span class="line">        view.canShowCallout = YES;</span><br><span class="line">        //设置左部分的callout：UIImageView</span><br><span class="line">        UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 46, 46)];</span><br><span class="line">        view.leftCalloutAccessoryView = imageView;</span><br><span class="line">        //设置右部分的callout：UIButton</span><br><span class="line">        UIButton *disclosurebutton = [[UIButton alloc] init];</span><br><span class="line">        [disclosurebutton setBackgroundImage:[UIImage imageNamed:@&quot;disclosure&quot;] forState:UIControlStateNormal];</span><br><span class="line">        [disclosurebutton sizeToFit];</span><br><span class="line">        view.rightCalloutAccessoryView = disclosurebutton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    view.annotation = annotation;</span><br><span class="line">    return view;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-点击大头针，更新callout左侧显示的缩略图"><a href="#6-点击大头针，更新callout左侧显示的缩略图" class="headerlink" title="6. 点击大头针，更新callout左侧显示的缩略图"></a>6. 点击大头针，更新callout左侧显示的缩略图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  点击大头针view</span><br><span class="line"> *</span><br><span class="line"> *  @param mapView 大头针所属的mapView</span><br><span class="line"> *  @param view    大头针view</span><br><span class="line"> */</span><br><span class="line">- (void)mapView:(MKMapView *)mapView didSelectAnnotationView:(MKAnnotationView *)view</span><br><span class="line">&#123;</span><br><span class="line">    [self updateLeftCalloutAccessoryViewInAnnotationView:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  更新callout里的图片（在左侧）</span><br><span class="line"> *</span><br><span class="line"> *  @param annotationView 当前被点击的大头针view</span><br><span class="line"> */</span><br><span class="line">- (void)updateLeftCalloutAccessoryViewInAnnotationView:(MKAnnotationView *)annotationView</span><br><span class="line">&#123;</span><br><span class="line">    UIImageView *imageView = nil;</span><br><span class="line">    if ([annotationView.leftCalloutAccessoryView isKindOfClass:[UIImageView class]]) &#123;</span><br><span class="line">        imageView = (UIImageView *)annotationView.leftCalloutAccessoryView;</span><br><span class="line">    &#125;</span><br><span class="line">    if (imageView) &#123;</span><br><span class="line">        Photo *photo = nil;</span><br><span class="line">        if ([annotationView.annotation isKindOfClass:[Photo class]]) &#123;</span><br><span class="line">            photo = (Photo *)annotationView.annotation;</span><br><span class="line">        &#125;</span><br><span class="line">        if (photo) &#123;</span><br><span class="line">            NSString *urlString = photo.thumbnailURL;</span><br><span class="line">            imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：显示图片的代码：<code>imageView.image = [UIImage imageWithData:[NSData dataWithContentsOfURL:[NSURL URLWithString:urlString]]];</code>方法会阻塞主线程，实际操作中应该放在子线程中执行。详情请参考笔者另一篇讲解关于多线程的博客：<a href="http://www.jianshu.com/p/6e74f5438f2c" target="_blank" rel="noopener">最浅显易懂的iOS多线程技术 - GCD的教程</a>。</p></blockquote><h4 id="7-点击callout，在下一页面显示原图"><a href="#7-点击callout，在下一页面显示原图" class="headerlink" title="7. 点击callout，在下一页面显示原图"></a>7. 点击callout，在下一页面显示原图</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *  点击callout实行跳转</span><br><span class="line"> *</span><br><span class="line"> *  @param mapView 当前的mapView</span><br><span class="line"> *  @param view    当前callout所属的AnnotationView</span><br><span class="line"> *  @param control callout内部被点击的控件</span><br><span class="line"> */</span><br><span class="line">- (void)mapView:(MKMapView *)mapView annotationView:(MKAnnotationView *)view calloutAccessoryControlTapped:(UIControl *)control</span><br><span class="line">&#123;</span><br><span class="line">    [self performSegueWithIdentifier:@&quot;Show Photo&quot; sender:view];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  调转执行前的代码</span><br><span class="line"> *</span><br><span class="line"> *  @param segue  连接前后两个控制器的segue</span><br><span class="line"> *  @param sender 被点击的AnnotaionView</span><br><span class="line"> */</span><br><span class="line">- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    if ([sender isKindOfClass:[MKAnnotationView class]]) &#123;</span><br><span class="line">        [self prepareViewController:segue.destinationViewController</span><br><span class="line">                           forSegue:segue.identifier</span><br><span class="line">                   toShowAnnotation:((MKAnnotationView *)sender).annotation];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  为目标控制器准备数据（图片的URL）</span><br><span class="line"> *</span><br><span class="line"> *  @param vc              目标控制器</span><br><span class="line"> *  @param segueIdentifier segue.identifier</span><br><span class="line"> *  @param annotation      被点击的AnnotaionView</span><br><span class="line"> */</span><br><span class="line">- (void)prepareViewController:(id)vc</span><br><span class="line">                     forSegue:(NSString *)segueIdentifier</span><br><span class="line">             toShowAnnotation:(id &lt;MKAnnotation&gt;)annotation</span><br><span class="line">&#123;</span><br><span class="line">    Photo *photo = nil;</span><br><span class="line">    if ([annotation isKindOfClass:[Photo class]]) &#123;</span><br><span class="line">        photo = (Photo *)annotation;</span><br><span class="line">    &#125;</span><br><span class="line">    if (photo) &#123;</span><br><span class="line">        if (![segueIdentifier length] || [segueIdentifier isEqualToString:@&quot;Show Photo&quot;]) &#123;</span><br><span class="line">            if ([vc isKindOfClass:[ImageViewController class]]) &#123;</span><br><span class="line">                ImageViewController *ivc = (ImageViewController *)vc;</span><br><span class="line">                ivc.imageURL = [NSURL URLWithString:photo.imageURL];</span><br><span class="line">                ivc.title = photo.title;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：这里的<code>ivc.imageURL = [NSURL URLWithString:photo.imageURL];</code>代码同样会阻塞主线程，实际操作中应该放在子线程来做！</p><p>而且,本demo的图片地址应该都是在墙外的，所以最好先让电脑翻墙，然后在模拟器上运行比较好。</p></blockquote><h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr><p>如果哪位小伙伴想拿到本文Demo的代码请不要客气，可以进入我的<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">GitHub</a>下载哦~    这一系列到现在为止的所有Demo都在里面，分为英文注释版本和中文注释版本两种。</p><p>十分欢迎给笔者的代码和文笔抛出宝贵的意见和建议~</p><p>本文为笔者原创，如需转载，请事先与笔者交涉~</p><p><strong>————————————————-   2018年7月17日更新  ————————————————-</strong></p><p><strong>注意注意！！！</strong></p><p>笔者在近期开通了个人公众号，主要分享编程，读书笔记，思考类的文章。</p><ul><li><strong>编程类</strong>文章：包括笔者以前发布的精选技术文章，以及后续发布的技术文章（以原创为主），并且逐渐脱离 iOS 的内容，将侧重点会转移到<strong>提高编程能力</strong>的方向上。</li><li><strong>读书笔记类</strong>文章：分享<strong>编程类</strong>，<strong>思考类</strong>，<strong>心理类</strong>，<strong>职场类</strong>书籍的读书笔记。</li><li><strong>思考类</strong>文章：分享笔者平时在<strong>技术上</strong>，<strong>生活上</strong>的思考。</li></ul><blockquote><p>因为公众号每天发布的消息数有限制，所以到目前为止还没有将所有过去的精选文章都发布在公众号上，后续会逐步发布的。</p></blockquote><p><strong>而且因为各大博客平台的各种限制，后面还会在公众号上发布一些短小精干，以小见大的干货文章哦~</strong></p><p>扫下方的公众号二维码并点击关注，期待与您的共同成长~</p><p><img src="http://upload-images.jianshu.io/upload_images/859001-5bddfacafb9e9079.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="公众号：程序员维他命"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本总结将第十四和十五课放在了一起，原因有二：第一是略去了ipad开发Demo的部分（因为笔者木有ipad，无法进行调试）。第二是两节课都讲解了关于地图框架的相关知识，故将二者放在一起总结。&lt;/p&gt;
&lt;p&gt;在本篇总结的最后，会给大家讲解在地图上显示Flickr上摄影师的照片作品。&lt;/p&gt;
&lt;h1 id=&quot;Network-Activity-Indicator&quot;&gt;&lt;a href=&quot;#Network-Activity-Indicator&quot; class=&quot;headerlink&quot; title=&quot;Network Activity Indicator&quot;&gt;&lt;/a&gt;Network Activity Indicator&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;顾名思义，该控件叫做网络活动指示器。当app有网络活动时，可以让状态栏左边的小圆圈滚动用来提示用户当前的网络状态。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@property(nonatomic,getter=isNetworkActivityIndicatorVisible) BOOL networkActivityIndicatorVisible;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果设定为YES，状态栏上的小转轮就会转，反之亦然。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：应用中的所有线程都可使用这个转轮，我们需要通过各种方法来向用户准确显示转轮的状态。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>

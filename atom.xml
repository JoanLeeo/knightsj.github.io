<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>J_Knight</title>
  <subtitle>每天进步一点点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/knightsj/knightsj.github.io/"/>
  <updated>2017-04-14T04:19:08.000Z</updated>
  <id>https://github.com/knightsj/knightsj.github.io/</id>
  
  <author>
    <name>J_Knight</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Objective-C 高级编程》干货三部曲（一）：引用计数篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/04/10/%E3%80%8AObjective-C%20%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E3%80%8B%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/04/10/《Objective-C 高级编程》干货三部曲（一）：引用计数篇/</id>
    <published>2017-04-10T00:40:50.000Z</published>
    <updated>2017-04-14T04:19:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>总结了<a href="http://www.jianshu.com/nb/6074358" target="_blank" rel="external">Effective Objective-C</a>之后，还想读一本进阶的iOS书，毫不犹豫选中了《Objective-C 高级编程》：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>这本书有三个章节，我针对每一章节进行总结并加上适当的扩展分享给大家。可以从下面这张图来看一下这三篇的整体结构：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程》 干货三部曲"></p>
<p>注意，这个结构并不和书中的结构一致，而是以书中的结构为参考，稍作了调整。</p>
<p>本篇是第一篇：引用计数，简单说两句：<br>Objective-C通过 retainCount 的机制来决定对象是否需要释放。 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。</p>
<a id="more"></a>
<p>先看一下手动内存管理：</p>
<h1 id="手动内存管理"><a href="#手动内存管理" class="headerlink" title="手动内存管理"></a>手动内存管理</h1><p>我个人觉得，学习一项新的技术之前，需要先了解一下它的核心思想。理解了核心思想之后，对技术点的把握就会更快一些：</p>
<h2 id="内存管理的思想"><a href="#内存管理的思想" class="headerlink" title="内存管理的思想"></a>内存管理的思想</h2><ul>
<li>思想一：自己生成的对象，自己持有。</li>
<li>思想二：非自己生成的对象，自己也能持有。</li>
<li>思想三：不再需要自己持有的对象时释放对象。</li>
<li>思想四：非自己持有的对象无法释放。</li>
</ul>
<p>从上面的思想来看，我们对对象的操作可以分为三种：生成，持有，释放，再加上废弃，一共有四种。它们所对应的Objective-C的方法和引用计数的变化是：</p>
<table>
<thead>
<tr>
<th>对象操作</th>
<th>Objecctive-C方法</th>
<th>引用计数的变化</th>
</tr>
</thead>
<tbody>
<tr>
<td>生成并持有对象</td>
<td>alloc/new/copy/mutableCopy等方法</td>
<td>+1</td>
</tr>
<tr>
<td>持有对象</td>
<td>retain方法</td>
<td>+1</td>
</tr>
<tr>
<td>释放对象</td>
<td>release方法</td>
<td>-1</td>
</tr>
<tr>
<td>废弃对象</td>
<td>dealloc方法</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>用书中的图来直观感受一下这四种操作：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-5ced77c57afcfab8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>下面开始逐一解释上面的四条思想：</p>
<h3 id="思想一：自己生成的对象，自己持有"><a href="#思想一：自己生成的对象，自己持有" class="headerlink" title="思想一：自己生成的对象，自己持有"></a>思想一：自己生成的对象，自己持有</h3><p>在生成对象时，使用以下面名称开头的方法生成对象以后，就会持有该对象：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure>
<p>这行代码过后，指向生成并持有[[NSObject alloc] init]的指针被赋给了obj，也就是说obj这个指针强引用[[NSObject alloc] init]这个对象。</p>
<p>同样适用于new方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure></p>
<p>注意：<br>这种将持有对象的指针赋给指针变量的情况不只局限于上面这四种方法名称，还包括以他们开头的所有方法名称：</p>
<ul>
<li>allocThisObject</li>
<li>newThatObject</li>
<li>copyThisObject</li>
<li>mutableCopyThatObject</li>
</ul>
<p>举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1 = [obj0 allocObject];<span class="comment">//符合上述命名规则，生成并持有对象</span></div></pre></td></tr></table></figure>
<p>它的内部实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)allocObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>反过来，如果不符合上述的命名规则，那么就不会持有生成的对象，<br>看一个不符合上述命名规则的返回对象的createObject方法的内部实现🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)createObject</div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">    [obj autorelease];<span class="comment">//取得对象，但自己不持有</span></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>经由这个方法返回以后，无法持有这个返回的对象。因为这里使用了autorelease。autorelease提供了这样一个功能：在对象超出其指定的生存范围时能够自动并正确地释放（详细会在后面介绍）。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-97b23d0108e4cadf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<blockquote>
<p>也就是说，生成一个调用方不持有的对象是可以通过autorelease来实现的（例如NSMutableArray的array类方法）。</p>
<p>我的个人理解是：通过autorelease方法，使对象的持有权转移给了自动释放池。所以实现了：调用方拿到了对象，但这个对象还不被调用方所持有。</p>
</blockquote>
<p>由这个不符合命名规则的例子来引出思想二：</p>
<h3 id="思想二：非自己生成的对象，自己也能持有"><a href="#思想二：非自己生成的对象，自己也能持有" class="headerlink" title="思想二：非自己生成的对象，自己也能持有"></a>思想二：非自己生成的对象，自己也能持有</h3><p>我们现在知道，仅仅通过上面那个不符合命名规则的返回对象实例的方法是无法持有对象的。但是我们可以通过某个操作来持有这个返回的对象：这个方法就是通过retain方法来让指针变量持有这个新生成的对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj <span class="keyword">retain</span>];<span class="comment">//持有新生成的对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里[NSMutableArray array]返回的非自己持有的对象正是通过上文介绍过的autorelease方法实现的。所以如果想持有这个对象，需要执行retain方法才可以。</p>
</blockquote>
<h3 id="思想三：不再需要自己持有的对象时释放对象"><a href="#思想三：不再需要自己持有的对象时释放对象" class="headerlink" title="思想三：不再需要自己持有的对象时释放对象"></a>思想三：不再需要自己持有的对象时释放对象</h3><p>对象的持有者<strong>有义务</strong>在不再需要这个对象的时候<strong>主动</strong>将这个对象释放。注意，是<strong>有义务</strong>，而不是有权利，注意两个词的不同。</p>
<p>来看一下释放对象的例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj doSomething];<span class="comment">//使用该对象做一些事情</span></div><div class="line">[obj release];<span class="comment">//事情做完了，释放该对象</span></div></pre></td></tr></table></figure></p>
<p>同样适用于非自己生成并持有的对象（参考思想二）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj <span class="keyword">retain</span>];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj soSomething];<span class="comment">//使用该对象做一些事情</span></div><div class="line">[obj release];<span class="comment">//事情做完了，释放该对象</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>可能遇到的面试题</strong>：调用对象的release方法会销毁对象吗？<br>答案是不会：调用对象的release方法只是将对象的引用计数器-1，当对象的引用计数器为0的时候会调用了对象的dealloc 方法才能进行释放对象的内存。</p>
</blockquote>
<h3 id="思想四：无法释放非自己持有的对象"><a href="#思想四：无法释放非自己持有的对象" class="headerlink" title="思想四：无法释放非自己持有的对象"></a>思想四：无法释放非自己持有的对象</h3><p>在释放对象的时候，我们只能释放已经持有的对象，非自己持有的对象是不能被自己释放的。这很符合常识：就好比你自己才能从你自己的银行卡里取钱，取别人的卡里的钱是不对的（除非他的钱归你管。。。只是随便举个例子）。</p>
<h4 id="两种不允许的情况："><a href="#两种不允许的情况：" class="headerlink" title="两种不允许的情况："></a>两种不允许的情况：</h4><h4 id="1-释放一个已经废弃了的对象"><a href="#1-释放一个已经废弃了的对象" class="headerlink" title="1.  释放一个已经废弃了的对象"></a>1.  释放一个已经废弃了的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//持有新生成的对象</span></div><div class="line">[obj doSomething];<span class="comment">//使用该对象</span></div><div class="line">[obj release];<span class="comment">//释放该对象，不再持有了</span></div><div class="line">[obj release];<span class="comment">//释放已经废弃了的对象，崩溃</span></div></pre></td></tr></table></figure>
<h4 id="2-释放自己不持有的对象"><a href="#2-释放自己不持有的对象" class="headerlink" title="2. 释放自己不持有的对象"></a>2. 释放自己不持有的对象</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];<span class="comment">//非自己生成并持有的对象</span></div><div class="line">[obj release];<span class="comment">//释放了非自己持有的对象</span></div></pre></td></tr></table></figure>
<p>思考：哪些情况会使对象失去拥有者呢？</p>
<ol>
<li>将指向某对象的指针变量指向另一个对象。</li>
<li>将指向某对象的指针变量设置为nil。</li>
<li>当程序释放对象的某个拥有者时。</li>
<li>从collection类中删除对象时。</li>
</ol>
<p>现在知道了引用计数式内存管理的四个思想，我们再来看一下四个操作引用计数的方法：</p>
<h2 id="alloc-retain-release-dealloc的实现"><a href="#alloc-retain-release-dealloc的实现" class="headerlink" title="alloc/retain/release/dealloc的实现"></a>alloc/retain/release/dealloc的实现</h2><p>某种意义上，GNUstep 和 Foundation 框架的实现是相似的。所以这本书的作者通过GNUstep的源码来推测了苹果Cocoa框架的实现。</p>
<p>下面开始针对每一个方法，同时用GNUstep和苹果的实现方式（追踪程序的执行和作者的猜测）来对比一下各自的实现。</p>
<h3 id="GNUstep实现："><a href="#GNUstep实现：" class="headerlink" title="GNUstep实现："></a>GNUstep实现：</h3><h4 id="alloc方法"><a href="#alloc方法" class="headerlink" title="alloc方法"></a>alloc方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m alloc:</span></div><div class="line"></div><div class="line">+ (<span class="keyword">id</span>) alloc</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> allocWithZone: <span class="built_in">NSDefaultMallocZone</span>()];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">+ (<span class="keyword">id</span>) allocWithZone: (<span class="built_in">NSZone</span>*)z</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSAllocateObject</span>(<span class="keyword">self</span>, <span class="number">0</span>, z);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里NSAllocateObject方法分配了对象，看一下它的内部实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m NSAllocateObject:</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> obj_layout &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> retained;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="built_in">NSAllocateObject</span>(Class aClass, <span class="built_in">NSUInteger</span> extraBytes, <span class="built_in">NSZone</span> *zone)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> size = 计算容纳对象所需内存大小;</div><div class="line">    <span class="keyword">id</span> new = <span class="built_in">NSZoneMalloc</span>(zone, <span class="number">1</span>, size);<span class="comment">//返回新的实例</span></div><div class="line">    memset (new, <span class="number">0</span>, size);</div><div class="line">    new = (<span class="keyword">id</span>)&amp;((obj)new)[<span class="number">1</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>NSAllocateObject函数通过NSZoneMalloc函数来分配存放对象所需要的内存空间。</li>
<li>obj_layout是用来保存引用计数，并将其写入对象内存头部。</li>
</ol>
</blockquote>
<p>对象的引用计数可以通过retainCount方法来取得：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">GNUstep/modules/core/base/Source/<span class="built_in">NSObject</span>.m retainCount:</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>) retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">NSExtraRefCount</span>(<span class="keyword">self</span>) + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">inline</span> <span class="built_in">NSUInteger</span></div><div class="line"><span class="built_in">NSExtraRefCount</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> ((obj_layout)anObject)[<span class="number">-1</span>].retained;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，给NSExtraRefCount传入anObject以后，通过访问对象内存头部的.retained变量，来获取引用计数。</p>
<h4 id="retain方法"><a href="#retain方法" class="headerlink" title="retain方法"></a>retain方法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">//GNUstep/modules/core/base/Source/NSObject.m retain:</div><div class="line"></div><div class="line">- (id)retain</div><div class="line">&#123;</div><div class="line">    NSIncrementExtraRefCount(self);</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">inline void NSIncrementExtraRefCount(id anObject)</div><div class="line">&#123;</div><div class="line">    //retained变量超出最大值,抛出异常</div><div class="line">    if (((obj)anObject)[-1].retained == UINT_MAX - 1)&#123;</div><div class="line">        [NSException raise: NSInternalInconsistencyException</div><div class="line">        format: @"NSIncrementExtraRefCount() asked to increment too far”];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    ((obj_layout)anObject)[-1].retained++;//retained变量+1</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m release</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果当前的引用计数 = 0，调用dealloc函数</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">self</span>))</div><div class="line">    &#123;</div><div class="line">        [<span class="keyword">self</span> dealloc];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="built_in">BOOL</span> <span class="built_in">NSDecrementExtraRefCountWasZero</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//如果当前的retained值 = 0.则返回yes</span></div><div class="line">    <span class="keyword">if</span> (((obj)anObject)[<span class="number">-1</span>].retained == <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果大于0，则-1，并返回NO</span></div><div class="line">    ((obj)anObject)[<span class="number">-1</span>].retained--;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="dealloc方法"><a href="#dealloc方法" class="headerlink" title="dealloc方法"></a>dealloc方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m dealloc</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>) dealloc</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSDeallocateObject</span> (<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="built_in">NSDeallocateObject</span>(<span class="keyword">id</span> anObject)</div><div class="line">&#123;</div><div class="line">    obj_layout o = &amp;((obj_layout)anObject)[<span class="number">-1</span>];</div><div class="line">    free(o);<span class="comment">//释放</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>总结一下上面的几个方法：</p>
<ul>
<li>Objective-C对象中保存着引用计数这一整数值。</li>
<li>调用alloc或者retain方法后，引用计数+1。</li>
<li>调用release后，引用计数-1。</li>
<li>引用计数为0时，调用dealloc方法废弃对象。</li>
</ul>
<p>下面看一下苹果的实现：</p>
<h3 id="苹果的实现"><a href="#苹果的实现" class="headerlink" title="苹果的实现"></a>苹果的实现</h3><h4 id="alloc方法-1"><a href="#alloc方法-1" class="headerlink" title="alloc方法"></a>alloc方法</h4><p>通过在NSObject类的alloc类方法上设置断点，我们可以看到执行所调用的函数：</p>
<ul>
<li>+alloc</li>
<li>+allocWithZone:</li>
<li>class_createInstance//生成实例</li>
<li>calloc//分配内存块</li>
</ul>
<p>retainCount:</p>
<ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashGetCountOfKey</li>
</ul>
<h4 id="retain方法-1"><a href="#retain方法-1" class="headerlink" title="retain方法"></a>retain方法</h4><ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashAddValue</li>
</ul>
<h4 id="release方法-1"><a href="#release方法-1" class="headerlink" title="release方法"></a>release方法</h4><ul>
<li>__CFdoExternRefOperation</li>
<li>CFBasicHashRemoveValue</li>
</ul>
<p>我们可以看到他们都调用了一个共同的 __CFdoExternRefOperation 方法。</p>
<p>看一下它的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> __CFDoExternRefOperation(uintptr_t op, <span class="keyword">id</span> obj) &#123;</div><div class="line"></div><div class="line">    <span class="built_in">CFBasicHashRef</span> table = 取得对象的散列表(obj);</div><div class="line">    <span class="keyword">int</span> count;</div><div class="line"> </div><div class="line">    <span class="keyword">switch</span> (op) &#123;</div><div class="line">    <span class="keyword">case</span> OPERATION_retainCount:</div><div class="line">        count = <span class="built_in">CFBasicHashGetCountOfKey</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> count;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> OPERATION_retain:</div><div class="line">        count = <span class="built_in">CFBasicHashAddValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> obj;</div><div class="line">    </div><div class="line">    <span class="keyword">case</span> OPERATION_release:</div><div class="line">        count = <span class="built_in">CFBasicHashRemoveValue</span>(table, obj);</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span> == count;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出，__CFDoExternRefOperation通过switch语句 针对不同的操作来进行具体的方法调用，如果 op 是 OPERATION_retain，就去掉用具体实现 retain 的方法，以此类推。</p>
<p>可以猜想上层的retainCount,retain,release方法的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)retainCount</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="built_in">NSUInteger</span>)____CFDoExternRefOperation(OPERATION_retainCount,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)<span class="keyword">retain</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)____CFDoExternRefOperation(OPERATION_retain,<span class="keyword">self</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//这里返回值应该是id，原书这里应该是错了</span></div><div class="line">- (<span class="keyword">id</span>)release</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">id</span>)____CFDoExternRefOperation(OPERATION_release,<span class="keyword">self</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们观察一下switch里面每个语句里的执行函数名称，似乎和散列表（Hash）有关，这说明苹果对引用计数的管理应该是通过散列表来执行的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-46b607c905f2355d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>在这张表里，key为内存块地址，而对应的值为引用计数。也就是说，它保存了这样的信息：一些被引用的内存块各自对应的引用计数。</p>
<p>那么使用散列表来管理内存有什么好处呢？</p>
<p>因为计数表保存内存块地址，我们就可以通过这张表来：</p>
<ul>
<li>确认损坏内存块的位置。</li>
<li>在检测内存泄漏时，可以查看各对象的持有者是否存在。</li>
</ul>
<h2 id="autorelease"><a href="#autorelease" class="headerlink" title="autorelease"></a>autorelease</h2><h3 id="autorelease-介绍"><a href="#autorelease-介绍" class="headerlink" title="autorelease 介绍"></a>autorelease 介绍</h3><p>当对象超出其作用域时，对象实例的release方法就会被调用，autorelease的具体使用方法如下：</p>
<ol>
<li>生成并持有NSAutoreleasePool对象。</li>
<li>调用已分配对象的autorelease方法。</li>
<li>废弃NSAutoreleasePool对象。</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-e4e905eeda890869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>所有调用过autorelease方法的对象，在废弃NSAutoreleasePool对象时，都将调用release方法（引用计数-1）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line">[pool drain];<span class="comment">//相当于obj调用release方法</span></div></pre></td></tr></table></figure></p>
<p>NSRunLoop在每次循环过程中，NSAutoreleasePool对象都会被生成或废弃。<br>也就是说，如果有大量的autorelease变量，在NSAutoreleasePool对象废弃之前（一旦监听到RunLoop即将进入睡眠等待状态，就释放NSAutoreleasePool），都不会被销毁，容易导致内存激增的问题:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageArray.count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = imageArray[i];</div><div class="line">    [image doSomething];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0a9bf49d47a0e3a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>因此，我们有必要在适当的时候再嵌套一个自动释放池来管理临时生成的autorelease变量：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imageArray.count; i++)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//临时pool</span></div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line">    <span class="built_in">UIImage</span> *image = imageArray[i];</div><div class="line">    [image doSomething];</div><div class="line">    [pool drain];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-157c469ad6fff139.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<blockquote>
<p>可能会出的面试题：什么时候会创建自动释放池？<br>答：运行循环检测到事件并启动后，就会创建自动释放池，而且子线程的 runloop 默认是不工作的，无法主动创建，必须手动创建。<br>举个🌰：<br>自定义的 NSOperation 类中的 main 方法里就必须添加自动释放池。否则在出了作用域以后，自动释放对象会因为没有自动释放池去处理自己而造成内存泄露。</p>
</blockquote>
<h3 id="autorelease实现"><a href="#autorelease实现" class="headerlink" title="autorelease实现"></a>autorelease实现</h3><p>和上文一样，我们还是通过GNUstep和苹果的实现来分别看一下。</p>
<h4 id="GNUstep-实现"><a href="#GNUstep-实现" class="headerlink" title="GNUstep 实现"></a>GNUstep 实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSObject.m autorelease</span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)autorelease</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">NSAutoreleasePool</span> addObject:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果调用NSObject类的autorelease方法，则该对象就会被追加到正在使用的NSAutoreleasePool对象中的数组里（作者假想了一个简化的源代码）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//GNUstep/modules/core/base/Source/NSAutoreleasePool.m addObject</span></div><div class="line"></div><div class="line">+ (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSAutoreleasePool</span> *pool = 取得正在使用的<span class="built_in">NSAutoreleasePool</span>对象</div><div class="line">    <span class="keyword">if</span> (pool != <span class="literal">nil</span>)&#123;</div><div class="line">        [pool addObject:anObj];</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"NSAutoreleasePool对象不存在"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)addObject:(<span class="keyword">id</span>)anObj</div><div class="line">&#123;</div><div class="line">    [pool.array addObject:anObj];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，autorelease实例方法的本质就是调用NSAutoreleasePool对象的addObject类方法，然后这个对象就被追加到正在使用的NSAutoreleasePool对象中的数组里。</p>
<p>再来看一下NSAutoreleasePool的drain方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drain</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> dealloc];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">self</span> emptyPool];</div><div class="line">    [array release];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)emptyPool</div><div class="line">&#123;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">id</span> obj <span class="keyword">in</span> array)&#123;</div><div class="line">        [obj release];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，在emptyPool方法里，确实是对数组里每一个对象进行了release操作。</p>
<h4 id="苹果的实现-1"><a href="#苹果的实现-1" class="headerlink" title="苹果的实现"></a>苹果的实现</h4><p>我们可以通过objc4/NSObject.mm来确认苹果中autorelease的实现：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">objc4/<span class="built_in">NSObject</span>.mm AutoreleasePoolPage</div><div class="line"> </div><div class="line"><span class="keyword">class</span> AutoreleasePoolPage</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> *push()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//生成或者持有 NSAutoreleasePool 类对象</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> pop(<span class="keyword">void</span> *token)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//废弃 NSAutoreleasePool 类对象</span></div><div class="line">        releaseAll();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">id</span> autorelease(<span class="keyword">id</span> obj)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//相当于 NSAutoreleasePool 类的 addObject 类方法</span></div><div class="line">        AutoreleasePoolPage *page = 取得正在使用的 AutoreleasePoolPage 实例;</div><div class="line">       autoreleaesPoolPage-&gt;add(obj)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">id</span> *add(<span class="keyword">id</span> obj)</div><div class="line">    &#123;   </div><div class="line">        <span class="comment">//将对象追加到内部数组中</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">void</span> releaseAll()</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//调用内部数组中对象的 release 方法</span></div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//压栈</span></div><div class="line"><span class="keyword">void</span> *objc_autoreleasePoolPush(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> AutoreleasePoolPage::push();</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">//出栈</span></div><div class="line"><span class="keyword">void</span> objc_autoreleasePoolPop(<span class="keyword">void</span> *ctxt)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (UseGC) <span class="keyword">return</span>;</div><div class="line">    AutoreleasePoolPage::pop(ctxt);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看一下外部的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</div><div class="line"><span class="comment">// 等同于 objc_autoreleasePoolPush</span></div><div class="line"> </div><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">[obj autorelease];</div><div class="line"><span class="comment">// 等同于 objc_autorelease(obj)</span></div><div class="line"> </div><div class="line">[<span class="built_in">NSAutoreleasePool</span> showPools];</div><div class="line"><span class="comment">// 查看 NSAutoreleasePool 状况</span></div><div class="line"> </div><div class="line">[pool drain];</div><div class="line"><span class="comment">// 等同于 objc_autoreleasePoolPop(pool)</span></div></pre></td></tr></table></figure>
<p>看函数名就可以知道，对autorelease分别执行push、pop操作。销毁对象时执行release操作。</p>
<blockquote>
<p><strong>可能出现的面试题：苹果是如何实现autoreleasepool的？</strong><br>autoreleasepool以一个队列数组的形式实现,主要通过下列三个函数完成.<br>•    objc_autoreleasepoolPush（压入）<br>•    objc_autoreleasepoolPop（弹出）<br>•    objc_autorelease（释放内部）</p>
</blockquote>
<h1 id="ARC内存管理"><a href="#ARC内存管理" class="headerlink" title="ARC内存管理"></a>ARC内存管理</h1><h2 id="内存管理的思想-1"><a href="#内存管理的思想-1" class="headerlink" title="内存管理的思想"></a>内存管理的思想</h2><p>上面学习了非ARC机制下的手动管理内存思想，针对引用计数的操作和自动释放池的相关内容。现在学习一下在ARC机制下的相关知识。</p>
<p>ARC和非ARC机制下的内存管理思想是一致的：</p>
<ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不再需要自己持有的对象时释放对象。</li>
<li>非自己持有的对象无法释放。</li>
</ul>
<p>在ARC机制下，编译器就可以自动进行内存管理，减少了开发的工作量。但我们有时仍需要四种所有权修饰符来配合ARC来进行内存管理</p>
<h2 id="四种所有权修饰符"><a href="#四种所有权修饰符" class="headerlink" title="四种所有权修饰符"></a>四种所有权修饰符</h2><p>但是，在ARC机制下我们有的时候需要追加所有权声明(以下内容摘自官方文档)：</p>
<ul>
<li><strong>__strong</strong>：is the default. An object remains “alive” as long as there is a strong pointer to it.</li>
<li><strong>__weak</strong>：specifies a reference that does not keep the referenced object alive. A weak reference is set to nil when there are no strong references to the object.</li>
<li><strong>__unsafe_unretained</strong>：specifies a reference that does not keep the referenced object alive and is not set to nil when there are no strong references to the object. If the object it references is deallocated, the pointer is left dangling.</li>
<li><strong>__autoreleasing</strong>：is used to denote arguments that are passed by reference (id *) and are autoreleased on return.</li>
</ul>
<p>下面分别讲解一下这几个修饰符：</p>
<h3 id="strong修饰符"><a href="#strong修饰符" class="headerlink" title="__strong修饰符"></a>__strong修饰符</h3><p>__strong修饰符 是id类型和对象类型默认的所有权修饰符：</p>
<h4 id="strong使用方法："><a href="#strong使用方法：" class="headerlink" title="__strong使用方法："></a>__strong使用方法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure>
<p>等同于：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];</div></pre></td></tr></table></figure></p>
<p>看一下内存管理的过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj持有对象</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//obj超出其作用域，强引用失效</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>__strong修饰符表示对对象的强引用。持有强引用的变量在超出其作用域时被废弃。</p>
</blockquote>
<p>在__strong修饰符修饰的变量之间相互赋值的情况：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj0 持有对象A</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj1 = [[<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj1 持有对象B</span></div><div class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj2 = <span class="literal">nil</span>;<span class="comment">//ojb2不持有任何对象</span></div><div class="line">obj0 = obj1;<span class="comment">//obj0强引用对象B；而对象A不再被ojb0引用，被废弃</span></div><div class="line">obj2 = obj0;<span class="comment">//obj2强引用对象B（现在obj0，ojb1，obj2都强引用对象B）</span></div><div class="line">obj1 = <span class="literal">nil</span>;<span class="comment">//obj1不再强引用对象B</span></div><div class="line">obj0 = <span class="literal">nil</span>;<span class="comment">//obj0不再强引用对象B</span></div><div class="line">obj2 = <span class="literal">nil</span>;<span class="comment">//obj2不再强引用对象B，不再有任何强引用引用对象B，对象B被废弃</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>而且，<strong>strong可以使一个变量初始化为nil：id </strong>strong obj0;<br>同样适用于：id <strong>weak obj1; id </strong>autoreleasing obj2;</p>
</blockquote>
<p>做个总结：被__strong修饰后，相当于强引用某个对象。对象一旦有一个强引用引用自己，引用计数就会+1，就不会被系统废弃。而这个对象如果不再被强引用的话，就会被系统废弃。</p>
<h4 id="strong内部实现："><a href="#strong内部实现：" class="headerlink" title="__strong内部实现："></a>__strong内部实现：</h4><p>生成并持有对象：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSObject</span> alloc] init];<span class="comment">//obj持有对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = objc_mesgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj,<span class="keyword">@selector</span>(init));</div><div class="line">objc_release(obj);<span class="comment">//超出作用域，释放对象</span></div></pre></td></tr></table></figure></p>
<p>再看一下使用命名规则以外的构造方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(array));</div><div class="line">objc_retainAutoreleasedReturnValue(obj);</div><div class="line">objc_release(obj);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>objc_retainAutoreleasedReturnValue的作用：持有对象，将对象注册到autoreleasepool并返回。</p>
</blockquote>
<p>同样也有objc_autoreleaseReturnValue，来看一下它的使用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)array</div><div class="line">&#123;</div><div class="line">   <span class="keyword">return</span> [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)array</div><div class="line">&#123;</div><div class="line">   <span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">   objc_msgSend(obj,, <span class="keyword">@selector</span>(init));</div><div class="line">   <span class="keyword">return</span> objc_autoreleaseReturnValue(obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>objc_autoreleaseReturnValue:返回注册到autoreleasepool的对象。</p>
</blockquote>
<h3 id="weak修饰符"><a href="#weak修饰符" class="headerlink" title="__weak修饰符"></a>__weak修饰符</h3><h4 id="weak使用方法："><a href="#weak使用方法：" class="headerlink" title="__weak使用方法："></a>__weak使用方法：</h4><p>__weak修饰符大多解决的是循环引用的问题：如果两个对象都互相强引用对方，同时都失去了外部对自己的引用，那么就会形成“孤岛”，这个孤岛将永远无法被释放，举个🌰：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">strong</span> obj_;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Test</span></span></div><div class="line">- (<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj</div><div class="line">&#123;</div><div class="line">    obj_ = obj;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> test0 = [[Test alloc] init];<span class="comment">//test0强引用对象A</span></div><div class="line">    <span class="keyword">id</span> test1 = [[Test alloc] init];<span class="comment">//test1强引用对象B</span></div><div class="line">    [test0 setObject:test1];<span class="comment">//test0强引用对象B</span></div><div class="line">    [test1 setObject:test0];<span class="comment">//test1强引用对象A</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为生成对象（第一，第二行）和set方法（第三，第四行）都是强引用，所以会造成两个对象互相强引用对方的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f2164aea2490deac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>所以，我们需要打破其中一种强引用：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Test</span>:<span class="title">NSObject</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj_;<span class="comment">//由__strong变成了__weak</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span> __<span class="keyword">strong</span>)obj;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这样一来，二者就只是弱引用对方了：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-98777f8ef5bbfc13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<h4 id="weak内部实现"><a href="#weak内部实现" class="headerlink" title="__weak内部实现"></a>__weak内部实现</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj1;</div><div class="line">objc_initWeak(&amp;obj1,obj);<span class="comment">//初始化附有__weak的变量</span></div><div class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(&amp;obj1);<span class="comment">//取出附有__weak修饰符变量所引用的对象并retain</span></div><div class="line">objc_autorelease(tmp);<span class="comment">//将对象注册到autoreleasepool中</span></div><div class="line">objc_destroyWeak(&amp;obj1);<span class="comment">//释放附有__weak的变量</span></div></pre></td></tr></table></figure>
<blockquote>
<p>这确认了<strong>weak的一个功能：使用附有</strong>weak修饰符的变量，即是使用注册到autoreleasepool中的对象。</p>
</blockquote>
<p>这里需要着重讲解一下objc_initWeak方法和objc_destroyWeak方法：</p>
<ul>
<li>objc_initWeak:初始化附有__weak的变量，具体通过执行objc_strongWeak(&amp;obj1, obj)方法，将obj对象以&amp;obj1作为key放入一个weak表（Hash）中。</li>
<li>objc_destroyWeak：释放附有__weak的变量。具体通过执行objc_storeWeak(&amp;obj1,0)方法，在weak表中查询&amp;obj1这个键，将这个键从weak表中删除。</li>
</ul>
<blockquote>
<p>注意：因为同一个对象可以赋值给多个附有__weak的变量中，所以对于同一个键值，可以注册多个变量的地址。</p>
</blockquote>
<p>当一个对象不再被任何人持有，则需要释放它，过程为：</p>
<ul>
<li>objc_dealloc</li>
<li>dealloc</li>
<li>_objc_rootDealloc</li>
<li>objc_dispose</li>
<li>objc_destructInstance</li>
<li>objc_clear_deallocating<ul>
<li>从weak表中获取废弃对象的地址</li>
<li>将包含在记录中的所有附有__weak修饰符变量的地址赋值为nil</li>
<li>从weak表中删除该记录</li>
<li>从引用计数表中删除废弃对象的地址</li>
</ul>
</li>
</ul>
<h3 id="autoreleasing修饰符"><a href="#autoreleasing修饰符" class="headerlink" title="__autoreleasing修饰符"></a>__autoreleasing修饰符</h3><h4 id="autoreleasing使用方法"><a href="#autoreleasing使用方法" class="headerlink" title="__autoreleasing使用方法"></a>__autoreleasing使用方法</h4><p>ARC下，可以用@autoreleasepool来替代NSAutoreleasePool类对象，用__autoreleasing修饰符修饰变量来替代ARC无效时调用对象的autorelease方法（对象被注册到autoreleasepool）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6dcb0d1fd878deeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Objective-C高级编程：iOS与OS X多线程和内存管理》"></p>
<p>说到<strong>autoreleasing修饰符，就不得不提</strong>weak：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span>  __<span class="keyword">weak</span> obj1 = obj0;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>,[obj1 <span class="keyword">class</span>]);</div></pre></td></tr></table></figure></p>
<p>等同于：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj0;</div><div class="line"><span class="keyword">id</span> __autoreleasing tmp = obj1;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>,[tmp <span class="keyword">class</span>]);<span class="comment">//实际访问的是注册到自动个释放池的对象</span></div></pre></td></tr></table></figure>
<p>注意一下两段等效的代码里，NSLog语句里面访问的对象是不一样的，它说明：在访问__weak修饰符的变量（obj1）时必须访问注册到autoreleasepool的对象（tmp）。为什么呢？</p>
<p>因为__weak修饰符只持有对象的弱引用，也就是说在将来访问这个对象的时候，无法保证它是否还没有被废弃。因此，如果把这个对象注册到autoreleasepool中，那么在@autoreleasepool块结束之前都能确保该对象存在。</p>
<h4 id="autoreleasing内部实现"><a href="#autoreleasing内部实现" class="headerlink" title="__autoreleasing内部实现"></a>__autoreleasing内部实现</h4><p>将对象赋值给附有__autoreleasing修饰符的变量等同于ARC无效时调用对象的autorelease方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">    <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译器的模拟代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> pool = objc_autoreleasePoolPush();<span class="comment">//pool入栈</span></div><div class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</div><div class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</div><div class="line">objc_autorelease(obj);</div><div class="line">objc_autoreleasePoolPop(pool);<span class="comment">//pool出栈</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们可以看到pool入栈，执行autorelease，出栈的三个方法。</p>
</blockquote>
<h2 id="ARC下的规则"><a href="#ARC下的规则" class="headerlink" title="ARC下的规则"></a>ARC下的规则</h2><p>我们知道了在ARC机制下编译器会帮助我们管理内存，但是在编译期，我们还是要遵守一些规则，作者为我们列出了以下的规则：</p>
<ol>
<li>不能使用retain/release/retainCount/autorelease</li>
<li>不能使用NSAllocateObject/NSDeallocateObject</li>
<li>必须遵守内存管理的方法名规则</li>
<li>不要显式调用dealloc</li>
<li>使用@autorelease块代替NSAutoreleasePool</li>
<li>不能使用区域（NSZone）</li>
<li>对象型变量不能作为C语言结构体的成员</li>
<li>显式转换id和void*</li>
</ol>
<h3 id="1-不能使用retain-release-retainCount-autorelease"><a href="#1-不能使用retain-release-retainCount-autorelease" class="headerlink" title="1. 不能使用retain/release/retainCount/autorelease"></a>1. 不能使用retain/release/retainCount/autorelease</h3><p>在ARC机制下使用retain/release/retainCount/autorelease方法，会导致编译器报错。</p>
<h3 id="2-不能使用NSAllocateObject-NSDeallocateObject"><a href="#2-不能使用NSAllocateObject-NSDeallocateObject" class="headerlink" title="2. 不能使用NSAllocateObject/NSDeallocateObject"></a>2. 不能使用NSAllocateObject/NSDeallocateObject</h3><p>在ARC机制下使用NSAllocateObject/NSDeallocateObject方法，会导致编译器报错。</p>
<h3 id="3-必须遵守内存管理的方法名规则"><a href="#3-必须遵守内存管理的方法名规则" class="headerlink" title="3. 必须遵守内存管理的方法名规则"></a>3. 必须遵守内存管理的方法名规则</h3><p>对象的生成／持有的方法必须遵循以下命名规则：</p>
<ul>
<li>alloc</li>
<li>new</li>
<li>copy</li>
<li>mutableCopy</li>
<li>init</li>
</ul>
<p>前四种方法已经介绍完。而关于init方法的要求则更为严格：</p>
<ul>
<li>必须是实例方法</li>
<li>必须返回对象</li>
<li>返回对象的类型必须是id类型或方法声明类的对象类型</li>
</ul>
<h3 id="4-不要显式调用dealloc"><a href="#4-不要显式调用dealloc" class="headerlink" title="4. 不要显式调用dealloc"></a>4. 不要显式调用dealloc</h3><p>对象被废弃时，无论ARC是否有效，系统都会调用对象的dealloc方法。</p>
<p>我们只能在dealloc方法里写一些对象被废弃时需要进行的操作（例如移除已经注册的观察者对象）但是不能手动调用dealloc方法。</p>
<p>注意在ARC无效的时候，还需要调用[super dealloc]：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc</div><div class="line">&#123;</div><div class="line">    <span class="comment">//该对象的处理</span></div><div class="line">    [<span class="keyword">super</span> dealloc];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-使用-autorelease块代替NSAutoreleasePool"><a href="#5-使用-autorelease块代替NSAutoreleasePool" class="headerlink" title="5. 使用@autorelease块代替NSAutoreleasePool"></a>5. 使用@autorelease块代替NSAutoreleasePool</h3><p>ARC下须使用使用@autorelease块代替NSAutoreleasePool。</p>
<h3 id="6-不能使用区域（NSZone）"><a href="#6-不能使用区域（NSZone）" class="headerlink" title="6. 不能使用区域（NSZone）"></a>6. 不能使用区域（NSZone）</h3><p>NSZone已经在目前的运行时系统（<strong>OBC2</strong>被设定的环境）被忽略了。</p>
<h3 id="7-对象型变量不能作为C语言结构体的成员"><a href="#7-对象型变量不能作为C语言结构体的成员" class="headerlink" title="7. 对象型变量不能作为C语言结构体的成员"></a>7. 对象型变量不能作为C语言结构体的成员</h3><p>C语言的结构体如果存在Objective-C对象型变量，便会引起错误，因为C语言在规约上没有方法来管理结构体成员的生存周期 。</p>
<h3 id="8-显式转换id和void"><a href="#8-显式转换id和void" class="headerlink" title="8. 显式转换id和void*"></a>8. 显式转换id和void*</h3><p>非ARC下，这两个类型是可以直接赋值的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id obj = [NSObject alloc] init];</div><div class="line">void *p = obj;</div><div class="line">id o = p;</div></pre></td></tr></table></figure>
<p>但是在ARC下就会引起编译错误。为了避免错误，我们需要通过__bridege来转换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</div><div class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span>*)obj;<span class="comment">//显式转换</span></div><div class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;<span class="comment">//显式转换</span></div></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>来看一下属性的声明与所有权修饰符的关系</p>
<table>
<thead>
<tr>
<th>属性关键字</th>
<th>所有权 修饰符</th>
</tr>
</thead>
<tbody>
<tr>
<td>assign</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>copy</td>
<td>__strong</td>
</tr>
<tr>
<td>retain</td>
<td>__strong</td>
</tr>
<tr>
<td>strong</td>
<td>__strong</td>
</tr>
<tr>
<td>__unsafe_unretained</td>
<td>__unsafe_unretained</td>
</tr>
<tr>
<td>weak</td>
<td>__weak</td>
</tr>
</tbody>
</table>
<p>说一下<strong>unsafe_unretained：
</strong>unsafe_unretained表示存取方法会直接为实例变量赋值。</p>
<p>这里的“unsafe”是相对于weak而言的。我们知道weak指向的对象被销毁时，指针会自动设置为nil。而__unsafe_unretained却不会，而是成为空指针。需要注意的是：当处理非对象属性的时候就不会出现空指针的问题。</p>
<p>这样第一章就介绍完了，第二篇会在下周一发布^^</p>
<hr>
<p>扩展文献：</p>
<ol>
<li><a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html" target="_blank" rel="external">Apple:Transitioning to ARC Release Notes</a> </li>
<li><a href="http://www.jianshu.com/p/6cf682f90fa2" target="_blank" rel="external">蚊香酱:可能是史上最全面的内存管理文章</a></li>
<li><a href="http://www.jianshu.com/p/0ad9957e3716" target="_blank" rel="external">微笑和飞飞:可能碰到的iOS笔试面试题（6）–内存管理</a></li>
<li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00RWORA1O/ref=sr_1_1?ie=UTF8&amp;qid=1491531635&amp;sr=8-1&amp;keywords=ios%E7%BC%96%E7%A8%8B" target="_blank" rel="external">《iOS编程(第4版)》</a> </li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;总结了&lt;a href=&quot;http://www.jianshu.com/nb/6074358&quot;&gt;Effective Objective-C&lt;/a&gt;之后，还想读一本进阶的iOS书，毫不犹豫选中了《Objective-C 高级编程》：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ceabf4418ec5228.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程：iOS与OS X多线程和内存管理》&quot;&gt;&lt;/p&gt;
&lt;p&gt;这本书有三个章节，我针对每一章节进行总结并加上适当的扩展分享给大家。可以从下面这张图来看一下这三篇的整体结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-169518e948933744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Objective-C高级编程》 干货三部曲&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，这个结构并不和书中的结构一致，而是以书中的结构为参考，稍作了调整。&lt;/p&gt;
&lt;p&gt;本篇是第一篇：引用计数，简单说两句：&lt;br&gt;Objective-C通过 retainCount 的机制来决定对象是否需要释放。 每次runloop迭代结束后，都会检查对象的 retainCount，如果retainCount等于0，就说明该对象没有地方需要继续使用它，可以被释放掉了。无论是手动管理内存，还是ARC机制，都是通过对retainCount来进行内存管理的。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>基于MVVM，用于快速搭建设置页，个人信息页的框架（附：仿微信iOS客户端发现页，个人页，设置页Demo）</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/03/20/%E5%9F%BA%E4%BA%8EMVVM%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E8%AE%BE%E7%BD%AE%E9%A1%B5%EF%BC%8C%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E9%A1%B5%E7%9A%84%E6%A1%86%E6%9E%B6%EF%BC%88%E9%99%84%EF%BC%9A%E4%BB%BF%E5%BE%AE%E4%BF%A1iOS%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E7%8E%B0%E9%A1%B5%EF%BC%8C%E4%B8%AA%E4%BA%BA%E9%A1%B5%EF%BC%8C%E8%AE%BE%E7%BD%AE%E9%A1%B5Demo%EF%BC%89/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/03/20/基于MVVM，用于快速搭建设置页，个人信息页的框架（附：仿微信iOS客户端发现页，个人页，设置页Demo）/</id>
    <published>2017-03-20T05:47:51.000Z</published>
    <updated>2017-03-21T00:08:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>写UITableView的时候，我们经常遇到的是完全依赖于网络请求，需要自定义的动态cell的需求（比如微博帖子列表）。但是同时，大多数app里面几乎也都有设置页，个人页等其他以静态表格为主的页面。</p>
<p>而且这些页面的共性比较多：</p>
<ol>
<li>大多数情况下在进入页面之前就已经拿到所有数据。</li>
<li>cell样式单一，自定义cell出现的几率比较小（几乎都是高度为44的cell）。</li>
<li>多数都分组。</li>
</ol>
<p>因为自己非常想写一个开源的东西出来（也可以暴露自己的不足），同时又受限于水平，所以就打算写这么一个比较简单，又具有通用性的框架：<strong>一个定制性比较高的适合在个人页和设置页使用的UITableView</strong>。</p>
<p>在真正写之前，看了几篇类似的文章，挑出三篇自己觉得比较好的：</p>
<ol>
<li><a href="https://www.objc.io/issues/1-view-controllers/table-views/" target="_blank" rel="external">Clean Table View Code</a> </li>
<li><a href="http://www.jianshu.com/p/504c61a9dc82" target="_blank" rel="external">如何写好一个UITableView</a></li>
<li><a href="http://www.jianshu.com/p/81d0c573f7a8" target="_blank" rel="external">利用MVVM设计快速开发个人中心、设置等模块</a></li>
</ol>
<p>看完总结之后，利用上周3天的业余时间写好了这个框架，为了它实用性，我仿照了微信客户端的发现页，个人页和设置页写了一个Demo，来看一下效果图：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjstatictableview_1.png" alt="发现页 | 个人页 | 个人信息页 | 设置页"><br><a id="more"></a></p>
<blockquote>
<p>项目所用资源来自：<a href="https://github.com/zhengwenming/WeChat">GitHub:zhengwenming/WeChat</a><br>Demo地址：<a href="https://github.com/knightsj/SJStaticTableView">GitHub: knightsj/SJStaticTableView</a></p>
</blockquote>
<p>为了体现出这个框架的定制性，我自己也在里面添加了两个页面，入口在设置页里面：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjstatictableview_2.png" alt="分组定制 | 同组定制"></p>
<blockquote>
<p>先不要纠结分组定制和同组定制的具体意思，在后面讲到定制性的时候我会详细说明。现在只是让大家看一下效果。</p>
</blockquote>
<p>在大概了解了功能之后，开始详细介绍这个框架。写这篇介绍的原因倒不是希望有多少人来用，而是表达一下我自己的思路而已。各位觉得不好的地方请多批评。</p>
<p>在正式讲解之前，先介绍一下本篇的基本目录：</p>
<ol>
<li>用到的技术点。</li>
<li>功能说明。</li>
<li>使用方法。</li>
<li>定制性介绍。</li>
</ol>
<h1 id="用到的技术点"><a href="#用到的技术点" class="headerlink" title="用到的技术点"></a>用到的技术点</h1><hr>
<p>框架整体来说还是比较简单的，主要还是基于苹果的<code>UITableView</code>组件，为了解耦和责任分离，主要运用了以下技术点：</p>
<ul>
<li><strong>MVVM</strong>：采用MVVM架构，将每一行“纯粹”的数据交给一个单独的<code>ViewModel</code>,让其持有每个cell的数据（行高，cell类型，文本宽度，图片高度等等）。而且每一个section也对应一个<code>ViewModel</code>，它持有当前section的配置数据（title，header和footer的高度等等）。</li>
<li><strong>轻UITableView</strong>：分离<code>UITableViewDataSource</code>与<code>UIViewController</code>，让单独一个类来实现<code>UITableViewDataSource</code>的职能。</li>
<li><strong>block</strong>：使用block来调用cell的绘制方法。</li>
<li><strong>分类</strong>：使用分类来定义每一种不同的cell的绘制方法。</li>
</ul>
<p>知道了主要运用的技术点以后，给大家详细介绍一下该框架的功能。</p>
<h1 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h1><hr>
<p>这个框架可以用来快速搭建设置页，个人信息页能静态表格页面，使用者只需要给tableView的DataSource传入元素是viewModel的数组就可以了。</p>
<p>虽说这类页面的布局还是比较单一的，但是还是会有几种不同的情况（cell的布局类型），我对比较常见的cell布局做了封装，使用者可以直接使用。</p>
<p>我在定义这些cell的类型的时候，大致划分了两类：</p>
<ol>
<li>第一类是系统风格的cell，大多数情况下，cell高度为44；在cell左侧会有一张图，一个label，也可以只存在一种（但是只存在图片的情况很少）；在cell右侧一般都有一个向右的箭头，而且有时这个箭头的左侧还可能有label，image，也可以两个都有。</li>
<li>第二类就是自定义的cell了，它的高度不一定是44，而且布局和系统风格的cell很不一样，需要用户自己添加。</li>
</ol>
<p>基于这两大类，再细分了几种情况，可以由下面这张图来直观看一下：</p>
<p>既然是cell的类型，那么就类型的枚举就需要定义在cell的viewModel里面：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SJStaticCellType) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//系统风格的各种cell类型，已封装好，可以直接用</span></div><div class="line">    SJStaticCellTypeSystemLogout,                          <span class="comment">//退出登录cell</span></div><div class="line">    SJStaticCellTypeSystemAccessoryNone,                   <span class="comment">//右侧没有任何控件</span></div><div class="line">    SJStaticCellTypeSystemAccessorySwitch,                 <span class="comment">//右侧是开关</span></div><div class="line">    SJStaticCellTypeSystemAccessoryDisclosureIndicator,    <span class="comment">//右侧是三角箭头(箭头左侧可以有一个image或者一个label，或者二者都有，根据传入的参数决定)</span></div><div class="line">    </div><div class="line">    <span class="comment">//需要用户自己添加的自定义cell类型</span></div><div class="line">    SJStaticCellTypeMeAvatar,                              <span class="comment">//个人页“我”cell    </span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>来一张图直观得体会一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjstatictableview_6.png" alt="支持cell类型"></p>
<p>在这里有三点需要说一下：</p>
<ol>
<li>这里面除了自定义的cell以外，其他类型的cell都不需要开发者自己布局，都已经被我封装好，只需要在cell的<code>ViewModel</code>里面传入相应的类型和数据（文字，图片）即可。</li>
<li>因为左侧的两个控件（图片和文字）是至少存在一个而且左右顺序固定（图片永远在最左侧），所以该框架通过开发者传入的左侧需要显示的图片和文字，可以自己进行cell的布局。所以类型的判断主要作用于cell的右侧。</li>
<li>值得一提的是，在”最右侧是一个箭头”子分支的五个类型其实都属于一个类型，只需要传入文字和图片，以及文字图片的显示顺序参数（这个参数只在同时存在图片和文字的时候有效）就可以自行判断布局。</li>
</ol>
<p>在了解了该框架的功能之后，我们先看一下如何使用这个框架：</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><hr>
<p>最开始先用文字说明一下：</p>
<ol>
<li>将SJStaticTableViewComponent文件夹复制到工程里。</li>
<li>将要开发的页面的ViewController继承<code>SJStaticTableViewController</code>。</li>
<li>在新ViewController里实现<code>createDataSource</code>方法，将viewModel数组传给控制器的<code>dataSource</code>属性。</li>
<li>根据不同的cell类型，调用不同的cell绘制方法。</li>
<li>如果需要接受cell的点击，需要实现<code>didSelectViewModel</code>方法。</li>
</ol>
<p>可能感觉比较抽象，我拿设置页来具体说明一下：</p>
<p>先看一下设置页的布局：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjstatictableview_3.png" alt="设置页"></p>
<p>然后我们看一下设置的ViewController的代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    <span class="keyword">self</span>.navigationItem.title = <span class="string">@"设置"</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)createDataSource</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.dataSource = [[SJStaticTableViewDataSource alloc] initWithViewModelsArray:[Factory settingPageData] configureBlock:^(SJStaticTableViewCell *cell, SJStaticTableviewCellViewModel *viewModel) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">switch</span> (viewModel.staticCellType)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessoryDisclosureIndicator:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessoryDisclosureIndicatorCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessorySwitch:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessorySwitchCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;             </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemLogout:</div><div class="line">            &#123;</div><div class="line">                [cell configureLogoutTableViewCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;                </div><div class="line">            <span class="keyword">case</span> SJStaticCellTypeSystemAccessoryNone:</div><div class="line">            &#123;</div><div class="line">                [cell configureAccessoryNoneCellWithViewModel:viewModel];</div><div class="line">            &#125;</div><div class="line">                <span class="keyword">break</span>;                </div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)didSelectViewModel:(SJStaticTableviewCellViewModel *)viewModel atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;    </div><div class="line">    <span class="keyword">switch</span> (viewModel.identifier)</div><div class="line">    &#123;            </div><div class="line">        <span class="keyword">case</span> <span class="number">6</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"退出登录"</span>);</div><div class="line">            [<span class="keyword">self</span> showAlertWithMessage:<span class="string">@"真的要退出登录嘛？"</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            </div><div class="line">        <span class="keyword">case</span> <span class="number">8</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"清理缓存"</span>);</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;            </div><div class="line">        <span class="keyword">case</span> <span class="number">9</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"跳转到定制性cell展示页面 - 分组"</span>);</div><div class="line">            SJCustomCellsViewController *vc = [[SJCustomCellsViewController alloc] init];</div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;            </div><div class="line">        <span class="keyword">case</span> <span class="number">10</span>:</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">NSLog</span>(<span class="string">@"跳转到定制性cell展示页面 - 同组"</span>);</div><div class="line">            SJCustomCellsOneSectionViewController *vc = [[SJCustomCellsOneSectionViewController alloc] init];</div><div class="line">            [<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</div><div class="line">        &#125;</div><div class="line">            <span class="keyword">break</span>;            </div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看到这里，你可能会有这些疑问：</p>
<ol>
<li>UITableViewDataSource方法哪儿去了？</li>
<li>viewModel数组是如何设置的？</li>
<li>cell的绘制方法是如何区分的？</li>
<li>UITableViewDelegate的方法哪里去了？</li>
</ol>
<p>下面我会一一解答，看完了下面的解答，就能几乎完全掌握这个框架的思路了：</p>
<h2 id="问题1：UITableViewDataSource方法哪儿去了？"><a href="#问题1：UITableViewDataSource方法哪儿去了？" class="headerlink" title="问题1：UITableViewDataSource方法哪儿去了？"></a>问题1：UITableViewDataSource方法哪儿去了？</h2><p>我自己封装了一个类<code>SJStaticTableViewDataSource</code>专门作为数据源，需要控制器给它一个viewModel数组。</p>
<p>来看一下它的实现文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableViewDataSource.m</span></div><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInTableView:(<span class="built_in">UITableView</span> *)tableView</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.viewModelsArray.count;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSInteger</span>)tableView:(<span class="built_in">UITableView</span> *)tableView numberOfRowsInSection:(<span class="built_in">NSInteger</span>)section</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.cellViewModelsArray.count;</div><div class="line">&#125;</div><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">//获取section的ViewModel</span></div><div class="line">    SJStaticTableviewSectionViewModel *sectionViewModel = <span class="keyword">self</span>.viewModelsArray[indexPath.section];</div><div class="line">    <span class="comment">//获取cell的viewModel</span></div><div class="line">    SJStaticTableviewCellViewModel *cellViewModel = sectionViewModel.cellViewModelsArray[indexPath.row];</div><div class="line">    </div><div class="line">    SJStaticTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:cellViewModel.cellID];</div><div class="line">    <span class="keyword">if</span> (!cell) &#123;</div><div class="line">        cell = [[SJStaticTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:cellViewModel.cellID];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">self</span>.cellConfigureBlock(cell,cellViewModel);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForHeaderInSection:(<span class="built_in">NSInteger</span>)section&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.sectionHeaderTitle;  </div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSString</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView titleForFooterInSection:(<span class="built_in">NSInteger</span>)section</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewSectionViewModel *vm = <span class="keyword">self</span>.viewModelsArray[section];</div><div class="line">    <span class="keyword">return</span> vm.sectionFooterTitle;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>表格的cell和section都设置了与其对应的viewModel，用于封装其对应的数据：</p>
</blockquote>
<p>cell的viewModel(大致看一下即可，后面有详细说明)：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SJStaticCellType) &#123;    </div><div class="line">    <span class="comment">//系统风格的各种cell类型，已封装好，可以直接用</span></div><div class="line">    SJStaticCellTypeSystemLogout,                          <span class="comment">//退出登录cell（已封装好）</span></div><div class="line">    SJStaticCellTypeSystemAccessoryNone,                   <span class="comment">//右侧没有任何控件</span></div><div class="line">    SJStaticCellTypeSystemAccessorySwitch,                 <span class="comment">//右侧是开关</span></div><div class="line">    SJStaticCellTypeSystemAccessoryDisclosureIndicator,    <span class="comment">//右侧是三角箭头(箭头左侧可以有一个image或者一个label，或者二者都有，根据传入的参数决定)</span></div><div class="line">    </div><div class="line">    <span class="comment">//需要用户自己添加的自定义cell类型</span></div><div class="line">    SJStaticCellTypeMeAvatar,                              <span class="comment">//个人页“我”cell    </span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SwitchValueChagedBlock)(<span class="built_in">BOOL</span> isOn);           <span class="comment">//switch开关切换时调用的block</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableviewCellViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) SJStaticCellType staticCellType;                  <span class="comment">//类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *cellID;                                  <span class="comment">//cell reuser identifier</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> identifier;                              <span class="comment">//区别每个cell，用于点击</span></div><div class="line"><span class="comment">// =============== 系统默认cell左侧 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span>  *leftImage;                               <span class="comment">//左侧的image，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> leftImageSize;                              <span class="comment">//左侧image的大小，存在默认设置</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *leftTitle;                               <span class="comment">//cell主标题，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *leftLabelTextColor;                       <span class="comment">//当前组cell左侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *leftLabelTextFont;                         <span class="comment">//当前组cell左侧label里文字的字体</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> leftImageAndLabelGap;                      <span class="comment">//左侧image和label的距离，存在默认值</span></div><div class="line"><span class="comment">// =============== 系统默认cell右侧 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *indicatorLeftTitle;                      <span class="comment">//右侧箭头左侧的文本，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *indicatorLeftLabelTextColor;              <span class="comment">//右侧文字的颜色，存在默认设置，也可以自定义</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *indicatorLeftLabelTextFont;                <span class="comment">//右侧文字的字体，存在默认设置，也可以自定义</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *indicatorLeftImage;                       <span class="comment">//右侧箭头左侧的image，按需传入</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> indicatorLeftImageSize;                     <span class="comment">//右侧尖头左侧image大小，存在默认设置，也可以自定义</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>)  <span class="built_in">BOOL</span> hasIndicatorImageAndLabel;         <span class="comment">//右侧尖头左侧的文本和image是否同时存在，只能通过内部计算</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> indicatorLeftImageAndLabelGap;             <span class="comment">//右侧尖头左侧image和label的距离，存在默认值</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> isImageFirst;                                 <span class="comment">//右侧尖头左侧的文本和image同时存在时，是否是image挨着箭头，默认为YES</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) SwitchValueChagedBlock switchValueDidChangeBlock;    <span class="comment">//切换switch开关的时候调用的block</span></div><div class="line"><span class="comment">// =============== 长宽数据 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> cellHeight;                                <span class="comment">//cell高度,默认是44，可以设置</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span>  leftTitleLabelSize;                        <span class="comment">//左侧默认Label的size，传入text以后内部计算</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span>  indicatorLeftLabelSize;                    <span class="comment">//右侧label的size</span></div><div class="line"><span class="comment">// =============== 自定义cell的数据放在这里 =============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *avatarImage;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *codeImage;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *userName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *userID;</div></pre></td></tr></table></figure></p>
<p>section的viewModel(大致看一下即可，后面有详细说明)：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableviewSectionViewModel</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sectionHeaderTitle;         <span class="comment">//该section的标题</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sectionFooterTitle;         <span class="comment">//该section的标题</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>  *cellViewModelsArray;        <span class="comment">//该section的数据源</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span>  sectionHeaderHeight;         <span class="comment">//header的高度</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span>  sectionFooterHeight;         <span class="comment">//footer的高度</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> leftImageSize;                 <span class="comment">//当前组cell左侧image的大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *leftLabelTextColor;          <span class="comment">//当前组cell左侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *leftLabelTextFont;            <span class="comment">//当前组cell左侧label里文字的字体</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> leftImageAndLabelGap;         <span class="comment">//当前组左侧image和label的距离，存在默认值</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIColor</span> *indicatorLeftLabelTextColor; <span class="comment">//当前组cell右侧label里文字的颜色</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIFont</span> *indicatorLeftLabelTextFont;   <span class="comment">//当前组cell右侧label里文字的字体</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGSize</span> indicatorLeftImageSize;        <span class="comment">//当前组cell右侧image的大小</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CGFloat</span> indicatorLeftImageAndLabelGap;<span class="comment">//当前组cell右侧image和label的距离，存在默认值</span></div><div class="line">- (<span class="keyword">instancetype</span>)initWithCellViewModelsArray:(<span class="built_in">NSArray</span> *)cellViewModelsArray;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>你可能会觉得属性太多了，但这些属性的存在意义是为cell的定制性服务的，在后文会有解释。</p>
</blockquote>
<p>现在了解了我封装好的数据源，cell的viewModel，section的viewModel以后，我们看一下第二个问题：</p>
<h2 id="问题2：-viewModel数组是如何设置的？"><a href="#问题2：-viewModel数组是如何设置的？" class="headerlink" title="问题2： viewModel数组是如何设置的？"></a>问题2： viewModel数组是如何设置的？</h2><p>我们来看一下设置页的viewModel数组的设置：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)settingPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">// ========== section 0</span></div><div class="line">    SJStaticTableviewCellViewModel *vm0 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm0.leftTitle = <span class="string">@"账号与安全"</span>;</div><div class="line">    vm0.identifier = <span class="number">0</span>;</div><div class="line">    vm0.indicatorLeftTitle = <span class="string">@"已保护"</span>;</div><div class="line">    vm0.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"ProfileLockOn"</span>];</div><div class="line">    vm0.isImageFirst = <span class="literal">NO</span>;    </div><div class="line">    SJStaticTableviewSectionViewModel *section0 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm0]];</div><div class="line">    </div><div class="line">    <span class="comment">// ========== section 1</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftTitle = <span class="string">@"新消息通知"</span>;</div><div class="line">    vm1.identifier = <span class="number">1</span>;    </div><div class="line">    <span class="comment">//额外添加switch</span></div><div class="line">    SJStaticTableviewCellViewModel *vm7 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftTitle = <span class="string">@"夜间模式"</span>;</div><div class="line">    vm7.switchValueDidChangeBlock = ^(<span class="built_in">BOOL</span> isON)&#123;</div><div class="line">        <span class="built_in">NSString</span> *message = isON?<span class="string">@"打开夜间模式"</span>:<span class="string">@"关闭夜间模式"</span>;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,message);</div><div class="line">    &#125;;</div><div class="line">    vm7.staticCellType = SJStaticCellTypeSystemAccessorySwitch;</div><div class="line">    vm7.identifier = <span class="number">7</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm8 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm8.leftTitle = <span class="string">@"清理缓存"</span>;</div><div class="line">    vm8.indicatorLeftTitle = <span class="string">@"12.3M"</span>;</div><div class="line">    vm8.identifier = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftTitle = <span class="string">@"隐私"</span>;</div><div class="line">    vm2.identifier = <span class="number">2</span>;</div><div class="line">     </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftTitle = <span class="string">@"通用"</span>;</div><div class="line">    vm3.identifier = <span class="number">3</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1,vm7,vm8,vm2,vm3]];</div><div class="line"></div><div class="line">    <span class="comment">// ========== section 2</span></div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftTitle = <span class="string">@"帮助与反馈"</span>;</div><div class="line">    vm4.identifier = <span class="number">4</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftTitle = <span class="string">@"关于微信"</span>;</div><div class="line">    vm5.identifier = <span class="number">5</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section2 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm4,vm5]];</div><div class="line"></div><div class="line">      <span class="comment">// ========== section 4</span></div><div class="line">    SJStaticTableviewCellViewModel *vm9 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm9.leftTitle = <span class="string">@"定制性cell展示页面 - 分组"</span>;</div><div class="line">    vm9.identifier = <span class="number">9</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm10 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm10.leftTitle = <span class="string">@"定制性cell展示页面 - 同组"</span>;</div><div class="line">    vm10.identifier = <span class="number">10</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section4 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm9,vm10]];</div><div class="line"></div><div class="line">    <span class="comment">// ========== section 3</span></div><div class="line">    SJStaticTableviewCellViewModel *vm6 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.staticCellType = SJStaticCellTypeSystemLogout;</div><div class="line">    vm6.cellID = <span class="string">@"logout"</span>;</div><div class="line">    vm6.identifier = <span class="number">6</span>;</div><div class="line">   </div><div class="line">    SJStaticTableviewSectionViewModel *section3 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm6]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section0,section1,section2,section4,section3];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，交给dataSource的数组是一个二维数组：</p>
<ul>
<li>第一维是section数组，元素是每一个section对应的viewModel：<code>SJStaticTableviewSectionViewModel</code>。</li>
<li>第二维是cell数组，元素是每一个cell对应的viewModel:<code>SJStaticTableviewCellViewModel</code>。</li>
</ul>
<p>有几个<code>SJStaticTableviewCellViewModel</code>的属性需要强调一下：</p>
<ol>
<li>isImageFirst：因为该页面第一组的cell右侧的箭头左边同时存在一个image和一个label，所以需要额外设置二者的顺序。因为默认紧挨着箭头的是图片，所以我们需要重新设置它为NO，作用是让label紧挨着箭头。</li>
<li>identifier：这个属性是一个整数，它用来标记每个cell，用于在用户点击cell的时候进行判断。我没有将用户的点击与cell的index相关联，是因为有的时候因为需求我们可能会更改cell的顺序或者删除某个cell，所以依赖cell的index是不妥的，容易出错。</li>
<li>cellID：这个属性用来cell的复用。因为总是有个别cell的布局是不同的：在这里出现了一个退出登录的cell，所以需要和其他的cell区别开来（cellID可以不用设置，有默认值，用来标记最常用的cell类型）。</li>
</ol>
<p>显然，<code>Factory</code>类属于<code>Model</code>，它将“纯数据”交给了dataSource使用的两个viewModel。这个类是我自己定义的，读者在使用这个框架的时候可以根据需求自己定义。</p>
<p>现在知道了数据源的设置方法，我们看一下第三个问题：</p>
<h2 id="问题3：cell的绘制方法是如何区分的？"><a href="#问题3：cell的绘制方法是如何区分的？" class="headerlink" title="问题3：cell的绘制方法是如何区分的？"></a>问题3：cell的绘制方法是如何区分的？</h2><p>心细的同学会发现，在dataSource的<code>cellForRow:</code>方法里，我用了block方法来绘制了cell。</p>
<p>先看一下这个block的定义：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^SJStaticCellConfigureBlock)(SJStaticTableViewCell *cell, SJStaticTableviewCellViewModel * viewModel);</div></pre></td></tr></table></figure></p>
<p>这个block在控制器里面回调，通过判断cell的类型来绘制不同的cell。</p>
<p>那么不同类型的cell是如何区分的呢？<br>— 我用的是分类。</p>
<p>有分类，就一定有一个被分类的类： <code>SJStaticTableViewCell</code></p>
<p>看一下它的头文件：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//所有cell都是这个类的分类</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> : <span class="title">UITableViewCell</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) SJStaticTableviewCellViewModel *viewModel;</div><div class="line"><span class="comment">// =============== 系统风格cell的所有控件 =============== //</span></div><div class="line"><span class="comment">//左半部分</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *leftImageView;               <span class="comment">//左侧的ImageView</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *leftTitleLabel;                  <span class="comment">//左侧的Label</span></div><div class="line"></div><div class="line"><span class="comment">//右半部分</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *indicatorArrow;              <span class="comment">//右侧的箭头</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *indicatorLeftImageView;      <span class="comment">//右侧的箭头的左边的imageview</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *indicatorLeftLabel;              <span class="comment">//右侧的箭头的左边的Label</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UISwitch</span> *indicatorSwitch;                <span class="comment">//右侧的箭头的左边的开关</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *logoutLabel;                     <span class="comment">//退出登录的label</span></div><div class="line"><span class="comment">// =============== 用户自定义的cell里面的控件 =============== //</span></div><div class="line"><span class="comment">//MeViewController里面的头像cell</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *avatarImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *codeImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImageView</span> *avatarIndicatorImageView;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *userNameLabel;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UILabel</span> *userIdLabel;</div><div class="line"></div><div class="line"><span class="comment">//统一的，布局cell左侧部分的内容（标题 ／ 图片 + 标题），所有系统风格的cell都要调用这个方法</span></div><div class="line">- (<span class="keyword">void</span>)layoutLeftPartSubViewsWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>在这里我定义了所有的控件和一个布局cell左侧的控件的方法。因为几乎所有的分类的左侧几乎都是类似的，所以将它抽取出来。</p>
<p>那么究竟有几个分类呢？（可以参考上面cellViewModel头文件里的枚举类型）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧有剪头的cell（最常见）</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessoryDisclosureIndicator</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessoryDisclosureIndicatorCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧没有控件的cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessoryNone</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessoryNoneCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//右侧是开关的 cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">AccessorySwitch</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureAccessorySwitchCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//退出登录cell</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">Logout</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureLogoutTableViewCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个自定义的cell（在个人页的第一排）</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SJStaticTableViewCell</span> (<span class="title">MeAvatar</span>)</span></div><div class="line">- (<span class="keyword">void</span>)configureMeAvatarTableViewCellWithViewModel:(SJStaticTableviewCellViewModel *)viewModel;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在使用这个框架的时候，如果遇到不满足当前需求的情况，可以自己添加分类。</p>
<h2 id="问题4：UITableViewDelegate的方法哪里去了？"><a href="#问题4：UITableViewDelegate的方法哪里去了？" class="headerlink" title="问题4：UITableViewDelegate的方法哪里去了？"></a>问题4：UITableViewDelegate的方法哪里去了？</h2><p>说到<code>UITableViewDelegate</code>的代理方法，我们最熟悉的莫过于<code>didSelectRowAtIndexPath:</code>了。</p>
<p>但是我在写这个框架的时候，自己定义了一个继承于<code>UITableViewDelegate</code>的代理：<code>SJStaticTableViewDelegate</code>，并给它添加了一个代理方法：<br>``<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SJStaticTableViewDelegate</span> &lt;<span class="title">UITableViewDelegate</span>&gt;</span></div><div class="line"><span class="keyword">@optional</span></div><div class="line">- (<span class="keyword">void</span>)didSelectViewModel: (SJStaticTableviewCellViewModel *)viewModel atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>这个方法返回的是当前点击的cell对应的viewModel，弱化了indexPath的作用。</p>
<p>为什么要这么做？</p>
<p>想一想原来点击cell的代理方法：<code>didSelectRowAtIndexPath:</code>。我们通过这个点击方法，拿到的是cell对应的indexPath，然后再通过这个indexPath，就可以在数据源里面查找对应的模型（viewModel或者model）。</p>
<p>因此，我定义的这个方法直接返回了被点击cell对应的viewModel，等于说帮使用者节省了一个步骤。当然如果要使用的话也可以使用系统原来的<code>didSelectRowAtIndexPath:</code>方法。</p>
<p>来看一下这个新的代理方法是如何实现的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableView.m</span></div><div class="line">- (<span class="keyword">void</span>)tableView:(<span class="built_in">UITableView</span> *)tableView didSelectRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    [tableView deselectRowAtIndexPath:indexPath animated:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.sjDelegate) &amp;&amp; [<span class="keyword">self</span>.sjDelegate respondsToSelector:<span class="keyword">@selector</span>(didSelectViewModel:atIndexPath:)]) &#123;        </div><div class="line">        SJStaticTableviewCellViewModel *cellViewModel = [<span class="keyword">self</span>.sjDataSource tableView:tableView cellViewModelAtIndexPath:indexPath];</div><div class="line">        [<span class="keyword">self</span>.sjDelegate didSelectViewModel:cellViewModel atIndexPath:indexPath];</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>((<span class="keyword">self</span>.sjDelegate)&amp;&amp; [<span class="keyword">self</span>.sjDelegate respondsToSelector:<span class="keyword">@selector</span>(tableView:didSelectRowAtIndexPath:)])&#123;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.sjDelegate tableView:tableView didSelectRowAtIndexPath:indexPath];        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在读者应该大致了解了这个框架的实现思路，现在我讲一下这个框架的定制性。</p>
<h1 id="定制性"><a href="#定制性" class="headerlink" title="定制性"></a>定制性</h1><hr>
<p>这个框架有一个配置文件：SJConst.h，它定义了这个框架的所有默认数据和默认配置，比如cell左侧lable的字体，颜色；左侧label和image的距离；右侧label的字体和颜色，右侧图片的默认大小等等。来看一下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#ifndef SJConst_h</span></div><div class="line"><span class="meta">#define SJConst_h</span></div><div class="line"><span class="comment">//distance</span></div><div class="line"><span class="meta">#define SJScreenWidth      [UIScreen mainScreen].bounds.size.width</span></div><div class="line"><span class="meta">#define SJScreenHeight     [UIScreen mainScreen].bounds.size.height</span></div><div class="line"><span class="meta">#define SJTopGap 8               //same as bottom gap</span></div><div class="line"><span class="meta">#define SJLeftGap 12             //same as right gap</span></div><div class="line"><span class="meta">#define SJLeftMiddleGap 10       //in left  part: the gap between image and label</span></div><div class="line"><span class="meta">#define SJRightMiddleGap 6       //in right part: the gap between image and label</span></div><div class="line"><span class="meta">#define SJImgWidth 30            //default width and height</span></div><div class="line"><span class="meta">#define SJTitleWidthLimit 180    //limt width of left and right labels</span></div><div class="line"><span class="comment">//image</span></div><div class="line"><span class="meta">#define SJIndicatorArrow @<span class="meta-string">"arrow"</span></span></div><div class="line"><span class="comment">//font</span></div><div class="line"><span class="meta">#define SJLeftTitleTextFont               [UIFont systemFontOfSize:15]</span></div><div class="line"><span class="meta">#define SJLogoutButtonFont                [UIFont systemFontOfSize:16]</span></div><div class="line"><span class="meta">#define SJIndicatorLeftTitleTextFont      [UIFont systemFontOfSize:13]</span></div><div class="line"><span class="comment">//color</span></div><div class="line"><span class="meta">#define SJColorWithRGB(R,G,B,A)           [UIColor colorWithRed:R/255.0 green:G/255.0 blue:B/255.0 alpha:A]</span></div><div class="line"><span class="meta">#define SJLeftTitleTextColor              [UIColor blackColor]</span></div><div class="line"><span class="meta">#define SJIndicatorLeftTitleTextColor     SJColorWithRGB(136,136,136,1)</span></div><div class="line"><span class="meta">#endif /* SJConst_h */</span></div></pre></td></tr></table></figure>
<p>这里定义的默认配置在cellViewModel和sectionViewModel初始化的时候使用：</p>
<p>cell的viewModel：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//SJStaticTableviewCellViewModel.m</span></div><div class="line">- (<span class="keyword">instancetype</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;        </div><div class="line">        _cellHeight = <span class="number">44</span>;</div><div class="line">        _cellID = <span class="string">@"defaultCell"</span>;</div><div class="line">        _staticCellType = SJStaticCellTypeSystemAccessoryDisclosureIndicator;<span class="comment">//默认是存在三角箭头的cell</span></div><div class="line">        _isImageFirst = <span class="literal">YES</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//都是默认配置</span></div><div class="line">        _leftLabelTextFont = SJLeftTitleTextFont;</div><div class="line">        _leftLabelTextColor = SJLeftTitleTextColor;</div><div class="line">        _leftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _leftImageAndLabelGap = SJLeftMiddleGap;</div><div class="line">        _indicatorLeftLabelTextFont = SJIndicatorLeftTitleTextFont;</div><div class="line">        _indicatorLeftLabelTextColor = SJIndicatorLeftTitleTextColor;</div><div class="line">        _indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _indicatorLeftImageAndLabelGap = SJRightMiddleGap;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>section的viewModel：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">instancetype</span>)initWithCellViewModelsArray:(<span class="built_in">NSArray</span> *)cellViewModelsArray</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        _sectionHeaderHeight = <span class="number">10</span>;</div><div class="line">        _sectionFooterHeight = <span class="number">10</span>;</div><div class="line">        _leftLabelTextFont = SJLeftTitleTextFont;</div><div class="line">        _leftLabelTextColor = SJLeftTitleTextColor;</div><div class="line">        _leftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _leftImageAndLabelGap = SJLeftMiddleGap;</div><div class="line">        _indicatorLeftLabelTextFont = SJIndicatorLeftTitleTextFont;</div><div class="line">        _indicatorLeftLabelTextColor = SJIndicatorLeftTitleTextColor;</div><div class="line">        _indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(SJImgWidth, SJImgWidth);</div><div class="line">        _indicatorLeftImageAndLabelGap = SJRightMiddleGap;</div><div class="line">        _cellViewModelsArray = cellViewModelsArray;        </div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>显然，这个默认配置只有一组，但是可能一个app里面同时存在一个设置页和一个个人页。而这两个页面的风格也可能是不一样的，所以这个默认配置只能给其中一个页面，另一个页面需要另外配置，于是就有了定制性的功能。</p>
<p>再来看一下展示定制性效果的图：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/sjstatictableview_2.png" alt="分组定制 | 同组定制"></p>
<p>参照这个效果图，我们看一下这两个页面的数据源是如何设置的：</p>
<p>分组页面：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)customCellsPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">//默认配置</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm1.leftTitle = <span class="string">@"全部默认配置，用于对照"</span>;</div><div class="line">    vm1.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm1.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1]];</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm2.leftTitle = <span class="string">@"左侧图片变小"</span>;</div><div class="line">    vm2.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm2.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section2 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm2]];</div><div class="line">    section2.leftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>);</div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm3.leftTitle = <span class="string">@"字体变小变红"</span>;</div><div class="line">    vm3.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm3.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section3 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm3]];</div><div class="line">    section3.leftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">8</span>];</div><div class="line">    section3.leftLabelTextColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm4.leftTitle = <span class="string">@"左侧两个控件距离变大"</span>;</div><div class="line">    vm4.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm4.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section4 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm4]];</div><div class="line">    section4.leftImageAndLabelGap = <span class="number">20</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm5.leftTitle = <span class="string">@"右侧图片变小"</span>;</div><div class="line">    vm5.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm5.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section5 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm5]];</div><div class="line">    section5.indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">15</span>, <span class="number">15</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm6= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm6.leftTitle = <span class="string">@"右侧字体变大变蓝"</span>;</div><div class="line">    vm6.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm6.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section6 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm6]];</div><div class="line">    section6.indicatorLeftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18</span>];</div><div class="line">    section6.indicatorLeftLabelTextColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm7= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm7.leftTitle = <span class="string">@"右侧两个控件距离变大"</span>;</div><div class="line">    vm7.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm7.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section7 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm7]];</div><div class="line">    section7.indicatorLeftImageAndLabelGap = <span class="number">18</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section1,section2,section3,section4,section5,section6,section7];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>我们可以看到，定制的代码都作用于section的viewModel。</p>
</blockquote>
<p>同组页面：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span> *)customCellsOneSectionPageData</div><div class="line">&#123;</div><div class="line">    <span class="comment">//默认配置</span></div><div class="line">    SJStaticTableviewCellViewModel *vm1 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm1.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm1.leftTitle = <span class="string">@"全部默认配置，用于对照"</span>;</div><div class="line">    vm1.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm1.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm2 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm2.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm2.leftTitle = <span class="string">@"左侧图片变小"</span>;</div><div class="line">    vm2.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm2.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm2.leftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">20</span>, <span class="number">20</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm3 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm3.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm3.leftTitle = <span class="string">@"字体变小变红"</span>;</div><div class="line">    vm3.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm3.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm3.leftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">8</span>];</div><div class="line">    vm3.leftLabelTextColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm4 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm4.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm4.leftTitle = <span class="string">@"左侧两个控件距离变大"</span>;</div><div class="line">    vm4.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm4.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm4.leftImageAndLabelGap = <span class="number">20</span>;</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm5 = [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm5.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm5.leftTitle = <span class="string">@"右侧图片变小"</span>;</div><div class="line">    vm5.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm5.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm5.indicatorLeftImageSize = <span class="built_in">CGSizeMake</span>(<span class="number">15</span>, <span class="number">15</span>);</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm6= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm6.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm6.leftTitle = <span class="string">@"右侧字体变大变蓝"</span>;</div><div class="line">    vm6.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm6.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm6.indicatorLeftLabelTextFont = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">18</span>];</div><div class="line">    vm6.indicatorLeftLabelTextColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">    </div><div class="line">    </div><div class="line">    SJStaticTableviewCellViewModel *vm7= [[SJStaticTableviewCellViewModel alloc] init];</div><div class="line">    vm7.leftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"MoreGame"</span>];</div><div class="line">    vm7.leftTitle = <span class="string">@"右侧两个控件距离变大"</span>;</div><div class="line">    vm7.indicatorLeftImage = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"wzry"</span>];</div><div class="line">    vm7.indicatorLeftTitle = <span class="string">@"王者荣耀!"</span>;</div><div class="line">    vm7.indicatorLeftImageAndLabelGap = <span class="number">18</span>;</div><div class="line">    </div><div class="line">    SJStaticTableviewSectionViewModel *section1 = [[SJStaticTableviewSectionViewModel alloc] initWithCellViewModelsArray:@[vm1,vm2,vm3,vm4,vm5,vm6,vm7]];</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> @[section1];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为了方便比较，同组页面的定制和分组是一致的。我们可以看到，定制代码都作用于cell的viewModel上了。</p>
</blockquote>
<p>为什么要有同组和分组展示？</p>
<p>同组和分组展示的目的，是为了展示这个框架的两种定制性。</p>
<ul>
<li><p>分组页面所展示的是section级的定制性：cell的配置任务交给section层的viewModel。一旦设置，该section里面的所有cell都能保持这一配置。</p>
</li>
<li><p>同组页面所展示的是cell级的定制性：cell的配置任务交给cell层的viewModel。一旦设置，只有当前cell具有这个配置，不影响其他cell。</p>
</li>
</ul>
<p>其实为了省事，只在section层的viewModel上配置即可（如果给每个cell都给设置相同的配置太不优雅了），因为从设计角度来看，一个section里面的cell的风格不一致的情况比较少见（我觉得不符合设计）：比如在一个section里面，不太可能两个cell里面的图片大小是不一样的，或者字体大小也不一样。</p>
<p>还是看一下section级的定制代码吧：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧label的字体</span></div><div class="line">- (<span class="keyword">void</span>)setLeftLabelTextFont:(<span class="built_in">UIFont</span> *)leftLabelTextFont</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (_leftLabelTextFont != leftLabelTextFont) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span> font1:_leftLabelTextFont hasSameFontSizeOfFont2:leftLabelTextFont]) &#123;</div><div class="line">            </div><div class="line">            _leftLabelTextFont = leftLabelTextFont;</div><div class="line">            </div><div class="line">            <span class="comment">//如果新的宽度大于原来的宽度，需要重新设置，否则不需要</span></div><div class="line">            [_cellViewModelsArray enumerateObjectsUsingBlock:^(SJStaticTableviewCellViewModel * viewModel, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">                viewModel.leftLabelTextFont = _leftLabelTextFont;</div><div class="line">                <span class="built_in">CGSize</span> size = [<span class="keyword">self</span> sizeForTitle:viewModel.leftTitle withFont:_leftLabelTextFont];</div><div class="line">                <span class="keyword">if</span> (size.width &gt; viewModel.leftTitleLabelSize.width) &#123;</div><div class="line">                    viewModel.leftTitleLabelSize = size;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧label的字的颜色</span></div><div class="line">- (<span class="keyword">void</span>)setLeftLabelTextColor:(<span class="built_in">UIColor</span> *)leftLabelTextColor</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> color1:_leftLabelTextColor hasTheSameRGBAOfColor2:leftLabelTextColor]) &#123;</div><div class="line">         _leftLabelTextColor = leftLabelTextColor;</div><div class="line">        [_cellViewModelsArray makeObjectsPerformSelector:<span class="keyword">@selector</span>(setLeftLabelTextColor:) withObject:_leftLabelTextColor];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//重新设置了该组全部cell里面左侧图片等大小</span></div><div class="line">- (<span class="keyword">void</span>)setLeftImageSize:(<span class="built_in">CGSize</span>)leftImageSize</div><div class="line">&#123;</div><div class="line">    SJStaticTableviewCellViewModel *viewMoel = _cellViewModelsArray.firstObject;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> cellHeight = viewMoel.cellHeight;</div><div class="line">    <span class="keyword">if</span> ( (!<span class="built_in">CGSizeEqualToSize</span>(_leftImageSize, leftImageSize)) &amp;&amp; (leftImageSize.height &lt; cellHeight)) &#123;</div><div class="line">        _leftImageSize = leftImageSize;</div><div class="line">        [_cellViewModelsArray enumerateObjectsUsingBlock:^(SJStaticTableviewCellViewModel *viewModel, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop)</div><div class="line">        &#123;</div><div class="line">            viewMoel.leftImageSize = _leftImageSize;</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为每个section都持有它内部的所有cell的viewModel，所以在set方法里面，如果发现传进来的配置与当前配置不一致，就需要更新所有cell的viewModel对应的属性。</p>
<p>既然section的ViewModel能做这些，为什么还要有一个cell层的配置呢？</p>
<p>– 只是为了提高配置的自由度罢了，万一突然来个需求需要某个cell很独特呢？（大家应该知道我说的神么意思 ^^）</p>
<p>cell的viewModel属性的set方法的实现和section的一致，这里就不上代码了。</p>
<hr>
<p>好了，到这里就讲差不多了，代码量虽然不多，但是都说清楚还是感觉挺需要时间想的。</p>
<p>希望如果各位觉得哪里不好，可以给出您的宝贵意见～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写UITableView的时候，我们经常遇到的是完全依赖于网络请求，需要自定义的动态cell的需求（比如微博帖子列表）。但是同时，大多数app里面几乎也都有设置页，个人页等其他以静态表格为主的页面。&lt;/p&gt;
&lt;p&gt;而且这些页面的共性比较多：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;大多数情况下在进入页面之前就已经拿到所有数据。&lt;/li&gt;
&lt;li&gt;cell样式单一，自定义cell出现的几率比较小（几乎都是高度为44的cell）。&lt;/li&gt;
&lt;li&gt;多数都分组。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为自己非常想写一个开源的东西出来（也可以暴露自己的不足），同时又受限于水平，所以就打算写这么一个比较简单，又具有通用性的框架：&lt;strong&gt;一个定制性比较高的适合在个人页和设置页使用的UITableView&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在真正写之前，看了几篇类似的文章，挑出三篇自己觉得比较好的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.objc.io/issues/1-view-controllers/table-views/&quot;&gt;Clean Table View Code&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/504c61a9dc82&quot;&gt;如何写好一个UITableView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jianshu.com/p/81d0c573f7a8&quot;&gt;利用MVVM设计快速开发个人中心、设置等模块&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看完总结之后，利用上周3天的业余时间写好了这个框架，为了它实用性，我仿照了微信客户端的发现页，个人页和设置页写了一个Demo，来看一下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/sjstatictableview_1.png&quot; alt=&quot;发现页 | 个人页 | 个人信息页 | 设置页&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/03/14/%E5%85%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%91%98%EF%BC%8C%E7%84%B6%E5%90%8E%E6%89%8D%E6%98%AFiOS%E7%A8%8B%E5%BA%8F%E5%91%98%20%E2%80%94%20%E5%86%99%E7%BB%99%E5%B9%BF%E5%A4%A7%E9%9D%9E%E7%A7%91%E7%8F%ADiOS%E5%BC%80%E5%8F%91%E8%80%85%E7%9A%84%E4%B8%80%E7%AF%87%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/03/14/先是程序员，然后才是iOS程序员 — 写给广大非科班iOS开发者的一篇面试总结/</id>
    <published>2017-03-14T00:37:08.000Z</published>
    <updated>2017-03-20T07:56:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-10c56d4121bfe78d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Objective-C | Swift | C"></p>
<p>这篇面试总结很短，也没有面试题的答案，只是写给像我一样的非科班iOS开发者的一些话。</p>
<p>昨天进行了人生第一次视频面试，一共三个小时的技术面，还没见到人事，应该是挂了。</p>
<p>不过整个过程下来感触还是蛮多的，除了感受到面试官的牛X之外，也知道自己平时在学习中的不足。</p>
<h4 id="先介绍一下面试中觉得比较吃力的问题："><a href="#先介绍一下面试中觉得比较吃力的问题：" class="headerlink" title="先介绍一下面试中觉得比较吃力的问题："></a>先介绍一下面试中觉得比较吃力的问题：</h4><ol>
<li>如果让你实现属性的weak，如何实现的？</li>
<li>如果让你来实现属性的atomic，如何实现？</li>
<li>KVO为什么要创建一个子类来实现？</li>
<li>类结构体的组成，isa指针指向了什么？（这里应该将元类和根元类也说一下）</li>
<li>RunLoop有几种事件源？有几种模式？</li>
<li>方法列表的数据结构是什么？</li>
<li>分类是如何实现的？它为什么会覆盖掉原来的方法？</li>
</ol>
<p>另外值得一提的就是问了我自己写的博客里的东西（JSONModel的解析，EOC的笔记）等等。。</p>
<a id="more"></a>
<h4 id="这次面试让我深刻意识到了两点："><a href="#这次面试让我深刻意识到了两点：" class="headerlink" title="这次面试让我深刻意识到了两点："></a>这次面试让我深刻意识到了两点：</h4><ol>
<li>对于每个设计，不能只停留在“会用”而已，应该理解它的实现机制，而且几乎每个设计都是与数据结构息息相关的，理解了数据结构和指针会有助于理解这些设计。</li>
<li>了解设计的原理之后，还要知其所以然：为什么这么设计？最好还要知道这个设计存在什么缺陷，这个缺陷是哪个解决类似问题的设计所没有的？</li>
</ol>
<p>第一点是“how”的问题，第二点是“why”的问题，然而我相信有不少人只停留在“what”和“using”上。</p>
<p>在面试的时候，我强烈感受到了面试官的功力之深：给我的感觉，对他而言，几乎所有的设计都可以用某种数据结构解释出来（有的时候也会结合指针），对知识点理解得非常透彻：即便是很简单知识点，也能说出很多深层次的东西来。而我自己只是刚开始学数据结构不久，在面对提到数据结构的问题几乎是没有思路的。</p>
<h4 id="我想说的："><a href="#我想说的：" class="headerlink" title="我想说的："></a>我想说的：</h4><p>所以我觉得对于广大非科班的iOS开发来说，如果想在iOS开发上走远，就必须尽快补充数据结构，算法，指针等计算机基础知识，不然会对知识的理解形成很大的阻力。因为只有知道了这些基础知识，才能更深入得理解每一个技术点，而且以后如果学习其他的语言，也会更高效一些。</p>
<p>简单来说就一句话：先是程序员，然后才是iOS程序员。只有这样思考，路才能越走越宽，越走越快，越走越远。</p>
<p>现在iOS开发形势这么不好，市场要过滤掉那些计算机基础知识薄弱的人也是情有可原的。</p>
<blockquote>
<p>所谓的现在的“不好”，只是相对于之前“不正常的好”的不好。现在这个行业变得“不好”，其实是因为这个行业正在变得好，应该值得我们高兴才是。</p>
</blockquote>
<p>所以对于我们这群人（非科班的iOS开发者），应该提高忧患意识，未雨绸缪，更何况，雨已经来过了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0dc7553fc98a04f7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-10c56d4121bfe78d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Objective-C | Swift | C&quot;&gt;&lt;/p&gt;
&lt;p&gt;这篇面试总结很短，也没有面试题的答案，只是写给像我一样的非科班iOS开发者的一些话。&lt;/p&gt;
&lt;p&gt;昨天进行了人生第一次视频面试，一共三个小时的技术面，还没见到人事，应该是挂了。&lt;/p&gt;
&lt;p&gt;不过整个过程下来感触还是蛮多的，除了感受到面试官的牛X之外，也知道自己平时在学习中的不足。&lt;/p&gt;
&lt;h4 id=&quot;先介绍一下面试中觉得比较吃力的问题：&quot;&gt;&lt;a href=&quot;#先介绍一下面试中觉得比较吃力的问题：&quot; class=&quot;headerlink&quot; title=&quot;先介绍一下面试中觉得比较吃力的问题：&quot;&gt;&lt;/a&gt;先介绍一下面试中觉得比较吃力的问题：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;如果让你实现属性的weak，如何实现的？&lt;/li&gt;
&lt;li&gt;如果让你来实现属性的atomic，如何实现？&lt;/li&gt;
&lt;li&gt;KVO为什么要创建一个子类来实现？&lt;/li&gt;
&lt;li&gt;类结构体的组成，isa指针指向了什么？（这里应该将元类和根元类也说一下）&lt;/li&gt;
&lt;li&gt;RunLoop有几种事件源？有几种模式？&lt;/li&gt;
&lt;li&gt;方法列表的数据结构是什么？&lt;/li&gt;
&lt;li&gt;分类是如何实现的？它为什么会覆盖掉原来的方法？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外值得一提的就是问了我自己写的博客里的东西（JSONModel的解析，EOC的笔记）等等。。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>JSONModel源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/22/JSONModel%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/22/JSONModel源码解析/</id>
    <published>2017-02-22T01:16:56.000Z</published>
    <updated>2017-03-20T07:56:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一系列的<a href="http://www.jianshu.com/nb/9137726" target="_blank" rel="external">源码解析</a>分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。</p>
<p>想来想去，还是从<a href="https://github.com/jsonmodel/jsonmodel">JSONModel</a>开始吧～</p>
<p>首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。</p>
<p>该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。</p>
<a id="more"></a>
<p>在讲解源码之前，有必要先给不会使用JSONModel的同学们通过实际的例子来介绍一下它的使用方法（而且后面的源码解析部分也是结合这些例子给出的，因为结合例子有助于加快理解）：</p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="1-最基本的使用"><a href="#1-最基本的使用" class="headerlink" title="1. 最基本的使用"></a>1. 最基本的使用</h2><p>第一种就是单纯地传入一个字典，并转换成模型：<br>首先我们需要定义我们自己的模型类：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>)   <span class="built_in">NSString</span> *sex;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>然后再使用字典来转换为模型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                        <span class="string">@"gender"</span>:<span class="string">@"male"</span>,</div><div class="line">                      &#125;;</div><div class="line"> <span class="built_in">NSError</span> *error;</div><div class="line"> Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;Person&gt; </div><div class="line">   [name]: Jack</div><div class="line">   [sex]: male</div><div class="line">   [gender]: 23</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure></p>
<p>可以看出来，该框架的使用非常方便，一行代码就将模型转换好了。<br>但是该框架的功能远不止这些：</p>
<h2 id="2-转换属性名称"><a href="#2-转换属性名称" class="headerlink" title="2. 转换属性名称"></a>2. 转换属性名称</h2><p>有的时候，传入的字典里的key发生了变化（比如接口重构之类的原因），但是我们前端这边已经写好的模型属性可能不容易被修改（因为业务逻辑很复杂什么的），所以这个时候，最好有一个转化的功能。</p>
<p>在这里举个例子：原来字典里的<code>gender</code>这个key变成了<code>sex</code>，这就需要我们定义一个转换的mapper（<code>JSONKeyMapper</code>）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></div><div class="line">+ (JSONKeyMapper *)keyMapper</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> [[JSONKeyMapper alloc] initWithModelToJSONDictionary:@&#123;</div><div class="line">                                                                  <span class="string">@"gender"</span>: <span class="string">@"sex"</span>,                                                             &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样一来，<code>JSONKeyMapper</code>就会自动帮我们做转换。<br>为了验证效果，我们修改一下传入的字典里的<code>gender</code>字段为<code>sex</code>：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                        <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</div><div class="line">                      &#125;;</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div></pre></td></tr></table></figure></p>
<p>再看一下输出：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;Person&gt; </div><div class="line">   [name]: Jack</div><div class="line">   [age]: 23</div><div class="line">   [gender]: male</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure>
<p>没有受到传入字典里key值的变化的影响，是吧？</p>
<h2 id="3-自定义错误"><a href="#3-自定义错误" class="headerlink" title="3. 自定义错误"></a>3. 自定义错误</h2><p>除了一些框架里自己处理的错误（比如传入的对象不是字典等），框架的作者也允许我们自己定义属于我们自己的错误。</p>
<p>比如，当<code>age</code>对应的数值小于25的时候，打印出<code>Too young!</code>,并阻止模型的转换：</p>
<p>首先，我们在模型的实现文件里添加：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)validate:(<span class="built_in">NSError</span> **)error</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">super</span> validate:error])</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.age &lt; <span class="number">25</span>)</div><div class="line">    &#123;</div><div class="line">        *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"Too young!"</span> code:<span class="number">10</span> userInfo:<span class="literal">nil</span>];</div><div class="line">        <span class="built_in">NSError</span> *errorLog = *error;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,errorLog.domain);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看一下结果：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] Too young!</div><div class="line"><span class="number">2017</span><span class="number">-02</span><span class="number">-20</span> <span class="number">16</span>:<span class="number">14</span>:<span class="number">54.217</span> jsonmodel_demo[<span class="number">32942</span>:<span class="number">1967433</span>] (null)</div></pre></td></tr></table></figure></p>
<p>打印了错误，而且模型也没有被转换。</p>
<h2 id="4-模型嵌套"><a href="#4-模型嵌套" class="headerlink" title="4. 模型嵌套"></a>4. 模型嵌套</h2><p>有的时候，我们需要在模型里加一个数组，而这个数组里面的元素是另一个对象：这就涉及到了模型的嵌套。</p>
<p>举个例子，我们让上面的<code>Person</code>对象含有一个数组<code>Friends</code>，它里面的元素是对象<code>Friend</code>，也就是好友信息。若要实现模型的嵌套，我们只需在原来的模型类里增加一个协议<code>Friend</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"JSONModel.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">Friend</span>;</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Friend</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">JSONModel</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSInteger</span> age;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *gender;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span>&lt;Friend&gt; *friends;<span class="comment">//数组，嵌套模型</span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>而且要在<code>Person</code>的实现文件里加上这一段代码：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Friend</span></span></div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p>
<p>注意！如果不添加，则会令程序崩溃。</p>
<p>最后，在使用的时候，我们只需将持有一个数组的字典里传入即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *array = @[</div><div class="line">                      @&#123;</div><div class="line">                        <span class="string">@"name"</span>:<span class="string">@"Peter"</span>,</div><div class="line">                        <span class="string">@"age"</span>:@<span class="number">35</span>,</div><div class="line">                        &#125;,</div><div class="line">                   ];</div><div class="line">    </div><div class="line"> <span class="built_in">NSDictionary</span> *dict = @&#123;</div><div class="line">                           <span class="string">@"name"</span>:<span class="string">@"Jack"</span>,</div><div class="line">                           <span class="string">@"age"</span>:@<span class="number">23</span>,</div><div class="line">                           <span class="string">@"sex"</span>:<span class="string">@"male"</span>,</div><div class="line">                           <span class="string">@"friends"</span>:array,<span class="comment">//朋友列表（模型嵌套）</span></div><div class="line">                         &#125;;</div><div class="line"><span class="built_in">NSError</span> *error;</div><div class="line">Person *person = [[Person alloc] initWithDictionary:dict error:&amp;error];</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,person);</div></pre></td></tr></table></figure>
<p>输出结果：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;Person&gt; </div><div class="line">   [age]: 23</div><div class="line">   [gender]: male</div><div class="line">   [friends]: (</div><div class="line">       "&lt;Friend&gt; \n   [name]: Peter\n   [age]: 35\n&lt;/Friend&gt;"</div><div class="line">   )</div><div class="line">   [name]: Jack</div><div class="line">&lt;/Person&gt;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，person对象里含有一个数组，这个数组只有一个元素，对应着上面字典里的array里的信息。</p>
<p>OK，这样一来，大家已经可以掌握该框架的主要用法了，现在开始详细讲解代码：</p>
<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>本篇源码解析主要围绕着<code>initWithDictionary:error:</code>来展开，在这一个方法里作者做到了所有的容错和模型的转化。</p>
<p>按照老规矩，先上流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-94b356eeb7b560e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="字典-&gt;模型"></p>
<p>该流程图对应的方法实现是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)initWithDictionary:(<span class="built_in">NSDictionary</span>*)dict error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//方法1. 参数为nil</span></div><div class="line">    <span class="keyword">if</span> (!dict) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInputIsNil];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法2. 参数不是nil，但也不是字典</span></div><div class="line">    <span class="keyword">if</span> (![dict isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMessage:<span class="string">@"Attempt to initialize JSONModel object using initWithDictionary:error: but the dictionary parameter was not an 'NSDictionary'."</span>];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法3. 初始化</span></div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">self</span> init];</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">//初始化失败</span></div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorModelIsInvalid];</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法4. 检查用户定义的模型里的属性集合是否大于传入的字典里的key集合（如果大于，则返回NO）</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __doesDictionary:dict matchModelWithKeyMapper:<span class="keyword">self</span>.__keyMapper error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法5. 核心方法：字典的key与模型的属性的映射</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> __importDictionary:dict withKeyMapper:<span class="keyword">self</span>.__keyMapper validation:<span class="literal">YES</span> error:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法6. 可以重写[self validate:err]方法并返回NO，让用户自定义错误并阻拦model的返回</span></div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validate:err]) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//方法7. 终于通过了！成功返回model</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li>方法1-4:都是对错误的发现与处理。</li>
<li>方法5:是真正的mapping。</li>
<li>方法6:是作者给用户自己定义错误的方法，如果复合了用户自己定义的错误，那么即使mapping成功了，也要返回nil。<br>-方法7:成功返回模型对象。</li>
</ul>
<p>在讲解代码之前，有必要先了解一下JSONModel所持有的一些数据：</p>
<ul>
<li><p><strong>关联对象kClassPropertiesKey</strong>:(用来保存所有属性信息的NSDictionary)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">       age = <span class="string">"@property primitive age (Setters = [])"</span>;</div><div class="line">      name = <span class="string">"@property NSString* name (Standard JSON type, Setters = [])"</span>;</div><div class="line">    gender = <span class="string">"@property NSString* gender (Standard JSON type, Setters = [])"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>关联对象kClassRequiredPropertyNamesKey</strong>：(用来保存所有属性的名称NSSet)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;(</div><div class="line">    name,</div><div class="line">    age,</div><div class="line">    gender</div><div class="line">)&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>关联对象kMapperObjectKey</strong>：(用来保存JSONKeyMapper)：自定义的mapper，具体的使用方法在上面的例子中可以看到。</p>
</li>
</ul>
<ul>
<li><strong>JSONModelClassProperty</strong>：封装的jsonmodel的一个属性，它包含了对应属性的名字（name：gender），类型（type：NSString），是否是JSONModel支持的类型（isStandardJSONType：YES/NO），是否是可变对象（isMutable:YES/NO）等属性。</li>
</ul>
<p>再大致讲解一下整个的流程：<br>首先，在这个模型类的对象被初始化的时候，遍历自身到所有的父类（直到JSONModel为止），获取所有的属性，并将其保存在一个字典里。获取传入字典的所有key，将这些key与保存的所有属性进行匹配。如果匹配成功，则进行kvc赋值。</p>
<p>OK，现在从上到下逐步讲解上段代码：</p>
<p>首先，在<code>load</code>方法里，定义了该框架支持的类型：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">+(<span class="keyword">void</span>)load</div><div class="line">&#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;           </div><div class="line">            <span class="comment">//兼容的对象属性</span></div><div class="line">            allowedJSONTypes = @[</div><div class="line">                [<span class="built_in">NSString</span> <span class="keyword">class</span>], [<span class="built_in">NSNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSDecimalNumber</span> <span class="keyword">class</span>], [<span class="built_in">NSArray</span> <span class="keyword">class</span>], [<span class="built_in">NSDictionary</span> <span class="keyword">class</span>], [<span class="built_in">NSNull</span> <span class="keyword">class</span>], <span class="comment">//immutable JSON classes</span></div><div class="line">                [<span class="built_in">NSMutableString</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableArray</span> <span class="keyword">class</span>], [<span class="built_in">NSMutableDictionary</span> <span class="keyword">class</span>] <span class="comment">//mutable JSON classes</span></div><div class="line">            ];</div><div class="line">            <span class="comment">//兼容的基本类型属性</span></div><div class="line">            allowedPrimitiveTypes = @[</div><div class="line">                <span class="string">@"BOOL"</span>, <span class="string">@"float"</span>, <span class="string">@"int"</span>, <span class="string">@"long"</span>, <span class="string">@"double"</span>, <span class="string">@"short"</span>,</div><div class="line">                <span class="comment">//and some famous aliases</span></div><div class="line">                <span class="string">@"NSInteger"</span>, <span class="string">@"NSUInteger"</span>,</div><div class="line">                <span class="string">@"Block"</span></div><div class="line">            ];</div><div class="line">            <span class="comment">//转换器</span></div><div class="line">            valueTransformer = [[JSONValueTransformer alloc] init];</div><div class="line">            </div><div class="line">            <span class="comment">//自己的类型</span></div><div class="line">            JSONModelClass = <span class="built_in">NSClassFromString</span>(<span class="built_in">NSStringFromClass</span>(<span class="keyword">self</span>));</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们看一下从方法3的init方法开始，作者都做了什么：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">id</span>)init</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> __setup__];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">-(<span class="keyword">void</span>)__setup__</div><div class="line">&#123;</div><div class="line">    <span class="comment">//只有第一次实例化时，才执行</span></div><div class="line">    <span class="keyword">if</span> (!objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kClassPropertiesKey)) &#123;</div><div class="line">        [<span class="keyword">self</span> __inspectProperties];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果存在自定义的mapper，则将它保存在关联对象里面，key是kMapperObjectKey</span></div><div class="line">    <span class="keyword">id</span> mapper = [[<span class="keyword">self</span> <span class="keyword">class</span>] keyMapper];</div><div class="line">    <span class="keyword">if</span> ( mapper &amp;&amp; !objc_getAssociatedObject(<span class="keyword">self</span>.class, &amp;kMapperObjectKey) ) &#123;</div><div class="line">        objc_setAssociatedObject(</div><div class="line">                                 <span class="keyword">self</span>.class,</div><div class="line">                                 &amp;kMapperObjectKey,</div><div class="line">                                 mapper,</div><div class="line">                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></div><div class="line">                                 );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>值得注意的是，这里的<code>__inspectProperties:</code>方法是该框架的核心方法之一：它的任务是保存了所有需要赋值的属性。用作在将来与传进来字典进行映射：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)__inspectProperties</div><div class="line">&#123;</div><div class="line"><span class="comment">//    最终保存所有属性的字典，形式为：</span></div><div class="line"><span class="comment">//    &#123;</span></div><div class="line"><span class="comment">//        age = "@property primitive age (Setters = [])";</span></div><div class="line"><span class="comment">//        friends = "@property NSArray*&lt;Friend&gt; friends (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//        gender = "@property NSString* gender (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//        name = "@property NSString* name (Standard JSON type, Setters = [])";</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line">    <span class="built_in">NSMutableDictionary</span>* propertyIndex = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    <span class="comment">//获取当前的类名</span></div><div class="line">    Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];    </div><div class="line">    <span class="built_in">NSScanner</span>* scanner = <span class="literal">nil</span>;</div><div class="line">    <span class="built_in">NSString</span>* propertyType = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">// 循环条件：当class 是 JSONModel自己的时候终止</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">class</span> != [JSONModel <span class="keyword">class</span>]) &#123;        </div><div class="line">        <span class="comment">//属性的个数</span></div><div class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> propertyCount;</div><div class="line">        <span class="comment">//获得属性列表（所有@property声明的属性）</span></div><div class="line">        objc_property_t *properties = class_copyPropertyList(<span class="keyword">class</span>, &amp;propertyCount);</div><div class="line">        <span class="comment">//遍历所有的属性</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; propertyCount; i++) &#123;</div><div class="line">            <span class="comment">//获得属性名称</span></div><div class="line">            objc_property_t property = properties[i];<span class="comment">//获得当前的属性</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *propertyName = property_getName(property);<span class="comment">//name（C字符串）            </span></div><div class="line">            <span class="comment">//JSONModel里的每一个属性，都被封装成一个JSONModelClassProperty对象</span></div><div class="line">            JSONModelClassProperty* p = [[JSONModelClassProperty alloc] init];</div><div class="line">            p.name = @(propertyName);<span class="comment">//propertyName:属性名称，例如：name，age，gender</span></div><div class="line">            <span class="comment">//获得属性类型</span></div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *attrs = property_getAttributes(property);</div><div class="line">            <span class="built_in">NSString</span>* propertyAttributes = @(attrs);</div><div class="line">            <span class="comment">// T@\"NSString\",C,N,V_name</span></div><div class="line">            <span class="comment">// Tq,N,V_age</span></div><div class="line">            <span class="comment">// T@\"NSString\",C,N,V_gender</span></div><div class="line">            <span class="comment">// T@"NSArray&lt;Friend&gt;",&amp;,N,V_friends            </span></div><div class="line">            <span class="built_in">NSArray</span>* attributeItems = [propertyAttributes componentsSeparatedByString:<span class="string">@","</span>];</div><div class="line">            <span class="comment">//说明是只读属性，不做任何操作</span></div><div class="line">            <span class="keyword">if</span> ([attributeItems containsObject:<span class="string">@"R"</span>]) &#123;</div><div class="line">                <span class="keyword">continue</span>; <span class="comment">//to next property</span></div><div class="line">            &#125;</div><div class="line">            <span class="comment">//检查出是布尔值</span></div><div class="line">            <span class="keyword">if</span> ([propertyAttributes hasPrefix:<span class="string">@"Tc,"</span>]) &#123;</div><div class="line">                p.structName = <span class="string">@"BOOL"</span>;<span class="comment">//使其变为结构体</span></div><div class="line">            &#125;            </div><div class="line">            <span class="comment">//实例化一个scanner</span></div><div class="line">            scanner = [<span class="built_in">NSScanner</span> scannerWithString: propertyAttributes];</div><div class="line">            [scanner scanUpToString:<span class="string">@"T"</span> intoString: <span class="literal">nil</span>];</div><div class="line">            [scanner scanString:<span class="string">@"T"</span> intoString:<span class="literal">nil</span>];</div><div class="line">            <span class="comment">//http://blog.csdn.net/kmyhy/article/details/8258858           </span></div><div class="line">            <span class="keyword">if</span> ([scanner scanString:<span class="string">@"@\""</span> intoString: &amp;propertyType]) &#123;                </div><div class="line">                 <span class="comment">//属性是一个对象</span></div><div class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@"\"&lt;"</span>]</div><div class="line">                                        intoString:&amp;propertyType];<span class="comment">//propertyType -&gt; NSString                </span></div><div class="line">                p.type = <span class="built_in">NSClassFromString</span>(propertyType);<span class="comment">// p.type = @"NSString"</span></div><div class="line">                p.isMutable = ([propertyType rangeOfString:<span class="string">@"Mutable"</span>].location != <span class="built_in">NSNotFound</span>); <span class="comment">//判断是否是可变的对象</span></div><div class="line">                p.isStandardJSONType = [allowedJSONTypes containsObject:p.type];<span class="comment">//是否是该框架兼容的类型</span></div><div class="line">                <span class="comment">//存在协议(数组，也就是嵌套模型)</span></div><div class="line">                <span class="keyword">while</span> ([scanner scanString:<span class="string">@"&lt;"</span> intoString:<span class="literal">NULL</span>]) &#123;</div><div class="line">                    <span class="built_in">NSString</span>* protocolName = <span class="literal">nil</span>;</div><div class="line">                    [scanner scanUpToString:<span class="string">@"&gt;"</span> intoString: &amp;protocolName];</div><div class="line">                    <span class="keyword">if</span> ([protocolName isEqualToString:<span class="string">@"Optional"</span>]) &#123;</div><div class="line">                        p.isOptional = <span class="literal">YES</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Index"</span>]) &#123;</div><div class="line"><span class="meta">#pragma GCC diagnostic push</span></div><div class="line"><span class="meta">#pragma GCC diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">                        p.isIndex = <span class="literal">YES</span>;</div><div class="line"><span class="meta">#pragma GCC diagnostic pop</span></div><div class="line">                        objc_setAssociatedObject(</div><div class="line">                                                 <span class="keyword">self</span>.class,</div><div class="line">                                                 &amp;kIndexPropertyNameKey,</div><div class="line">                                                 p.name,</div><div class="line">                                                 OBJC_ASSOCIATION_RETAIN <span class="comment">// This is atomic</span></div><div class="line">                                                 );</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>([protocolName isEqualToString:<span class="string">@"Ignore"</span>]) &#123;</div><div class="line">                        p = <span class="literal">nil</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        p.protocol = protocolName;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//到最接近的&gt;为止</span></div><div class="line">                    [scanner scanString:<span class="string">@"&gt;"</span> intoString:<span class="literal">NULL</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;            </div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ([scanner scanString:<span class="string">@"&#123;"</span> intoString: &amp;propertyType])                </div><div class="line">                <span class="comment">//属性是结构体</span></div><div class="line">                [scanner scanCharactersFromSet:[<span class="built_in">NSCharacterSet</span> alphanumericCharacterSet]</div><div class="line">                                    intoString:&amp;propertyType];</div><div class="line">                p.isStandardJSONType = <span class="literal">NO</span>;</div><div class="line">                p.structName = propertyType;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//属性是基本类型：Tq,N,V_age</span></div><div class="line">                [scanner scanUpToCharactersFromSet:[<span class="built_in">NSCharacterSet</span> characterSetWithCharactersInString:<span class="string">@","</span>]</div><div class="line">                                        intoString:&amp;propertyType];</div><div class="line">                <span class="comment">//propertyType:q</span></div><div class="line">                propertyType = valueTransformer.primitivesNames[propertyType];              </div><div class="line">                <span class="comment">//propertyType:long</span></div><div class="line">                <span class="comment">//基本类型数组</span></div><div class="line">                <span class="keyword">if</span> (![allowedPrimitiveTypes containsObject:propertyType]) &#123;</div><div class="line">                    <span class="comment">//类型不支持</span></div><div class="line">                    <span class="keyword">@throw</span> [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"JSONModelProperty type not allowed"</span></div><div class="line">                                                   reason:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Property type of %@.%@ is not supported by JSONModel."</span>, <span class="keyword">self</span>.class, p.name]</div><div class="line">                                                 userInfo:<span class="literal">nil</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSString</span> *nsPropertyName = @(propertyName);            </div><div class="line">            <span class="comment">//可选的</span></div><div class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsOptional:nsPropertyName])&#123;</div><div class="line">                p.isOptional = <span class="literal">YES</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//可忽略的</span></div><div class="line">            <span class="keyword">if</span>([[<span class="keyword">self</span> <span class="keyword">class</span>] propertyIsIgnored:nsPropertyName])&#123;</div><div class="line">                p = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//集合类</span></div><div class="line">            Class customClass = [[<span class="keyword">self</span> <span class="keyword">class</span>] classForCollectionProperty:nsPropertyName];            </div><div class="line">            <span class="keyword">if</span> (customClass) &#123;</div><div class="line">                p.protocol = <span class="built_in">NSStringFromClass</span>(customClass);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//忽略block</span></div><div class="line">            <span class="keyword">if</span> ([propertyType isEqualToString:<span class="string">@"Block"</span>]) &#123;</div><div class="line">                p = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果字典里不存在，则添加到属性字典里（终于添加上去了。。。）</span></div><div class="line">            <span class="keyword">if</span> (p &amp;&amp; ![propertyIndex objectForKey:p.name]) &#123;</div><div class="line">                [propertyIndex setValue:p forKey:p.name];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//setter 和 getter</span></div><div class="line">            <span class="keyword">if</span> (p)</div><div class="line">            &#123;   <span class="comment">//name -&gt;Name</span></div><div class="line">                <span class="built_in">NSString</span> *name = [p.name stringByReplacingCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:[p.name substringToIndex:<span class="number">1</span>].uppercaseString];</div><div class="line">                <span class="comment">// getter</span></div><div class="line">                SEL <span class="keyword">getter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"JSONObjectFor%@"</span>, name]);</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">getter</span>])</div><div class="line">                    p.customGetter = <span class="keyword">getter</span>;</div><div class="line">                <span class="comment">// setters</span></div><div class="line">                p.customSetters = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">                SEL genericSetter = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@WithJSONObject:"</span>, name]);</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:genericSetter])</div><div class="line">                    p.customSetters[<span class="string">@"generic"</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;genericSetter objCType:<span class="keyword">@encode</span>(SEL)];</div><div class="line">                <span class="keyword">for</span> (Class type <span class="keyword">in</span> allowedJSONTypes)</div><div class="line">                &#123;</div><div class="line">                    <span class="built_in">NSString</span> *<span class="keyword">class</span> = <span class="built_in">NSStringFromClass</span>([JSONValueTransformer classByResolvingClusterClasses:type]);</div><div class="line">                    <span class="keyword">if</span> (p.customSetters[<span class="keyword">class</span>])</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    SEL <span class="keyword">setter</span> = <span class="built_in">NSSelectorFromString</span>([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"set%@With%@:"</span>, name, <span class="keyword">class</span>]);</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">setter</span>])</div><div class="line">                        p.customSetters[<span class="keyword">class</span>] = [<span class="built_in">NSValue</span> valueWithBytes:&amp;<span class="keyword">setter</span> objCType:<span class="keyword">@encode</span>(SEL)];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        free(properties);</div><div class="line">        <span class="comment">//再指向自己的父类，知道等于JSONModel才停止</span></div><div class="line">        <span class="keyword">class</span> = [<span class="keyword">class</span> superclass];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//最后保存所有当前类，JSONModel的所有的父类的属性</span></div><div class="line">    objc_setAssociatedObject(</div><div class="line">                             <span class="keyword">self</span>.class,</div><div class="line">                             &amp;kClassPropertiesKey,</div><div class="line">                             [propertyIndex <span class="keyword">copy</span>],</div><div class="line">                             OBJC_ASSOCIATION_RETAIN</div><div class="line">                             );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意几点：</p>
<ol>
<li>作者利用一个<code>while</code>函数，获取当前类和当前类的除JSONModel的所有父类的属性保存在一个字典中。在将来用于和传入的字典进行映射。</li>
<li>作者用<code>JSONModelClassProperty</code>类封装了JSONModel的每一个属性。这个类有两个重要的属性：一个是<code>name</code>，它是属性的名称(例如gender)。另一个是<code>type</code>，它是属性的类型（例如NSString）。</li>
<li>作者将属性分为了如下几个类型：<ol>
<li>对象（不含有协议）。</li>
<li>对象（含有协议，属于模型嵌套）。</li>
<li>基本数据类型。</li>
<li>结构体。</li>
</ol>
</li>
</ol>
</blockquote>
<p>我们来看一下方法4的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)__doesDictionary:(<span class="built_in">NSDictionary</span>*)dict matchModelWithKeyMapper:(JSONKeyMapper*)keyMapper error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//拿到字典里所有的key</span></div><div class="line">    <span class="built_in">NSArray</span>* incomingKeysArray = [dict allKeys];    </div><div class="line">    <span class="comment">//返回保存所有属性名称的数组(name,age,gender...)</span></div><div class="line">    <span class="built_in">NSMutableSet</span>* requiredProperties = [<span class="keyword">self</span> __requiredPropertyNames].mutableCopy;    </div><div class="line">    <span class="comment">//从array拿到set</span></div><div class="line">    <span class="built_in">NSSet</span>* incomingKeys = [<span class="built_in">NSSet</span> setWithArray: incomingKeysArray];</div><div class="line">    <span class="comment">//如果用户自定义了mapper，则进行转换</span></div><div class="line">    <span class="keyword">if</span> (keyMapper || globalKeyMapper) &#123;</div><div class="line">        <span class="built_in">NSMutableSet</span>* transformedIncomingKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity: requiredProperties.count];</div><div class="line">        <span class="built_in">NSString</span>* transformedName = <span class="literal">nil</span>;</div><div class="line">        <span class="comment">//便利需要转换的属性列表</span></div><div class="line">        <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</div><div class="line">            <span class="comment">//被转换成的属性名称 gender（模型内） -&gt; sex（字典内）</span></div><div class="line">            transformedName = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</div><div class="line">            <span class="comment">//拿到sex以后，查看传入的字典里是否有sex对应的值</span></div><div class="line">            <span class="keyword">id</span> value;</div><div class="line">            <span class="keyword">@try</span> &#123;</div><div class="line">                value = [dict valueForKeyPath:transformedName];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">                value = dict[transformedName];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//如果值存在，则将sex添加到传入的keys数组中</span></div><div class="line">            <span class="keyword">if</span> (value) &#123;</div><div class="line">                [transformedIncomingKeys addObject: property.name];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        incomingKeys = transformedIncomingKeys;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//查看当前的model的属性的集合是否大于传入的属性集合，如果是，则返回错误。</span></div><div class="line">    <span class="comment">//也就是说模型类里的属性是不能多于传入字典里的key的，例如：</span></div><div class="line">    <span class="keyword">if</span> (![requiredProperties isSubsetOfSet:incomingKeys]) &#123;</div><div class="line">        <span class="comment">//获取多出来的属性</span></div><div class="line">        [requiredProperties minusSet:incomingKeys];</div><div class="line">        <span class="comment">//not all required properties are in - invalid input</span></div><div class="line">        JMLog(<span class="string">@"Incoming data was invalid [%@ initWithDictionary:]. Keys missing: %@"</span>, <span class="keyword">self</span>.class, requiredProperties);</div><div class="line">        <span class="keyword">if</span> (err) *err = [JSONModelError errorInvalidDataWithMissingKeys:requiredProperties];</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//不需要了，释放掉</span></div><div class="line">    incomingKeys= <span class="literal">nil</span>;</div><div class="line">    requiredProperties= <span class="literal">nil</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里需要需要注意的：</p>
<ol>
<li>model类里面定义的属性集合是不能大于传入的字典里的key集合的。</li>
<li>如果存在了用户自定义的mapper，则需要按照用户的定义来进行转换。<br>（在这里是奖gender转换为了sex）。</li>
</ol>
</blockquote>
<p>最后来看一下本框架第二个核心代码(上面的方法5)，也就是真正从字典里获取值并赋给当前模型对象的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line">-(<span class="built_in">BOOL</span>)__importDictionary:(<span class="built_in">NSDictionary</span>*)dict withKeyMapper:(JSONKeyMapper*)keyMapper validation:(<span class="built_in">BOOL</span>)validation error:(<span class="built_in">NSError</span>**)err</div><div class="line">&#123;</div><div class="line">    <span class="comment">//遍历保存的所有属性的字典</span></div><div class="line">    <span class="keyword">for</span> (JSONModelClassProperty* property <span class="keyword">in</span> [<span class="keyword">self</span> __properties__]) &#123;</div><div class="line">        <span class="comment">//将属性的名称拿过来，作为key，用这个key来查找传进来的字典里对应的值</span></div><div class="line">        <span class="built_in">NSString</span>* jsonKeyPath = (keyMapper||globalKeyMapper) ? [<span class="keyword">self</span> __mapString:property.name withKeyMapper:keyMapper] : property.name;</div><div class="line">        <span class="comment">//用来保存从字典里获取的值</span></div><div class="line">        <span class="keyword">id</span> jsonValue;        </div><div class="line">        <span class="keyword">@try</span> &#123;</div><div class="line">            jsonValue = [dict valueForKeyPath: jsonKeyPath];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</div><div class="line">            jsonValue = dict[jsonKeyPath];</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//字典不存在对应的key</span></div><div class="line">        <span class="keyword">if</span> (isNull(jsonValue)) &#123;</div><div class="line">            <span class="comment">//如果这个key是可以不存在的</span></div><div class="line">            <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;            </div><div class="line">            <span class="comment">//如果这个key是必须有的，则返回错误</span></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Value of required model key %@ is null"</span>, property.name];</div><div class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//获取 取到的值的类型</span></div><div class="line">        Class jsonValueClass = [jsonValue <span class="keyword">class</span>];</div><div class="line">        <span class="built_in">BOOL</span> isValueOfAllowedType = <span class="literal">NO</span>;</div><div class="line">        <span class="comment">//查看是否是本框架兼容的属性类型</span></div><div class="line">        <span class="keyword">for</span> (Class allowedType <span class="keyword">in</span> allowedJSONTypes) &#123;</div><div class="line">            <span class="keyword">if</span> ( [jsonValueClass isSubclassOfClass: allowedType] ) &#123;</div><div class="line">                isValueOfAllowedType = <span class="literal">YES</span>;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//如果不兼容，则返回NO，mapping失败</span></div><div class="line">        <span class="keyword">if</span> (isValueOfAllowedType==<span class="literal">NO</span>) &#123;</div><div class="line">            <span class="comment">//type not allowed</span></div><div class="line">            JMLog(<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass));</div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Type %@ is not allowed in JSON."</span>, <span class="built_in">NSStringFromClass</span>(jsonValueClass)];</div><div class="line">                JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是兼容的类型：</span></div><div class="line">        <span class="keyword">if</span> (property) &#123;</div><div class="line">            <span class="comment">// 查看是否有自定义setter，并设置</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __customSetValue:jsonValue forProperty:property]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;;</div><div class="line">            <span class="comment">// 基本类型</span></div><div class="line">            <span class="keyword">if</span> (property.type == <span class="literal">nil</span> &amp;&amp; property.structName==<span class="literal">nil</span>) &#123;</div><div class="line">                <span class="comment">//kvc赋值</span></div><div class="line">                <span class="keyword">if</span> (jsonValue != [<span class="keyword">self</span> valueForKey:property.name]) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 如果传来的值是空，即使当前的属性对应的值不是空，也要将空值赋给它</span></div><div class="line">            <span class="keyword">if</span> (isNull(jsonValue)) &#123;</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span> valueForKey:property.name] != <span class="literal">nil</span>) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:<span class="literal">nil</span> forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 1. 属性本身是否是jsonmodel类型</span></div><div class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span> __isJSONModelSubClass:property.type]) &#123;</div><div class="line">                <span class="comment">//通过自身的转模型方法，获取对应的值</span></div><div class="line">                JSONModelError* initErr = <span class="literal">nil</span>;</div><div class="line">                <span class="keyword">id</span> value = [[property.type alloc] initWithDictionary: jsonValue error:&amp;initErr];</div><div class="line">                <span class="keyword">if</span> (!value) &#123;               </div><div class="line">                    <span class="comment">//如果该属性不是必须的，则略过</span></div><div class="line">                    <span class="keyword">if</span> (property.isOptional || !validation) <span class="keyword">continue</span>;</div><div class="line">                    <span class="comment">//如果该属性是必须的，则返回错误</span></div><div class="line">                    <span class="keyword">if</span>((err != <span class="literal">nil</span>) &amp;&amp; (initErr != <span class="literal">nil</span>))</div><div class="line">                    &#123;</div><div class="line">                        *err = [initErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                &#125;            </div><div class="line">                <span class="comment">//当前的属性值为空，则赋值</span></div><div class="line">                <span class="keyword">if</span> (![value isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</div><div class="line">                    [<span class="keyword">self</span> setValue:value forKey: property.name];</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// 如果不是jsonmodel的类型，则可能是一些普通的类型：NSArray，NSString。。。</span></div><div class="line">                <span class="comment">// 是否是模型嵌套（带有协议）</span></div><div class="line">                <span class="keyword">if</span> (property.protocol) &#123;</div><div class="line">                    <span class="comment">//转化为数组，这个数组就是例子中的friends属性。</span></div><div class="line">                    jsonValue = [<span class="keyword">self</span> __transform:jsonValue forProperty:property error:err];</div><div class="line">                   </div><div class="line">                    <span class="keyword">if</span> (!jsonValue) &#123;</div><div class="line">                        <span class="keyword">if</span> ((err != <span class="literal">nil</span>) &amp;&amp; (*err == <span class="literal">nil</span>)) &#123;</div><div class="line">                            <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Failed to transform value, but no error was set during transformation. (%@)"</span>, property];</div><div class="line">                            JSONModelError* dataErr = [JSONModelError errorInvalidDataWithMessage:msg];</div><div class="line">                            *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 对象类型</span></div><div class="line">                <span class="keyword">if</span> (property.isStandardJSONType &amp;&amp; [jsonValue isKindOfClass: property.type]) &#123;</div><div class="line">                    <span class="comment">//可变类型</span></div><div class="line">                    <span class="keyword">if</span> (property.isMutable) &#123;</div><div class="line">                        jsonValue = [jsonValue mutableCopy];</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//赋值</span></div><div class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]]) &#123;</div><div class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey: property.name];</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">continue</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 当前的值的类型与对应的属性的类型不一样的时候，需要查看用户是否自定义了转换器（例如从NSSet到NSArray转换：- (NSSet *)NSSetFromNSArray:(NSArray *)array）</span></div><div class="line">                <span class="keyword">if</span> (</div><div class="line">                    (![jsonValue isKindOfClass:property.type] &amp;&amp; !isNull(jsonValue))</div><div class="line">                    ||</div><div class="line">                    <span class="comment">//the property is mutable</span></div><div class="line">                    property.isMutable</div><div class="line">                    ||</div><div class="line">                    <span class="comment">//custom struct property</span></div><div class="line">                    property.structName</div><div class="line">                    ) &#123;</div><div class="line">                    <span class="comment">// searched around the web how to do this better</span></div><div class="line">                    <span class="comment">// but did not find any solution, maybe that's the best idea? (hardly)</span></div><div class="line">                    Class sourceClass = [JSONValueTransformer classByResolvingClusterClasses:[jsonValue <span class="keyword">class</span>]];</div><div class="line">                    <span class="comment">//JMLog(@"to type: [%@] from type: [%@] transformer: [%@]", p.type, sourceClass, selectorName);</span></div><div class="line"></div><div class="line">                    <span class="comment">//build a method selector for the property and json object classes</span></div><div class="line">                    <span class="built_in">NSString</span>* selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@From%@:"</span>,</div><div class="line">                                              (property.structName? property.structName : property.type), <span class="comment">//target name</span></div><div class="line">                                              sourceClass]; <span class="comment">//source name</span></div><div class="line">                    SEL selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line">                    <span class="comment">//查看自定义的转换器是否存在</span></div><div class="line">                    <span class="built_in">BOOL</span> foundCustomTransformer = <span class="literal">NO</span>;</div><div class="line">                    <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</div><div class="line">                        foundCustomTransformer = <span class="literal">YES</span>;                        </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        <span class="comment">//try for hidden custom transformer</span></div><div class="line">                        selectorName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"__%@"</span>,selectorName];</div><div class="line">                        selector = <span class="built_in">NSSelectorFromString</span>(selectorName);</div><div class="line">                        <span class="keyword">if</span> ([valueTransformer respondsToSelector:selector]) &#123;</div><div class="line">                            foundCustomTransformer = <span class="literal">YES</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//如果存在自定义转换器，则进行转换</span></div><div class="line">                    <span class="keyword">if</span> (foundCustomTransformer) &#123;                        </div><div class="line">                        IMP imp = [valueTransformer methodForSelector:selector];</div><div class="line">                        <span class="keyword">id</span> (*func)(<span class="keyword">id</span>, SEL, <span class="keyword">id</span>) = (<span class="keyword">void</span> *)imp;</div><div class="line">                        jsonValue = func(valueTransformer, selector, jsonValue);</div><div class="line"></div><div class="line">                        <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">                            [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];                        </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;                       </div><div class="line">                        <span class="comment">//没有自定义转换器，返回错误</span></div><div class="line">                        <span class="built_in">NSString</span>* msg = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ type not supported for %@.%@"</span>, property.type, [<span class="keyword">self</span> <span class="keyword">class</span>], property.name];</div><div class="line">                        JSONModelError* dataErr = [JSONModelError errorInvalidDataWithTypeMismatch:msg];</div><div class="line">                        *err = [dataErr errorByPrependingKeyPathComponent:property.name];</div><div class="line">                        <span class="keyword">return</span> <span class="literal">NO</span>;                        </div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// 3.4) handle "all other" cases (if any)</span></div><div class="line">                    <span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">                        [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>值得注意的是：</p>
<ul>
<li>作者在最后给属性赋值的时候使用的是kvc的<code>setValue:ForKey:</code>的方法。</li>
<li>作者判断了模型里的属性的类型是否是JSONModel的子类，可见作者的考虑是非常周全的。</li>
<li>整个框架看下来，有很多的地方涉及到了错误判断，作者将将错误类型单独抽出一个类（<code>JSONModelError</code>），里面支持的错误类型很多，可以侧面反应作者思维之缜密。而且这个做法也可以在我们写自己的框架或者项目中使用。</li>
</ul>
</blockquote>
<p>错误判断的一个例子：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JSONModelError.m</span></div><div class="line">+(<span class="keyword">id</span>)errorInvalidDataWithMessage:(<span class="built_in">NSString</span>*)message</div><div class="line">&#123;</div><div class="line">    message = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Invalid JSON data: %@"</span>, message];</div><div class="line">    <span class="keyword">return</span> [JSONModelError errorWithDomain:JSONModelErrorDomain</div><div class="line">                                      code:kJSONModelErrorInvalidData</div><div class="line">                                  userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span>:message&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>夸了作者这么多，唯一我个人不太喜欢的地方就是if语句下只有一行的时候，作者不喜欢加上大括号：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])</div><div class="line">    [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div></pre></td></tr></table></figure></p>
<p>但是我觉得应该加的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (![jsonValue isEqual:[<span class="keyword">self</span> valueForKey:property.name]])&#123;</div><div class="line">  [<span class="keyword">self</span> setValue:jsonValue forKey:property.name];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h2><ul>
<li>作者用NSScanner来扫描字符串，将从类结构体里拿过来的属性的描述字符串<code>T@\&quot;NSString\&quot;,C,N,V_name</code>中扫描出了类型：<code>NSString</code>。</li>
<li>作者两次用到了NSSet：当集合里的元素顺序不重要的时候，优先考虑用NSSet。</li>
</ul>
<p>总的来说这个框架的难度还是不大的，但可能因为是第一次阅读不涉及UIVIiew的框架，感觉有些枯燥，不过慢慢习惯就好啦～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一系列的&lt;a href=&quot;http://www.jianshu.com/nb/9137726&quot;&gt;源码解析&lt;/a&gt;分享到现在已经是第五篇了。这五篇讲解的都是view层的一些流行的iOS开源框架。而从本篇开始开始，我打算要逐渐加深难度，讲解一些model层和网络层相关的开源框架。&lt;/p&gt;
&lt;p&gt;想来想去，还是从&lt;a href=&quot;https://github.com/jsonmodel/jsonmodel&quot;&gt;JSONModel&lt;/a&gt;开始吧～&lt;/p&gt;
&lt;p&gt;首先因为该框架还是比较流行的，在GitHub上也有将近6000颗星了，而且我自己对这个框架的使用也比较熟悉。还有一点是这个框架运用了运行时的相关知识，对想要了解运行时的童鞋还是很有帮助的。&lt;/p&gt;
&lt;p&gt;该框架的核心代码并不是很多，主要还是错误类型判断和容错处理占了不少内容。读过一遍之后，感觉到作者思维的严谨性是非常值得我们学习的：作者专门建立了一个展示错误(NSError)的类，里面封装了很多错误类型，而且这个框架还允许用户根据自己的需求来自定义错误类型并阻止最终模型的生成，在后文会有详细讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>VVeboTableView源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/14/VVeboTableView%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/14/VVeboTableView源码解析/</id>
    <published>2017-02-14T02:57:30.000Z</published>
    <updated>2017-03-20T07:57:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>这次分享一个关于性能优化的源码。</p>
<p>我们知道<code>UITabelView</code>在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，<code>UITabelView</code>的性能将直接影响这个app的性能。</p>
<p>如果<code>UITabelView</code>里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。</p>
<p>但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。</p>
<p>最近在看一些iOS性能优化的文章，我找到了<a href="https://github.com/johnil/VVeboTableViewDemo">VVeboTableView</a>这个框架。严格来说这个不属于框架，而是作者用自己的方式优化<code>UITableView</code>的一个实现。</p>
<p>作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？</p>
<p>看了源码之后，我把作者的思路整理了出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png" alt="优化思路图"></p>
<p>下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。</p>
<a id="more"></a>
<h2 id="1-减少CPU／GPU计算量"><a href="#1-减少CPU／GPU计算量" class="headerlink" title="1. 减少CPU／GPU计算量"></a>1. 减少CPU／GPU计算量</h2><h3 id="1-1-cell的重用机制"><a href="#1-1-cell的重用机制" class="headerlink" title="1.1 cell的重用机制"></a>1.1 cell的重用机制</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//cell重用</span></div><div class="line">    VVeboTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:<span class="string">@"cell"</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (cell==<span class="literal">nil</span>) &#123;</div><div class="line">        cell = [[VVeboTableViewCell alloc] initWithStyle:<span class="built_in">UITableViewCellStyleDefault</span> reuseIdentifier:<span class="string">@"cell"</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制</span></div><div class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</div><div class="line">    <span class="keyword">return</span> cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这部分就不赘述了，相信大家都可以掌握。</p>
<h3 id="1-2-将cell高度和-cell里的控件的frame缓存在model里"><a href="#1-2-将cell高度和-cell里的控件的frame缓存在model里" class="headerlink" title="1.2 将cell高度和 cell里的控件的frame缓存在model里"></a>1.2 将cell高度和 cell里的控件的frame缓存在model里</h3><p>这一步我们需要在字典转模型里统一计算(不需要看代码细节，只需要知道这里在模型里保存了需要保存的控件的frame和整个cell的高度即可)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadData&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *dict <span class="keyword">in</span> temp) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *user = dict[<span class="string">@"user"</span>];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="built_in">NSDictionary</span> *retweet = [dict valueForKey:<span class="string">@"retweeted_status"</span>];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (retweet) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">            ...</div><div class="line">            &#123;</div><div class="line">                <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</div><div class="line">                <span class="built_in">CGSize</span> size = [subData[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_SUBCONTENT) lineSpace:<span class="number">5</span>];</div><div class="line">                <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</div><div class="line">                subData[<span class="string">@"textRect"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_BIG, width, sizeHeight)];</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                <span class="keyword">if</span> (subData[<span class="string">@"pic_urls"</span>] &amp;&amp; [subData[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</div><div class="line">                    sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</div><div class="line">                &#125;</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                subData[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            data[<span class="string">@"subData"</span>] = subData;</div><div class="line">           </div><div class="line">        </div><div class="line">            <span class="keyword">float</span> width = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT*<span class="number">2</span>;</div><div class="line">            <span class="built_in">CGSize</span> size = [data[<span class="string">@"text"</span>] sizeWithConstrainedToWidth:width fromFont:FontWithSize(SIZE_FONT_CONTENT) lineSpace:<span class="number">5</span>];</div><div class="line">            <span class="built_in">NSInteger</span> sizeHeight = (size.height+<span class="number">.5</span>);</div><div class="line">            ...</div><div class="line">            sizeHeight += SIZE_GAP_TOP+SIZE_AVATAR+SIZE_GAP_BIG;</div><div class="line">            <span class="keyword">if</span> (data[<span class="string">@"pic_urls"</span>] &amp;&amp; [data[<span class="string">@"pic_urls"</span>] count]&gt;<span class="number">0</span>) &#123;</div><div class="line">                sizeHeight += (SIZE_GAP_IMG+SIZE_IMAGE+SIZE_GAP_IMG);</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="built_in">NSMutableDictionary</span> *subData = [data valueForKey:<span class="string">@"subData"</span>];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (subData) &#123;</div><div class="line">                sizeHeight += SIZE_GAP_BIG;</div><div class="line">                <span class="built_in">CGRect</span> frame = [subData[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">                ...</div><div class="line">                sizeHeight += frame.size.height;</div><div class="line">                data[<span class="string">@"subData"</span>] = subData;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            sizeHeight += <span class="number">30</span>;</div><div class="line">            data[<span class="string">@"frame"</span>] = [<span class="built_in">NSValue</span> valueWithCGRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, [<span class="built_in">UIScreen</span> screenWidth], sizeHeight)];</div><div class="line">        &#125;</div><div class="line">        [datas addObject:data];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//获取高度缓存</span></div><div class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *dict = datas[indexPath.row];</div><div class="line">    <span class="keyword">float</span> height = [dict[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>].size.height;</div><div class="line">    <span class="keyword">return</span> height;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里我们可以看到，作者根据帖子类型的不同：原贴(subData)的存在与否），来逐渐叠加cell的高度。</p>
<p>而缓存的控件的frame，我们在下面讲解绘制cell的代码里详细介绍。</p>
<h3 id="1-3-减少cell内部控件的层级"><a href="#1-3-减少cell内部控件的层级" class="headerlink" title="1.3 减少cell内部控件的层级"></a>1.3 减少cell内部控件的层级</h3><p>我们先来看一下一个带有原贴的转发贴的布局：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_3.png" alt="布局"></p>
<p>可能有小伙伴会将上中下这三个部分各自封装成一个view，再通过每个view来管理各自的子view。但是这个框架的作者却将它们都排列到一层上。</p>
<p>减少了子view的层级，有助于减少cpu对各种约束的计算。这在子view的数量，层级都很多的情况下对cpu的压力会减轻很多。</p>
<h3 id="1-4-通过覆盖圆角图片来实现头像的圆角效果"><a href="#1-4-通过覆盖圆角图片来实现头像的圆角效果" class="headerlink" title="1.4 通过覆盖圆角图片来实现头像的圆角效果"></a>1.4 通过覆盖圆角图片来实现头像的圆角效果</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//头像，frame固定</span></div><div class="line">avatarView = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];<span class="comment">//[[VVeboAvatarView alloc] initWithFrame:avatarRect];</span></div><div class="line">avatarView.frame = <span class="built_in">CGRectMake</span>(SIZE_GAP_LEFT, SIZE_GAP_TOP, SIZE_AVATAR, SIZE_AVATAR);</div><div class="line">avatarView.backgroundColor = [<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>];</div><div class="line">avatarView.hidden = <span class="literal">NO</span>;</div><div class="line">avatarView.tag = <span class="built_in">NSIntegerMax</span>;</div><div class="line">avatarView.clipsToBounds = <span class="literal">YES</span>;</div><div class="line">[<span class="keyword">self</span>.contentView addSubview:avatarView];</div><div class="line"><span class="comment">//覆盖在头像上面的图片，制造圆角效果：frame</span></div><div class="line">cornerImage = [[<span class="built_in">UIImageView</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, SIZE_AVATAR+<span class="number">5</span>, SIZE_AVATAR+<span class="number">5</span>)];</div><div class="line">cornerImage.center = avatarView.center;</div><div class="line">cornerImage.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"corner_circle@2x.png"</span>];</div><div class="line">cornerImage.tag = <span class="built_in">NSIntegerMax</span>;</div><div class="line">[<span class="keyword">self</span>.contentView addSubview:cornerImage];</div></pre></td></tr></table></figure>
<p>在这里，作者没有使用任何复杂的技术来实现图片的圆角（使用layer或者裁剪图片），只是将一张圆角颜色和cell背景色一致的图片覆盖在了原来的头像上，实现了圆角的效果（但是这个方法不太适用于有多个配色方案的app）。</p>
<h2 id="2-按需加载cell"><a href="#2-按需加载cell" class="headerlink" title="2. 按需加载cell"></a>2. 按需加载cell</h2><p>上文提到过，<code>UITableView</code>持有一个<code>needLoadArr</code>数组，它保存着需要刷新的cell的<code>NSIndexPath</code>。</p>
<p>我们先来看一下<code>needLoadArr</code>是如何使用的：</p>
<h3 id="2-1-在cellForRow-方法里只加载可见cell"><a href="#2-1-在cellForRow-方法里只加载可见cell" class="headerlink" title="2.1 在cellForRow:方法里只加载可见cell"></a>2.1 在cellForRow:方法里只加载可见cell</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    ...</div><div class="line">    [<span class="keyword">self</span> drawCell:cell withIndexPath:indexPath];</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)drawCell:(VVeboTableViewCell *)cell withIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath&#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSDictionary</span> *data = [datas objectAtIndex:indexPath.row];    </div><div class="line">    ...</div><div class="line">    cell.data = data;</div><div class="line">    <span class="comment">//当前的cell的indexPath不在needLoadArr里面，不用绘制</span></div><div class="line">    <span class="keyword">if</span> (needLoadArr.count&gt;<span class="number">0</span>&amp;&amp;[needLoadArr indexOfObject:indexPath]==<span class="built_in">NSNotFound</span>) &#123;</div><div class="line">        [cell clear];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//将要滚动到顶部，不绘制</span></div><div class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;  </div><div class="line">    <span class="comment">//真正绘制cell的代码</span></div><div class="line">    [cell draw];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"><a href="#2-2-监听tableview的快速滚动，保存目标滚动范围的前后三行的索引" class="headerlink" title="2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引"></a>2.2 监听tableview的快速滚动，保存目标滚动范围的前后三行的索引</h3><p>知道了如何使用<code>needLoadArr</code>，我们看一下<code>needLoadArr</code>里面的元素师如何添加和删除。</p>
<h4 id="添加元素NSIndexPath"><a href="#添加元素NSIndexPath" class="headerlink" title="添加元素NSIndexPath"></a>添加元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//按需加载 - 如果目标行与当前行相差超过指定行数，只在目标滚动范围的前后指定3行加载。</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewWillEndDragging:(<span class="built_in">UIScrollView</span> *)scrollView withVelocity:(<span class="built_in">CGPoint</span>)velocity targetContentOffset:(<span class="keyword">inout</span> <span class="built_in">CGPoint</span> *)targetContentOffset&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//targetContentOffset ： 停止后的contentOffset</span></div><div class="line">    <span class="built_in">NSIndexPath</span> *ip = [<span class="keyword">self</span> indexPathForRowAtPoint:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y)];</div><div class="line">    </div><div class="line">    <span class="comment">//当前可见第一行row的index</span></div><div class="line">    <span class="built_in">NSIndexPath</span> *cip = [[<span class="keyword">self</span> indexPathsForVisibleRows] firstObject];</div><div class="line">    </div><div class="line">    <span class="comment">//设置最小跨度，当滑动的速度很快，超过这个跨度时候执行按需加载</span></div><div class="line">    <span class="built_in">NSInteger</span> skipCount = <span class="number">8</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//快速滑动(跨度超过了8个cell)</span></div><div class="line">    <span class="keyword">if</span> (labs(cip.row-ip.row)&gt;skipCount) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//某个区域里的单元格的indexPath</span></div><div class="line">        <span class="built_in">NSArray</span> *temp = [<span class="keyword">self</span> indexPathsForRowsInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, targetContentOffset-&gt;y, <span class="keyword">self</span>.width, <span class="keyword">self</span>.height)];</div><div class="line">        <span class="built_in">NSMutableArray</span> *arr = [<span class="built_in">NSMutableArray</span> arrayWithArray:temp];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (velocity.y&lt;<span class="number">0</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//向上滚动</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp lastObject];</div><div class="line">            </div><div class="line">            <span class="comment">//超过倒数第3个</span></div><div class="line">            <span class="keyword">if</span> (indexPath.row+<span class="number">3</span>&lt;datas.count) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">1</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row+<span class="number">3</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//向下滚动</span></div><div class="line">            <span class="built_in">NSIndexPath</span> *indexPath = [temp firstObject];</div><div class="line">            <span class="comment">//超过正数第3个</span></div><div class="line">            <span class="keyword">if</span> (indexPath.row&gt;<span class="number">3</span>) &#123;</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-3</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-2</span> inSection:<span class="number">0</span>]];</div><div class="line">                [arr addObject:[<span class="built_in">NSIndexPath</span> indexPathForRow:indexPath.row<span class="number">-1</span> inSection:<span class="number">0</span>]];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//添加arr里的内容到needLoadArr的末尾</span></div><div class="line">        [needLoadArr addObjectsFromArray:arr];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>知道了如何向<code>needLoadArr</code>里添加元素，现在看一下何时（重置）清理这个array：</p>
<h4 id="移除元素NSIndexPath"><a href="#移除元素NSIndexPath" class="headerlink" title="移除元素NSIndexPath"></a>移除元素NSIndexPath</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用户触摸时第一时间加载内容</span></div><div class="line">- (<span class="built_in">UIView</span> *)hitTest:(<span class="built_in">CGPoint</span>)point withEvent:(<span class="built_in">UIEvent</span> *)event&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!scrollToToping) &#123;</div><div class="line">        [needLoadArr removeAllObjects];</div><div class="line">        [<span class="keyword">self</span> loadContent];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> hitTest:point withEvent:event];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)scrollViewWillBeginDragging:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    [needLoadArr removeAllObjects];</div><div class="line">&#125;</div><div class="line"><span class="comment">//将要滚动到顶部</span></div><div class="line">- (<span class="built_in">BOOL</span>)scrollViewShouldScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">YES</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//停止滚动</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewDidEndScrollingAnimation:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> loadContent];</div><div class="line">&#125;</div><div class="line"><span class="comment">//滚动到了顶部</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewDidScrollToTop:(<span class="built_in">UIScrollView</span> *)scrollView&#123;</div><div class="line">    scrollToToping = <span class="literal">NO</span>;</div><div class="line">    [<span class="keyword">self</span> loadContent];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，当手指触碰到tableview时 和 开始拖动tableview的时候就要清理这个数组。</p>
<p>而且在手指触碰到tableview时和 tableview停止滚动后就会执行<code>loadContent</code>方法，用来加载可见区域的cell。</p>
<p><code>loadContent</code>方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)loadContent&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//正在滚动到顶部</span></div><div class="line">    <span class="keyword">if</span> (scrollToToping) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//可见cell数</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.indexPathsForVisibleRows.count&lt;=<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//触摸的时候刷新可见cell</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.visibleCells&amp;&amp;<span class="keyword">self</span>.visibleCells.count&gt;<span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> temp <span class="keyword">in</span> [<span class="keyword">self</span>.visibleCells <span class="keyword">copy</span>]) &#123;</div><div class="line">            VVeboTableViewCell *cell = (VVeboTableViewCell *)temp;</div><div class="line">            [cell draw];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里注意一下，tableview的<code>visibleCells</code>属性是可见的cell的数组。</p>
<h2 id="3-异步处理cell"><a href="#3-异步处理cell" class="headerlink" title="3. 异步处理cell"></a>3. 异步处理cell</h2><p>在讲解cell是如何显示出来之前，我们大致看一下这个cell都有哪些控件：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_4.png" alt="控件名称"></p>
<p>了解到控件的名称，位置之后，我们看一下作者是如何布局这些控件的：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_2.png" alt="控件布局"><br>在上面可以大致看出来，除了需要异步网络加载的头像(avatarView)和帖子图片(multiPhotoScrollView)，作者都将这些控件画在了一张图上面（postBgView）。</p>
<p>而且我们可以看到，在postBgView上面需要异步显示的内容分为四种：</p>
<ol>
<li>UIImageView：本地图片（comments, more,reposts）。</li>
<li>UIView：背景，分割线(topLine)。</li>
<li>NSString：name，from字符串。</li>
<li>Label：原贴的detailLabel 和 当前贴的 label。</li>
</ol>
<p>下面结合代码来讲解这四种绘制：</p>
<p>首先看一下cell内部的核心绘制方法：</p>
<p>现在我们来看一下cell绘制的核心方法,draw方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将cell的主要内容绘制到图片上</span></div><div class="line">- (<span class="keyword">void</span>)draw&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//drawed = YES说明正在绘制，则立即返回。因为绘制是异步的，所以在开始绘制之后需要立即设为yes，防止重复绘制</span></div><div class="line">    <span class="keyword">if</span> (drawed) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//标记当前的绘制</span></div><div class="line">    <span class="built_in">NSInteger</span> flag = drawColorFlag;</div><div class="line">    </div><div class="line">    drawed = <span class="literal">YES</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">//获取整个cell的frame，已经换存在模型里了</span></div><div class="line">        <span class="built_in">CGRect</span> rect = [_data[<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//开启图形上下文</span></div><div class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(rect.size, <span class="literal">YES</span>, <span class="number">0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//获取图形上下文</span></div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        </div><div class="line">        <span class="comment">//背景颜色</span></div><div class="line">        [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">        </div><div class="line">        <span class="comment">//通过rect填充背景颜色</span></div><div class="line">        <span class="built_in">CGContextFillRect</span>(context, rect);</div><div class="line">        </div><div class="line">        <span class="comment">//如果有原帖（说明当前贴是转发贴）</span></div><div class="line">        <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">            </div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">243</span>/<span class="number">255.0</span> green:<span class="number">243</span>/<span class="number">255.0</span> blue:<span class="number">243</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGRect</span> subFrame = [_data[<span class="string">@"subData"</span>][<span class="string">@"frame"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, subFrame);</div><div class="line">            </div><div class="line">            <span class="comment">//原帖上面的分割线</span></div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, subFrame.origin.y, rect.size.width, <span class="number">.5</span>));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            <span class="keyword">float</span> leftX = SIZE_GAP_LEFT+SIZE_AVATAR+SIZE_GAP_BIG;</div><div class="line">            <span class="keyword">float</span> x = leftX;</div><div class="line">            <span class="keyword">float</span> y = (SIZE_AVATAR-(SIZE_FONT_NAME+SIZE_FONT_SUBTITLE+<span class="number">6</span>))/<span class="number">2</span><span class="number">-2</span>+SIZE_GAP_TOP+SIZE_GAP_SMALL<span class="number">-5</span>;</div><div class="line">            </div><div class="line">            <span class="comment">//绘制名字</span></div><div class="line">            [_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</div><div class="line">                             andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                                andHeight:rect.size.height];</div><div class="line">            </div><div class="line">            <span class="comment">//绘制名字下面的info</span></div><div class="line">            y += SIZE_FONT_NAME+<span class="number">5</span>;</div><div class="line">            <span class="keyword">float</span> fromX = leftX;</div><div class="line">            <span class="keyword">float</span> size = [<span class="built_in">UIScreen</span> screenWidth]-leftX;</div><div class="line">            <span class="built_in">NSString</span> *from = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@  %@"</span>, _data[<span class="string">@"time"</span>], _data[<span class="string">@"from"</span>]];</div><div class="line">            </div><div class="line">            [from drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(fromX, y) andFont:FontWithSize(SIZE_FONT_SUBTITLE)</div><div class="line">                   andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                      andHeight:rect.size.height andWidth:size];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//评论角</span></div><div class="line">            <span class="built_in">CGRect</span> countRect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30</span>, [<span class="built_in">UIScreen</span> screenWidth], <span class="number">30</span>);</div><div class="line">            [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, countRect);</div><div class="line">            <span class="keyword">float</span> alpha = <span class="number">1</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">float</span> x = [<span class="built_in">UIScreen</span> screenWidth]-SIZE_GAP_LEFT<span class="number">-10</span>;</div><div class="line">            <span class="built_in">NSString</span> *comments = _data[<span class="string">@"comments"</span>];</div><div class="line">            <span class="keyword">if</span> (comments) &#123;</div><div class="line">                <span class="built_in">CGSize</span> size = [comments sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</div><div class="line">                </div><div class="line">                x -= size.width;</div><div class="line">                </div><div class="line">                <span class="comment">//图片文字</span></div><div class="line">                [comments drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                                andFont:FontWithSize(<span class="number">12</span>)</div><div class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                              andHeight:rect.size.height];</div><div class="line">                </div><div class="line">                <span class="comment">//评论图片（bundle里的图片）</span></div><div class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div><div class="line">                </div><div class="line">                commentsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, [<span class="built_in">UIScreen</span> screenWidth]-x+<span class="number">5</span>, <span class="number">50</span>);</div><div class="line">                x -= <span class="number">20</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//转发角</span></div><div class="line">            <span class="built_in">NSString</span> *reposts = _data[<span class="string">@"reposts"</span>];</div><div class="line">            <span class="keyword">if</span> (reposts) &#123;</div><div class="line">                <span class="built_in">CGSize</span> size = [reposts sizeWithConstrainedToSize:<span class="built_in">CGSizeMake</span>(<span class="built_in">CGFLOAT_MAX</span>, <span class="built_in">CGFLOAT_MAX</span>) fromFont:FontWithSize(SIZE_FONT_SUBTITLE) lineSpace:<span class="number">5</span>];</div><div class="line">                </div><div class="line">                x -= MAX(size.width, <span class="number">5</span>)+SIZE_GAP_BIG;</div><div class="line">                </div><div class="line">                <span class="comment">//转发文字</span></div><div class="line">                [reposts drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                                andFont:FontWithSize(<span class="number">12</span>)</div><div class="line">                           andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">                 </div><div class="line">                             andHeight:rect.size.height];</div><div class="line">               </div><div class="line">                <span class="comment">//转发图片（bundle里的图片）</span></div><div class="line">                [[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_repost.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">11</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div><div class="line">                repostsRect = <span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="keyword">self</span>.height<span class="number">-50</span>, commentsRect.origin.x-x, <span class="number">50</span>);</div><div class="line">                x -= <span class="number">20</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">//更多角</span></div><div class="line">            [<span class="string">@"•••"</span> drawInContext:context</div><div class="line">                     withPosition:<span class="built_in">CGPointMake</span>(SIZE_GAP_LEFT, <span class="number">8</span>+countRect.origin.y)</div><div class="line">                          andFont:FontWithSize(<span class="number">11</span>)</div><div class="line">                     andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">178</span>/<span class="number">255.0</span> green:<span class="number">178</span>/<span class="number">255.0</span> blue:<span class="number">178</span>/<span class="number">255.0</span> alpha:<span class="number">.5</span>]</div><div class="line">                        andHeight:rect.size.height];</div><div class="line">            </div><div class="line">            <span class="comment">//绘制原帖底部的分割线</span></div><div class="line">            <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">                [[<span class="built_in">UIColor</span> colorWithRed:<span class="number">200</span>/<span class="number">255.0</span> green:<span class="number">200</span>/<span class="number">255.0</span> blue:<span class="number">200</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">                <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, rect.size.height<span class="number">-30.5</span>, rect.size.width, <span class="number">.5</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//将整个contex转化为图片，赋给背景imageview</span></div><div class="line">        <span class="built_in">UIImage</span> *temp = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            <span class="keyword">if</span> (flag==drawColorFlag) &#123;</div><div class="line">                postBGView.frame = rect;</div><div class="line">                postBGView.image = <span class="literal">nil</span>;</div><div class="line">                postBGView.image = temp;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="comment">//绘制两个label的text</span></div><div class="line">    [<span class="keyword">self</span> drawText];</div><div class="line">    </div><div class="line">    <span class="comment">//加载帖子里的网路图片，使用SDWebImage</span></div><div class="line">    [<span class="keyword">self</span> loadThumb];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面抽出每一种绘制内容的代码，分别讲解：</p>
<h3 id="3-1-异步加载网络图片"><a href="#3-1-异步加载网络图片" class="headerlink" title="3.1 异步加载网络图片"></a>3.1 异步加载网络图片</h3><p>关于网络图片的异步加载和缓存，作者使用了第三方框架：<code>SDWebImage</code>。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setData:(<span class="built_in">NSDictionary</span> *)data&#123;</div><div class="line">    _data = data;</div><div class="line">    [avatarView setBackgroundImage:<span class="literal">nil</span> forState:<span class="built_in">UIControlStateNormal</span>];</div><div class="line">    <span class="keyword">if</span> ([data valueForKey:<span class="string">@"avatarUrl"</span>]) &#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:[data valueForKey:<span class="string">@"avatarUrl"</span>]];</div><div class="line">        [avatarView sd_setBackgroundImageWithURL:url forState:<span class="built_in">UIControlStateNormal</span> placeholderImage:<span class="literal">nil</span> options:SDWebImageLowPriority];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于<code>SDWebImage</code>，我相信大家都不会陌生，我前一阵写了一篇源码解析，有兴趣的话可以看一下：<a href="http://www.jianshu.com/p/93696717b4a3" target="_blank" rel="external">SDWebImage源码解析</a>。</p>
<h3 id="3-2-异步绘制本地图片"><a href="#3-2-异步绘制本地图片" class="headerlink" title="3.2 异步绘制本地图片"></a>3.2 异步绘制本地图片</h3><p>本地图片的绘制，只需要提供图片在bundle内部的名字和frame就可以绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"t_comments.png"</span>] drawInRect:<span class="built_in">CGRectMake</span>(x<span class="number">-5</span>, <span class="number">10.5</span>+countRect.origin.y, <span class="number">10</span>, <span class="number">9</span>) blendMode:kCGBlendModeNormal alpha:alpha];</div></pre></td></tr></table></figure>
<p>###3.3  异步绘制UIView</p>
<p>对于<code>UIView</code>的绘制，我们只需要知道要绘制的<code>UIView</code>的frame和颜色即可：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//背景颜色</span></div><div class="line">[[<span class="built_in">UIColor</span> colorWithRed:<span class="number">250</span>/<span class="number">255.0</span> green:<span class="number">250</span>/<span class="number">255.0</span> blue:<span class="number">250</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>] set];</div><div class="line">        </div><div class="line"><span class="comment">//通过rect填充背景颜色</span></div><div class="line"><span class="built_in">CGContextFillRect</span>(context, rect);</div></pre></td></tr></table></figure>
<p>讲到现在，就剩下了关于文字的绘制，包括脱离了UILabel的纯文本的绘制和UILabel里文本的绘制，我们先说一下关于简单的纯NSString的绘制：</p>
<h3 id="3-4-异步绘制NSString"><a href="#3-4-异步绘制NSString" class="headerlink" title="3.4  异步绘制NSString"></a>3.4  异步绘制NSString</h3><p>作者通过传入字符串的字体，颜色和行高，以及位置就实现了纯文本的绘制：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//绘制名字</span></div><div class="line">[_data[<span class="string">@"name"</span>] drawInContext:context withPosition:<span class="built_in">CGPointMake</span>(x, y) andFont:FontWithSize(SIZE_FONT_NAME)</div><div class="line">                 andTextColor:[<span class="built_in">UIColor</span> colorWithRed:<span class="number">106</span>/<span class="number">255.0</span> green:<span class="number">140</span>/<span class="number">255.0</span> blue:<span class="number">181</span>/<span class="number">255.0</span> alpha:<span class="number">1</span>]</div><div class="line">             andHeight:rect.size.height];</div></pre></td></tr></table></figure>
<p>这个方法是作者在<code>NSString</code>的一个分类里自定义的，我们看一下它的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)context withPosition:(<span class="built_in">CGPoint</span>)p andFont:(<span class="built_in">UIFont</span> *)font andTextColor:(<span class="built_in">UIColor</span> *)color andHeight:(<span class="keyword">float</span>)height andWidth:(<span class="keyword">float</span>)width&#123;    </div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(width, font.pointSize+<span class="number">10</span>);    </div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);    </div><div class="line">    <span class="comment">//移动坐标系统，所有点的y增加了height</span></div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,height);</div><div class="line">    </div><div class="line">    <span class="comment">//缩放坐标系统，所有点的x乘以1.0，所有的点的y乘以-1.0</span></div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//文字颜色</span></div><div class="line">    <span class="built_in">UIColor</span>* textColor = color;</div><div class="line">    </div><div class="line">    <span class="comment">//生成CTFont</span></div><div class="line">    <span class="built_in">CTFontRef</span> font1 = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)font.fontName, font.pointSize,<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//用于创建CTParagraphStyleRef的一些基本数据</span></div><div class="line">    <span class="built_in">CGFloat</span> minimumLineHeight = font.pointSize,maximumLineHeight = minimumLineHeight+<span class="number">10</span>, linespace = <span class="number">5</span>;</div><div class="line">    <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByTruncatingTail;</div><div class="line">    </div><div class="line">    <span class="comment">//左对齐</span></div><div class="line">    <span class="built_in">CTTextAlignment</span> alignment = kCTLeftTextAlignment;</div><div class="line">    </div><div class="line">    <span class="comment">//创建CTParagraphStyleRef</span></div><div class="line">    <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</div><div class="line">        &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">        &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</div><div class="line">    &#125;,<span class="number">6</span>);</div><div class="line">    <span class="comment">//设置属性字典；对象，key</span></div><div class="line">    <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:</div><div class="line">                                (__bridge <span class="keyword">id</span>)font1,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</div><div class="line">                                textColor.CGColor,kCTForegroundColorAttributeName,</div><div class="line">                                style,kCTParagraphStyleAttributeName,</div><div class="line">                                <span class="literal">nil</span>];</div><div class="line"></div><div class="line">    <span class="comment">//生成path，添加到cgcontex上</span></div><div class="line">    <span class="built_in">CGMutablePathRef</span> path = <span class="built_in">CGPathCreateMutable</span>();</div><div class="line">    <span class="built_in">CGPathAddRect</span>(path,<span class="literal">NULL</span>,<span class="built_in">CGRectMake</span>(p.x, height-p.y-size.height,(size.width),(size.height)));</div><div class="line">    </div><div class="line">    <span class="comment">//生成CF属性字符串</span></div><div class="line">    <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:<span class="keyword">self</span> attributes:attributes];</div><div class="line">    <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)attributedStr;</div><div class="line">    </div><div class="line">    <span class="comment">//从attributedString拿到ctframesetter</span></div><div class="line">    <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</div><div class="line">    </div><div class="line">    <span class="comment">//从framesetter拿到 core text 的 ctframe</span></div><div class="line">    <span class="built_in">CTFrameRef</span> ctframe = <span class="built_in">CTFramesetterCreateFrame</span>(framesetter, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>,<span class="built_in">CFAttributedStringGetLength</span>(attributedString)),path,<span class="literal">NULL</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//将ctframe绘制到context里面</span></div><div class="line">    <span class="built_in">CTFrameDraw</span>(ctframe,context);</div><div class="line">    </div><div class="line">    <span class="comment">//因为不是对象类型，需要释放</span></div><div class="line">    <span class="built_in">CGPathRelease</span>(path);</div><div class="line">    <span class="built_in">CFRelease</span>(font1);</div><div class="line">    <span class="built_in">CFRelease</span>(framesetter);</div><div class="line">    <span class="built_in">CFRelease</span>(ctframe);</div><div class="line">    [[attributedStr mutableString] setString:<span class="string">@""</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//恢复context坐标系统</span></div><div class="line">    <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">    <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>, height);</div><div class="line">    <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，作者根据文字的起点，颜色，字体大小和行高，使用Core Text，将文字绘制在了传入的context上面。</p>
<h3 id="3-5-异步绘制UILabel"><a href="#3-5-异步绘制UILabel" class="headerlink" title="3.5 异步绘制UILabel"></a>3.5 异步绘制UILabel</h3><p>而对于<code>UILabel</code>里面的绘制，作者也采取了类似的方法：</p>
<p>首先看一下在cell实现文件里，关于绘制label文字方法的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//将文本内容绘制到图片上，也是异步绘制</span></div><div class="line">- (<span class="keyword">void</span>)drawText&#123;</div><div class="line">    </div><div class="line">    <span class="comment">//如果发现label或detailLabel不存在，则重新add一次</span></div><div class="line">    <span class="keyword">if</span> (label==<span class="literal">nil</span>||detailLabel==<span class="literal">nil</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> addLabel];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//传入frame</span></div><div class="line">    label.frame = [_data[<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">    <span class="comment">//异步绘制text</span></div><div class="line">    [label setText:_data[<span class="string">@"text"</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">//如果存在原帖</span></div><div class="line">    <span class="keyword">if</span> ([_data valueForKey:<span class="string">@"subData"</span>]) &#123;</div><div class="line">        </div><div class="line">        detailLabel.frame = [[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"textRect"</span>] <span class="built_in">CGRectValue</span>];</div><div class="line">        <span class="comment">//异步绘制text</span></div><div class="line">        [detailLabel setText:[_data valueForKey:<span class="string">@"subData"</span>][<span class="string">@"text"</span>]];</div><div class="line">        detailLabel.hidden = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，对于帖子而言，是否存在原贴（当前贴是否是转发贴）是不固定的，所以需要在判断之后，用<code>hidden</code>属性来控制相应控件的隐藏和显示，而不是用<code>addSubView</code>的方法。</p>
<p>这里的label是作者自己封装的<code>VVeboLabel</code>。它具有高亮显示点击，利用正则表达式区分不同类型的特殊文字（话题名，用户名，网址，emoji）的功能。</p>
<p>简单介绍一下这个封装好的label：</p>
<ul>
<li>继承于<code>UIView</code>,可以响应用户点击，在初始化之后，<code>_textAlignment</code>,<code>_textColor</code>,<code>_font</code>,<code>_lienSpace</code>属性都会被初始化。</li>
<li>使用Core Text绘制文字。</li>
<li>持有两种UIImageView，用来显示默认状态和高亮状态的图片（将字符串绘制成图片）。</li>
<li>保存了四种特殊文字的颜色，用正则表达式识别以后，给其着色。</li>
</ul>
<p>这里讲一下这个label的<code>setText:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用coretext将文本绘制到图片。</span></div><div class="line">- (<span class="keyword">void</span>)setText:(<span class="built_in">NSString</span> *)text&#123;</div><div class="line">   </div><div class="line">    <span class="comment">//labelImageView 普通状态时的imageview</span></div><div class="line">    <span class="comment">//highlightImageView 高亮状态时的iamgeview</span></div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//绘制标记，初始化时赋一个随机值；clear之后更新一个随机值</span></div><div class="line">    <span class="built_in">NSInteger</span> flag = drawFlag;</div><div class="line">    </div><div class="line">    <span class="comment">//是否正在高亮（在点击label的时候设置为yes，松开的时候设置为NO）</span></div><div class="line">    <span class="built_in">BOOL</span> isHighlight = highlighting;</div><div class="line">    </div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSString</span> *temp = text;</div><div class="line">        _text = text;</div><div class="line">        <span class="built_in">CGSize</span> size = <span class="keyword">self</span>.frame.size;</div><div class="line">        size.height += <span class="number">10</span>;</div><div class="line">       </div><div class="line">        <span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, ![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]], <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="keyword">if</span> (context==<span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (![<span class="keyword">self</span>.backgroundColor isEqual:[<span class="built_in">UIColor</span> clearColor]]) &#123;</div><div class="line">            [<span class="keyword">self</span>.backgroundColor set];</div><div class="line">            <span class="built_in">CGContextFillRect</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, size.width, size.height));</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">        <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</div><div class="line">        <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">        </div><div class="line">        <span class="comment">//Determine default text color</span></div><div class="line">        <span class="built_in">UIColor</span>* textColor = <span class="keyword">self</span>.textColor;</div><div class="line">        </div><div class="line">        <span class="comment">//Set line height, font, color and break mode</span></div><div class="line">        <span class="built_in">CGFloat</span> minimumLineHeight = <span class="keyword">self</span>.font.pointSize,maximumLineHeight = minimumLineHeight, linespace = <span class="keyword">self</span>.lineSpace;</div><div class="line">        </div><div class="line">        <span class="built_in">CTFontRef</span> font = <span class="built_in">CTFontCreateWithName</span>((__bridge <span class="built_in">CFStringRef</span>)<span class="keyword">self</span>.font.fontName, <span class="keyword">self</span>.font.pointSize,<span class="literal">NULL</span>);</div><div class="line">        <span class="built_in">CTLineBreakMode</span> lineBreakMode = kCTLineBreakByWordWrapping;</div><div class="line">        <span class="built_in">CTTextAlignment</span> alignment = <span class="built_in">CTTextAlignmentFromUITextAlignment</span>(<span class="keyword">self</span>.textAlignment);</div><div class="line">        <span class="comment">//Apply paragraph settings</span></div><div class="line">        <span class="built_in">CTParagraphStyleRef</span> style = <span class="built_in">CTParagraphStyleCreate</span>((<span class="built_in">CTParagraphStyleSetting</span>[<span class="number">6</span>])&#123;</div><div class="line">            &#123;kCTParagraphStyleSpecifierAlignment, <span class="keyword">sizeof</span>(alignment), &amp;alignment&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineHeight,<span class="keyword">sizeof</span>(minimumLineHeight),&amp;minimumLineHeight&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineHeight,<span class="keyword">sizeof</span>(maximumLineHeight),&amp;maximumLineHeight&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMaximumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierMinimumLineSpacing, <span class="keyword">sizeof</span>(linespace), &amp;linespace&#125;,</div><div class="line">            &#123;kCTParagraphStyleSpecifierLineBreakMode,<span class="keyword">sizeof</span>(<span class="built_in">CTLineBreakMode</span>),&amp;lineBreakMode&#125;</div><div class="line">        &#125;,<span class="number">6</span>);</div><div class="line">    </div><div class="line">        <span class="comment">//属性字典</span></div><div class="line">        <span class="built_in">NSDictionary</span>* attributes = [<span class="built_in">NSDictionary</span> dictionaryWithObjectsAndKeys:(__bridge <span class="keyword">id</span>)font,(<span class="built_in">NSString</span>*)kCTFontAttributeName,</div><div class="line">                                    textColor.CGColor,kCTForegroundColorAttributeName,</div><div class="line">                                    style,kCTParagraphStyleAttributeName,</div><div class="line">                                    <span class="literal">nil</span>];</div><div class="line">        </div><div class="line">        <span class="comment">//拿到CFAttributedStringRef</span></div><div class="line">        <span class="built_in">NSMutableAttributedString</span> *attributedStr = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:text attributes:attributes];</div><div class="line">        <span class="built_in">CFAttributedStringRef</span> attributedString = (__bridge <span class="built_in">CFAttributedStringRef</span>)[<span class="keyword">self</span> highlightText:attributedStr];</div><div class="line">        </div><div class="line">        <span class="comment">//根据attributedStringRef 获取CTFramesetterRef</span></div><div class="line">        <span class="built_in">CTFramesetterRef</span> framesetter = <span class="built_in">CTFramesetterCreateWithAttributedString</span>((<span class="built_in">CFAttributedStringRef</span>)attributedString);</div><div class="line">        </div><div class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">5</span>,(size.width),(size.height<span class="number">-5</span>));</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//根据 framesetter 和 attributedString 绘制text</span></div><div class="line">            [<span class="keyword">self</span> drawFramesetter:framesetter attributedString:attributedStr textRange:<span class="built_in">CFRangeMake</span>(<span class="number">0</span>, text.length) inRect:rect context:context];</div><div class="line">            </div><div class="line">            <span class="comment">//恢复context</span></div><div class="line">            <span class="built_in">CGContextSetTextMatrix</span>(context,<span class="built_in">CGAffineTransformIdentity</span>);</div><div class="line">            <span class="built_in">CGContextTranslateCTM</span>(context,<span class="number">0</span>,size.height);</div><div class="line">            <span class="built_in">CGContextScaleCTM</span>(context,<span class="number">1.0</span>,<span class="number">-1.0</span>);</div><div class="line">            </div><div class="line">            <span class="comment">//截取当前图片</span></div><div class="line">            <span class="built_in">UIImage</span> *screenShotimage = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</div><div class="line">            <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">            </div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                </div><div class="line">                <span class="built_in">CFRelease</span>(font);</div><div class="line">                <span class="built_in">CFRelease</span>(framesetter);</div><div class="line">                [[attributedStr mutableString] setString:<span class="string">@""</span>];</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (drawFlag==flag) &#123;</div><div class="line">                    </div><div class="line">                    <span class="keyword">if</span> (isHighlight) &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//高亮状态：把图片付给highlightImageView</span></div><div class="line">                        <span class="keyword">if</span> (highlighting) &#123;</div><div class="line">                            highlightImageView.image = <span class="literal">nil</span>;</div><div class="line">                            <span class="keyword">if</span> (highlightImageView.width!=screenShotimage.size.width) &#123;</div><div class="line">                                highlightImageView.width = screenShotimage.size.width;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (highlightImageView.height!=screenShotimage.size.height) &#123;</div><div class="line">                                highlightImageView.height = screenShotimage.size.height;</div><div class="line">                            &#125;</div><div class="line">                            highlightImageView.image = screenShotimage;</div><div class="line">                        &#125;</div><div class="line">                    </div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//非高亮状态，把图片付给labelImageView</span></div><div class="line">                        <span class="keyword">if</span> ([temp isEqualToString:text]) &#123;</div><div class="line">                            <span class="keyword">if</span> (labelImageView.width!=screenShotimage.size.width) &#123;</div><div class="line">                                labelImageView.width = screenShotimage.size.width;</div><div class="line">                            &#125;</div><div class="line">                            <span class="keyword">if</span> (labelImageView.height!=screenShotimage.size.height) &#123;</div><div class="line">                                labelImageView.height = screenShotimage.size.height;</div><div class="line">                            &#125;</div><div class="line">                            highlightImageView.image = <span class="literal">nil</span>;</div><div class="line">                            labelImageView.image = <span class="literal">nil</span>;</div><div class="line">                            labelImageView.image = screenShotimage;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"><span class="comment">//                    [self debugDraw];//绘制可触摸区域</span></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个被作者封装好的Label里面还有很多其他的方法，比如用正则表达式高亮显示特殊字符串等等。</p>
<p>关于tableView的优化，作者做了很多处理，使得这种显示内容比较丰富的cell在4s真机上好不卡顿，非常值得学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这次分享一个关于性能优化的源码。&lt;/p&gt;
&lt;p&gt;我们知道&lt;code&gt;UITabelView&lt;/code&gt;在iOS开发中扮演者举足轻重的角色，因为它是iOS开发中使用频率非常高的控件之一：几乎每个app都离不开它，因此，&lt;code&gt;UITabelView&lt;/code&gt;的性能将直接影响这个app的性能。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;UITabelView&lt;/code&gt;里的cell设计的比较简单，那么即使不做相应的优化，对性能的影响也不会很大。&lt;/p&gt;
&lt;p&gt;但是，当cell里面涉及到图文混排，cell高度不都相等的设计时，如果不进行一些操作的话，会非常影响性能，甚至会出现卡顿，造成非常不好的用户体验。&lt;/p&gt;
&lt;p&gt;最近在看一些iOS性能优化的文章，我找到了&lt;a href=&quot;https://github.com/johnil/VVeboTableViewDemo&quot;&gt;VVeboTableView&lt;/a&gt;这个框架。严格来说这个不属于框架，而是作者用自己的方式优化&lt;code&gt;UITableView&lt;/code&gt;的一个实现。&lt;/p&gt;
&lt;p&gt;作者模仿了新浪微博的cell样式，在里面展示了各种微博的cell。虽然样式比较复杂，但是性能却很好：我在我的iphone 4s上进行了Core Animation测试，在滑动的时候帧率没有低于56，而且也没有觉得有半点卡顿，那么他是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;看了源码之后，我把作者的思路整理了出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/VVeboTableView_0.png&quot; alt=&quot;优化思路图&quot;&gt;&lt;/p&gt;
&lt;p&gt;下面我就从左到右，从上到下，结合代码来展示一下作者是如何实现每一点的。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>PNChart源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/09/PNChart%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/09/PNChart源码解析/</id>
    <published>2017-02-09T03:33:20.000Z</published>
    <updated>2017-03-20T07:56:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-框架介绍"><a href="#一-框架介绍" class="headerlink" title="一. 框架介绍"></a>一. 框架介绍</h2><p><a href="https://github.com/kevinzhow/PNChart">PNChart</a>是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。</p>
<p>该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类<code>PNGenericChart</code>,第二层就是所有类型的图表。提供一张图来直观感受一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png" alt="层级图"></p>
<blockquote>
<p>在这张图里，需要注意以下几点：</p>
<ol>
<li>带箭头的线和不带箭头的线的区别。</li>
<li><code>Data</code>类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有<code>Data</code>类，因为饼状图没有多组数据，而折线图<code>LineChart</code>是支持多组数据的，所以有<code>Data</code>类。</li>
<li><code>Item</code>类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。</li>
<li><code>BarChart</code>类里面的每一根柱子都是<code>PNBar</code>的实例（该类型的图表不在本篇讲解的范围之内）。</li>
</ol>
</blockquote>
<a id="more"></a>
<p>今天就来介绍一下该框架里的折线图的源码。上文提到过，该框架的折线图是支持多组数据的，也就是在同一张图表上显示多条折线。先带大家看一下效果图：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_2.png" alt="折线图"></p>
<p>折线图在效果上还是很简洁美观的，如果现在的你还不知道如何使用<code>CAShapeLayer</code>和<code>UIBezierPath</code>画图并附加动画效果，那么本篇源码解析非常适合你。</p>
<p>阅读本文之后，你可以掌握有关图形绘制的相关知识，也可以掌握自定义各种图形（<code>UIView</code>）的方法，而且你也应该有能力作出这样的图表，甚至更好！</p>
<p>在开始讲解之前，我先粗略介绍一下利用<code>CAShapeLayer</code>画图的过程。这个过程有三个大前提：</p>
<ul>
<li>因为<code>UIView</code>是对<code>CALayer</code>的封装，所以我们可以通过改变<code>UIView</code>所持有的<code>layer</code>属性来直接改变<code>UIView</code>的显示效果。</li>
<li><code>CAShapeLayer</code>是<code>CALayer</code>的子类。</li>
<li><code>CAShapeLayer</code>的使用是依赖于<code>UIBezierPath</code>的。<code>UIBezierPath</code>就是“路径”，可以理解为形状。不难理解，想象一下，如果我们想画一个图形，那么这个图形的形状（包括颜色）是必不可少的，而这个角色，就需要<code>UIBezierPath</code>来充当。</li>
</ul>
<p>那么了这三个大前提，我们就可以知道如何画图了：</p>
<ol>
<li>实例化一个<code>UIBezierPath</code>，并赋给<code>CAShapeLayer</code>实例的<code>path</code>属性。</li>
<li>将这个<code>CAShapeLayer</code>的实例添加到<code>UIView</code>的<code>layer</code>上。</li>
</ol>
<p>简单的代码演示上述过程：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIBezierPath</span> *path = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">...自定义path...</div><div class="line"><span class="built_in">CAShapeLayer</span> *shapLayer = [<span class="built_in">CAShapeLayer</span> alloc] init];</div><div class="line">shapLayer.path = path;</div><div class="line">[<span class="keyword">self</span>.view.layer addSubLayer:shapeLayer];</div></pre></td></tr></table></figure></p>
<p>现在大致了解了画图的过程，我们来看一下该框架的作者是如何实现一个折线图的吧！</p>
<h2 id="二-源码解析"><a href="#二-源码解析" class="headerlink" title="二. 源码解析"></a>二. 源码解析</h2><p>首先看一下整个绘制折线图的步骤：</p>
<ol>
<li>图表的初始化。</li>
<li>获取横轴和纵轴的数据。</li>
<li>计算折线上所有拐点的x，y值。</li>
<li>计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）。</li>
<li>生成每个拐点上面的Label（可有可无）。</li>
<li>计算每条线段的贝塞尔曲线（UIBezierPath）。</li>
<li>将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</li>
<li>绘制所有折线（所有线段+所有圆圈）。</li>
<li>添加动画(可有可无)。</li>
<li>绘制x，y坐标轴。</li>
</ol>
<p>在集合代码具体讲解之前，我们要清楚三点（非常非常重要）：</p>
<ol>
<li>此折线图框架是可以设置拐点的样式的:可以设置为没有样式，也可以设置有样式：圆圈，方块，三角形。<ul>
<li>如果没有样式，则是简单的线段与线段的连接，在拐点处没有任何其他控件。</li>
<li>如果是有样式的，那么这条折线里的每条线段（在本篇文章里统一说成线段）之间是<strong>分离的</strong>，因为线段中间有一个拐点控件。本篇文章介绍的是圆圈样式（如上图所示，拐点控件是一个圆圈）。</li>
</ul>
</li>
<li>上文提到过，该折线图框架可以在一张图表里同时显示多条折线，也就是可以设置多组数据（一条折线对应一组数据）。因此，上面的3，4，5，6，7项都是用各自不同的一个数组保存的，数组里的每一个元素对应一条折线的数据。</li>
<li>既然同一个张图表可以显示多条折线：<ul>
<li>那么有些属性就是这些折线共有的，比如横坐标的value，这些属性保存在<code>PNLineChart</code>的实例里面。</li>
<li>有些属性是每条折线私有的，比如每条折线的颜色，纵坐标value等等，这些属性保存在<code>PNLineChartData</code>里面。每一条折线对应一个<code>PNLineChartData</code>实例。这些实例汇总到一个数组里面，这个数组由<code>PNLineChart</code>的实例管理。</li>
</ul>
</li>
</ol>
<p>在充分了解了这三点之后，我们结合一下代码来看一下具体的实现：</p>
<h3 id="1-图表的初始化"><a href="#1-图表的初始化" class="headerlink" title="1. 图表的初始化"></a>1. 图表的初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithFrame:(<span class="built_in">CGRect</span>)frame &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithFrame:frame];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> setupDefaultValues];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)setupDefaultValues &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> setupDefaultValues];</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//四个内边距</span></div><div class="line">    _chartMarginLeft = <span class="number">25.0</span>;</div><div class="line">    _chartMarginRight = <span class="number">25.0</span>;</div><div class="line">    _chartMarginTop = <span class="number">25.0</span>;</div><div class="line">    _chartMarginBottom = <span class="number">25.0</span>;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">//真正绘制图表的画布（CavanWidth）的宽高</span></div><div class="line">    _chartCavanWidth = <span class="keyword">self</span>.frame.size.width - _chartMarginLeft - _chartMarginRight;</div><div class="line">    _chartCavanHeight = <span class="keyword">self</span>.frame.size.height - _chartMarginBottom - _chartMarginTop;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>上面这段代码我刻意省去了其他一些基本的设置，突出了图表布局的设置。</p>
<p>布局的设置是图表绘制的前提，因为在最开始的时候，就应该计算出“画布”，也就是图表内容（不包括坐标轴和坐标label）的具体大小和位置（内边距以内的部分）。</p>
<p>在这里，我们需要获取真正绘制图表的画布的宽高(<code>_chartCavanWidth</code>和<code>_chartCavanHeight</code>)。而且，要留意的是<code>_chartMarginLeft</code>在将来是要用作y轴Label的宽度，而<code>_chartMarginBottom</code>在将来是要用作x轴Label的高度的。</p>
</blockquote>
<p>用一张图直观看一下：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/PNChart_4.png" alt="整个控件的大小和画布的大小"></p>
<h3 id="2-获取横轴和纵轴的数据"><a href="#2-获取横轴和纵轴的数据" class="headerlink" title="2. 获取横轴和纵轴的数据"></a>2. 获取横轴和纵轴的数据</h3><p>现在画布的位置和大小确定了，我们可以来看一下折线图是怎么画的了。<br>整个图表的绘制都基于三组数据（也可以是两组，为什么是两组，我稍后会给出解释），在讲解该框架是如何利用这些数据之前，我们来看一下这些数据是如何传进图表的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"><span class="comment">//设置x轴的数据</span></div><div class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</div><div class="line"><span class="comment">//设置y轴的数据</span></div><div class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</div><div class="line">                             <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</div><div class="line">                             ]</div><div class="line"> ];</div><div class="line"><span class="comment">// Line Chart</span></div><div class="line"><span class="comment">//设置每个点的y值</span></div><div class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</div><div class="line">PNLineChartData *data = [PNLineChartData new];</div><div class="line">data.pointLabelColor = [<span class="built_in">UIColor</span> blackColor];</div><div class="line">data.color = PNTwitterColor;</div><div class="line">data.alpha = <span class="number">0.5</span>f;</div><div class="line">data.itemCount = dataArray.count;</div><div class="line">data.inflexionPointStyle = PNLineChartPointStyleCircle;</div><div class="line"><span class="comment">//这个block的作用是将上面的dataArray里的每一个值传给line chart。</span></div><div class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</div><div class="line">    <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</div><div class="line">    <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</div><div class="line">&#125;;</div><div class="line"><span class="comment">//因为只有一条折线，所以只有一组数据</span></div><div class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</div><div class="line"><span class="comment">//绘制图表</span></div><div class="line">[<span class="keyword">self</span>.lineChart strokeChart];</div><div class="line"><span class="comment">//设置代理，响应点击</span></div><div class="line"><span class="keyword">self</span>.lineChart.delegate = <span class="keyword">self</span>;</div><div class="line">[<span class="keyword">self</span>.view addSubview:<span class="keyword">self</span>.lineChart];</div></pre></td></tr></table></figure>
<p>上面的代码我可以略去了很多多余的设置，目的是突出图表数据的设置。</p>
<p>不难看出，这里有三个数据传给了lineChart：</p>
<p>1.x轴的数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.lineChart setXLabels:@[<span class="string">@"SEP 1"</span>, <span class="string">@"SEP 2"</span>, <span class="string">@"SEP 3"</span>, <span class="string">@"SEP 4"</span>, <span class="string">@"SEP 5"</span>, <span class="string">@"SEP 6"</span>, <span class="string">@"SEP 7"</span>]];</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码调用之后，实现了：</p>
<ol>
<li>根据传入的xLabel数组里元素的数量，内容宽度(<code>_chartCavanWidth</code>)和下边距（<code>_chartMarginBottom</code>），计算每个xlabel的size。</li>
<li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的xLabel（包括内容，位置）并显示出来，最后保存在<code>_xChartLabels</code>里面。</li>
</ol>
</blockquote>
<p>2.y轴的数据：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[<span class="keyword">self</span>.lineChart setYLabels:@[</div><div class="line">                <span class="string">@"0"</span>,<span class="string">@"50"</span>,<span class="string">@"100"</span>,<span class="string">@"150"</span>,<span class="string">@"200"</span>,<span class="string">@"250"</span>,<span class="string">@"300"</span>,</div><div class="line">                ]</div><div class="line">    ];</div></pre></td></tr></table></figure>
<blockquote>
<p>这段代码调用之后，实现了：</p>
<ol>
<li>根据传入的yLabel数组里元素的数量，内容高度(<code>_chartCavanHeight</code>)和左边距(<code>_chartMarginLeft</code>)，计算出每个ylabel的size。</li>
<li>根据xLabel所需要展示的内容(<code>NSString</code>)和宽度，实例化所有的yLabel（包括内容，位置）并显示出来，最后保存在<code>_yChartLabels</code>里面。</li>
</ol>
</blockquote>
<p>3.一条折线上每个点的实际值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *dataArray = @[@<span class="number">0.0</span>, @<span class="number">180.1</span>, @<span class="number">26.4</span>, @<span class="number">202.2</span>, @<span class="number">126.2</span>, @<span class="number">167.2</span>, @<span class="number">276.2</span>];</div><div class="line">data.getData = ^(<span class="built_in">NSUInteger</span> index) &#123;</div><div class="line">        <span class="built_in">CGFloat</span> yValue = [dataArray[index] floatValue];</div><div class="line">        <span class="keyword">return</span> [PNLineChartDataItem dataItemWithY:yValue];</div><div class="line">    &#125;;</div><div class="line"><span class="keyword">self</span>.lineChart.chartData = @[data];</div></pre></td></tr></table></figure>
<blockquote>
<p>着重讲一下block：为什么不直接把这个数组(<code>dataArray</code>)作为line chart的属性传进去呢？我认为作者是想提供一个接口给用户一个自己转化y值的机会。</p>
<p>像上文所说的，这里1，2是属于<code>lineChart</code>的数据，它适用于这张图表上所有的折线的。而3是属于某一条折线的。</p>
<p>现在回答一下为什么可以只传入两组数据：因为y轴数据可以由每个点的实际值数组得出。可以简单想一下，我们可以获取这些真实值里面的最大值，然后将它n等分，就自然得到了y轴数据了。</p>
</blockquote>
<p>我们已经布局了x轴和y轴的所有label，现在开始真正计算图表的数据了。</p>
<blockquote>
<p>注意：下面要介绍的3，4，5，6项都是在同一方法中计算出来，为了避免代码过长，我将每个部分分解开来做出解释。因为在同一方法里，所以这些涉及到for循环的语句是一致的。</p>
<p>整个图表的绘制都是依赖于数据的处理，所以3，4，5，6项也是理解该框架的一个关键！</p>
</blockquote>
<p>首先，我们需要计算每个数据点（拐点）的准确位置：</p>
<h3 id="3-计算折线上所有拐点的x，y值。"><a href="#3-计算折线上所有拐点的x，y值。" class="headerlink" title="3. 计算折线上所有拐点的x，y值。"></a>3. 计算折线上所有拐点的x，y值。</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="comment">//还记得chartData属性么？它是用来保存多组折线的数据的，在这里只有一个折线，所以这个循环只循环一次）</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">   <span class="comment">//保存每条折线上的所有点的CGPoint  </span></div><div class="line">   <span class="built_in">NSMutableArray</span> *linePointsArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">    <span class="comment">//遍历每条折线里的每个点    </span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//传入index，获取y值(调用的是上文提到的block)</span></div><div class="line">        yValue = chartData.getData(i).y;</div><div class="line">        <span class="comment">//当前点的x： _chartMarginLeft + _xLabelWidth / 2.0为0坐标，每多一个点就多一个_xLabelWidth</span></div><div class="line">        <span class="keyword">int</span> x = (<span class="keyword">int</span>) (i * _xLabelWidth + _chartMarginLeft + _xLabelWidth / <span class="number">2.0</span>);</div><div class="line">            </div><div class="line">        <span class="comment">//当前点的y：根据当前点的值和当前点所在的数组里的最大值的比例 以及 图表的总高度，算出当前点在图表里的y坐标</span></div><div class="line">        <span class="keyword">int</span> y = (<span class="keyword">int</span>)[<span class="keyword">self</span> yValuePositionInLineChart:yValue];</div><div class="line">        <span class="comment">//保存所有拐点的坐标</span></div><div class="line">        [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</div><div class="line">    &#125;</div><div class="line">  <span class="comment">//保存多条折线的CGPoint（这里只有一条折线，所以该数组只有一个元素）</span></div><div class="line">  [pathPoints addObject:[linePointsArray <span class="keyword">copy</span>]];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里需要注意两点：</p>
<ol>
<li>这里的<code>pathPoints</code>对应的是<code>lineChart</code>的<code>_pathPoints</code>属性。它是一个二维数组，保存每条折线上所有点的<code>CGPoint</code>。</li>
<li>y值的计算：是需要从y的真实值转化为这个拐点在图表里的y坐标，转化方法的实现(仔细看几遍就懂了)：</li>
</ol>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)yValuePositionInLineChart:(<span class="built_in">CGFloat</span>)y &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> innerGrade;<span class="comment">//真实的最大值与最小值的差 与 当前点与最小值的差 的比值</span></div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!(_yValueMax - _yValueMin)) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//特殊情况：当_yValueMax和_yValueMin相等的时候</span></div><div class="line">        innerGrade = <span class="number">0.5</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        innerGrade = ((<span class="built_in">CGFloat</span>) y - _yValueMin) / (_yValueMax - _yValueMin);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//innerGrade 与画布的高度（_chartCavanHeight）相乘，就能得出在画布中的高度</span></div><div class="line">    <span class="keyword">return</span> _chartCavanHeight - (innerGrade * _chartCavanHeight) - (_yLabelHeight / <span class="number">2</span>) + _chartMarginTop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"><a href="#4-计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）" class="headerlink" title="4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）"></a>4. 计算每个拐点中间的圆圈的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    <span class="comment">//每条折线所有圆圈的贝塞尔曲线</span></div><div class="line">    <span class="built_in">UIBezierPath</span> *pointPath = [<span class="built_in">UIBezierPath</span> bezierPath];    </div><div class="line">    <span class="comment">//inflexionWidth默认是6,是两个线段中间的距离（因为中间有一个圈圈，所以需要定一个距离）</span></div><div class="line">    <span class="built_in">CGFloat</span> inflexionWidth = chartData.inflexionPointWidth;</div><div class="line">    <span class="comment">//遍历每条折线里的每个点</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;  </div><div class="line">        <span class="comment">//1. 计算圆圈的rect：已当前点为中心，以inflexionWidth为半径</span></div><div class="line">        <span class="built_in">CGRect</span> circleRect = <span class="built_in">CGRectMake</span>(x - inflexionWidth / <span class="number">2</span>, y - inflexionWidth / <span class="number">2</span>, inflexionWidth, inflexionWidth);    </div><div class="line">        <span class="comment">//2. 计算圆圈的中心：由圆圈的x，y和inflexionWidth算出</span></div><div class="line">        <span class="built_in">CGPoint</span> circleCenter = <span class="built_in">CGPointMake</span>(circleRect.origin.x + (circleRect.size.width / <span class="number">2</span>), circleRect.origin.y + (circleRect.size.height / <span class="number">2</span>));</div><div class="line">        <span class="comment">//3.1 移动到圆圈的右中部</span></div><div class="line">        [pointPath moveToPoint:<span class="built_in">CGPointMake</span>(circleCenter.x + (inflexionWidth / <span class="number">2</span>), circleCenter.y)];        </div><div class="line">        <span class="comment">//3.2 画线（圆形）</span></div><div class="line">        [pointPath addArcWithCenter:circleCenter radius:inflexionWidth / <span class="number">2</span> startAngle:<span class="number">0</span> endAngle:(<span class="built_in">CGFloat</span>) (<span class="number">2</span> * M_PI) clockwise:<span class="literal">YES</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//保存到pointsPath数组里</span></div><div class="line">    [pointsPath insertObject:pointPath atIndex:lineIndex];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，<code>pointsPath</code>对应的是<code>lineChart</code>的<code>_pointsPath</code>属性。它是一个一维数组，保存每条折线上的圆圈贝塞尔曲线（UIBezierPath）。</p>
</blockquote>
<h3 id="5-生成每个拐点上面的Label（可有可无）"><a href="#5-生成每个拐点上面的Label（可有可无）" class="headerlink" title="5. 生成每个拐点上面的Label（可有可无）"></a>5. 生成每个拐点上面的Label（可有可无）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    <span class="comment">//遍历每条折线里的每一段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">    </div><div class="line">        <span class="keyword">if</span> (chartData.showPointLabel) &#123;</div><div class="line">            [gradePathArray addObject:[<span class="keyword">self</span> createPointLabelFor:chartData.getData(i).rawY pointCenter:circleCenter width:inflexionWidth withChartData:chartData]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，在这里，这些label的实现是通过一个<code>CATextLayer</code>实现的，并不是生成一个个<code>Label</code>放在数组里保存，具体实现方法如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CATextLayer</span> *)createPointLabelFor:(<span class="built_in">CGFloat</span>)grade pointCenter:(<span class="built_in">CGPoint</span>)pointCenter width:(<span class="built_in">CGFloat</span>)width withChartData:(PNLineChartData *)chartData &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//grade：提供textLayer显示的数值</span></div><div class="line">    <span class="comment">//pointCenter：根据pointCenter算出textLayer的x，y</span></div><div class="line">    <span class="comment">//width：根据width得到textLayer的总宽度</span></div><div class="line">    <span class="comment">//chartData：获取chartData里保存的textLayer上应该保存的字体大小和颜色</span></div><div class="line">    </div><div class="line">    <span class="built_in">CATextLayer</span> *textLayer = [[<span class="built_in">CATextLayer</span> alloc] init];</div><div class="line">    [textLayer setAlignmentMode:kCAAlignmentCenter];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的背景色</span></div><div class="line">    [textLayer setForegroundColor:[chartData.pointLabelColor <span class="built_in">CGColor</span>]];</div><div class="line">    [textLayer setBackgroundColor:<span class="keyword">self</span>.backgroundColor.CGColor];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的字体大小和颜色</span></div><div class="line">    <span class="keyword">if</span> (chartData.pointLabelFont != <span class="literal">nil</span>) &#123;</div><div class="line">        [textLayer setFont:(__bridge <span class="built_in">CFTypeRef</span>) (chartData.pointLabelFont)];</div><div class="line">        textLayer.fontSize = [chartData.pointLabelFont pointSize];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的高度</span></div><div class="line">    <span class="built_in">CGFloat</span> textHeight = (<span class="built_in">CGFloat</span>) (textLayer.fontSize * <span class="number">1.1</span>);</div><div class="line">    </div><div class="line">    <span class="built_in">CGFloat</span> textWidth = width * <span class="number">8</span>;</div><div class="line">    <span class="built_in">CGFloat</span> textStartPosY;</div><div class="line">    </div><div class="line">    textStartPosY = pointCenter.y - textLayer.fontSize;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span>.layer addSublayer:textLayer];</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的文字显示格式</span></div><div class="line">    <span class="keyword">if</span> (chartData.pointLabelFormat != <span class="literal">nil</span>) &#123;</div><div class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:chartData.pointLabelFormat, grade]];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [textLayer setString:[[<span class="built_in">NSString</span> alloc] initWithFormat:_yLabelFormat, grade]];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//设置textLayer的位置和scale（1x，2x，3x）</span></div><div class="line">    [textLayer setFrame:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, textWidth, textHeight)];</div><div class="line">    [textLayer setPosition:<span class="built_in">CGPointMake</span>(pointCenter.x, textStartPosY)];</div><div class="line">    textLayer.contentsScale = [<span class="built_in">UIScreen</span> mainScreen].scale;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> textLayer;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="6-计算每条线段的贝塞尔曲线（UIBezierPath）"><a href="#6-计算每条线段的贝塞尔曲线（UIBezierPath）" class="headerlink" title="6. 计算每条线段的贝塞尔曲线（UIBezierPath）"></a>6. 计算每条线段的贝塞尔曲线（UIBezierPath）</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//遍历图表里每条折线</span></div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//每一条线段的贝塞尔曲线（UIBezierPath），用数组装起来</span></div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    </div><div class="line">    <span class="comment">//chartPath（二维数组）：保存所有折线上所有线段的贝塞尔曲线。现在只有一条折线，所以只有一个元素</span></div><div class="line">    [chartPath insertObject:progressLines atIndex:lineIndex];</div><div class="line">    </div><div class="line">    <span class="comment">//progressLinePaths的每个元素是一个字典，字典里存放每一条线段的端点（from，to）</span></div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *&gt; *progressLinePaths = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> last_x = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last_y = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//遍历每条折线里的每一段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; chartData.itemCount; i++) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">//x，y的算法参考上文第三项</span></div><div class="line">            <span class="comment">// 计算index为0以后的点的位置</span></div><div class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) sqrt(pow(x - last_x, <span class="number">2</span>) + pow(y - last_y, <span class="number">2</span>));</div><div class="line">            <span class="keyword">float</span> last_x1 = last_x + (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</div><div class="line">            <span class="keyword">float</span> last_y1 = last_y + (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</div><div class="line">            <span class="keyword">float</span> x1 = x - (inflexionWidth / <span class="number">2</span>) / distance * (x - last_x);</div><div class="line">            <span class="keyword">float</span> y1 = y - (inflexionWidth / <span class="number">2</span>) / distance * (y - last_y);</div><div class="line">            </div><div class="line">            <span class="comment">//当前线段的端点</span></div><div class="line">            from = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(last_x1, last_y1)];</div><div class="line">            to = [<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x1, y1)];</div><div class="line">            </div><div class="line">            </div><div class="line">            <span class="keyword">if</span>(from != <span class="literal">nil</span> &amp;&amp; to != <span class="literal">nil</span>) &#123;</div><div class="line">                <span class="comment">//保存每一段的端点</span></div><div class="line">                [progressLinePaths addObject:@&#123;<span class="string">@"from"</span>: from,  <span class="string">@"to"</span>:to&#125;];</div><div class="line">                <span class="comment">//保存所有的端点</span></div><div class="line">                [lineStartEndPointsArray addObject:from];</div><div class="line">                [lineStartEndPointsArray addObject:to];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//保存所有折点的坐标</span></div><div class="line">            [linePointsArray addObject:[<span class="built_in">NSValue</span> valueWithCGPoint:<span class="built_in">CGPointMake</span>(x, y)]];</div><div class="line">            <span class="comment">//将当前的x转化为下一个点的last_x（y也一样）</span></div><div class="line">            last_x = x;</div><div class="line">            last_y = y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//pointsOfPath：保存所有折线里的所有线段两端的端点</span></div><div class="line">    [pointsOfPath addObject:[lineStartEndPointsArray <span class="keyword">copy</span>]];</div><div class="line">    </div><div class="line">    <span class="comment">//根据每一条线段的两个端点，成生每条线段的贝塞尔曲线</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSDictionary</span> *&gt; *calculatedRanges =</div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">            [currentProgressLine moveToPoint:[range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>]];</div><div class="line">            [currentProgressLine addLineToPoint:[range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>]];</div><div class="line">            [progressLines addObject:currentProgressLine];</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        &#125;    </div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"><a href="#7-将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。" class="headerlink" title="7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。"></a>7. 将上面得到的贝塞尔曲线赋给每条线段和圆圈的layer（CAShapeLayer）。</h3><h4 id="7-1-所有线段的layer："><a href="#7-1-所有线段的layer：" class="headerlink" title="7.1 所有线段的layer："></a>7.1 所有线段的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)populateChartLines &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//遍历每条线段</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = <span class="keyword">self</span>.chartPath[lineIndex];</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">//_chartLineArray:二维数组，装载每个chartData对应的一个数组。这个数组的元素是这一条折线上所有线段对应的CAShapeLayer</span></div><div class="line">        [<span class="keyword">self</span>.chartLineArray[lineIndex] removeAllObjects];</div><div class="line">        </div><div class="line">        <span class="built_in">NSUInteger</span> progressLineIndex = <span class="number">0</span>;;</div><div class="line">        </div><div class="line">        <span class="comment">//遍历含有UIBezierPath对象元素的数组。在每个循环里新建一个CAShapeLayer对象，将UIBezierPath赋给它。</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *progressLinePath <span class="keyword">in</span> progressLines) &#123;</div><div class="line">            </div><div class="line">            PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</div><div class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">            </div><div class="line">            ...</div><div class="line">            </div><div class="line">            <span class="comment">//将当前线段的UIBezierPath赋给当前线段的CAShapeLayer</span></div><div class="line">            chartLine.path = progressLinePath.CGPath;</div><div class="line">            </div><div class="line">            <span class="comment">//添加layer</span></div><div class="line">            [<span class="keyword">self</span>.layer addSublayer:chartLine];</div><div class="line">            </div><div class="line">            <span class="comment">//保存当前线段的layer</span></div><div class="line">            [<span class="keyword">self</span>.chartLineArray[lineIndex] addObject:chartLine];</div><div class="line">            progressLineIndex++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="7-2-所有圆圈的layer："><a href="#7-2-所有圆圈的layer：" class="headerlink" title="7.2 所有圆圈的layer："></a>7.2 所有圆圈的layer：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)recreatePointLayers &#123;</div><div class="line">- </div><div class="line">    <span class="keyword">for</span> (PNLineChartData *chartData <span class="keyword">in</span> _chartData) &#123;</div><div class="line">    </div><div class="line">        <span class="comment">// create as many chart line layers as there are data-lines</span></div><div class="line">        [<span class="keyword">self</span>.chartLineArray addObject:[<span class="built_in">NSMutableArray</span> new]];</div><div class="line"></div><div class="line">        <span class="comment">// create point</span></div><div class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = [<span class="built_in">CAShapeLayer</span> layer];</div><div class="line">        pointLayer.strokeColor = [[chartData.color colorWithAlphaComponent:chartData.alpha] <span class="built_in">CGColor</span>];</div><div class="line">        pointLayer.lineCap = kCALineCapRound;</div><div class="line">        pointLayer.lineJoin = kCALineJoinBevel;</div><div class="line">        pointLayer.fillColor = <span class="literal">nil</span>;</div><div class="line">        pointLayer.lineWidth = chartData.lineWidth;</div><div class="line">        [<span class="keyword">self</span>.layer addSublayer:pointLayer];</div><div class="line">        [<span class="keyword">self</span>.chartPointArray addObject:pointLayer];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意，这里并没有将所有圆圈的<code>UIBezierPath</code>赋给对应的<code>layer</code>，而是在下一步，绘图的时候做的。</p>
</blockquote>
<h3 id="8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画"><a href="#8-绘制所有折线（所有线段-所有圆圈）-amp-amp-9-添加动画" class="headerlink" title="8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画"></a>8.绘制所有折线（所有线段+所有圆圈）&amp;&amp; 9. 添加动画</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)strokeChart &#123;</div><div class="line">    </div><div class="line">    ...</div><div class="line">    </div><div class="line">    <span class="comment">// 绘制所有折线（所有线段+所有圆圈）</span></div><div class="line">    <span class="comment">// 遍历所有折线</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>; lineIndex &lt; <span class="keyword">self</span>.chartData.count; lineIndex++) &#123;</div><div class="line">       </div><div class="line">        PNLineChartData *chartData = <span class="keyword">self</span>.chartData[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有线段的CAShapeLayer</span></div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">CAShapeLayer</span> *&gt; *chartLines =<span class="keyword">self</span>.chartLineArray[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有圆圈的CAShapeLayer</span></div><div class="line">        <span class="built_in">CAShapeLayer</span> *pointLayer = (<span class="built_in">CAShapeLayer</span> *) <span class="keyword">self</span>.chartPointArray[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//开始绘制折线</span></div><div class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="keyword">self</span>.frame.size);</div><div class="line">        </div><div class="line">        ...</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有线段的UIBezierPath</span></div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *progressLines = _chartPath[lineIndex];</div><div class="line">        </div><div class="line">        <span class="comment">//当前折线的所有圆圈的UIBezierPath</span></div><div class="line">        <span class="built_in">UIBezierPath</span> *pointPath = _pointPath[lineIndex];</div><div class="line"></div><div class="line">        <span class="comment">//7.2将圆圈的UIBezierPath赋给了圆圈的CAShapeLayer</span></div><div class="line">        pointLayer.path = pointPath.CGPath;</div><div class="line"></div><div class="line">        <span class="comment">//添加动画</span></div><div class="line">        [<span class="built_in">CATransaction</span> begin];</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> index = <span class="number">0</span>; index &lt; progressLines.count; index++) &#123;</div><div class="line">            <span class="built_in">CAShapeLayer</span> *chartLine = chartLines[index];</div><div class="line">            <span class="comment">//chartLine strokeColor is already set. no need to override here</span></div><div class="line">            [chartLine addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</div><div class="line">            chartLine.strokeEnd = <span class="number">1.0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// if you want cancel the point animation, comment this code, the point will show immediately</span></div><div class="line">        <span class="keyword">if</span> (chartData.inflexionPointStyle != PNLineChartPointStyleNone) &#123;</div><div class="line">            [pointLayer addAnimation:<span class="keyword">self</span>.pathAnimation forKey:<span class="string">@"strokeEndAnimation"</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//提交动画</span></div><div class="line">        [<span class="built_in">CATransaction</span> commit];</div><div class="line"></div><div class="line">       ...</div><div class="line"></div><div class="line">        <span class="comment">//绘制完毕</span></div><div class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要注意两点：</p>
<blockquote>
<p>1.如果想给layer添加动画，只需要实例化一个animation（在这里是<code>CABasicAnimation</code>）并调用layer的<code>addAnimation:</code>方法即可。我们看一下关于<code>CABasicAnimation</code>的实例化代码：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CABasicAnimation</span> *)pathAnimation &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.displayAnimated &amp;&amp; !_pathAnimation) &#123;</div><div class="line">        _pathAnimation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"strokeEnd"</span>];</div><div class="line">        <span class="comment">//持续时间</span></div><div class="line">        _pathAnimation.duration = <span class="number">1.0</span>;</div><div class="line">         <span class="comment">//类型</span></div><div class="line">        _pathAnimation.timingFunction = [<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">        _pathAnimation.fromValue = @<span class="number">0.0</span>f;</div><div class="line">        _pathAnimation.toValue = @<span class="number">1.0</span>f;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!<span class="keyword">self</span>.displayAnimated) &#123;</div><div class="line">        _pathAnimation = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> _pathAnimation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>2.在这里调用了<code>setNeedsDisplay</code>方法之后，会调用<code>drawRect：</code>方法，在这个方法里，完成了x，y坐标轴的绘制：</p>
</blockquote>
<h3 id="10-绘制x，y坐标轴"><a href="#10-绘制x，y坐标轴" class="headerlink" title="10.绘制x，y坐标轴"></a>10.绘制x，y坐标轴</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制坐标轴和背景竖线</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isShowCoordinateAxis) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> yAxisOffset = <span class="number">10.</span>f;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsPopContext</span>();</div><div class="line">        <span class="built_in">UIGraphicsPushContext</span>(ctx);</div><div class="line">        <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="keyword">self</span>.axisWidth);</div><div class="line">        <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="keyword">self</span>.axisColor <span class="built_in">CGColor</span>]);</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> xAxisWidth = <span class="built_in">CGRectGetWidth</span>(rect) - (_chartMarginLeft + _chartMarginRight) / <span class="number">2</span>;</div><div class="line">        <span class="built_in">CGFloat</span> yAxisHeight = _chartMarginBottom + _chartCavanHeight;</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制xy轴</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制y轴的箭头</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, _chartMarginBottom + yAxisOffset - <span class="number">3</span>, <span class="number">6</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset, <span class="number">0</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, _chartMarginBottom + yAxisOffset + <span class="number">3</span>, <span class="number">6</span>);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制x轴的箭头</span></div><div class="line">        <span class="built_in">CGContextMoveToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight - <span class="number">3</span>);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth, yAxisHeight);</div><div class="line">        <span class="built_in">CGContextAddLineToPoint</span>(ctx, xAxisWidth - <span class="number">6</span>, yAxisHeight + <span class="number">3</span>);</div><div class="line">        <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        </div><div class="line">        <span class="comment">//绘制x轴和y轴的label</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.showLabel) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">// 绘制x轴的小分割线</span></div><div class="line">            <span class="built_in">CGPoint</span> point;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</div><div class="line">                point = <span class="built_in">CGPointMake</span>(<span class="number">2</span> * _chartMarginLeft + (i * _xLabelWidth), _chartMarginBottom + _chartCavanHeight);</div><div class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y - <span class="number">2</span>);</div><div class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x, point.y);</div><div class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 绘制y轴的小分割线</span></div><div class="line">            <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; [<span class="keyword">self</span>.xLabels count]; i++) &#123;</div><div class="line">                point = <span class="built_in">CGPointMake</span>(_chartMarginBottom + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</div><div class="line">                <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</div><div class="line">                <span class="built_in">CGContextAddLineToPoint</span>(ctx, point.x + <span class="number">2</span>, point.y);</div><div class="line">                <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">UIFont</span> *font = [<span class="built_in">UIFont</span> systemFontOfSize:<span class="number">11</span>];</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制y轴单位</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.yUnit length]) &#123;</div><div class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.yUnit withWidth:<span class="number">30.</span>f font:font].height;</div><div class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(_chartMarginLeft + <span class="number">10</span> + <span class="number">5</span>, <span class="number">0</span>, <span class="number">30.</span>f, height);</div><div class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.yUnit inRect:drawRect font:font color:<span class="keyword">self</span>.yLabelColor];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 绘制x轴的单位</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.xUnit length]) &#123;</div><div class="line">            <span class="built_in">CGFloat</span> height = [PNLineChart sizeOfString:<span class="keyword">self</span>.xUnit withWidth:<span class="number">30.</span>f font:font].height;</div><div class="line">            <span class="built_in">CGRect</span> drawRect = <span class="built_in">CGRectMake</span>(<span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, _chartMarginBottom + _chartCavanHeight - height / <span class="number">2</span>, <span class="number">25.</span>f, height);</div><div class="line">            [<span class="keyword">self</span> drawTextInContext:ctx text:<span class="keyword">self</span>.xUnit inRect:drawRect font:font color:<span class="keyword">self</span>.xLabelColor];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//绘制竖线</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.showYGridLines) &#123;</div><div class="line">        <span class="built_in">CGContextRef</span> ctx = <span class="built_in">UIGraphicsGetCurrentContext</span>();</div><div class="line">        <span class="built_in">CGFloat</span> yAxisOffset = _showLabel ? <span class="number">10.</span>f : <span class="number">0.0</span>f;</div><div class="line">        <span class="built_in">CGPoint</span> point;</div><div class="line">        </div><div class="line">        <span class="comment">//每一条竖线的跨度</span></div><div class="line">        <span class="built_in">CGFloat</span> yStepHeight = _chartCavanHeight / _yLabelNum;</div><div class="line">        </div><div class="line">        <span class="comment">//颜色</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.yGridLinesColor) &#123;</div><div class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, <span class="keyword">self</span>.yGridLinesColor.CGColor);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">CGContextSetStrokeColorWithColor</span>(ctx, [<span class="built_in">UIColor</span> lightGrayColor].CGColor);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//绘制每一条竖线</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; _yLabelNum; i++) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//拿到起点</span></div><div class="line">            point = <span class="built_in">CGPointMake</span>(_chartMarginLeft + yAxisOffset, (_chartCavanHeight - i * yStepHeight + _yLabelHeight / <span class="number">2</span>));</div><div class="line">            </div><div class="line">            <span class="comment">//将画笔移动到起点</span></div><div class="line">            <span class="built_in">CGContextMoveToPoint</span>(ctx, point.x, point.y);</div><div class="line">            </div><div class="line">            <span class="comment">//设置线的属性</span></div><div class="line">            <span class="built_in">CGFloat</span> dash[] = &#123;<span class="number">6</span>, <span class="number">5</span>&#125;;</div><div class="line">            <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">0.5</span>);</div><div class="line">            <span class="built_in">CGContextSetLineCap</span>(ctx, kCGLineCapRound);</div><div class="line">            <span class="built_in">CGContextSetLineDash</span>(ctx, <span class="number">0.0</span>, dash, <span class="number">2</span>);</div><div class="line">            </div><div class="line">            <span class="comment">//设置这条线的终点</span></div><div class="line">            <span class="built_in">CGContextAddLineToPoint</span>(ctx, <span class="built_in">CGRectGetWidth</span>(rect) - _chartMarginLeft + <span class="number">5</span>, point.y);</div><div class="line">            </div><div class="line">            <span class="comment">//画线</span></div><div class="line">            <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> drawRect:rect];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，一张完整的图表就可以画出来了。但是当前绘制的图表的折线都是直线，在上面还展示了一张曲线图。那么如果想绘制带有曲线的折线图应该怎么做呢？对，就是在贝塞尔曲线上下功夫。</p>
<p>当我们获取了所有线段的端点数组后，我们可以通过他们绘制弯曲的贝塞尔曲线（注意：该方法是对应上面对第6项的下半部分:生成每一个线段对贝塞尔曲线）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//_showSmoothLines是用来控制是否绘制曲线折线的开关属性</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.showSmoothLines &amp;&amp; chartData.itemCount &gt;= <span class="number">4</span>) &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSValue</span> *&gt; *item <span class="keyword">in</span> progressLinePaths) &#123;</div><div class="line">        </div><div class="line">        ...</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *range <span class="keyword">in</span> calculatedRanges) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">UIBezierPath</span> *currentProgressLine = [<span class="built_in">UIBezierPath</span> bezierPath];</div><div class="line">            <span class="built_in">CGPoint</span> segmentP1 = [range[<span class="string">@"from"</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> segmentP2 = [range[<span class="string">@"to"</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            [currentProgressLine moveToPoint:segmentP1];</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> midPoint = [PNLineChart midPointBetweenPoint1:segmentP1 andPoint2:segmentP2];</div><div class="line">            </div><div class="line">            <span class="comment">//以每条线段以中间点为分割点，分成两组。每一组形成柔和的外凸曲线，而不是内凹</span></div><div class="line">            [currentProgressLine addQuadCurveToPoint:midPoint</div><div class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP1]];</div><div class="line">            </div><div class="line">            [currentProgressLine addQuadCurveToPoint:segmentP2</div><div class="line">                                        controlPoint:[PNLineChart controlPointBetweenPoint1:midPoint andPoint2:segmentP2]];</div><div class="line">            </div><div class="line">            [progressLines addObject:currentProgressLine];</div><div class="line">            [progressLineColors addObject:range[<span class="string">@"color"</span>]];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意一下生成弯曲的贝塞尔曲线的方法：<code>controlPointBetweenPoint1:andPoint2</code>:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//返回的点的x：是两点的中间；返回的点的y：与第二个点保持一致</span></div><div class="line">+ (<span class="built_in">CGPoint</span>)controlPointBetweenPoint1:(<span class="built_in">CGPoint</span>)point1 andPoint2:(<span class="built_in">CGPoint</span>)point2 &#123;</div><div class="line">    </div><div class="line">    <span class="comment">//线段两端的中间点</span></div><div class="line">    <span class="built_in">CGPoint</span> controlPoint = [<span class="keyword">self</span> midPointBetweenPoint1:point1 andPoint2:point2];</div><div class="line">    </div><div class="line">    <span class="comment">//末端点 和  中间点y的差</span></div><div class="line">    <span class="built_in">CGFloat</span> diffY = abs((<span class="keyword">int</span>) (point2.y - controlPoint.y));</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (point1.y &lt; point2.y)</div><div class="line">    <span class="comment">//如果前端点更高</span></div><div class="line">        controlPoint.y += diffY;</div><div class="line">    </div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (point1.y &gt; point2.y)</div><div class="line">    <span class="comment">//如果后端点更高</span></div><div class="line">        controlPoint.y -= diffY;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> controlPoint;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>OK，这样一来，直线的曲线图还有曲线的曲线图就大概掌握了。不过还差一个东西，就是图表对点击的响应。</p>
<p>我们需要思考一下：既然一张图表里可以显示多条折线，所以，当手指点击图表上的点以后，应该同时返回两个数据：</p>
<ol>
<li>点击了哪条折线上的这个点。</li>
<li>点击了这条折线上的哪个点。</li>
</ol>
<p>该框架的作者很好地完成了这两个任务，我们来看一下他是如何实现的：</p>
<h3 id="响应点击的代理方法"><a href="#响应点击的代理方法" class="headerlink" title="响应点击的代理方法"></a>响应点击的代理方法</h3><h4 id="点击了哪条折线的判断"><a href="#点击了哪条折线的判断" class="headerlink" title="点击了哪条折线的判断"></a>点击了哪条折线的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="comment">// Get the point user touched</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">NSArray</span> *linePointsArray = _endPointsOfPath[p];</div><div class="line">        </div><div class="line">        <span class="comment">//遍历每个端点</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">2</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// Closest distance from point to line</span></div><div class="line">            <span class="comment">//触摸点到线段的距离</span></div><div class="line">            <span class="keyword">float</span> distance = (<span class="keyword">float</span>) fabs(((p2.x - p1.x) * (touchPoint.y - p1.y)) - ((p1.x - touchPoint.x) * (p1.y - p2.y)));</div><div class="line">            distance /= hypot(p2.x - p1.x, p1.y - p2.y);</div><div class="line">            </div><div class="line">            <span class="comment">//如果距离小于5，则判断为“点击了当前的线段”，剩下的工作是判断具体点击了哪一条线段</span></div><div class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">5.0</span>) &#123;</div><div class="line">                <span class="comment">// Conform to delegate parameters, figure out what bezier path this CGPoint belongs to.</span></div><div class="line">                <span class="built_in">NSUInteger</span> lineIndex = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="built_in">NSArray</span>&lt;<span class="built_in">UIBezierPath</span> *&gt; *paths <span class="keyword">in</span> _chartPath) &#123;</div><div class="line">                    <span class="keyword">for</span> (<span class="built_in">UIBezierPath</span> *path <span class="keyword">in</span> paths) &#123;</div><div class="line">                        <span class="comment">//如果当前点处于UIBezierPath曲线上</span></div><div class="line">                        <span class="built_in">BOOL</span> pointContainsPath = <span class="built_in">CGPathContainsPoint</span>(path.CGPath, <span class="literal">NULL</span>, p1, <span class="literal">NO</span>);</div><div class="line">                        <span class="keyword">if</span> (pointContainsPath) &#123;</div><div class="line">                            <span class="comment">//点击了某一条折线</span></div><div class="line">                            [_delegate userClickedOnLinePoint:touchPoint lineIndex:lineIndex];</div><div class="line">                            <span class="keyword">return</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    lineIndex++;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="点击了哪个点的判断"><a href="#点击了哪个点的判断" class="headerlink" title="点击了哪个点的判断"></a>点击了哪个点的判断</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)touchKeyPoint:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</div><div class="line">    <span class="comment">// Get the point user touched</span></div><div class="line">    <span class="built_in">UITouch</span> *touch = [touches anyObject];</div><div class="line">    <span class="built_in">CGPoint</span> touchPoint = [touch locationInView:<span class="keyword">self</span>];</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> p = <span class="number">0</span>; p &lt; _pathPoints.count; p++) &#123;</div><div class="line">        <span class="built_in">NSArray</span> *linePointsArray = _pathPoints[p];</div><div class="line">        </div><div class="line">        <span class="comment">//遍历所有的点</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>) linePointsArray.count - <span class="number">1</span>; i += <span class="number">1</span>) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">CGPoint</span> p1 = [linePointsArray[i] <span class="built_in">CGPointValue</span>];</div><div class="line">            <span class="built_in">CGPoint</span> p2 = [linePointsArray[i + <span class="number">1</span>] <span class="built_in">CGPointValue</span>];</div><div class="line">            </div><div class="line">            <span class="comment">//获取到前一点的距离和后一点的距离</span></div><div class="line">            <span class="keyword">float</span> distanceToP1 = (<span class="keyword">float</span>) fabs(hypot(touchPoint.x - p1.x, touchPoint.y - p1.y));</div><div class="line">            <span class="keyword">float</span> distanceToP2 = (<span class="keyword">float</span>) hypot(touchPoint.x - p2.x, touchPoint.y - p2.y);</div><div class="line">            </div><div class="line">            <span class="keyword">float</span> distance = MIN(distanceToP1, distanceToP2);</div><div class="line">            </div><div class="line">            <span class="comment">//如果较小的距离小于10，则判定为点击了某个点</span></div><div class="line">            <span class="keyword">if</span> (distance &lt;= <span class="number">10.0</span>) &#123;</div><div class="line">                <span class="comment">//点击了某一条折线上的某个点</span></div><div class="line">                [_delegate userClickedOnLineKeyPoint:touchPoint</div><div class="line">                                           lineIndex:p</div><div class="line">                                          pointIndex:(distance == distanceToP2 ? i + <span class="number">1</span> : i)];</div><div class="line">                </div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这下就完整了，一个带有响应功能的图表就做好啦！</p>
<h3 id="关于自定义UIView"><a href="#关于自定义UIView" class="headerlink" title="关于自定义UIView"></a>关于自定义UIView</h3><p>这里只是将图表的<code>layer</code>加在了<code>UIView</code>的layer上，那如果想完全自定义view的话，只需将图表的<code>layer</code>完全赋给<code>UIView</code>的layer即可，这样一来，想要画出任意形状的<code>UIView</code>都可以。</p>
<hr>
<h2 id="三-最后的话"><a href="#三-最后的话" class="headerlink" title="三. 最后的话"></a>三. 最后的话</h2><p>关于图表的绘制，相对贝塞尔曲线与<code>CALayer</code>来说，数据的处理是一个比较麻烦的点。但是一旦学会了折线图的绘制，了解了绘图原理，那么其他类型的图表就可以触类旁通。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一-框架介绍&quot;&gt;&lt;a href=&quot;#一-框架介绍&quot; class=&quot;headerlink&quot; title=&quot;一. 框架介绍&quot;&gt;&lt;/a&gt;一. 框架介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/kevinzhow/PNChart&quot;&gt;PNChart&lt;/a&gt;是国内开发者开发的iOS图表框架，现在已经7900多颗star了。它涵盖了折线图，柱状图，饼图，散点图等图表。图表的可定制性很高，而且UI设计简洁大方。&lt;/p&gt;
&lt;p&gt;该框架分为两层：视图层和数据层。视图层里有两层继承关系，第一层是所有类型图表的父类&lt;code&gt;PNGenericChart&lt;/code&gt;,第二层就是所有类型的图表。提供一张图来直观感受一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/PNChart_00.png&quot; alt=&quot;层级图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在这张图里，需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;带箭头的线和不带箭头的线的区别。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Data&lt;/code&gt;类对应图表的一组数据，因为当前类型的图表支持多组数据（例如：饼状图没有&lt;code&gt;Data&lt;/code&gt;类，因为饼状图没有多组数据，而折线图&lt;code&gt;LineChart&lt;/code&gt;是支持多组数据的，所以有&lt;code&gt;Data&lt;/code&gt;类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Item&lt;/code&gt;类负责将传入图表的某个真实值转化为图表中显示的值，具体做法会在下文详细讲解。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;BarChart&lt;/code&gt;类里面的每一根柱子都是&lt;code&gt;PNBar&lt;/code&gt;的实例（该类型的图表不在本篇讲解的范围之内）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MJRefresh源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/04/MJRefresh%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/04/MJRefresh 源码解析/</id>
    <published>2017-02-04T01:30:17.000Z</published>
    <updated>2017-03-20T07:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/CoderMJLee/MJRefresh">MJRefresh</a>是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。</p>
<p>该框架的结构设计得很清晰，使用一个基类<code>MJRefreshComponent</code>来做一些基本的设定，然后通过继承的方式，让<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png" alt="框架组织结构图"></p>
<a id="more"></a>
<p>首先来看一下该控件的基类：MJRefreshComponent：</p>
<h2 id="MJRefreshComponent"><a href="#MJRefreshComponent" class="headerlink" title="MJRefreshComponent"></a>MJRefreshComponent</h2><p>这个类作为该控件几类，涵盖了基类所具备的成份：状态，回调block等，大致分成下面这5种职能：</p>
<h3 id="有哪些职能"><a href="#有哪些职能" class="headerlink" title="有哪些职能?"></a>有哪些职能?</h3><ol>
<li>声明控件的所有状态。</li>
<li>声明控件的回调函数。</li>
<li>添加监听。</li>
<li>提供刷新，停止刷新接口。</li>
<li>提供子类需要实现的方法。</li>
</ol>
<h3 id="职能如何实现？"><a href="#职能如何实现？" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><h4 id="1-声明控件的所有状态"><a href="#1-声明控件的所有状态" class="headerlink" title="1. 声明控件的所有状态"></a>1. 声明控件的所有状态</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 刷新控件的状态 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, MJRefreshState) &#123;</div><div class="line">    <span class="comment">/** 普通闲置状态 */</span></div><div class="line">    MJRefreshStateIdle = <span class="number">1</span>,</div><div class="line">    <span class="comment">/** 松开就可以进行刷新的状态 */</span></div><div class="line">    MJRefreshStatePulling,</div><div class="line">    <span class="comment">/** 正在刷新中的状态 */</span></div><div class="line">    MJRefreshStateRefreshing,</div><div class="line">    <span class="comment">/** 即将刷新的状态 */</span></div><div class="line">    MJRefreshStateWillRefresh,</div><div class="line">    <span class="comment">/** 所有数据加载完毕，没有更多的数据了 */</span></div><div class="line">    MJRefreshStateNoMoreData</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="2-声明控件的回调函数"><a href="#2-声明控件的回调函数" class="headerlink" title="2. 声明控件的回调函数"></a>2. 声明控件的回调函数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** 进入刷新状态的回调 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentRefreshingBlock)();</div><div class="line"><span class="comment">/** 开始刷新后的回调(进入刷新状态后的回调) */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentbeginRefreshingCompletionBlock)();</div><div class="line"><span class="comment">/** 结束刷新后的回调 */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> (^MJRefreshComponentEndRefreshingCompletionBlock)();</div></pre></td></tr></table></figure>
<h4 id="3-添加监听"><a href="#3-添加监听" class="headerlink" title="3. 添加监听"></a>3. 添加监听</h4><p>监听的声明：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)addObservers</div><div class="line">&#123;</div><div class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</div><div class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentOffset options:options context:<span class="literal">nil</span>];<span class="comment">//contentOffset属性</span></div><div class="line">    [<span class="keyword">self</span>.scrollView addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathContentSize options:options context:<span class="literal">nil</span>];<span class="comment">//contentSize属性</span></div><div class="line">    <span class="keyword">self</span>.pan = <span class="keyword">self</span>.scrollView.panGestureRecognizer;</div><div class="line">    [<span class="keyword">self</span>.pan addObserver:<span class="keyword">self</span> forKeyPath:MJRefreshKeyPathPanState options:options context:<span class="literal">nil</span>];<span class="comment">//UIPanGestureRecognizer 的state属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于监听的处理：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 遇到这些情况就直接返回</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.userInteractionEnabled) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 这个就算看不见也需要处理</span></div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentSize]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewContentSizeDidChange:change];</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 看不见</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathContentOffset]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewContentOffsetDidChange:change];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:MJRefreshKeyPathPanState]) &#123;</div><div class="line">        [<span class="keyword">self</span> scrollViewPanStateDidChange:change];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-提供刷新，停止刷新接口"><a href="#4-提供刷新，停止刷新接口" class="headerlink" title="4. 提供刷新，停止刷新接口"></a>4. 提供刷新，停止刷新接口</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark 进入刷新状态</span></div><div class="line">- (<span class="keyword">void</span>)beginRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.beginRefreshingCompletionBlock = completionBlock;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> beginRefreshing];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)beginRefreshing</div><div class="line">&#123;</div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">        <span class="keyword">self</span>.alpha = <span class="number">1.0</span>;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">self</span>.pullingPercent = <span class="number">1.0</span>;</div><div class="line">    <span class="comment">// 只要正在刷新，就完全显示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.window) &#123;</div><div class="line">        <span class="comment">//将状态切换为正在刷新</span></div><div class="line">        <span class="keyword">self</span>.state = MJRefreshStateRefreshing;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 预防正在刷新中时，调用本方法使得header inset回置失败</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateRefreshing) &#123;</div><div class="line">            <span class="comment">//将状态切换为即将刷新</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStateWillRefresh;</div><div class="line">            <span class="comment">// 刷新(预防从另一个控制器回到这个控制器的情况，回来要重新刷新一下)</span></div><div class="line">            [<span class="keyword">self</span> setNeedsDisplay];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark 结束刷新状态</span></div><div class="line">- (<span class="keyword">void</span>)endRefreshing</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.state = MJRefreshStateIdle;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)endRefreshingWithCompletionBlock:(<span class="keyword">void</span> (^)())completionBlock</div><div class="line">&#123;</div><div class="line">    <span class="keyword">self</span>.endRefreshingCompletionBlock = completionBlock;</div><div class="line">    </div><div class="line">    [<span class="keyword">self</span> endRefreshing];</div><div class="line">&#125;</div><div class="line"><span class="meta">#pragma mark 是否正在刷新</span></div><div class="line">- (<span class="built_in">BOOL</span>)isRefreshing</div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == MJRefreshStateRefreshing || <span class="keyword">self</span>.state == MJRefreshStateWillRefresh;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>交给子类实现的方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 摆放子控件frame */</span></div><div class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div></pre></td></tr></table></figure>
<h4 id="5-提供子类需要实现的方法"><a href="#5-提供子类需要实现的方法" class="headerlink" title="5. 提供子类需要实现的方法"></a>5. 提供子类需要实现的方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#pragma mark - 交给子类们去实现</span></div><div class="line"><span class="comment">/** 初始化 */</span></div><div class="line">- (<span class="keyword">void</span>)prepare <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 摆放子控件frame */</span></div><div class="line">- (<span class="keyword">void</span>)placeSubviews <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentOffset发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的contentSize发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewContentSizeDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div><div class="line"><span class="comment">/** 当scrollView的拖拽状态发生改变的时候调用 */</span></div><div class="line">- (<span class="keyword">void</span>)scrollViewPanStateDidChange:(<span class="built_in">NSDictionary</span> *)change <span class="built_in">NS_REQUIRES_SUPER</span>;</div></pre></td></tr></table></figure>
<p>从上面等结构图可以看出，紧接着这个基类，下面分为<code>MJRefreshHeader</code>和<code>MJRefreshFooter</code>,这里顺着<code>MJRefreshHeader</code>这个分支向下展开：</p>
<h2 id="MJRefreshHeader"><a href="#MJRefreshHeader" class="headerlink" title="MJRefreshHeader"></a>MJRefreshHeader</h2><p><code>MJRefreshHeader</code>继承于<code>MJRefreshComponent</code>，它做了这几件事：</p>
<h3 id="有哪些职能？"><a href="#有哪些职能？" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol>
<li>初始化。</li>
<li>设置header高度。</li>
<li>重新调整y值。</li>
<li>根据<code>contentOffset</code>的变化，来切换状态（默认状态，可以刷新的状态，正在刷新的状态），实现方法是：<code>scrollViewContentOffsetDidChange:</code>。</li>
<li>在切换状态时，执行相应的操作。实现方法是：<code>setState:</code>。</li>
</ol>
<h3 id="职能如何实现？-1"><a href="#职能如何实现？-1" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化</p>
<p>初始化有两种方法：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingBlock:(MJRefreshComponentRefreshingBlock)refreshingBlock</div><div class="line">&#123;</div><div class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="comment">//传入block</span></div><div class="line">    cmp.refreshingBlock = refreshingBlock;</div><div class="line">    <span class="keyword">return</span> cmp;</div><div class="line">&#125;</div><div class="line">+ (<span class="keyword">instancetype</span>)headerWithRefreshingTarget:(<span class="keyword">id</span>)target refreshingAction:(SEL)action</div><div class="line">&#123;</div><div class="line">    MJRefreshHeader *cmp = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    <span class="comment">//设置self.refreshingTarget 和 self.refreshingAction</span></div><div class="line">    [cmp setRefreshingTarget:target refreshingAction:action];</div><div class="line">    <span class="keyword">return</span> cmp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="2-设置header高度"><a href="#2-设置header高度" class="headerlink" title="2. 设置header高度"></a>2. 设置header高度</h4><p>通过重写<code>prepare</code>方法来设置header的高度：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置用于在NSUserDefaults里存储时间的key</span></div><div class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = MJRefreshHeaderLastUpdatedTimeKey;</div><div class="line">    </div><div class="line">    <span class="comment">// 设置header的高度</span></div><div class="line">    <span class="keyword">self</span>.mj_h = MJRefreshHeaderHeight;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-重新调整y值"><a href="#3-重新调整y值" class="headerlink" title="3. 重新调整y值"></a>3. 重新调整y值</h4><p>通过重写<code>placeSubviews</code>方法来重新调整y值：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">// 设置y值(当自己的高度发生改变了，肯定要重新调整Y值，所以放到placeSubviews方法中设置y值)</span></div><div class="line">    <span class="keyword">self</span>.mj_y = - <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.ignoredScrollViewContentInsetTop;</div><div class="line">    <span class="comment">//self.ignoredScrollViewContentInsetTop 如果是10，那么就向上移动10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-状态切换的代码："><a href="#4-状态切换的代码：" class="headerlink" title="4. 状态切换的代码："></a>4. 状态切换的代码：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)scrollViewContentOffsetDidChange:(<span class="built_in">NSDictionary</span> *)change</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> scrollViewContentOffsetDidChange:change];</div><div class="line">    <span class="comment">// 正在刷新的状态</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.window == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//- self.scrollView.mj_offsetY：-（-54-64）= 118 ： 刷新的时候，偏移量是不动的。偏移量 = 状态栏 + 导航栏 + header的高度</span></div><div class="line">        <span class="comment">//_scrollViewOriginalInset.top：64 （状态栏 + 导航栏）</span></div><div class="line">        <span class="comment">//insetT 取二者之间大的那一个</span></div><div class="line">        <span class="built_in">CGFloat</span> insetT = - <span class="keyword">self</span>.scrollView.mj_offsetY &gt; _scrollViewOriginalInset.top ? - <span class="keyword">self</span>.scrollView.mj_offsetY : _scrollViewOriginalInset.top;</div><div class="line">       </div><div class="line">        <span class="comment">//118</span></div><div class="line">        insetT = insetT &gt; <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top ? <span class="keyword">self</span>.mj_h + _scrollViewOriginalInset.top : insetT;</div><div class="line">        </div><div class="line">        <span class="comment">//设置contentInset</span></div><div class="line">        <span class="keyword">self</span>.scrollView.mj_insetT = insetT;</div><div class="line">        </div><div class="line">        <span class="comment">// 记录刷新的时候的偏移量 -54 = 64 - 118</span></div><div class="line">        <span class="keyword">self</span>.insetTDelta = _scrollViewOriginalInset.top - insetT;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 跳转到下一个控制器时，contentInset可能会变</span></div><div class="line">     _scrollViewOriginalInset = <span class="keyword">self</span>.scrollView.contentInset;</div><div class="line">    </div><div class="line">    <span class="comment">// 记录当前的contentOffset</span></div><div class="line">    <span class="built_in">CGFloat</span> offsetY = <span class="keyword">self</span>.scrollView.mj_offsetY;</div><div class="line"></div><div class="line">    <span class="comment">// 头部控件刚好全部出现的offsetY,默认是-64（20 + 44）</span></div><div class="line">    <span class="built_in">CGFloat</span> happenOffsetY = - <span class="keyword">self</span>.scrollViewOriginalInset.top;</div><div class="line">    </div><div class="line">    <span class="comment">// 向上滚动，直接返回</span></div><div class="line">    <span class="keyword">if</span> (offsetY &gt; happenOffsetY) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 从普通 到 即将刷新 的临界距离</span></div><div class="line">    <span class="built_in">CGFloat</span> normal2pullingOffsetY = happenOffsetY - <span class="keyword">self</span>.mj_h;<span class="comment">// -64 - 54 = -118</span></div><div class="line">    </div><div class="line">    <span class="comment">//下拉的百分比：下拉的距离与header高度的比值</span></div><div class="line">    <span class="built_in">CGFloat</span> pullingPercent = (happenOffsetY - offsetY) / <span class="keyword">self</span>.mj_h;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.scrollView.isDragging) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//记录当前下拉的百分比</span></div><div class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStateIdle &amp;&amp; offsetY &lt; normal2pullingOffsetY) &#123;</div><div class="line">            <span class="comment">// 如果当前为默认状态 &amp;&amp; 下拉的距离大于临界距离（将tableview下拉得很低），则将状态切换为可以刷新</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStatePulling;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling &amp;&amp; offsetY &gt;= normal2pullingOffsetY) &#123;</div><div class="line">            <span class="comment">// 如果当前状态为可以刷新 &amp;&amp; 下拉的距离小于临界距离，则将状态切换为默认</span></div><div class="line">            <span class="keyword">self</span>.state = MJRefreshStateIdle;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.state == MJRefreshStatePulling) &#123;<span class="comment">// 即将刷新 &amp;&amp; 手松开</span></div><div class="line">        <span class="comment">// 手松开 &amp;&amp; 状态为可以刷新（MJRefreshStatePulling）时 开始刷新</span></div><div class="line">        [<span class="keyword">self</span> beginRefreshing];        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pullingPercent &lt; <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">//手松开后，默认状态时，恢复self.pullingPercent</span></div><div class="line">        <span class="keyword">self</span>.pullingPercent = pullingPercent;        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>需要注意三点：</p>
<ol>
<li>这里的状态有三种：默认状态（MJRefreshStateIdle），可以刷新的状态（MJRefreshStatePulling）以及正在刷新的状态（MJRefreshStateRefreshing）。</li>
<li>状态切换的因素有两个：一个是下拉的距离是否超过临界值，另一个是 手指是否离开屏幕。</li>
<li>注意:<strong>可以刷新的状态</strong>和<strong>正在刷新的状态</strong>是不同的。因为在手指还贴在屏幕的时候是不能进行刷新的。所以即使在下拉的距离超过了临界距离（状态栏 + 导航栏 + header高度），如果手指没有离开屏幕，那么也不能马上进行刷新，而是将状态切换为：可以刷新。一旦手指离开了屏幕，马上将状态切换为正在刷新。 </li>
</ol>
</blockquote>
<p>这里提供一张图来体现三个状态的不同：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_2.png" alt="三个状态"></p>
<h4 id="5-状态切换时的相应操作："><a href="#5-状态切换时的相应操作：" class="headerlink" title="5. 状态切换时的相应操作："></a>5. 状态切换时的相应操作：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">   </div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//============== 设置状态为默认状态 =============//</span></div><div class="line">        </div><div class="line">        <span class="comment">//如果当前不是正在刷新就返回，因为这个方法主要针对从正在刷新状态（oldstate）到默认状态</span></div><div class="line">        <span class="keyword">if</span> (oldState != MJRefreshStateRefreshing) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        <span class="comment">//刷新完成后，保存刷新完成的时间</span></div><div class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:[<span class="built_in">NSDate</span> date] forKey:<span class="keyword">self</span>.lastUpdatedTimeKey];</div><div class="line">        [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] synchronize];</div><div class="line">        </div><div class="line">        <span class="comment">// 恢复inset和offset</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">            </div><div class="line">            <span class="comment">//118 -&gt; 64（剪去了header的高度）</span></div><div class="line">            <span class="keyword">self</span>.scrollView.mj_insetT += <span class="keyword">self</span>.insetTDelta;</div><div class="line">            </div><div class="line">            <span class="comment">// 自动调整透明度</span></div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.isAutomaticallyChangeAlpha) <span class="keyword">self</span>.alpha = <span class="number">0.0</span>;</div><div class="line">            </div><div class="line">        &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            </div><div class="line">            <span class="keyword">self</span>.pullingPercent = <span class="number">0.0</span>;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.endRefreshingCompletionBlock) &#123;</div><div class="line">                <span class="comment">//调用刷新完成的block</span></div><div class="line">                <span class="keyword">self</span>.endRefreshingCompletionBlock();</div><div class="line">            &#125;</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">         <span class="comment">//============== 设置状态为正在刷新状态 =============//</span></div><div class="line">         <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            </div><div class="line">             [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">               </div><div class="line">                <span class="built_in">CGFloat</span> top = <span class="keyword">self</span>.scrollViewOriginalInset.top + <span class="keyword">self</span>.mj_h;<span class="comment">//64 + 54 (都是默认的高度)</span></div><div class="line">                <span class="comment">// 重新设置contentInset，top = 118</span></div><div class="line">                <span class="keyword">self</span>.scrollView.mj_insetT = top;</div><div class="line">                <span class="comment">// 设置滚动位置</span></div><div class="line">                [<span class="keyword">self</span>.scrollView setContentOffset:<span class="built_in">CGPointMake</span>(<span class="number">0</span>, -top) animated:<span class="literal">NO</span>];</div><div class="line">                 </div><div class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                <span class="comment">//调用进行刷新的block</span></div><div class="line">                [<span class="keyword">self</span> executeRefreshingCallback];</div><div class="line">            &#125;];</div><div class="line">         &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里需要注意两点：</p>
<ol>
<li>这里状态的切换，主要围绕着两种：默认状态和正在刷新状态。也就是针对<strong>开始刷新</strong>和<strong>结束刷新</strong>这两个切换点。</li>
<li>从正在刷新状态状态切换为默认状态时（结束刷新），需要记录刷新结束的时间。因为header里面有一个默认的label是用来显示上次刷新的时间的。</li>
</ol>
</blockquote>
<h2 id="MJRefreshStateHeader"><a href="#MJRefreshStateHeader" class="headerlink" title="MJRefreshStateHeader"></a>MJRefreshStateHeader</h2><p>这个类是<code>MJRefreshHeader</code>类的子类，它做了两件事：</p>
<h3 id="有哪些职能？-1"><a href="#有哪些职能？-1" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><ol>
<li>简单布局了<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>。</li>
<li>根据控件状态的切换（默认状态，正在刷新状态），实现了这两个label显示的文字的切换。</li>
</ol>
<p>给一张图，让大家直观感受一下这两个控件：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_3.png" alt="两个Label"></p>
<h3 id="职能如何实现？-2"><a href="#职能如何实现？-2" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>这个类通过覆盖父类三个方法来实现上述两个实现：</p>
<h4 id="方法1：prepare方法"><a href="#方法1：prepare方法" class="headerlink" title="方法1：prepare方法"></a>方法1：prepare方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化间距</span></div><div class="line">    <span class="keyword">self</span>.labelLeftInset = MJRefreshLabelLeftInset;</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化文字</span></div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderIdleText] forState:MJRefreshStateIdle];</div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderPullingText] forState:MJRefreshStatePulling];</div><div class="line">    [<span class="keyword">self</span> setTitle:[<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderRefreshingText] forState:MJRefreshStateRefreshing];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，将每一个状态对应的提示文字放入一个字典里面,key是状态的NSNumber形式</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setTitle:(<span class="built_in">NSString</span> *)title forState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (title == <span class="literal">nil</span>) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">self</span>.stateTitles[@(state)] = title;</div><div class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(<span class="keyword">self</span>.state)];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：placeSubviews方法"><a href="#方法2：placeSubviews方法" class="headerlink" title="方法2：placeSubviews方法"></a>方法2：placeSubviews方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">BOOL</span> noConstrainsOnStatusLabel = <span class="keyword">self</span>.stateLabel.constraints.count == <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果更新时间label是隐藏的，则让状态label撑满整个header</span></div><div class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) <span class="keyword">self</span>.stateLabel.frame = <span class="keyword">self</span>.bounds;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果更新时间label不是隐藏的，根据约束设置更新时间label和状态label（高度各占一半）</span></div><div class="line">        <span class="built_in">CGFloat</span> stateLabelH = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (noConstrainsOnStatusLabel) &#123;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_x = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_y = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_w = <span class="keyword">self</span>.mj_w;</div><div class="line">            <span class="keyword">self</span>.stateLabel.mj_h = stateLabelH;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 更新时间label</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_x = <span class="number">0</span>;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y = stateLabelH;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_w = <span class="keyword">self</span>.mj_w;</div><div class="line">            <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_h = <span class="keyword">self</span>.mj_h - <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_y;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里主要是对<code>lastUpdatedTimeLabel</code>和<code>stateLabel</code>进行布局。要注意<code>lastUpdatedTimeLabel</code>隐藏的情况。</p>
</blockquote>
<h4 id="方法3-setState-方法"><a href="#方法3-setState-方法" class="headerlink" title="方法3: setState:方法"></a>方法3: setState:方法</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="comment">// 设置状态文字</span></div><div class="line">    <span class="keyword">self</span>.stateLabel.text = <span class="keyword">self</span>.stateTitles[@(state)];</div><div class="line">    </div><div class="line">    <span class="comment">// 重新设置key（重新显示时间）</span></div><div class="line">    <span class="keyword">self</span>.lastUpdatedTimeKey = <span class="keyword">self</span>.lastUpdatedTimeKey;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，根据传入的state的不同，在<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>里切换相应的文字。</p>
<ul>
<li><code>stateLabel</code>里的文字直接从<code>stateTitles</code>字典里取出即可。</li>
<li><code>lastUpdatedTimeLabel</code>里的文字需要通过一个方法来取出即可：</li>
</ul>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setLastUpdatedTimeKey:(<span class="built_in">NSString</span> *)lastUpdatedTimeKey</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> setLastUpdatedTimeKey:lastUpdatedTimeKey];</div><div class="line">    </div><div class="line">    <span class="comment">// 如果label隐藏了，就不用再处理</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//根据key，从NSUserDefaults获取对应的NSData型时间</span></div><div class="line">    <span class="built_in">NSDate</span> *lastUpdatedTime = [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] objectForKey:lastUpdatedTimeKey];</div><div class="line">    </div><div class="line">    <span class="comment">// 如果有block，从block里拿来时间，这应该是用户自定义显示时间格式的渠道</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.lastUpdatedTimeText) &#123;</div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = <span class="keyword">self</span>.lastUpdatedTimeText(lastUpdatedTime);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//如果没有block，就按照下面的默认方法显示时间格式</span></div><div class="line">    <span class="keyword">if</span> (lastUpdatedTime) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 获得了上次更新时间</span></div><div class="line">        <span class="comment">// 1.获得年月日</span></div><div class="line">        <span class="built_in">NSCalendar</span> *calendar = [<span class="keyword">self</span> currentCalendar];</div><div class="line">        <span class="built_in">NSUInteger</span> unitFlags = <span class="built_in">NSCalendarUnitYear</span>| <span class="built_in">NSCalendarUnitMonth</span> | <span class="built_in">NSCalendarUnitDay</span> |<span class="built_in">NSCalendarUnitHour</span> |<span class="built_in">NSCalendarUnitMinute</span>;</div><div class="line">        <span class="built_in">NSDateComponents</span> *cmp1 = [calendar components:unitFlags fromDate:lastUpdatedTime];</div><div class="line">        <span class="built_in">NSDateComponents</span> *cmp2 = [calendar components:unitFlags fromDate:[<span class="built_in">NSDate</span> date]];</div><div class="line">        </div><div class="line">        <span class="comment">// 2.格式化日期</span></div><div class="line">        <span class="built_in">NSDateFormatter</span> *formatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</div><div class="line">        <span class="built_in">BOOL</span> isToday = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> ([cmp1 day] == [cmp2 day]) &#123;</div><div class="line">            <span class="comment">//今天，省去年月日</span></div><div class="line">            formatter.dateFormat = <span class="string">@" HH:mm"</span>;</div><div class="line">            isToday = <span class="literal">YES</span>;</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([cmp1 year] == [cmp2 year]) &#123; <span class="comment">// 今年</span></div><div class="line">            <span class="comment">//今年，省去年，显示月日</span></div><div class="line">            formatter.dateFormat = <span class="string">@"MM-dd HH:mm"</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//其他，年月日都显示</span></div><div class="line">            formatter.dateFormat = <span class="string">@"yyyy-MM-dd HH:mm"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSString</span> *time = [formatter stringFromDate:lastUpdatedTime];</div><div class="line">        </div><div class="line">        <span class="comment">// 3.显示日期</span></div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@%@"</span>,</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</div><div class="line">                                          isToday ? [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderDateTodayText] : <span class="string">@""</span>,</div><div class="line">                                          time];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 没有获得上次更新时间（应该是第一次更新或者多次更新，之前的更新都失败了）</span></div><div class="line">        <span class="keyword">self</span>.lastUpdatedTimeLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>,</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderLastTimeText],</div><div class="line">                                          [<span class="built_in">NSBundle</span> mj_localizedStringForKey:MJRefreshHeaderNoneLastDateText]];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里注意两点：</p>
<ol>
<li>作者通过使用block来让用户自己定义日期现实的格式，如果用户没有自定义，就使用作者提供的默认格式。</li>
<li>在默认格式的设置里，判断了是否是今日，是否是今年的情况。在以后设计显示时间的labe的时候可以借鉴一下。</li>
</ol>
</blockquote>
<h2 id="MJRefreshNormalHeader"><a href="#MJRefreshNormalHeader" class="headerlink" title="MJRefreshNormalHeader"></a>MJRefreshNormalHeader</h2><h3 id="有哪些职能？-2"><a href="#有哪些职能？-2" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>MJRefreshNormalHeader 继承于 MJRefreshStateHeader，它主要做了两件事：</p>
<ol>
<li>它在MJRefreshStateHeader上添加了<code>_arrowView</code>和<code>loadingView</code>。</li>
<li>布局了这两个view并在Refresh控件的状态切换的时候改变这两个view的样式。</li>
</ol>
<p>还是给一张图来直观感受一下这两个view：</p>
<p><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_4.png" alt="两个view"></p>
<h3 id="职能如何实现？-3"><a href="#职能如何实现？-3" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>同MJRefreshStateHeader一样，也是重写了父类的三个方法：</p>
<h4 id="方法1：prepare"><a href="#方法1：prepare" class="headerlink" title="方法1：prepare"></a>方法1：prepare</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.activityIndicatorViewStyle = <span class="built_in">UIActivityIndicatorViewStyleGray</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法2：placeSubviews"><a href="#方法2：placeSubviews" class="headerlink" title="方法2：placeSubviews"></a>方法2：placeSubviews</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">// 首先将箭头的中心点x设为header宽度的一半</span></div><div class="line">    <span class="built_in">CGFloat</span> arrowCenterX = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.stateLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</div><div class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//在stateLabel里的文字宽度和更新时间里的文字宽度里取较宽的</span></div><div class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</div><div class="line">        <span class="comment">//根据self.labelLeftInset和textWidth向左移动中心点x</span></div><div class="line">        arrowCenterX -= textWidth / <span class="number">2</span> + <span class="keyword">self</span>.labelLeftInset;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//中心点y永远设置为header的高度的一半</span></div><div class="line">    <span class="built_in">CGFloat</span> arrowCenterY = <span class="keyword">self</span>.mj_h * <span class="number">0.5</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//获得了最终的center，而这个center同时适用于arrowView和loadingView，因为二者是不共存的。</span></div><div class="line">    <span class="built_in">CGPoint</span> arrowCenter = <span class="built_in">CGPointMake</span>(arrowCenterX, arrowCenterY);</div><div class="line">    </div><div class="line">    <span class="comment">// 箭头</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.arrowView.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//控件大小等于图片大小</span></div><div class="line">        <span class="keyword">self</span>.arrowView.mj_size = <span class="keyword">self</span>.arrowView.image.size;</div><div class="line">        <span class="keyword">self</span>.arrowView.center = arrowCenter;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">    <span class="comment">// 菊花</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.loadingView.constraints.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.loadingView.center = arrowCenter;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//arrowView的色调与stateLabel的字体颜色一致</span></div><div class="line">    <span class="keyword">self</span>.arrowView.tintColor = <span class="keyword">self</span>.stateLabel.textColor;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里注意一点：因为<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>是上下并排分布的，而<code>arrowView</code>或<code>loadingView</code>是在这二者的左边，所以为了避免这两组重合，在计算<code>arrowView</code>或<code>loadingView</code>的center的时候，需要获取<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>两个控件的宽度并比较大小，将较大的一个作为两个label的‘最宽距离’，再计算center，这样一来就不会重合了。<br>而对于如何计算宽度，作者给出了一个方案，大家可以在以后的实践中使用：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">CGFloat</span>)mj_textWith &#123;</div><div class="line">    <span class="built_in">CGFloat</span> stringWidth = <span class="number">0</span>;</div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(MAXFLOAT, MAXFLOAT);</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.text.length &gt; <span class="number">0</span>) &#123;</div><div class="line"><span class="meta">#if defined(__IPHONE_OS_VERSION_MAX_ALLOWED) &amp;&amp; __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000</span></div><div class="line">        stringWidth =[<span class="keyword">self</span>.text</div><div class="line">                      boundingRectWithSize:size</div><div class="line">                      options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span></div><div class="line">                      attributes:@&#123;<span class="built_in">NSFontAttributeName</span>:<span class="keyword">self</span>.font&#125;</div><div class="line">                      context:<span class="literal">nil</span>].size.width;</div><div class="line"><span class="meta">#else</span></div><div class="line">        </div><div class="line">        stringWidth = [<span class="keyword">self</span>.text sizeWithFont:<span class="keyword">self</span>.font</div><div class="line">                             constrainedToSize:size</div><div class="line">                                 lineBreakMode:<span class="built_in">NSLineBreakByCharWrapping</span>].width;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> stringWidth;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="方法3-setState"><a href="#方法3-setState" class="headerlink" title="方法3: setState:"></a>方法3: setState:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="comment">// 根据状态更新arrowView和loadingView的显示</span></div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">       </div><div class="line">        <span class="comment">//1. 设置为默认状态</span></div><div class="line">        <span class="keyword">if</span> (oldState == MJRefreshStateRefreshing) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//1.1 从正在刷新状态中切换过来</span></div><div class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            </div><div class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshSlowAnimationDuration animations:^&#123;</div><div class="line">                <span class="comment">//隐藏菊花</span></div><div class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">0.0</span>;</div><div class="line">                </div><div class="line">            &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                </div><div class="line">                <span class="comment">// 如果执行完动画发现不是idle状态，就直接返回，进入其他状态</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.state != MJRefreshStateIdle) <span class="keyword">return</span>;</div><div class="line">                <span class="comment">//菊花停止旋转</span></div><div class="line">                <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>;</div><div class="line">                [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">                <span class="comment">//显示箭头</span></div><div class="line">                <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//1.2 从其他状态中切换过来</span></div><div class="line">            [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">            <span class="comment">//显示箭头并设置为初始状态</span></div><div class="line">            <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">            [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">                <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformIdentity</span>;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStatePulling) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//2. 设置为可以刷新状态</span></div><div class="line">        [<span class="keyword">self</span>.loadingView stopAnimating];</div><div class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">NO</span>;</div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:MJRefreshFastAnimationDuration animations:^&#123;</div><div class="line">            <span class="comment">//箭头倒立</span></div><div class="line">            <span class="keyword">self</span>.arrowView.transform = <span class="built_in">CGAffineTransformMakeRotation</span>(<span class="number">0.000001</span> - M_PI);</div><div class="line">        &#125;];</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//3. 设置为正在刷新状态</span></div><div class="line">        <span class="keyword">self</span>.loadingView.alpha = <span class="number">1.0</span>; <span class="comment">// 防止refreshing -&gt; idle的动画完毕动作没有被执行</span></div><div class="line">        <span class="comment">//菊花旋转</span></div><div class="line">        [<span class="keyword">self</span>.loadingView startAnimating];</div><div class="line">        <span class="comment">//隐藏arrowView</span></div><div class="line">        <span class="keyword">self</span>.arrowView.hidden = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到此为止，我们已经从<code>MJRefreshComponent</code>到<code>MJRefreshNormalHeader</code>的实现过程看了一遍。可以看出，作者将<code>prepare</code>,<code>placeSubviews</code>以及<code>setState：</code>方法作为基类的方法，让下面的子类去一层一层实现。</p>
<p>而每一层的子类，根据自身的职责，分别按照自己的方式来实现这三个方法：</p>
<ul>
<li><code>MJRefreshHeader</code>: 负责header的高度和调整header自身在外部的位置。</li>
<li><code>MJRefreshStateHeader</code>:负责header内部的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>的布局和不同状态下内部文字的显示。</li>
<li><code>MJRefreshNormalHeader</code>:负责header内部的<code>loadingView</code>以及<code>arrowView</code>的布局和不同状态下的显示。</li>
</ul>
<p>这样做的好处是，如果想要增加某种类型的header，只要在某一层上做文章即可。例如该框架里的<code>MJRefreshGifHeader</code>,它和<code>MJRefreshNormalHeader</code>属于同一级，都是继承于<code>MJRefreshStateHeader</code>。因为二者都具有相同形式的<code>stateLabel</code>和<code>lastUpdatedTimeLabel</code>，唯一不同的就是左侧的部分：</p>
<ul>
<li><code>MJRefreshNormalHeader</code>的左侧是箭头。</li>
<li><code>MJRefreshGifHeader</code>的左侧则是一个gif动画。</li>
</ul>
<p>还是提供一张图来直观感受一下：<br><img src="http://oih3a9o4n.bkt.clouddn.com/MJRefresh_5.png" alt="normalHeader 与 gifHeader"></p>
<p>下面我们来看一下的实现：</p>
<h2 id="MJRefreshGifHeader"><a href="#MJRefreshGifHeader" class="headerlink" title="MJRefreshGifHeader"></a>MJRefreshGifHeader</h2><p>它提供了两个接口，是用来设置不同状态下使用的图片数组的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images duration:(<span class="built_in">NSTimeInterval</span>)duration forState:(MJRefreshState)state </div><div class="line">&#123; </div><div class="line">    <span class="keyword">if</span> (images == <span class="literal">nil</span>) <span class="keyword">return</span>; </div><div class="line">    </div><div class="line">    <span class="comment">//设置不同状态下的图片组和持续时间</span></div><div class="line">    <span class="keyword">self</span>.stateImages[@(state)] = images; </div><div class="line">    <span class="keyword">self</span>.stateDurations[@(state)] = @(duration); </div><div class="line">    </div><div class="line">    <span class="comment">/* 根据图片设置控件的高度 */</span> </div><div class="line">    <span class="built_in">UIImage</span> *image = [images firstObject]; </div><div class="line">    <span class="keyword">if</span> (image.size.height &gt; <span class="keyword">self</span>.mj_h) &#123; </div><div class="line">        <span class="keyword">self</span>.mj_h = image.size.height; </div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)setImages:(<span class="built_in">NSArray</span> *)images forState:(MJRefreshState)state </div><div class="line">&#123; </div><div class="line">   <span class="comment">//如果没有传入duration，则根据图片的多少来计算</span></div><div class="line">    [<span class="keyword">self</span> setImages:images duration:images.count * <span class="number">0.1</span> forState:state]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="有哪些职能？-3"><a href="#有哪些职能？-3" class="headerlink" title="有哪些职能？"></a>有哪些职能？</h3><p>然后，和<code>MJRefreshNormalHeader</code>一样，它也重写了基类提供的三个方法来实现显示gif图片的职能。</p>
<h3 id="职能如何实现？-4"><a href="#职能如何实现？-4" class="headerlink" title="职能如何实现？"></a>职能如何实现？</h3><p>####1. 初始化和label的间距<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)prepare</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> prepare];</div><div class="line">    </div><div class="line">    <span class="comment">// 初始化间距</span></div><div class="line">    <span class="keyword">self</span>.labelLeftInset = <span class="number">20</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>####2. 根据label的宽度和存在与否设置gif的位置<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)placeSubviews</div><div class="line">&#123;</div><div class="line">    [<span class="keyword">super</span> placeSubviews];</div><div class="line">    </div><div class="line">    <span class="comment">//如果约束存在，就立即返回</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.gifView.constraints.count) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">self</span>.gifView.frame = <span class="keyword">self</span>.bounds;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.stateLabel.hidden &amp;&amp; <span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel都在隐藏状态，将gif剧中显示</span></div><div class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeCenter</span>;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//如果stateLabel和lastUpdatedTimeLabel中至少一个存在，则根据label的宽度设置gif的位置</span></div><div class="line">        <span class="keyword">self</span>.gifView.contentMode = <span class="built_in">UIViewContentModeRight</span>;</div><div class="line">        </div><div class="line">        <span class="built_in">CGFloat</span> stateWidth = <span class="keyword">self</span>.stateLabel.mj_textWith;</div><div class="line">        <span class="built_in">CGFloat</span> timeWidth = <span class="number">0.0</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.lastUpdatedTimeLabel.hidden) &#123;</div><div class="line">            timeWidth = <span class="keyword">self</span>.lastUpdatedTimeLabel.mj_textWith;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CGFloat</span> textWidth = MAX(stateWidth, timeWidth);</div><div class="line">        <span class="keyword">self</span>.gifView.mj_w = <span class="keyword">self</span>.mj_w * <span class="number">0.5</span> - textWidth * <span class="number">0.5</span> - <span class="keyword">self</span>.labelLeftInset;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-根据传入状态的不同来设置动画"><a href="#3-根据传入状态的不同来设置动画" class="headerlink" title="3. 根据传入状态的不同来设置动画"></a>3. 根据传入状态的不同来设置动画</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setState:(MJRefreshState)state</div><div class="line">&#123;</div><div class="line">    MJRefreshCheckState</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (state == MJRefreshStatePulling || state == MJRefreshStateRefreshing) &#123;</div><div class="line">        </div><div class="line">        <span class="comment">//1. 如果传进来的状态是可以刷新和正在刷新</span></div><div class="line">        <span class="built_in">NSArray</span> *images = <span class="keyword">self</span>.stateImages[@(state)];</div><div class="line">        <span class="keyword">if</span> (images.count == <span class="number">0</span>) <span class="keyword">return</span>;</div><div class="line">        </div><div class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (images.count == <span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">//1.1 单张图片</span></div><div class="line">            <span class="keyword">self</span>.gifView.image = [images lastObject];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//1.2 多张图片</span></div><div class="line">            <span class="keyword">self</span>.gifView.animationImages = images;</div><div class="line">            <span class="keyword">self</span>.gifView.animationDuration = [<span class="keyword">self</span>.stateDurations[@(state)] doubleValue];</div><div class="line">            [<span class="keyword">self</span>.gifView startAnimating];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == MJRefreshStateIdle) &#123;</div><div class="line">        <span class="comment">//2.如果传进来的状态是默认状态</span></div><div class="line">        [<span class="keyword">self</span>.gifView stopAnimating];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>Footer类是用来处理上拉加载的，实现原理和下拉刷新很类似，在这里先不介绍了～</p>
<p>总的来说，该框架设计得非常工整：通过一个基类来定义一些状态和一些需要子类实现的接口。通过一层一层地继承，让每一层的子类各司其职，只完成真正属于自己的任务，提高了框架的可定制性，而且对于功能的扩展和bug的追踪也很有帮助，非常值得我们参考与借鉴。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/CoderMJLee/MJRefresh&quot;&gt;MJRefresh&lt;/a&gt;是李明杰老师的作品，到现在已经有9800多颗star了，是一个简单实用，功能强大的iOS下拉刷新（也支持上拉加载更多）控件。它的可定制性很高，几乎可以满足大部分下拉刷新的设计需求，值得学习。&lt;/p&gt;
&lt;p&gt;该框架的结构设计得很清晰，使用一个基类&lt;code&gt;MJRefreshComponent&lt;/code&gt;来做一些基本的设定，然后通过继承的方式，让&lt;code&gt;MJRefreshHeader&lt;/code&gt;和&lt;code&gt;MJRefreshFooter&lt;/code&gt;分别具备下拉刷新和上拉加载的功能。从继承机构来看可以分为三层，具体可以从下面的图里看出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oih3a9o4n.bkt.clouddn.com/MJRefresh_1.png&quot; alt=&quot;框架组织结构图&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/02/04/SDWebImage%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/02/04/SDWebImage源码解析/</id>
    <published>2017-02-04T01:24:37.000Z</published>
    <updated>2017-03-20T07:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>相信对于广大的iOS开发者，对<a href="https://github.com/rs/SDWebImage">SDWebImage</a>并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。</p>
<p>在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>] placeholderImage:[<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>] completed:^(<span class="built_in">UIImage</span> * _Nullable image, <span class="built_in">NSError</span> * _Nullable error, SDImageCacheType cacheType, <span class="built_in">NSURL</span> * _Nullable imageURL) &#123;</div><div class="line">        </div><div class="line">        imageview.image = image;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"图片加载完成"</span>);</div><div class="line">        </div><div class="line">    &#125;];</div></pre></td></tr></table></figure>
<p>而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//图片下载完成后直接显示下载后的图片</span></div><div class="line">[imageview sd_setImageWithURL:[<span class="built_in">NSURL</span> URLWithString:<span class="string">@"pic.jpg"</span>]];</div></pre></td></tr></table></figure>
<p>在最开始先简单介绍这个框架：</p>
<p>这个框架的核心类是<code>SDWebImageManger</code>，在外部有<code>UIImageView+WebCache</code> 和 <code>UIButton+WebCache</code> 为下载图片的操作提供接口。内部有<code>SDWebImageManger</code>负责处理和协调 <code>SDWebImageDownloader</code> 和 <code>SDWebImageCache</code>：<code>SDWebImageDownloader</code>负责具体的下载任务，<code>SDWebImageCache</code>负责关于缓存的工作：添加，删除，查询缓存。</p>
<p>首先我们大致看一下这个框架的调用流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SDWebImage"></p>
<p>从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。</p>
<p>OK～基本流程大概清楚了，我们看一下每个层具体实现吧～</p>
<a id="more"></a>
<hr>
<p>##UIKit层</p>
<p>该框架最外层的类是<code>UIImageView +WebCache</code>，我们将图片的URL，占位图片直接给这个类。下面是这个类的公共接口：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  UIImageView + WebCache.h ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>可以看出，这个类提供的接口非常灵活，可以根据我们自己的需求来调用其中某一个方法，而这些方法到最后都会走到：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_setImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">          placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                   options:(SDWebImageOptions)options</div><div class="line">                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                 completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<p>而这个方法里面，调用的是<code>UIView+WebCache</code>分类的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line">- (<span class="keyword">void</span>)sd_internalSetImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                  placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                           options:(SDWebImageOptions)options</div><div class="line">                      operationKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)operationKey</div><div class="line">                     setImageBlock:(<span class="keyword">nullable</span> SDSetImageBlock)setImageBlock</div><div class="line">                          progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                         completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock;</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么不是UIImageView+WebCache而要上一层到UIView的分类里呢？<br>因为SDWebImage框架也支持UIButton的下载图片等方法，所以需要在它们的父类：UIView里面统一一个下载方法。</p>
</blockquote>
<p>简单看一下这个方法的实现（省略的代码用…代替）：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ==============  UIView+ WebCache.m ============== //</span></div><div class="line"></div><div class="line">   <span class="comment">//valid key：UIImageView || UIButton</span></div><div class="line">   <span class="built_in">NSString</span> *validOperationKey = operationKey ?: <span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>]);</div><div class="line">   <span class="comment">//UIView+WebCacheOperation 的 operationDictionary</span></div><div class="line">   <span class="comment">//下面这行代码是保证没有当前正在进行的异步下载操作, 使它不会与即将进行的操作发生冲突</span></div><div class="line">   [<span class="keyword">self</span> sd_cancelImageLoadOperationWithKey:validOperationKey];</div><div class="line">   </div><div class="line"></div><div class="line">   <span class="comment">//添加临时的占位图（在不延迟添加占位图的option下）</span></div><div class="line">   <span class="keyword">if</span> (!(options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">       &#125;);</div><div class="line">   &#125;    </div><div class="line">   <span class="comment">//如果url存在</span></div><div class="line">   <span class="keyword">if</span> (url) &#123;     </div><div class="line">      ...</div><div class="line">       __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">      <span class="comment">//SDWebImageManager下载图片</span></div><div class="line">       <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager loadImageWithURL:url options:options progress:progressBlock completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">         </div><div class="line">           ...</div><div class="line">           <span class="comment">//dispatch_main_sync_safe : 保证block能在主线程进行</span></div><div class="line">           dispatch_main_async_safe(^&#123;</div><div class="line">               </div><div class="line">               <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                   <span class="keyword">return</span>;</div><div class="line">               &#125;               </div><div class="line">               <span class="keyword">if</span> (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123;</div><div class="line">                    <span class="comment">//image，而且不自动替换 placeholder image</span></div><div class="line">                   completedBlock(image, error, cacheType, url);</div><div class="line">                   <span class="keyword">return</span>;                    </div><div class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (image) &#123;</div><div class="line">                   <span class="comment">//存在image，需要马上替换 placeholder image</span></div><div class="line">                   [sself sd_setImage:image imageData:data basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                   [sself sd_setNeedsLayout];                </div><div class="line">               &#125; <span class="keyword">else</span> &#123;                    </div><div class="line">                   <span class="comment">//没有image，在图片下载完之后显示 placeholder image</span></div><div class="line">                   <span class="keyword">if</span> ((options &amp; SDWebImageDelayPlaceholder)) &#123;</div><div class="line">                       [sself sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">                       [sself sd_setNeedsLayout];</div><div class="line">                   &#125;</div><div class="line">               &#125;                </div><div class="line">               <span class="keyword">if</span> (completedBlock &amp;&amp; finished) &#123;</div><div class="line">                   completedBlock(image, error, cacheType, url);</div><div class="line">               &#125;</div><div class="line">           &#125;);</div><div class="line">       &#125;];</div><div class="line">       </div><div class="line">       <span class="comment">//在操作缓存字典（operationDictionary）里添加operation，表示当前的操作正在进行</span></div><div class="line">       [<span class="keyword">self</span> sd_setImageLoadOperation:operation forKey:validOperationKey];        </div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">       <span class="comment">//如果url不存在，就在completedBlock里传入error（url为空）</span></div><div class="line">       dispatch_main_async_safe(^&#123;</div><div class="line">           [<span class="keyword">self</span> sd_removeActivityIndicator];</div><div class="line">           <span class="keyword">if</span> (completedBlock) &#123;</div><div class="line">               <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">-1</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Trying to load a nil url"</span>&#125;];</div><div class="line">               completedBlock(<span class="literal">nil</span>, error, SDImageCacheTypeNone, url);</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，在这一层，使用一个字典<code>operationDictionary</code>专门用作存储操作的缓存，随时添加，删除操作任务。<br>而这个字典是<code>UIView+WebCacheOperation</code>分类的关联对象，它的存取方法使用运行时来操作：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  UIView+WebCacheOperation.m ============== //</span></div><div class="line"> <span class="comment">//获取关联对象：operations（用来存放操作的字典）</span></div><div class="line">- (SDOperationsDictionary *)operationDictionary &#123;</div><div class="line">    SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line">    <span class="comment">//存放操作的字典</span></div><div class="line">    <span class="keyword">if</span> (operations) &#123;</div><div class="line">        <span class="keyword">return</span> operations;</div><div class="line">    &#125;    </div><div class="line">    <span class="comment">//如果没有，就新建一个</span></div><div class="line">    operations = [<span class="built_in">NSMutableDictionary</span> dictionary];    </div><div class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    <span class="keyword">return</span> operations;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>为什么不直接在<code>UIImageView+WebCache</code>里直接关联这个对象呢？我觉得这里作者应该是遵从面向对象的<strong>单一职责原则（SRP：Single responsibility principle）</strong>，就连类都要履行这个职责，何况分类呢？这里作者专门创造一个分类<code>UIView+WebCacheOperation</code>来管理操作缓存（字典）。</p>
</blockquote>
<p>到这里，<code>UIKit</code>层上面的东西都讲完了，现在开始正式讲解工具层。</p>
<h2 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h2><p>上文提到过，<code>SDWebImageManager</code>同时管理<code>SDImageCache</code>和<code>SDWebImageDownloader</code>两个类，它是这一层的<strong>老大哥</strong>。在下载任务开始的时候，<code>SDWebImageManager</code>首先访问<code>SDImageCache</code>来查询是否存在缓存，如果有缓存，直接返回缓存的图片。如果没有缓存，就命令<code>SDWebImageDownloader</code>来下载图片，下载成功后，存入缓存，显示图片。以上是<code>SDWebImageManager</code>大致的工作流程。</p>
<p>在详细讲解<code>SDWebImageManager</code>是如何下载图片之前，我们先看一下这个类的几个重要的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageManager.h ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDImageCache *imageCache;<span class="comment">//管理缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) SDWebImageDownloader <span class="comment">//下载器*imageDownloader;</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableSet</span>&lt;<span class="built_in">NSURL</span> *&gt; *failedURLs;<span class="comment">//记录失效url的名单</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableArray</span>&lt;SDWebImageCombinedOperation *&gt; *runningOperations;<span class="comment">//记录当前正在执行的操作</span></div></pre></td></tr></table></figure>
<p><code>SDWebImageManager</code>下载图片的方法只有一个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[SDWebImageManager.sharedManager loadImageWithURL:options:progress:completed:]</div></pre></td></tr></table></figure>
<p>看一下这个方法的具体实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageManager.m ============== //</span></div><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">     ...                             </div><div class="line">    <span class="comment">//在SDImageCache里查询是否存在缓存的图片</span></div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;        </div><div class="line">        ...</div><div class="line">        <span class="comment">//（没有缓存图片） || （即使有缓存图片，也需要更新缓存图片） || （代理没有响应imageManager:shouldDownloadImageForURL:消息，默认返回yes，需要下载图片）|| （imageManager:shouldDownloadImageForURL:返回yes，需要下载图片）</span></div><div class="line">        <span class="keyword">if</span> ((!cachedImage || options &amp; SDWebImageRefreshCached) &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url])) &#123;            </div><div class="line">            <span class="comment">//1. 存在缓存图片 &amp;&amp; 即使有缓存图片也要下载更新图片</span></div><div class="line">            <span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:weakOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 2. 如果不存在缓存图片</span></div><div class="line">            ...            </div><div class="line">            <span class="comment">//开启下载器下载</span></div><div class="line">            <span class="comment">//subOperationToken 用来标记当前的下载任务，便于被取消</span></div><div class="line">            SDWebImageDownloadToken *subOperationToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">                    <span class="comment">// 1. 如果任务被取消，则什么都不做，避免和其他的completedBlock重复</span></div><div class="line">                </div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//2. 如果有错误</span></div><div class="line">                    <span class="comment">//2.1 在completedBlock里传入error</span></div><div class="line">                    [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock error:error url:url];</div><div class="line"></div><div class="line">							<span class="comment">//2.2 在错误url名单中添加当前的url</span></div><div class="line">                    <span class="keyword">if</span> (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></div><div class="line">                        &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span>) &#123;</div><div class="line">                        </div><div class="line">                       <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs addObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> &#123;</div><div class="line">                    </div><div class="line">                    <span class="comment">//3. 下载成功</span></div><div class="line">                    <span class="comment">//3.1 如果需要下载失败后重新下载，则将当前url从失败url名单里移除</span></div><div class="line">                    <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">                        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                            [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="comment">//3.2 进行缓存</span></div><div class="line">                    <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);                   </div><div class="line">                    <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">                    </div><div class="line">                        <span class="comment">//（即使缓存存在，也要刷新图片） &amp;&amp; 缓存图片 &amp;&amp; 不存在下载后的图片：不做操作</span></div><div class="line">                                           </div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">                        </div><div class="line">          <span class="comment">//（下载图片成功 &amp;&amp; （没有动图||处理动图） &amp;&amp; （下载之后，缓存之前处理图片）               dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span></div><div class="line">                            <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line"></div><div class="line">                            <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                                <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">                                <span class="comment">//缓存图片</span></div><div class="line">                                [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:(imageWasTransformed ? <span class="literal">nil</span> : downloadedData) forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                            &#125;</div><div class="line">                            <span class="comment">//将图片传入completedBlock</span></div><div class="line">                            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:transformedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                        &#125;);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        </div><div class="line">                        <span class="comment">//(图片下载成功并结束)</span></div><div class="line">                        <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                            [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">					 <span class="comment">//如果完成，从当前运行的操作列表里移除当前操作</span></div><div class="line">                <span class="keyword">if</span> (finished) &#123;</div><div class="line">                    [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">            </div><div class="line">            <span class="comment">//取消的block</span></div><div class="line">            operation.cancelBlock = ^&#123;</div><div class="line">            </div><div class="line">                <span class="comment">//取消当前的token</span></div><div class="line">                [<span class="keyword">self</span>.imageDownloader cancel:subOperationToken];</div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">                <span class="comment">//从当前运行的操作列表里移除当前操作</span></div><div class="line">                [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            &#125;;</div><div class="line">        </div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">            </div><div class="line">            <span class="comment">//存在缓存图片</span></div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;            </div><div class="line">            <span class="comment">//调用完成的block</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];            </div><div class="line">            <span class="comment">//删去当前的的下载操作（线程安全）</span></div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];        </div><div class="line">        &#125; <span class="keyword">else</span> &#123;            </div><div class="line">            <span class="comment">//没有缓存的图片，而且下载被代理终止了</span></div><div class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">           </div><div class="line">            <span class="comment">// 调用完成的block</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:<span class="literal">YES</span> url:url];            </div><div class="line">            <span class="comment">//删去当前的下载操作</span></div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:operation];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;                                                             </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看完了<code>SDWebImageManager</code>的回调处理，我们分别看一下<br><code>SDImageCache</code>和<code>SDWebImageDownloader</code>内部具体是如何工作的。首先看一下<code>SDImageCache</code>：</p>
<h3 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSCache</span> *memCache;<span class="comment">//内存缓存</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSString</span> *diskCachePath;<span class="comment">//磁盘缓存路径</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSString</span> *&gt; *customPaths;<span class="comment">//</span></div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> <span class="comment">//ioQueue唯一子线程;</span></div></pre></td></tr></table></figure>
<h4 id="核心方法：查询缓存"><a href="#核心方法：查询缓存" class="headerlink" title="核心方法：查询缓存"></a>核心方法：查询缓存</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDImageCache.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;   </div><div class="line">    <span class="keyword">if</span> (!key) &#123;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;		</div><div class="line">    <span class="comment">//================查看内存的缓存=================//</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];    </div><div class="line">    <span class="comment">// 如果存在，直接调用block，将image，data，CaheType传进去</span></div><div class="line">    <span class="keyword">if</span> (image) &#123;    </div><div class="line">        <span class="built_in">NSData</span> *diskData = <span class="literal">nil</span>;        </div><div class="line">        <span class="comment">//如果是gif，就拿到data，后面要传到doneBlock里。不是gif就传nil</span></div><div class="line">        <span class="keyword">if</span> ([image isGIF]) &#123;</div><div class="line">            diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">        &#125;        </div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, diskData, SDImageCacheTypeMemory);</div><div class="line">        &#125;        </div><div class="line">        <span class="comment">//因为图片有缓存可供使用，所以不用实例化NSOperation，直接范围nil</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//================查看磁盘的缓存=================//</span></div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];    </div><div class="line">    <span class="comment">//唯一的子线程：self.ioQueue</span></div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;        </div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// 在用之前就判断operation是否被取消了，作者考虑的非常严谨</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;            </div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];            </div><div class="line">            <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                  <span class="comment">// cost 被用来计算缓存中所有对象的代价。当内存受限或者所有缓存对象的总代价超过了最大允许的值时，缓存会移除其中的一些对象。</span></div><div class="line">                <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);                </div><div class="line">                <span class="comment">//存入内存缓存中</span></div><div class="line">                [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    doneBlock(diskImage, diskData, SDImageCacheTypeDisk);</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h3><h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSOperationQueue</span> *downloadQueue;<span class="comment">//下载队列</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *lastAddedOperation;<span class="comment">//最后添加的下载操作</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) Class operationClass;<span class="comment">//操作类</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, SDWebImageDownloaderOperation *&gt; *URLOperations;<span class="comment">//操作数组</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDHTTPHeadersMutableDictionary *HTTPHeaders;<span class="comment">//HTTP请求头</span></div><div class="line"><span class="keyword">@property</span> (SDDispatchQueueSetterSementics, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">dispatch_queue_t</span> barrierQueue;<span class="comment">//用来阻塞前面的下载线程（串行化）</span></div></pre></td></tr></table></figure>
<h4 id="核心方法：下载图片"><a href="#核心方法：下载图片" class="headerlink" title="核心方法：下载图片"></a>核心方法：下载图片</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        </div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">        </div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">        </div><div class="line">        <span class="comment">//创建下载请求</span></div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url cachePolicy:(options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>) timeoutInterval:timeoutInterval];</div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself.HTTPHeaders <span class="keyword">copy</span>]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.HTTPHeaders;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//创建下载操作：SDWebImageDownloaderOperation用于请求网络资源的操作，它是一个 NSOperation 的子类</span></div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="comment">//url证书</span></div><div class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">//优先级</span></div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//在下载队列里添加下载操作，执行下载操作</span></div><div class="line">        [sself.downloadQueue addOperation:operation];</div><div class="line">        </div><div class="line">        <span class="comment">//如果后进先出</span></div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            <span class="comment">//addDependency:参数opertaion倍添加到NSOperationQueue后，只有等该opertion结束后才能执行其他的operation，实现了后进先出</span></div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面还有一个<code>addProgressCallback: progressBlock: completedBlock: forURL: createCallback:</code>方法，用来保存<code>progressBlock</code>和<code>completedBlock</code>。我们看一下这个方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"> <span class="comment">// ==============  SDWebImageDownloader.m ============== //</span></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)())createCallback &#123;</div><div class="line"></div><div class="line">    <span class="comment">// url 用来作为回调字典的key，如果为空，立即返回失败 </span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    __block SDWebImageDownloadToken *token = <span class="literal">nil</span>;</div><div class="line">    <span class="comment">//串行化前面所有的操作</span></div><div class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.barrierQueue, ^&#123;    </div><div class="line">        	<span class="comment">//当前下载操作中取出SDWebImageDownloaderOperation实例</span></div><div class="line">        SDWebImageDownloaderOperation *operation = <span class="keyword">self</span>.URLOperations[url];        </div><div class="line">        <span class="keyword">if</span> (!operation) &#123;</div><div class="line">        <span class="comment">//如果没有，就初始化它</span></div><div class="line">            operation = createCallback();</div><div class="line">            <span class="keyword">self</span>.URLOperations[url] = operation;</div><div class="line">            __<span class="keyword">weak</span> SDWebImageDownloaderOperation *woperation = operation;</div><div class="line">            </div><div class="line">            operation.completionBlock = ^&#123;</div><div class="line">              SDWebImageDownloaderOperation *soperation = woperation;</div><div class="line">              <span class="keyword">if</span> (!soperation) <span class="keyword">return</span>;</div><div class="line">              <span class="keyword">if</span> (<span class="keyword">self</span>.URLOperations[url] == soperation) &#123;</div><div class="line">                  [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">              &#125;;</div><div class="line">            &#125;;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">        <span class="comment">//这里 downloadOperationCancelToken 默认是一个字典，存放 progressBlock 和 completedBlock</span></div><div class="line">        token = [SDWebImageDownloadToken new];</div><div class="line">        token.url = url;</div><div class="line">        token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> token;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里真正保存两个block的方法是<code>addHandlersForProgress: completed:</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)addHandlersForProgress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                            completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    <span class="comment">//实例化一个SDCallbacksDictionary，存放一个progressBlock 和 completedBlock</span></div><div class="line">    SDCallbacksDictionary *callbacks = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">    <span class="keyword">if</span> (progressBlock) callbacks[kProgressCallbackKey] = [progressBlock <span class="keyword">copy</span>];</div><div class="line">    <span class="keyword">if</span> (completedBlock) callbacks[kCompletedCallbackKey] = [completedBlock <span class="keyword">copy</span>];</div><div class="line">    dispatch_barrier_async(<span class="keyword">self</span>.barrierQueue, ^&#123;</div><div class="line">        <span class="comment">//添加到缓存中 self.callbackBlocks</span></div><div class="line">        [<span class="keyword">self</span>.callbackBlocks addObject:callbacks];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> callbacks;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里<code>SDWebImage</code>的核心方法都讲解完毕了，其他没有讲到的部分以后会慢慢添加上去。</p>
<h2 id="最后看一下一些比较零散的知识点："><a href="#最后看一下一些比较零散的知识点：" class="headerlink" title="最后看一下一些比较零散的知识点："></a>最后看一下一些比较零散的知识点：</h2><hr>
<h4 id="1-运行时存取关联对象："><a href="#1-运行时存取关联对象：" class="headerlink" title="1. 运行时存取关联对象："></a>1. 运行时存取关联对象：</h4><p><strong>存：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">objc_setAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey, operations, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line"><span class="comment">//将operations对象关联给self，地址为&amp;loadOperationKey，语义是OBJC_ASSOCIATION_RETAIN_NONATOMIC。</span></div></pre></td></tr></table></figure>
<p><strong>取：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SDOperationsDictionary *operations = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;loadOperationKey);</div><div class="line"><span class="comment">//将operations对象通过地址&amp;loadOperationKey从self里取出来</span></div></pre></td></tr></table></figure>
<h4 id="2-数组的写操作需要加锁（多线程访问，避免覆写）"><a href="#2-数组的写操作需要加锁（多线程访问，避免覆写）" class="headerlink" title="2. 数组的写操作需要加锁（多线程访问，避免覆写）"></a>2. 数组的写操作需要加锁（多线程访问，避免覆写）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//给self.runningOperations加锁</span></div><div class="line"><span class="comment">//self.runningOperations数组的添加操作</span></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div><div class="line"><span class="comment">//self.runningOperations数组的删除操作</span></div><div class="line">- (<span class="keyword">void</span>)safelyRemoveOperationFromRunning:(<span class="keyword">nullable</span> SDWebImageCombinedOperation*)operation &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        <span class="keyword">if</span> (operation) &#123;</div><div class="line">            [<span class="keyword">self</span>.runningOperations removeObject:operation];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-确保在主线程的宏："><a href="#3-确保在主线程的宏：" class="headerlink" title="3. 确保在主线程的宏："></a>3. 确保在主线程的宏：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">dispatch_main_async_safe(^&#123;</div><div class="line"> 				 <span class="comment">//将下面这段代码放在主线程中</span></div><div class="line">            [<span class="keyword">self</span> sd_setImage:placeholder imageData:<span class="literal">nil</span> basedOnClassOrViaCustomSetImageBlock:setImageBlock];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line"><span class="comment">//宏定义：</span></div><div class="line"><span class="meta">#define dispatch_main_async_safe(block)\</span></div><div class="line">    <span class="keyword">if</span> (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == <span class="number">0</span>) &#123;\</div><div class="line">        block();\</div><div class="line">    &#125; <span class="keyword">else</span> &#123;\</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), block);\</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div></pre></td></tr></table></figure>
<h4 id="4-设置不能为nil的参数"><a href="#4-设置不能为nil的参数" class="headerlink" title="4. 设置不能为nil的参数"></a>4. 设置不能为nil的参数</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithCache:(<span class="keyword">nonnull</span> SDImageCache *)cache downloader:(<span class="keyword">nonnull</span> SDWebImageDownloader *)downloader &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        _imageCache = cache;</div><div class="line">        _imageDownloader = downloader;</div><div class="line">        _failedURLs = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">        _runningOperations = [<span class="built_in">NSMutableArray</span> new];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果在参数里添加了nonnull关键字，那么编译器就可以检查传入的参数是否为nil，如果是，则编译器会有警告</p>
</blockquote>
<h4 id="5-容错，强制转换类型"><a href="#5-容错，强制转换类型" class="headerlink" title="5. 容错，强制转换类型"></a>5. 容错，强制转换类型</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</div><div class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在传入的参数为NSString时（但是方法参数要求是NSURL），自动转换为NSURL</p>
</blockquote>
<hr>
<p>貌似还有图片解码等内容没有详细看，以后会逐渐补充哒～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信对于广大的iOS开发者，对&lt;a href=&quot;https://github.com/rs/SDWebImage&quot;&gt;SDWebImage&lt;/a&gt;并不会陌生，这个框架通过给UIImageView和UIButton添加分类，实现一个异步下载图片并且支持缓存的功能。整个框架的接口非常简洁，每个类的分工都很明确，是很值得大家学习的。&lt;/p&gt;
&lt;p&gt;在使用这个框架的时候，只需要提供一个下载的url和占位图就可以在回调里拿到下载后的图片：&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;] placeholderImage:[&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; imageNamed:&lt;span class=&quot;string&quot;&gt;@&quot;placeholder&quot;&lt;/span&gt;] completed:^(&lt;span class=&quot;built_in&quot;&gt;UIImage&lt;/span&gt; * _Nullable image, &lt;span class=&quot;built_in&quot;&gt;NSError&lt;/span&gt; * _Nullable error, SDImageCacheType cacheType, &lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; * _Nullable imageURL) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        imageview.image = image;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;NSLog&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;@&quot;图片加载完成&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;而且我们还可以不设置占位图片，也可以不使用回调的block，非常灵活:&lt;/p&gt;
&lt;figure class=&quot;highlight objc&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//图片下载完成后直接显示下载后的图片&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;[imageview sd_setImageWithURL:[&lt;span class=&quot;built_in&quot;&gt;NSURL&lt;/span&gt; URLWithString:&lt;span class=&quot;string&quot;&gt;@&quot;pic.jpg&quot;&lt;/span&gt;]];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在最开始先简单介绍这个框架：&lt;/p&gt;
&lt;p&gt;这个框架的核心类是&lt;code&gt;SDWebImageManger&lt;/code&gt;，在外部有&lt;code&gt;UIImageView+WebCache&lt;/code&gt; 和 &lt;code&gt;UIButton+WebCache&lt;/code&gt; 为下载图片的操作提供接口。内部有&lt;code&gt;SDWebImageManger&lt;/code&gt;负责处理和协调 &lt;code&gt;SDWebImageDownloader&lt;/code&gt; 和 &lt;code&gt;SDWebImageCache&lt;/code&gt;：&lt;code&gt;SDWebImageDownloader&lt;/code&gt;负责具体的下载任务，&lt;code&gt;SDWebImageCache&lt;/code&gt;负责关于缓存的工作：添加，删除，查询缓存。&lt;/p&gt;
&lt;p&gt;首先我们大致看一下这个框架的调用流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-7ad6493a2b2f0b43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;SDWebImage&quot;&gt;&lt;/p&gt;
&lt;p&gt;从这个流程图里可以大致看出，该框架分为两个层：UIKit层（负责接收下载参数）和工具层（负责下载操作和缓存）。&lt;/p&gt;
&lt;p&gt;OK～基本流程大概清楚了，我们看一下每个层具体实现吧～&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MBProgressHUD源码解析</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/17/MBProgressHUD%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/17/MBProgressHUD源码解析/</id>
    <published>2017-01-17T09:02:54.000Z</published>
    <updated>2017-03-20T07:56:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的<strong>读好源码Project</strong>。</p>
<p>从哪个框架开始呢？我想到了<code>SDWebImage</code>，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～</p>
<p>找着找着就找到了<code>MBProgressHUD</code>，这个框架只有两个文件，一个头文件和一个实现文件，很适合我现在的水平（对于一个没怎么读过源码的选手），于是就撸起了袖子开始了。</p>
<p>连查知识点带记笔记一共花了大概3个小时（虽然文件很少，但是里面好多东西都不知道[捂脸]）。整体说来，收获还是比较大的，除了一些零碎的语法之外，框架作者对于代码结构的设计和各种情况的考虑还是很出色的，很值得学习，而且我在下文也有介绍。</p>
<p>这篇总结主要分三个部分来介绍这个框架：</p>
<ol>
<li>核心Public API</li>
<li>方法调用流程图</li>
<li>方法内部实现</li>
</ol>
<p>不多说了，开始吧～</p>
<a id="more"></a>
<h2 id="1-核心Public-API"><a href="#1-核心Public-API" class="headerlink" title="1. 核心Public API"></a>1. 核心Public API</h2><h3 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDMode mode;<span class="comment">//HUD的类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) MBProgressHUDAnimation animationType <span class="built_in">UI_APPEARANCE_SELECTOR</span>;<span class="comment">//动画类型</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> graceTime;<span class="comment">//show函数触发到显示HUD的时间段</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimeInterval</span> minShowTime;<span class="comment">//HUD显示的最短时间</span></div></pre></td></tr></table></figure>
<h3 id="类方法："><a href="#类方法：" class="headerlink" title="类方法："></a>类方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 在某个view上添加HUD并显示</div><div class="line"> *</div><div class="line"> * 注意：显示之前，先去掉在当前view上显示的HUD。这个做法很严谨，我们将这个方案抽象出来：如果一个模型是这样的：我们需要将A加入到B中，但是需求上B里面只允许只有一个A。那么每次将A添加到B之前，都要先判断当前的b里面是否有A，如果有，则移除。</div><div class="line"> */</div><div class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 找到某个view上最上层的HUD并隐藏它。</div><div class="line"> * 如果返回值是YES的话，就表明HUD被找到而且被移除了。</div><div class="line"> */</div><div class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/**</span></div><div class="line"> * 在某个view上找到最上层的HUD并返回它。</div><div class="line"> * 返回值可以是空，所以返回值的关键字为：nullable</div><div class="line"> */</div><div class="line">+ (<span class="keyword">nullable</span> MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view;</div></pre></td></tr></table></figure>
<h3 id="对象方法："><a href="#对象方法：" class="headerlink" title="对象方法："></a>对象方法：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个HUD的便利构造函数，用某个view来初始化HUD：这个view的bounds就是HUD的bounds</div><div class="line"> */</div><div class="line">- (<span class="keyword">instancetype</span>)initWithView:(<span class="built_in">UIView</span> *)view;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 显示HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 隐藏HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated;</div><div class="line"><span class="comment">/** </span></div><div class="line"> * 在delay的时间过后隐藏HUD，有无动画。</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated afterDelay:(<span class="built_in">NSTimeInterval</span>)delay;</div></pre></td></tr></table></figure>
<p>看完了这些比较主要的API，我们看一下方法调用的流程图：</p>
<h2 id="2-方法调用流程图："><a href="#2-方法调用流程图：" class="headerlink" title="2. 方法调用流程图："></a>2. 方法调用流程图：</h2><p>总体来说，这个第三方框架的接口还是比较整齐的，可以大致上分为两类：显示（show）和隐藏（hide）。而且无论是调用显示方法还是隐藏方法，最终都会走到私有方法<code>animateIn:withType: completion:</code>里（前提是附加动画效果）。可以看一下方法调用的流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-fe3f0f393bcc3b9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="方法调用流程图"></p>
<p>看完方法调用的结构之后，我们来具体看一下方法内部是如何实现的：</p>
<h2 id="3-方法内部实现："><a href="#3-方法内部实现：" class="headerlink" title="3. 方法内部实现："></a>3. 方法内部实现：</h2><p>在讲解API之前，有必要先介绍一下HUD使用的三个Timer。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *graceTimer; <span class="comment">//执行一次：在show方法触发后到HUD真正显示之前,前提是设定了graceTime，默认为0</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *minShowTimer;<span class="comment">//执行一次：在HUD显示后到HUD被隐藏之前</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="built_in">NSTimer</span> *hideDelayTimer;<span class="comment">//执行一次：在HUD被隐藏的方法触发后到真正隐藏之前</span></div></pre></td></tr></table></figure>
<ul>
<li>graceTimer：用来推迟HUD的显示。如果设定了graceTime，那么HUD会在<code>show</code>方法触发后的graceTime时间后显示。它的意义是：如果任务完成所消耗的时间非常短并且短于graceTime，则HUD就不会出现了，避免HUD一闪而过的差体验。</li>
<li>minShowTimer：如果设定了minShowTime，就会在<code>hide</code>方法触发后判断任务执行的时间是否短于minShowTime。因此即使任务在minShowTime之前完成了，HUD也不会立即消失，它会在走完minShowTime之后才消失，这应该也是避免HUD一闪而过的情况。</li>
<li>hideDelayTimer：用来推迟HUD的隐藏。如果设定了delayTime，那么在触发<code>hide</code>方法后HUD也不会立即隐藏，它会在走完delayTime之后才隐藏。</li>
</ul>
<p>这三者的关系可以由下面这张图来体现（并没有包含所有的情况）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c9f49bfcec64dd0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三种timer"></p>
<p>下面开始分别讲解<code>show</code>系列的方法和<code>hide</code>系列的方法。</p>
<h3 id="show系列方法"><a href="#show系列方法" class="headerlink" title="show系列方法"></a>show系列方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">instancetype</span>)showHUDAddedTo:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBProgressHUD *hud = [[<span class="keyword">self</span> alloc] initWithView:view];<span class="comment">// 接着调用 [self initWithFrame:view.bounds]：根据传进来的view的frame来设定自己的frame</span></div><div class="line">    hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;<span class="comment">//removeFromSuperViewOnHide 应该是一个标记，表明HUD自己处于“应该被移除的状态”</span></div><div class="line">    [view addSubview:hud];<span class="comment">//在view上将自己的实例添加上去</span></div><div class="line">    [hud showAnimated:animated];</div><div class="line">    <span class="keyword">return</span> hud;</div><div class="line">&#125;</div><div class="line"><span class="comment">//调用showAnimated：</span></div><div class="line">- (<span class="keyword">void</span>)showAnimated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBMainThreadAssert();</div><div class="line">    [<span class="keyword">self</span>.minShowTimer invalidate];<span class="comment">//取消当前的minShowTimer</span></div><div class="line">     <span class="keyword">self</span>.useAnimation = animated;<span class="comment">//设置animated状态</span></div><div class="line">     <span class="keyword">self</span>.finished = <span class="literal">NO</span>;<span class="comment">//添加标记：表明当前任务仍在进行</span></div><div class="line">    <span class="comment">// 如果设定了graceTime，就要推迟HUD的显示</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.graceTime &gt; <span class="number">0.0</span>) &#123;</div><div class="line">        <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.graceTime target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleGraceTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line">        <span class="keyword">self</span>.graceTimer = timer;</div><div class="line">    &#125; </div><div class="line">    <span class="comment">// ... otherwise show the HUD immediately</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//self.graceTimer触发的方法</span></div><div class="line">- (<span class="keyword">void</span>)handleGraceTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</div><div class="line">    <span class="comment">// Show the HUD only if the task is still running</span></div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.hasFinished) &#123;</div><div class="line">        [<span class="keyword">self</span> showUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//所有的show方法最终都会走到这个方法</span></div><div class="line">- (<span class="keyword">void</span>)showUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    <span class="comment">// Cancel any previous animations : 移走所有的动画</span></div><div class="line">    [<span class="keyword">self</span>.bezelView.layer removeAllAnimations];</div><div class="line">    [<span class="keyword">self</span>.backgroundView.layer removeAllAnimations];</div><div class="line">    <span class="comment">// Cancel any scheduled hideDelayed: calls :取消delay的timer</span></div><div class="line">    [<span class="keyword">self</span>.hideDelayTimer invalidate];</div><div class="line">    <span class="comment">//记忆开始的时间</span></div><div class="line">    <span class="keyword">self</span>.showStarted = [<span class="built_in">NSDate</span> date];</div><div class="line">    <span class="keyword">self</span>.alpha = <span class="number">1.</span>f;</div><div class="line">    <span class="comment">// Needed in case we hide and re-show with the same NSProgress object attached.</span></div><div class="line">    [<span class="keyword">self</span> setNSProgressDisplayLinkEnabled:<span class="literal">YES</span>];</div><div class="line">    <span class="keyword">if</span> (animated) &#123;        </div><div class="line">        [<span class="keyword">self</span> animateIn:<span class="literal">YES</span> withType:<span class="keyword">self</span>.animationType completion:<span class="literal">NULL</span>];   </div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//方法弃用警告</span></div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">        <span class="keyword">self</span>.bezelView.alpha = <span class="keyword">self</span>.opacity;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，无论是类方法的show方法，还是对象方法的show方法，而且无论是触发了<code>graceTimer</code>还是没有触发，最后都会走到<code>showUsingAnimation:</code>方法来让HUD显示出来。</p>
</blockquote>
<p>这里补充讲解一下NSProgress的监听方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setNSProgressDisplayLinkEnabled:(<span class="built_in">BOOL</span>)enabled &#123;</div><div class="line">    <span class="comment">// 这里使用 CADisplayLink 来刷新progress的变化。因为如果使用kvo机制来监听的话可能会非常消耗主线程（因为频率可能非常快）。</span></div><div class="line">    <span class="keyword">if</span> (enabled &amp;&amp; <span class="keyword">self</span>.progressObject) &#123;</div><div class="line">        <span class="comment">// Only create if not already active.</span></div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.progressObjectDisplayLink) &#123;</div><div class="line">            <span class="keyword">self</span>.progressObjectDisplayLink = [<span class="built_in">CADisplayLink</span> displayLinkWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(updateProgressFromProgressObject)];</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">//不刷新</span></div><div class="line">        <span class="keyword">self</span>.progressObjectDisplayLink = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>CADisplayLink是一个能让我们以和屏幕刷新率同步的频率将特定的内容画到屏幕上的定时器类。 CADisplayLink以特定模式注册到runloop后， 每当屏幕显示内容刷新结束的时候，runloop就会向 CADisplayLink指定的target发送一次指定的selector消息，  CADisplayLink类对应的selector就会被调用一次。<br>参考文章：<a href="http://www.tuicool.com/articles/meMVR3" target="_blank" rel="external">Core Animation系列之CADisplayLink</a></p>
</blockquote>
<h3 id="hide系列方法"><a href="#hide系列方法" class="headerlink" title="hide系列方法"></a>hide系列方法</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">BOOL</span>)hideHUDForView:(<span class="built_in">UIView</span> *)view animated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBProgressHUD *hud = [<span class="keyword">self</span> HUDForView:view];<span class="comment">//获取当前view的最前为止的HUD</span></div><div class="line">    <span class="keyword">if</span> (hud != <span class="literal">nil</span>) &#123;</div><div class="line">        hud.removeFromSuperViewOnHide = <span class="literal">YES</span>;</div><div class="line">        [hud hideAnimated:animated];</div><div class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div><div class="line">+ (MBProgressHUD *)HUDForView:(<span class="built_in">UIView</span> *)view &#123;   </div><div class="line">    <span class="built_in">NSEnumerator</span> *subviewsEnum = [view.subviews reverseObjectEnumerator]; <span class="comment">//倒叙排序</span></div><div class="line">    <span class="keyword">for</span> (<span class="built_in">UIView</span> *subview <span class="keyword">in</span> subviewsEnum) &#123;</div><div class="line">        <span class="keyword">if</span> ([subview isKindOfClass:<span class="keyword">self</span>]) &#123;</div><div class="line">            <span class="keyword">return</span> (MBProgressHUD *)subview;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)hideAnimated:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    MBMainThreadAssert();</div><div class="line">    [<span class="keyword">self</span>.graceTimer invalidate];</div><div class="line">     <span class="keyword">self</span>.useAnimation = animated;</div><div class="line">     <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">     <span class="comment">//如果设定了HUD最小显示时间，那就需要判断最小显示时间和已经经过的时间的大小</span></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span>.minShowTime &gt; <span class="number">0.0</span> &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</div><div class="line">        <span class="built_in">NSTimeInterval</span> interv = [[<span class="built_in">NSDate</span> date] timeIntervalSinceDate:<span class="keyword">self</span>.showStarted];</div><div class="line">        </div><div class="line">        <span class="comment">//如果最小显示时间比较大，则暂时不触发HUD的隐藏，而是启动一个timer，再经过二者的时间差的时间之后再触发隐藏</span></div><div class="line">        <span class="keyword">if</span> (interv &lt; <span class="keyword">self</span>.minShowTime) &#123;</div><div class="line">            <span class="built_in">NSTimer</span> *timer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:(<span class="keyword">self</span>.minShowTime - interv) target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(handleMinShowTimer:) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</div><div class="line">            [[<span class="built_in">NSRunLoop</span> currentRunLoop] addTimer:timer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</div><div class="line">            <span class="keyword">self</span>.minShowTimer = timer;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125; </div><div class="line">     &#125;</div><div class="line">    <span class="comment">//如果最小显示时间比较小，则立即将HUD隐藏</span></div><div class="line">    [<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">&#125;</div><div class="line"><span class="comment">//self.minShowTimer触发的方法</span></div><div class="line">- (<span class="keyword">void</span>)handleMinShowTimer:(<span class="built_in">NSTimer</span> *)theTimer &#123;</div><div class="line">    [<span class="keyword">self</span> hideUsingAnimation:<span class="keyword">self</span>.useAnimation];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)hideUsingAnimation:(<span class="built_in">BOOL</span>)animated &#123;</div><div class="line">    <span class="keyword">if</span> (animated &amp;&amp; <span class="keyword">self</span>.showStarted) &#123;</div><div class="line">        <span class="comment">//隐藏时，将showStarted设为nil</span></div><div class="line">        <span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</div><div class="line">        [<span class="keyword">self</span> animateIn:<span class="literal">NO</span> withType:<span class="keyword">self</span>.animationType completion:^(<span class="built_in">BOOL</span> finished) &#123;</div><div class="line">            [<span class="keyword">self</span> done];</div><div class="line">        &#125;];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.showStarted = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">self</span>.bezelView.alpha = <span class="number">0.</span>f;</div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = <span class="number">1.</span>f;</div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，无论是类方法的<code>hide</code>方法，还是对象方法的<code>hide</code>方法，而且无论是触发还是没有触发<code>minShowTimer</code>,最终都会走到<code>hideUsingAnimation</code>这个方法里。</p>
</blockquote>
<p>而无论是<code>show</code>方法，还是<code>hide</code>方法，在设定animated属性为YES的前提下，最终都会走到<code>animateIn: withType: completion:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)animateIn:(<span class="built_in">BOOL</span>)animatingIn withType:(MBProgressHUDAnimation)type completion:(<span class="keyword">void</span>(^)(<span class="built_in">BOOL</span> finished))completion &#123;</div><div class="line">    <span class="comment">// Automatically determine the correct zoom animation type</span></div><div class="line">    <span class="keyword">if</span> (type == MBProgressHUDAnimationZoom) &#123;</div><div class="line">        type = animatingIn ? MBProgressHUDAnimationZoomIn : MBProgressHUDAnimationZoomOut;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//()内代表x和y方向缩放倍数</span></div><div class="line">    <span class="built_in">CGAffineTransform</span> small = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</div><div class="line">    <span class="built_in">CGAffineTransform</span> large = <span class="built_in">CGAffineTransformMakeScale</span>(<span class="number">1.5</span>f, <span class="number">1.5</span>f);</div><div class="line">    <span class="comment">// 设定初始状态</span></div><div class="line">    <span class="built_in">UIView</span> *bezelView = <span class="keyword">self</span>.bezelView;</div><div class="line">    <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</div><div class="line">        bezelView.transform = small;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animatingIn &amp;&amp; bezelView.alpha == <span class="number">0.</span>f &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</div><div class="line">        bezelView.transform = large;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 创建动画任务</span></div><div class="line">    dispatch_block_t animations = ^&#123;</div><div class="line">        <span class="keyword">if</span> (animatingIn) &#123;</div><div class="line">            bezelView.transform = <span class="built_in">CGAffineTransformIdentity</span>;<span class="comment">//重置</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomIn) &#123;</div><div class="line">            bezelView.transform = large;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!animatingIn &amp;&amp; type == MBProgressHUDAnimationZoomOut) &#123;</div><div class="line">            bezelView.transform = small;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wdeprecated-declarations"</span></span></div><div class="line">        bezelView.alpha = animatingIn ? <span class="keyword">self</span>.opacity : <span class="number">0.</span>f;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">       <span class="comment">//如果animatingIn是true，就是show方法，否则是hide方法</span></div><div class="line">        <span class="keyword">self</span>.backgroundView.alpha = animatingIn ? <span class="number">1.</span>f : <span class="number">0.</span>f;</div><div class="line">    &#125;;</div><div class="line">    <span class="comment">// Spring animations are nicer, but only available on iOS 7+</span></div><div class="line"><span class="meta">#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= 70000 || TARGET_OS_TV</span></div><div class="line">    <span class="keyword">if</span> (kCFCoreFoundationVersionNumber &gt;= kCFCoreFoundationVersionNumber_iOS_7_0) &#123;</div><div class="line">        <span class="comment">//执行动画 &gt;= iOS7</span></div><div class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> usingSpringWithDamping:<span class="number">1.</span>f initialSpringVelocity:<span class="number">0.</span>f options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">    [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.3</span> delay:<span class="number">0.</span> options:<span class="built_in">UIViewAnimationOptionBeginFromCurrentState</span> animations:animations completion:completion];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>除了一些细节上的语法之外，我觉得该框架有几个地方值得我们借鉴：</p>
<ol>
<li>暴露出来的API最终都会走到同一个私有方法里。</li>
<li>将真正显示的时间的前后加上缓冲的时间（graceTimer 和 hideDelayTimer），可以提高可定制性和稳定性。</li>
<li>如果有两个方法是矛盾的，并且可以同时调用，就需要在全局设置一个属性来判断当前的状态（removeFromSuperViewOnHide属性，finished属性）</li>
<li>使用CADisplayLink来刷新更新频率可能很高的view。</li>
<li>使用NSAssert来捕获各种异常。</li>
</ol>
<p>就这样大致写完了，没有怎么读过第三方框架的源码，所以第一次可能显得稍许不足。有不好的地方还希望多多指点哈～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;听过好多次：“程序员要通过多读好的源码来提升自己”这样类似的话，而且又觉得自己有很多不会的，于是就马上启动了自己的&lt;strong&gt;读好源码Project&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从哪个框架开始呢？我想到了&lt;code&gt;SDWebImage&lt;/code&gt;，但是大致看下来文件很多，代码也不少，不知道从何看起，于是作罢。所以茅塞顿开，还是从最最简单的框架开始吧～因为学习曲线要给自己设定得平缓一点才有利于稳步提升，小步快跑才是王道～&lt;/p&gt;
&lt;p&gt;找着找着就找到了&lt;code&gt;MBProgressHUD&lt;/code&gt;，这个框架只有两个文件，一个头文件和一个实现文件，很适合我现在的水平（对于一个没怎么读过源码的选手），于是就撸起了袖子开始了。&lt;/p&gt;
&lt;p&gt;连查知识点带记笔记一共花了大概3个小时（虽然文件很少，但是里面好多东西都不知道[捂脸]）。整体说来，收获还是比较大的，除了一些零碎的语法之外，框架作者对于代码结构的设计和各种情况的考虑还是很出色的，很值得学习，而且我在下文也有介绍。&lt;/p&gt;
&lt;p&gt;这篇总结主要分三个部分来介绍这个框架：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;核心Public API&lt;/li&gt;
&lt;li&gt;方法调用流程图&lt;/li&gt;
&lt;li&gt;方法内部实现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不多说了，开始吧～&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
      <category term="源码解析" scheme="https://github.com/knightsj/knightsj.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>2016年终总结 | 善于总结，把握方向</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93%20%7C%20%E5%96%84%E4%BA%8E%E6%80%BB%E7%BB%93%EF%BC%8C%E6%8A%8A%E6%8F%A1%E6%96%B9%E5%90%91/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/2016年终总结 | 善于总结，把握方向/</id>
    <published>2017-01-13T05:55:17.000Z</published>
    <updated>2017-03-20T07:51:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>记得去年这个时候看到很多同行写了年终总结，当时只工作了1个月的我觉得很是高大上。转眼一年过去了，从第一家公司来到现在的这家公司，无论技术上还是思想上都成熟了一些，巧的是简书在这个时候给我们这个平台来写年终总结。贵在参与，也为了自己，写一篇吧～</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-88a964d0151cb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GoodBye 2016，Welcome 2017"></p>
<p>2016年，是我事业起步的第一年，现在回头看去，这一年大致分为五个时期：</p>
<ol>
<li><strong>技术基础建设期（1月～5月）</strong>：从iOS小白的小白到独立上线app。</li>
<li><strong>技术快速成长期（6月～9月）</strong>：简书更新30篇文章，粉丝达到1000+。</li>
<li><strong>写简历找工作期（10月）</strong>：8家面试，3个offer。</li>
<li><strong>适应新的公司期（11月）</strong>：新项目1个月内上架。</li>
<li><strong>明年方向定位期（12月）</strong>：决定研究Hybrid app开发。</li>
</ol>
<p>下面开始按时间顺序分别总结一下每个时期里我的所做所思。</p>
<a id="more"></a>
<h2 id="基础形成期：2016年1月～5月"><a href="#基础形成期：2016年1月～5月" class="headerlink" title="基础形成期：2016年1月～5月"></a>基础形成期：2016年1月～5月</h2><hr>
<p>我的第一份工作就是iOS开发，从2015年11月入职，熟悉了一段时间的项目代码，在12月份又接了一段时间的测试工作，所以真正开始做iOS的时间应该是今年的1月份。</p>
<p>从开始接手简单的需求到独立负责完成前公司第二个项目上线一共经历了5个月的时间，在这个阶段里，我从一个连UITableView的代理都不怎么会用的小白中的小白逐渐成长为一个独立负责app上线的小白。</p>
<p>由于开始的时候基础太差，每天都累得不行，因为当时的我，就算一个特别小的问题都要去问谷哥或者度娘，所以几乎每天都去无止境地在浏览器里输入问题，搜索问题的答案，几乎每天都有记录下来的代码段，几乎每天都有需要改的bug（因为自己之前代码写的不好需要重写）。</p>
<p>我记得当时为了赶上进度，不给大家拖后腿，每天经常是2点之后睡觉，觉得代码可以了就在家里上传代码。而且因为用眼过度+用脑过度，有时会眼睛疼，头疼，甚至偶尔在睡觉之前眼睛看东西的时候出现了散光的情况。</p>
<p>在前公司的主项目在渡过了两次迭代之后，也就是今年3月份的时候，紧接着要上线一个新的小项目，而iOS端开发的任务就落在我的头上。虽然伴随着各种懵逼，各种恐惧，但我还是欣然接受的，因为像这种突破舒适区的事情还是接下来为好，我心里还是知道这是一个难得的锻炼自己的机会。</p>
<p>可能也是因为这个项目还是比较简单，而且一些功能集成了第三方的SDK，在开发的时候渐渐没有显得那么吃力了。但我仍然记得很清楚地记得有好几个夜晚是自己最后从公司走出去的，因为当时安卓那边是有两个人一起做这个项目，而且接口也比较简单，后端的童鞋也比较轻松。</p>
<p>到最后结果还是不错的，我这里结束得没有比计划晚，而且比安卓提早开发完毕了。当时看着app store里自己开发的app上线了，心里还是很开心的，毕竟对于一个工作刚半年的人来说，这个机会挺难得的，而且我把握的还算不错。</p>
<blockquote>
<p>这个时期应该是我成长得最痛苦的时期，因为在这个阶段里，我经历了iOS开发的“从0到1”的阶段，也可以理解为骑自行车的“第一蹬”。也就是，我“上路”了。</p>
</blockquote>
<h2 id="快速成长期：2016年6月～9月"><a href="#快速成长期：2016年6月～9月" class="headerlink" title="快速成长期：2016年6月～9月"></a>快速成长期：2016年6月～9月</h2><hr>
<p>虽然说程序员需要自学，但是以我之前的水平，只是搞懂公司现有的代码，完成项目需求就已经耗尽了我所有的休息时间，几乎没有其他的时间用来学习。</p>
<p>但是经过了近半年的历练，对公司业务的驾轻就熟了。在开发公司项目后，余下的自己的时间越来越多了，于是就找一些资料进行学习。在这段时间里，我的学习成果主要包括两个：</p>
<h4 id="1-第一个成果：简书博客"><a href="#1-第一个成果：简书博客" class="headerlink" title="1. 第一个成果：简书博客"></a>1. 第一个成果：简书博客</h4><p>我的学习方式是采取以：<strong>“面向博客学习”</strong>的学习方法。</p>
<ul>
<li>具体说来就是：将学习到的东西进行反复总结，能达到让任何人看懂的水准。</li>
<li>它的核心思想：能让其他人理解了自己才算是理解。</li>
<li>最后总结一句就是：笔记即博客（笔记总结完了就直接能到发布博客的水准）。</li>
</ul>
<p>除了能更好地理解知识，我认为分享技术的好处还有：</p>
<ol>
<li>认识一些优秀的同行（神交的基友）：<a href="http://www.jianshu.com/users/e39da354ce50/latest_articles" target="_blank" rel="external">神经骚栋</a> | <a href="http://www.jianshu.com/users/c68741efc396/latest_articles" target="_blank" rel="external">熊皮皮</a> | <a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a> | <a href="http://www.jianshu.com/users/a54931de4c9b/latest_articles" target="_blank" rel="external">阿拉斯加的狗</a> |<a href="http://www.jianshu.com/users/bfb3a06ce1cd/latest_articles" target="_blank" rel="external">小菜一碟321</a> 。</li>
<li>有时会有人指出博客里的错误或者提出一些更好的建议。</li>
</ol>
<p><strong>以下是我分享的其中三个专题：</strong></p>
<ul>
<li><p><a href="http://www.jianshu.com/notebooks/4747753/latest" target="_blank" rel="external">斯坦福公开课（18节课的所有课程的总结和Demo）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/notebooks/6074358/latest" target="_blank" rel="external">《Effective Objective-C》 超级干货三部曲（重整全书的精华部分）</a></p>
</li>
<li><p><a href="http://www.jianshu.com/notebooks/3482176/latest" target="_blank" rel="external">读书笔记 - 程序员素养（《高效能程序员的修炼》等书的读书总结）</a></p>
</li>
</ul>
<p><strong>还有几篇质量不是很低的文章：</strong></p>
<ul>
<li><a href="http://www.jianshu.com/p/7702f58be845" target="_blank" rel="external">高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息</a></li>
<li><a href="http://www.jianshu.com/p/bf5c0e462119" target="_blank" rel="external">详解 iOS 多图下载的缓存机制</a></li>
<li><a href="http://www.jianshu.com/p/6e74f5438f2c" target="_blank" rel="external">最浅显易懂的iOS多线程技术 - GCD的教程</a></li>
</ul>
<h4 id="2-第二个成果：开源库"><a href="#2-第二个成果：开源库" class="headerlink" title="2. 第二个成果：开源库"></a>2. 第二个成果：开源库</h4><p>哎呀，说出来都不好意思，因为这个库很简单的。但是因为是写总结嘛，就要面面俱到，虽然贴出来大家能看，但是总结毕竟还是给自己写的。</p>
<p>这个开源框架主要封装了一下iOS的FMDB框架，用来操作本地数据库的。因为之前公司的需求总是和多用户的用户信息离不开，所以就想写一个可以随时增删改查多个用户信息的数据库，我记得当时想法出来以后，从写代码到上传到Github，连续写了10个小时，天都亮了，额。</p>
<p>最后还是附上传送门：<a href="https://github.com/knightsj/SJUserInfoManager">GitHub:SJUserInfoManager</a></p>
<blockquote>
<p>这个阶段是我成长得最快的时期，基本完成了从菜鸟到新手的升级。更让人欣慰的是，我的成长历程留在了简书博客里，它是可见的，也为我下阶段换公司打下了基础（因为都体现在了简历里，为我的求职添加了砝码）。</p>
</blockquote>
<h2 id="3-找工作期：10月。"><a href="#3-找工作期：10月。" class="headerlink" title="3. 找工作期：10月。"></a>3. 找工作期：10月。</h2><hr>
<p>由于上家公司前景不是很理想，渐渐地，很多人都离开了，而且项目需求也渐渐变成修边幅的那种，于是我也为自己打算，准备换一家公司。</p>
<p>准备简历和找工作的经历就不赘述了，大家可以看我上一篇文章，详细地介绍了10月份找工作的心路历程：<br><a href="http://www.jianshu.com/p/087027dcc942" target="_blank" rel="external">2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer</a></p>
<p>这篇文章可能由于标题起的还不错，而且我写的也比较实在，阅读量已经4000+了，我记得当时一个上午不到3个小时就已经超过2000了，而且留言也有很多，我也逐一认真回复，因为我真心很想帮助那些有疑问的同行，让他们少走弯路。</p>
<blockquote>
<p>如果还是要在这里总结一下这段经历的感受的话，我想说的是：<strong>人要凭做出来的东西说话，其余的都是虚的。如果有，该出手时就出手；如果没有，低着头，沉住气，把它做出来</strong>。</p>
</blockquote>
<h2 id="4-适应新公司期：11月"><a href="#4-适应新公司期：11月" class="headerlink" title="4. 适应新公司期：11月"></a>4. 适应新公司期：11月</h2><hr>
<p>工作找了一个月之后，在11月来到了新公司，这里的规模比上一家大一些，技术团队60+人，仅iOS端就有10个人，除了我之外几乎都是2年以上工作经验的（是的，我很幸运），而且其中也有会PHP的，会Java的，会Javascript的iOS，感觉自己只会做iOS好low啊～～</p>
<p>刚进入公司后，就和另外一名新进来的iOS开发者联手负责了一个新项目，这个新项目需求还是比较简单的，开发3个星期就结束了，第4个星期已经在app store审核通过了，非常顺利。</p>
<p>在这次开发中，我学会的全新技术点是：</p>
<ol>
<li>MVVM框架的实际运用，并体会到了MVC框架的不足。</li>
<li>iOS图表的实现（使用CAShapeLayer和贝塞尔曲线绘图）。</li>
</ol>
<p>而且在写代码之外，通过积极地沟通，逐渐认识了一些负责设计，负责接口，安卓那边的小伙伴，以及产品经理，建立了很友好的合作关系，反正一切都很顺就是啦～～</p>
<blockquote>
<p>新公司不乏各路高手，在这60多人的技术团队里，有做技术20年+的技术经理，也有清华高材生，也有美国，英国留学生，也有一些朝气蓬勃刚入职场的小伙伴，感觉以后可以向他们学习的东西蛮多的。</p>
</blockquote>
<h2 id="5-下阶段方向抉择期：12月"><a href="#5-下阶段方向抉择期：12月" class="headerlink" title="5. 下阶段方向抉择期：12月"></a>5. 下阶段方向抉择期：12月</h2><hr>
<p>在项目的第一版成功上架后有一段时间是比较闲的，除了研究下一版要使用的图表以外，我有时间去思考下一步要去学什么。</p>
<p>为什么我在思考这个问题呢？因为iOS这一行业开发者突然增多的客观情况的存在，我们心里都很明白今后如果只会iOS开发已经不够了，况且程序员这一行业本来就变化很快，每一年最好要接触一个新的语言。而且我自己心里也很明白：现在到了该选择的时候了：<strong>我该学哪门语言呢？</strong></p>
<h3 id="Python？"><a href="#Python？" class="headerlink" title="Python？"></a>Python？</h3><p>新公司的技术团队里，有20+的人是python开发，接口就是用python写的。而且新认识的小伙伴也有做python的，随便聊两句就能指点我一二。再说，如果会写脚本，爬虫啥的，岂不是感觉屌屌的？而且机器学习，大数据什么的也可以做的。</p>
<h3 id="PHP？"><a href="#PHP？" class="headerlink" title="PHP？"></a>PHP？</h3><p>PHP7的性能提升了很多，而且部署能力强，很多公司的后端都用PHP，所以它的需求很大。况且我已经学会了iOS，如果再学会PHP，岂不是等于全栈了？</p>
<h3 id="Java？"><a href="#Java？" class="headerlink" title="Java？"></a>Java？</h3><p>如果学会了java，那么搞定安卓开发也就是时间问题了。再说java也可以写后台，所以是不是学会了java就真的移动端和后台自己全能包了？</p>
<h3 id="Javascript！"><a href="#Javascript！" class="headerlink" title="Javascript！"></a>Javascript！</h3><p>在我今年面试新公司的时候，跟我交流过的公司一共有10个左右，这其中，问我会不会混合开发（hybrid app develop：native app develop + web app develop）的就有5个。而且我也有问过之前的同事，他们的公司也几乎都有混合开发。于是我觉得这是个趋势，甚至可能已经开始了。就好比很多商城应用，很多界面都是通过H5来实现的，只是在本地做了js与OC的交互。</p>
<p>有的时候人就需要现实一点：对我来说，与其去学跨度很大的后端语言，为什么不用相同的时间学习混合开发呢？而且对于混合开发来说，我已经了解了native app 开发了不是么？</p>
<p>所以，我暂时放弃了能写脚本的Python，需求仅次于Java的PHP，能写安卓的Java，果断选择了Javascript（当然还有Html5和Css）！</p>
<p>而就在前几天，在公司项目第二版开发完成后，马上报名了优达学诚的前端工程师纳米学位的课程：<a href="https://cn.udacity.com/course/front-end-web-developer-nanodegree--nd001" target="_blank" rel="external">优达学诚 前端工程师纳米学位</a></p>
<p>昨天已经提交了第二个作业：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f60daa7f617b7ea1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="前端工程师纳米学位 Project2"></p>
<p>励志在明年成为一个独当一面的hybrid app developer～哇咔咔</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><hr>
<p>在这一年里，我不断成熟了自己的iOS开发技术，也定下来了下一年的学习方向。当然，iOS开发还是既需要深入的，因为毕竟native app的一些实现能力，短时间用web技术还是很难超越，比如CPU和GPU密集型的任务还有就是底层的优化，与C，C++混编等等。但是毕竟现在native 与web的界限变得越来越模糊，有必要去学习web的一些东西，以备不时之需。</p>
<p>最后点个题：</p>
<p>学习提升的前提是总结，没有总结，就很难一步一个脚印，踏踏实实地走下去。就好比航海，如果不经常看星座，一步步总结之前犯下的错误，找方向，调整路线，是很难达到最终的目的地的。</p>
<p>而对于大多数人来说，提高生活质量的唯一途径就是通过工作。但是，如果工作本身对这个社会的价值不是很大，那么就很难拿到可观的薪水，就算该领域的高手，可能也不如那些工资高的行业的新手。</p>
<p>所以，现实一点来说，就像选择一个高薪的工作一样，选择一个需求比较大，前景可观的编程语言还是比较正确的。我很实在，说的都是些实实在在的话，当你想转一个跨度比较大的行业，一定要量力而行，而且好好做做研究，研究一下这个行业是不是在走下坡路，毕竟你不是一个人，你背后有养你的父母，有朋友伙伴，可能还有你的人生伴侣，把握好方向很重要。</p>
<p>可能你会说：</p>
<ul>
<li>我年轻，想做什么就做什么；</li>
<li>语言只是工具，学什么都行；</li>
</ul>
<p>但是我会告诉你：</p>
<ul>
<li>人生的每一个选择都很重要，你现在的生活取决于你曾经的选择；你今后的生活取决于你现在的选择。</li>
<li>人的精力有限，领域跨度过大的时候一定要仔细考虑，这个社会需要的是T型人才，而这个T的根基是这根竖！</li>
</ul>
<p>人最危险的就是不知道自己不知道，所以嘛，没事多想想，没有坏处。</p>
<hr>
<p>最后感谢在身后支持我转行的父母和陪伴我的女朋友，么么哒～</p>
<p>最后的最后附上本次互动的链接：<a href="http://www.jianshu.com/p/20707def779a" target="_blank" rel="external">程序员专题征文活动|GoodBye 2016,Welcome 2017
</a><br>请大家多多参与啊～</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记得去年这个时候看到很多同行写了年终总结，当时只工作了1个月的我觉得很是高大上。转眼一年过去了，从第一家公司来到现在的这家公司，无论技术上还是思想上都成熟了一些，巧的是简书在这个时候给我们这个平台来写年终总结。贵在参与，也为了自己，写一篇吧～&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-88a964d0151cb8b6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;GoodBye 2016，Welcome 2017&quot;&gt;&lt;/p&gt;
&lt;p&gt;2016年，是我事业起步的第一年，现在回头看去，这一年大致分为五个时期：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;技术基础建设期（1月～5月）&lt;/strong&gt;：从iOS小白的小白到独立上线app。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术快速成长期（6月～9月）&lt;/strong&gt;：简书更新30篇文章，粉丝达到1000+。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;写简历找工作期（10月）&lt;/strong&gt;：8家面试，3个offer。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适应新的公司期（11月）&lt;/strong&gt;：新项目1个月内上架。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;明年方向定位期（12月）&lt;/strong&gt;：决定研究Hybrid app开发。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面开始按时间顺序分别总结一下每个时期里我的所做所思。&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>2016年10月求职记 | iOS工作经验不到1年，在1个月内拿到了3个offer</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/2016%E5%B9%B410%E6%9C%88%E6%B1%82%E8%81%8C%E8%AE%B0%EF%BC%9AiOS%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C%E4%B8%8D%E5%88%B01%E5%B9%B4%EF%BC%8C%E5%9C%A81%E4%B8%AA%E6%9C%88%E5%86%85%E6%8B%BF%E5%88%B0%E4%BA%863%E4%B8%AAoffer/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/2016年10月求职记：iOS工作经验不到1年，在1个月内拿到了3个offer/</id>
    <published>2017-01-13T05:54:44.000Z</published>
    <updated>2017-03-20T07:51:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>真的是非常非常感谢我的新东家，在我最需要新工作的时候给我抛来橄榄枝~</p>
<p>新东家的知名度很高，但并不是做互联网起家的，是一家有自己线下产业的大公司，创立时间也比较久，新项目（互联网）的技术团队组成非常优秀，所以虽然给我的待遇并没有很多，但还是毫不犹豫选择了这一家。为此还谢绝了后面的面试邀请（因为要准备一些入职材料和入职之前的相关学习）。</p>
<p>笔者在国庆节期间准备简历，在国庆节后开始投递简历。从最开始投递简历到拿到最后一个offer历时3周多。因为在这段求职时间里感触很多，所以想专门写一篇博客来讲述一下自己的求职心得，希望能给各位年底求职的小伙伴，特别是做iOS的同行一些值得借鉴的东西。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-23f60ab52ef7bafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
<a id="more"></a>
<h3 id="1-总求职数据："><a href="#1-总求职数据：" class="headerlink" title="1. 总求职数据："></a>1. 总求职数据：</h3><hr>
<ol>
<li>从写简历到拿到最后一个offer历时26天。</li>
<li>总面试通知数：11个</li>
<li>总面试次数：8次</li>
<li>总offer数：3个</li>
</ol>
<h4 id="有趣的3个点："><a href="#有趣的3个点：" class="headerlink" title="有趣的3个点："></a>有趣的3个点：</h4><ol>
<li>简历的最初稿的完成历时2天并开始投递，在第10天才最终定稿。</li>
<li>在简历开始投递后的第一个星期里没有收到任何面试通知。</li>
<li>在3个offer里，只有一家是小公司（不到50人），其他两个都是具有相当规模的大公司。</li>
</ol>
<p>下面写一下整个求职过程的心得：</p>
<h3 id="1-简历需要持续更新"><a href="#1-简历需要持续更新" class="headerlink" title="1. 简历需要持续更新"></a>1. 简历需要持续更新</h3><hr>
<p>虽然开始简历的初版完成的挺快的，但是后来却不断发现有很多不妥的地方：</p>
<ol>
<li>不应该添加我自己的证件照：其实除了美女，是不建议有自己的证明照的。</li>
<li>不应该添加项目的icon：导致排版显得很乱，应该去掉。</li>
<li>项目经验的技术点不够具体，而且主次没有顺序：最好将技术亮点放在最前面，而且要细致一点。</li>
<li>技能清单太过俗套，不够具体：比如不能只写“熟悉RunLoop的使用”，建议这么写：“熟悉RunLoop的机制，创建常驻线程执行任务”，也就是将具体的技术点和具体的应用结合起来写一下会好一些。</li>
<li>个人优势不突出：因为项目经验少而且比较简单，所以相对来说博客和开源项目就是我的优势，而这些 优势我甚至没有在初版简历中写明，后来在更新简历的时候才写出来放在偏后的位置。但是再后来，<a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a>大大建议我开源项目的地址和优秀博客文章最好放在显著位置，我才鼓起勇气将它们放在个人信息的下面，也就是简历的第二项。</li>
<li>除了简历的撰写技巧之外，笔者也在不断自学来增添简历上的技术点：在学习前两天在简历上添加要学习的技术点，保证将来面试的时候可以用上。</li>
</ol>
<blockquote>
<p>在简历的初版完成之后就开始投递了，之后也在不断更新自己的简历，直到10天后更新才趋于稳定。</p>
</blockquote>
<h3 id="2-简历要突出个人优势"><a href="#2-简历要突出个人优势" class="headerlink" title="2. 简历要突出个人优势"></a>2. 简历要突出个人优势</h3><hr>
<p>之前提到过，在第一个星期里，我没有收到任何面试通知，直到第二个星期的星期三我才收到了第一个面试通知。而这个时间点，也正是简历最终定稿之后的2，3天。而且后来，面试通知就“源源不断”了：两周里有11个面试通知，而且越到后面越多。</p>
<p>虽然可能不是很准确，但我个人觉得：将我的博客优秀文章链接和开源项目地址放（并加上简单介绍）在简历的前面之后，我的简历变得“招人喜欢了”。</p>
<blockquote>
<p>因此，在写简历的时候，就要想：到底自己的优势点在哪里？哪个最有亮点，就毫不犹豫地写在最前面吧！</p>
<ul>
<li>如果你的优势是公司项目里的某个功能模块（不能太简单），就把这个模块写出来好好描述一下。</li>
<li>如果你在github上有星星，就把它放在简历前面，多啰嗦几句。</li>
<li>如果你的文章很热，或者被知名网站转载过，也把它放在简历前面，多啰嗦几句。</li>
<li>如果你上面三点都没有，就将你研究过或者参与过的开源框架拿出来，写一写你都从中学到了什么。</li>
</ul>
</blockquote>
<h3 id="3-大公司和小公司的用人侧重点不一样"><a href="#3-大公司和小公司的用人侧重点不一样" class="headerlink" title="3. 大公司和小公司的用人侧重点不一样"></a>3. 大公司和小公司的用人侧重点不一样</h3><hr>
<p>简历写得再好，它的性质也只是面试的敲门砖，真正考验你的还是面试。这段时间我的面试次数是8次，但是只拿到了2个offer，成绩很一般。</p>
<p>我分析了一下自己的优势和劣势：</p>
<h4 id="我的优势："><a href="#我的优势：" class="headerlink" title="我的优势："></a>我的优势：</h4><ol>
<li>学历高：海外硕士（非科班）。</li>
<li>自学能力强：iOS完全自学，而且持续更新博客，有开源项目（很渣）。入职四个月后独立负责一个新项目。</li>
</ol>
<h4 id="我的劣势："><a href="#我的劣势：" class="headerlink" title="我的劣势："></a>我的劣势：</h4><ol>
<li>工作经验少：严格来讲只有10个月。</li>
<li>项目经验少：而且项目技术点难度偏低。</li>
</ol>
<p>整体来说就是：经验少一些，潜力大一点。</p>
<p>有意思的是，这8家面试我的公司里有3家是有相当规模的大公司，而其中2家都给了我offer。而且在我面试的过程中，明显觉得自己比较受大公司青睐，而小公司却反差比较大。</p>
<h4 id="结合我的特点和面试结果有一个结论："><a href="#结合我的特点和面试结果有一个结论：" class="headerlink" title="结合我的特点和面试结果有一个结论："></a>结合我的特点和面试结果有一个结论：</h4><p>大公司招人大多还是以<strong>培养</strong>为目的。<br>小公司招人大多是以<strong>上手</strong>为目的。</p>
<blockquote>
<p>因此，<br>如果你觉得你技术很牛，能独当一面的话，大公司和小公司都可以尝试；<br>如果你经验少，但是潜力相对大一点，小公司还是相对不适合的。<br>如果你经验少，潜力也不是很大，不建议马上跳槽，把前两点的某一点或者其中一点强化再说。</p>
</blockquote>
<h3 id="4-面试题的准备有点虐心"><a href="#4-面试题的准备有点虐心" class="headerlink" title="4. 面试题的准备有点虐心"></a>4. 面试题的准备有点虐心</h3><hr>
<p>笔者在第一第二星期的时间里一直在刷网上的iOS面试题，不断地查缺补漏。在2个星期的时间里，笔记数量增加了100+条，都是记录面试题和相关基础知识的，后来实在是看不下去了，已经看吐了。</p>
<p>不过可笑的是：<br>在面试小公司的时候，问的问题及其刁钻以至于我的“iOS面试题库”几乎形同虚设，网上看的iOS面试题已经应付不了了。<br>而面试大公司的时候，几乎都没有问太多iOS相关的问题，而且问题都不难。</p>
<blockquote>
<p>虽然我最终要去的公司面试我的时候没有问我几个iOS的面试题，不过面试题还是需要准备的。这段时间总结的100多条笔记虽然一方面是为了在面试的时候发挥，另一方面也巩固了自己的基础知识，而且效果很好。</p>
</blockquote>
<h3 id="5-要么做，要么走"><a href="#5-要么做，要么走" class="headerlink" title="5. 要么做，要么走"></a>5. 要么做，要么走</h3><hr>
<p>在求职的过程中看到过这么一句话：“不是互联网不行，而是你不行”。<br>随后我就自行脑补：“不是iOS形势不行，而是你不行”。<br>那么是否可以通用一下呢：“不是<em>__</em>形势不行，而是你不行”？</p>
<p>难道互联网资本寒冬，互联网从业者就一定会失业么？<br>难道iOS形势不好，iOS开发者就一定很难找到工作或者跳槽么？</p>
<p>不要听到一些“什么什么形势不好”就给自己找不到工作找借口，给自己受伤的心灵抹上一点自欺欺人的糖。</p>
<p>为什么简历石沉大海？<br>为什么面试屡屡不中？</p>
<p>挺起胸膛解决问题好么？！</p>
<p>不要去抱怨，你抱怨的时候，可能有人在默默刷题，默默刷开源框架。对自己要求不高，必定会被淘汰。</p>
<p>认清现实吧！以前iOS这边“会拉个线就能月薪过万”的时代已经一去不复返了，如今正是淘汰浑水摸鱼的人的阶段。但这是一个好现象，说明这个行业终于走上正轨了。</p>
<p>如果觉得做不下去了，最好尽早离开；<br>如果决定坚持做下去，就要拿出你的本事让人家看看。</p>
<p>怎么看？当然不是靠说的，而是靠你做过什么。</p>
<p>现在这个时代知识的共享太容易了，绝大多数科目的入门资料在网上都能轻而易举地看到。很多人看得多了，会说了，就以为自己懂了。因此这个时代也过于浮躁，尤其是有一些会上网的年轻人。</p>
<p>但是，技术领域，对一个人的认可并不是靠说的，而是你做过了什么，或是能拿出什么能证明你以后能做什么。</p>
<p>举两个三国武将的例子：<br>从什么时候人们觉得关羽厉害？- 温酒斩华雄<br>从什么时候人们觉得吕布厉害？- 三英战吕布</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b6810305d1803032.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="关二爷"></p>
<p>看出问题了么？<br>看谁牛不牛，是围绕着“事件”说的，而不是围绕花里胡哨的<strong>青龙偃月刀</strong>和<strong>方天画戟</strong>这些表面上的东西说的（虽然能舞得动这些的也能算是不弱）。</p>
<p>觉得舞刀弄枪离自己太远？举两个程序员界的例子：<br>Python的作者求职谷歌的时候只在简历上写了三个词：“I wrote Python.”<br>在iOS界家喻户晓的网络请求第三方框架AFNetworking的作者听说已经被苹果收编了。<br>（我也是听别人说的，真的假的不知道，但我就是要说，不喜欢来打我呀）</p>
<p>很现实的问题：<br>武将厉不厉害，拿战功说事儿；<br>技术工作者厉不厉害，拿作品说事儿。你的作品，反映了你的水平，也能反映你的潜力</p>
<p>所以，对于iOS程序员来说，如果想在这盘淘汰赛中不被抛弃，现在就着手构思真正属于自己的项目。或者用博客记录一下自己的学习历程，勾勒出自己的成长轨迹：“让别人知道你知道”很重要。</p>
<p>如果没有思路，没有关系，看一些已经开源的好的app和框架，相信我，不久你就会有自己的想法。因为创造无非就是拼凑，你懂得多了，自然就会“拼”了（此处双关[掩面]）。</p>
<h3 id="6-心得写完了，以后要怎么做呢？"><a href="#6-心得写完了，以后要怎么做呢？" class="headerlink" title="6. 心得写完了，以后要怎么做呢？"></a>6. 心得写完了，以后要怎么做呢？</h3><hr>
<p>上面说过，我个人感觉这次面试成功率不是很高，而原因也暴露的很明显：项目经验不足。</p>
<p>因此，笔者打算今后在不影响工作质量的情况下好好研究一些比较好的开源app和第三方框架，仔细阅读源码，从中抽取出值得学习的地方，不断提高自己的技术水平，而不仅仅停留在公司项目中。</p>
<p>目的并不是为了下次跳槽，而是为了不断搭建自己的技术壁垒，取各家之所长，借此来打造一个无法取代的自己：</p>
<p>就好比段誉：只会六脉神剑或者凌波微步还不足以独步武林，但是将二者结合在一起就能与萧大侠抗衡了。</p>
<h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><hr>
<p>整个求职过程中心情还是有低落的时候的，特别是第一个星期，面试通知丝毫没有动静。不过还好有一些“道上”的朋友给我鼓励和支持。在这里特别感谢在简书上认识的同行<a href="http://www.jianshu.com/users/55c8fdc3c6e7/latest_articles" target="_blank" rel="external">TianBai</a>， <a href="http://www.jianshu.com/users/a54931de4c9b/latest_articles" target="_blank" rel="external">阿拉斯加的狗</a>，<a href="http://www.jianshu.com/users/e39da354ce50/latest_articles" target="_blank" rel="external">神经骚栋</a>，<a href="http://www.jianshu.com/users/c68741efc396/latest_articles" target="_blank" rel="external">熊皮皮</a>的支持和鼓励，他们都是很优秀的iOS开发者，而且很有潜力，有很多我需要学习的地方。</p>
<p>如果有小伙伴有问题想问我，评论本文，发简信，加我微信（简书主页有我的微信二维码）都可以。<br>不过因为新东家的知名度比较高，具体新东家是谁就不方便说啦，请谅解~</p>
<p>最后还是祝愿在最近找工作的小伙伴们马到功成~</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-784af8ebfba85366.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：pixabay.com"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;真的是非常非常感谢我的新东家，在我最需要新工作的时候给我抛来橄榄枝~&lt;/p&gt;
&lt;p&gt;新东家的知名度很高，但并不是做互联网起家的，是一家有自己线下产业的大公司，创立时间也比较久，新项目（互联网）的技术团队组成非常优秀，所以虽然给我的待遇并没有很多，但还是毫不犹豫选择了这一家。为此还谢绝了后面的面试邀请（因为要准备一些入职材料和入职之前的相关学习）。&lt;/p&gt;
&lt;p&gt;笔者在国庆节期间准备简历，在国庆节后开始投递简历。从最开始投递简历到拿到最后一个offer历时3周多。因为在这段求职时间里感触很多，所以想专门写一篇博客来讲述一下自己的求职心得，希望能给各位年底求职的小伙伴，特别是做iOS的同行一些值得借鉴的东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-23f60ab52ef7bafa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片来自：pixabay.com&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Career" scheme="https://github.com/knightsj/knightsj.github.io/categories/Career/"/>
    
    
      <category term="Life" scheme="https://github.com/knightsj/knightsj.github.io/tags/Life/"/>
    
      <category term="Job" scheme="https://github.com/knightsj/knightsj.github.io/tags/Job/"/>
    
  </entry>
  
  <entry>
    <title>高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E9%AB%98%E5%BA%A6%E5%B0%81%E8%A3%85FMDB%E6%A1%86%E6%9E%B6%EF%BC%9A%E5%90%84%E7%94%A8%E4%B8%80%E5%8F%A5%E4%BB%A3%E7%A0%81%E6%9B%B4%E6%96%B0%EF%BC%88%E6%B7%BB%E5%8A%A0&amp;%E4%BF%AE%E6%94%B9%EF%BC%89%EF%BC%8C%E6%9F%A5%E8%AF%A2%EF%BC%8C%E5%88%A0%E9%99%A4%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/高度封装FMDB框架：各用一句代码更新（添加&amp;修改），查询，删除用户信息/</id>
    <published>2017-01-13T05:54:08.000Z</published>
    <updated>2017-03-20T07:52:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>在移动开发中，有时不得不在客户端本地保存一些数据。在iOS端，我们可以使用plist，属性列表等技术来存储数据，而相比而下更高端一点的，我们也可以使用<strong>数据库</strong>来存储数据。</p>
<p>有趣的是，很多iOS开发者没有去选择使用苹果自家的Core Data技术来操作数据库，而是选择了<a href="[https://github.com/ccgus/fmdb](https://github.com/ccgus/fmdb">FMDB</a>)这个第三方框架。</p>
<p>该框架很好地封装了操作繁琐的SQLite语句，让数据库的操作更加面向对象，而且上手快，门槛低，不用学习数据库的相关知识就可以使用自如。如此优秀流行的框架是值得学习的，于是笔者这两天研究了一下FMDB。研究后，略有所思，将它封装了一下，写了一个<code>Manager</code>类，最后结合了一个Demo演示如何使用这个类。</p>
<p>该博客分为两个部分:第一个部分讲解笔者封装的这个<code>Manager</code>类；第二部分结合Demo来体现该类的实用性。</p>
<a id="more"></a>
<h1 id="1-封装FMDB"><a href="#1-封装FMDB" class="headerlink" title="1. 封装FMDB"></a>1. 封装FMDB</h1><hr>
<h2 id="1-1-封装类的功能"><a href="#1-1-封装类的功能" class="headerlink" title="1.1 封装类的功能"></a>1.1 封装类的功能</h2><p>首先看一下这个类的大名：SJUserInfoManager</p>
<ul>
<li>SJ：笔者的名字缩写，作为前缀，都懂得。</li>
<li>UserInfo:说明这个类用于操作用户信息。</li>
<li>Manager:这个类只具有工厂方法，省内存，而且方便使用。</li>
</ul>
<p><strong>这个类的功能是：它可以创建一个关于用户信息的表（数据库），可以保存，修改，读取，删除用户信息</strong>。</p>
<blockquote>
<p>现在几乎每个app都有登录功能，有登录就意味着有用户信息。有的时候，我们需要将一些用户信息存储到本地，方便今后的读取和操作。</p>
<p>而对于用户信息，几乎永远不变的一项就是用户id，因为用户可以改自己的名字，自己的注册手机号，用户签名等等，然而用户id是唯一一成不变的，后端查找用户信息一般都通过用户id来查找，这不难理解。</p>
</blockquote>
<p>因此，这个封装类基于用户id（user_id），让使用者可以自主添加<strong>一项</strong>自定义的用户信息（可以是用户名，用户签名，用户性别等等），从而形成一个只具有两个纵行的表（第一个纵行是默认的字段：user_id,第二个纵行是自定义字段，可以是user_name等等）。</p>
<p>这样一来，我们就可以生成很多基于用户id的表：可以是用户姓名的表，可以是用户出生日期的表，可以是用户手机号的表等等。</p>
<h2 id="1-2-API介绍"><a href="#1-2-API介绍" class="headerlink" title="1.2 API介绍"></a>1.2 API介绍</h2><p>该封装类的API一共有五个，分别是：</p>
<ol>
<li>创建表格</li>
<li>更新用户信息（添加&amp;修改）</li>
<li>查询某个用户的信息</li>
<li>查询全部用户的信息</li>
<li>删除某个用户的信息</li>
</ol>
<p>下面开始一一讲解：</p>
<h4 id="1-创建表格"><a href="#1-创建表格" class="headerlink" title="1. 创建表格"></a>1. 创建表格</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** Create table with tableName and fieldName **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userInfoField   fieldNameString（自定义字段名）</div><div class="line"> *</div><div class="line"> * @return  if the table is successfully created</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">BOOL</span>)createDataBaseWithName:(<span class="built_in">NSString</span> *)dataBaseName andUserInfoField:(<span class="built_in">NSString</span> *)userInfoField;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个方法的意图很明显，只要传进去表的名字和自定义字段的名字就能创造一个表。</p>
<ul>
<li>创建成功，返回YES；</li>
<li>创建失败，返回NO。</li>
</ul>
<p>而且这个表有一个默认的字段：user_id。因为通过这个类创建用户信息的表是基于用户id来操作的，前面已有说明。</p>
</blockquote>
<h4 id="2-更新用户信息（添加-amp-修改）"><a href="#2-更新用户信息（添加-amp-修改）" class="headerlink" title="2. 更新用户信息（添加&amp;修改）"></a>2. 更新用户信息（添加&amp;修改）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** update specific userInfo with specific userID and userInfoField and userInfoValue **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userID          userIDString（用户id的值）</div><div class="line"> * @param   userInfoField   fieldNameString（自定义字段名）</div><div class="line"> * @param   userInfoValue   userInfoValueString（字段对应的值）</div><div class="line"> *</div><div class="line"> * @return  the result of updating specific userInfo </div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSString</span> *)updateUserInfoIntoDataBase:(<span class="built_in">NSString</span> *)dataBaseName withUserID:(<span class="built_in">NSString</span> *)userID andUserInfoField:(<span class="built_in">NSString</span> *)userInfoField andUserInfoValue:(<span class="built_in">NSString</span> *)userInfoValue;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个方法用于更新用户信息，传入表的名字，用户id，自定义字段名，和自定义字段对应的值。</p>
<ul>
<li>如果输入的表不存在，则返回相应的错误信息。</li>
<li>如果输入的用户id已经存在，就更新对应的用户信息。</li>
<li>如果输入的用户id不存在，就添加这个用户的信息。</li>
</ul>
</blockquote>
<h4 id="3-查询某个用户的信息"><a href="#3-查询某个用户的信息" class="headerlink" title="3. 查询某个用户的信息"></a>3. 查询某个用户的信息</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** Query specific userInfoValue with tableName and userID and userInfoField **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userID          userIDString（用户id的值）</div><div class="line"> * @param   userInfoField   fieldNameString（自定义字段名）</div><div class="line"> *</div><div class="line"> * @return  specific userInfoValue （表内某用户id对应的用户信息）</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSString</span> *)queryUserInfoInDataBase:(<span class="built_in">NSString</span> *)dataBaseName WithUserID:(<span class="built_in">NSString</span> *)userId andUserInfoField:(<span class="built_in">NSString</span> *)userInfoField;</div></pre></td></tr></table></figure>
<blockquote>
<p>该方法用于查询某个用户的信息，传入表的名字，用户id和自定义字段名。</p>
<ul>
<li>如果输入的表不存在，则返回相应的错误信息。</li>
<li>如果输入的用户id存在，则返回对应的信息。</li>
<li>如果输入的用户id不存在，则返回相应的错误信息。</li>
</ul>
</blockquote>
<h4 id="4-查询全部用户的信息"><a href="#4-查询全部用户的信息" class="headerlink" title="4. 查询全部用户的信息"></a>4. 查询全部用户的信息</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** Query all userInfos in this table with userInfoField **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userInfoField   fieldNameString（自定义字段名）</div><div class="line"> *</div><div class="line"> * @return  all the userInfos in this table （表内所有的用户信息）</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSDictionary</span> *)queryUserInfosInDataBase:(<span class="built_in">NSString</span> *)dataBaseName andUserInfoField:(<span class="built_in">NSString</span> *)userInfoField;</div></pre></td></tr></table></figure>
<blockquote>
<p>该方法用户获取某个表内的所有用户信息，传入表的名字和自定义字段名即可。<br>返回的字典里包含一个数组，数组元素为表的每一行的信息。每一行的信息是一个字典：</p>
<ul>
<li>其中一个key为默认的字段名：user_id，它的值为对应的user_id的值。</li>
<li>另一个key为添加的自定义字段名，它对应的值为该字段对应的值。</li>
</ul>
</blockquote>
<h4 id="5-删除某个用户的信息"><a href="#5-删除某个用户的信息" class="headerlink" title="5. 删除某个用户的信息"></a>5. 删除某个用户的信息</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> ********** Delete specific userInfo with specific userID **********</div><div class="line"> *</div><div class="line"> * @param   dataBaseName    tableNameString (表的名字)</div><div class="line"> * @param   userId          userIDString（用户id的值）</div><div class="line"> *</div><div class="line"> * @return  the result of deleting specific userInfo （删除的结果）</div><div class="line"> *</div><div class="line"> */</div><div class="line">+ (<span class="built_in">NSString</span> *)deleteUserInfoInDataBase:(<span class="built_in">NSString</span> *)dataBaseName WithUserID:(<span class="built_in">NSString</span> *)userId;</div></pre></td></tr></table></figure>
<blockquote>
<p>该方法用于删除表里的某个用户信息，只要传入表的名字和用户id即可，可以删除表中对应的一整行信息。同样地，如果输入的表不存在，则返回相应的错误信息。</p>
</blockquote>
<p>如果觉得有点抽象的话，可以看下面这个Demo，可以看到该封装类的具体使用方法。</p>
<h1 id="2-Demo演示"><a href="#2-Demo演示" class="headerlink" title="2. Demo演示"></a>2. Demo演示</h1><hr>
<p>在这个Demo中，我们要在表里添加的自定义字段名(fieldNameString)为：“user_name”。也就是说这个表将保存用户id和用户名信息。</p>
<h2 id="2-1-需求"><a href="#2-1-需求" class="headerlink" title="2.1 需求"></a>2.1 需求</h2><ol>
<li>在插入板块中插入用户信息（用户id和用户名）。</li>
<li>在查询板块中，根据输入的用户id，可以显示对应的用户名。如果没有对应的用户id，则显示“没有对应id”。</li>
<li>在删除板块中，根据输入的用户id，可以删除对应的用户信息（包括用户id和用户名，也就是删除了表的一整行）。如果没有对应的用户id，则显示“没有对应id”。</li>
<li>点击导航栏右侧的按钮，进入“用户信息列表页”。在这一页显示当前表里的全部用户的信息（在cell的textLabel里显示用户名；在cell的detailTextLabel里显示用户id）。</li>
</ol>
<h2 id="2-2-效果图"><a href="#2-2-效果图" class="headerlink" title="2.2 效果图"></a>2.2 效果图</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-404e4004af3b981a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左图：数据库操作页面（插入，查询，删除板块）| 右图：数据库全部用户信息"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f32a934c4eb45af6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="本地沙盒中sqlite表文件内容"></p>
<h3 id="2-3-代码讲解"><a href="#2-3-代码讲解" class="headerlink" title="2.3 代码讲解"></a>2.3 代码讲解</h3><p><strong>1. 最先导入这个封装类和FMDB框架：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"SJUserInfoManager.h"</span></span></div></pre></td></tr></table></figure>
<p><strong>2. 因为表的名字和自定义字段是固定的，所以就以宏来定义了：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#define DATABASENAME  @<span class="meta-string">"userInfoTable"</span> //表的名字</span></div><div class="line"><span class="meta">#define USERINFOFIELD @<span class="meta-string">"user_name"</span>     //自定义字段的名字</span></div></pre></td></tr></table></figure>
<p><strong>3. 添加几个输入框的属性，获取输入框的内容；和查询结果显示</strong>Label：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *insertUserIdTextfield;       <span class="comment">//插入输入框：输入用户id</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *insertUserInfoValueTextfiled;<span class="comment">//插入收入框：输入用户名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *queryUserIdTextfield;        <span class="comment">//查询输入框：输入用户id</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UILabel</span> *queryUserInfoValueLabel;         <span class="comment">//查询结果显示Label:显示用户id对应的用户名</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UITextField</span> *deleteUserIdTextField;       <span class="comment">//删除输入框：输入用户id</span></div></pre></td></tr></table></figure>
<p><strong>4. 下面看一下封装的增改&amp;查&amp;删的代码：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//插入用户信息</span></div><div class="line">- (<span class="keyword">IBAction</span>)insertAction:(<span class="keyword">id</span>)sender &#123;</div><div class="line">   </div><div class="line">    <span class="built_in">NSString</span> *result = <span class="string">@""</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.insertUserInfoValueTextfiled.text.length == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">         result = <span class="string">@"Please Input UserID!"</span>;<span class="comment">//没有输入用户id就点击了插入按钮</span></div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">         result = [SJUserInfoManager updateUserInfoIntoDataBase:DATABASENAME withUserID:<span class="keyword">self</span>.insertUserIdTextfield.text andUserInfoField:USERINFOFIELD andUserInfoValue:<span class="keyword">self</span>.insertUserInfoValueTextfiled.text];</div><div class="line">    &#125;</div><div class="line">   </div><div class="line">   [<span class="keyword">self</span> showAlertWithTitle:result];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"><span class="comment">//查询用户信息</span></div><div class="line">- (<span class="keyword">IBAction</span>)queryUserInfoValue:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *result = <span class="string">@""</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.queryUserIdTextfield.text.length == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        result = <span class="string">@"Please Input UserID!"</span>;<span class="comment">//没有输入用户id就点击了查询按钮</span></div><div class="line">        <span class="keyword">self</span>.queryUserInfoValueLabel.text = <span class="string">@""</span>;<span class="comment">//重置查询输入框</span></div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        result =  [SJUserInfoManager queryUserInfoInDataBase:DATABASENAME WithUserID:<span class="keyword">self</span>.queryUserIdTextfield.text andUserInfoField:USERINFOFIELD];</div><div class="line">        <span class="keyword">self</span>.queryUserInfoValueLabel.text = result;</div><div class="line">        [<span class="keyword">self</span> showAlertWithTitle:result];</div><div class="line">        </div><div class="line">    &#125;    </div><div class="line">    [<span class="keyword">self</span> showAlertWithTitle:result];</div><div class="line">&#125;</div><div class="line"><span class="comment">//删除用户信息</span></div><div class="line">- (<span class="keyword">IBAction</span>)deleteUserInfoWithUserID:(<span class="built_in">UIButton</span> *)sender &#123;</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *result = <span class="string">@""</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.deleteUserIdTextField.text.length == <span class="number">0</span>) &#123;</div><div class="line">        </div><div class="line">        result = <span class="string">@"Please Input UserID!"</span>;</div><div class="line">        </div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        </div><div class="line">        result =  [SJUserInfoManager deleteUserInfoInDataBase:DATABASENAME WithUserID:<span class="keyword">self</span>.deleteUserIdTextField.text];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span> showAlertWithTitle:result];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>其实不难看出，除了处理错误信息的代码以外，数据库的操作代码是非常简洁的:都是一行结束，而且返回一个结果字符串或者布尔值。</p>
</blockquote>
<p><strong>5. 在进入第二页之前，需要查询表内所有的用户信息并传递给第二个页面的VC：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)prepareForSegue:(<span class="built_in">UIStoryboardSegue</span> *)segue sender:(<span class="keyword">id</span>)sender</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> ([segue.destinationViewController isKindOfClass:[DataListTableViewController <span class="keyword">class</span>]]) &#123;</div><div class="line">        <span class="keyword">if</span> ([segue.identifier isEqualToString:<span class="string">@"userInfosList"</span>]) &#123;</div><div class="line">            </div><div class="line">            <span class="built_in">NSDictionary</span> *userInfosDict = [SJUserInfoManager queryUserInfosInDataBase:DATABASENAME andUserInfoField:USERINFOFIELD];</div><div class="line">            DataListTableViewController *dataListVc = (DataListTableViewController *)segue.destinationViewController;</div><div class="line">            dataListVc.userInfosDict = userInfosDict;</div><div class="line">        &#125;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>6. 在第二页的viewDidLoad方法里获取用户信息列表，并刷新表格将其显示出来：</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</div><div class="line">    </div><div class="line">    [<span class="keyword">super</span> viewDidLoad];</div><div class="line">    </div><div class="line">    <span class="built_in">NSString</span> *alertTitle = [<span class="keyword">self</span>.userInfosDict objectForKey:<span class="string">@"result"</span>];</div><div class="line">    [<span class="keyword">self</span> showAlertWithTitle:alertTitle];</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span> *userInfosArray = [<span class="keyword">self</span>.userInfosDict objectForKey:<span class="string">@"userInfosArray"</span>];</div><div class="line">    <span class="keyword">if</span> ([userInfosArray count] != <span class="number">0</span>) &#123;</div><div class="line">         <span class="keyword">self</span>.userInfosArray = userInfosArray;</div><div class="line">        [<span class="keyword">self</span>.tableView reloadData];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>想知道Demo是如何实现的么？</p>
<p>Demo传送门：<a href="https://github.com/Shijie0111/SJUserInfoManager">SJUserInfoManager - GitHub</a></p>
<p>如果可以给星星，或者给笔者提意见，那就再好不过啦~</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>说来惭愧，笔者封装的这个类的功能还是很有局限性的：</p>
<ol>
<li>操作表格前必须创建一次表格（一次就可以）。</li>
<li>只支持NSString类型的值。</li>
<li>除user_id字段以外只支持一个自定义字段。</li>
<li>不同的自定义字段必须对应不同的表格名，也就是说不同的自定义字段不能对应同一个表格名。</li>
<li>数据库操作API的返回值还不够完善，最好以枚举类型返回，有待改进。</li>
<li>没有使用FMDB的队列API。</li>
</ol>
<p>虽然这个封装很简单，但是笔者始终赞同<strong>学习的最终目的在于应用和创造</strong>这句话。如果只是用眼睛看FMDB框架的API或是复制粘贴一些别人写好的FMDB的应用代码，那么其实是意义不大的。</p>
<p>如果在学习后，可以融会贯通，将学到的知识可以按照自己的意图加以改进和运用的话，那么相对于“搬运工”式学习来说，显然收获更大。</p>
<p>这是笔者第一个开源项目，虽然简单，算上优化和改bug只写了大概3个小时，但是毕竟是开源的第一步，对自己的鼓励还是蛮大的，以后还会封装优化更多的库，加油~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在移动开发中，有时不得不在客户端本地保存一些数据。在iOS端，我们可以使用plist，属性列表等技术来存储数据，而相比而下更高端一点的，我们也可以使用&lt;strong&gt;数据库&lt;/strong&gt;来存储数据。&lt;/p&gt;
&lt;p&gt;有趣的是，很多iOS开发者没有去选择使用苹果自家的Core Data技术来操作数据库，而是选择了&lt;a href=&quot;[https://github.com/ccgus/fmdb](https://github.com/ccgus/fmdb&quot;&gt;FMDB&lt;/a&gt;)这个第三方框架。&lt;/p&gt;
&lt;p&gt;该框架很好地封装了操作繁琐的SQLite语句，让数据库的操作更加面向对象，而且上手快，门槛低，不用学习数据库的相关知识就可以使用自如。如此优秀流行的框架是值得学习的，于是笔者这两天研究了一下FMDB。研究后，略有所思，将它封装了一下，写了一个&lt;code&gt;Manager&lt;/code&gt;类，最后结合了一个Demo演示如何使用这个类。&lt;/p&gt;
&lt;p&gt;该博客分为两个部分:第一个部分讲解笔者封装的这个&lt;code&gt;Manager&lt;/code&gt;类；第二部分结合Demo来体现该类的实用性。&lt;/p&gt;
    
    </summary>
    
      <category term="Production" scheme="https://github.com/knightsj/knightsj.github.io/categories/Production/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C》超级干货三部曲（三）：技巧篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E3%80%8AEffective%20Objective-C%E3%80%8B%E8%B6%85%E7%BA%A7%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%8A%80%E5%B7%A7%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（三）：技巧篇/</id>
    <published>2017-01-13T05:52:57.000Z</published>
    <updated>2017-03-20T07:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>《Effective Objective-C 》超级干货三部曲系列迎来了最后一篇：技巧篇，这一篇总结汇总了这本书中一些用来解决问题的偏向“设计模式”的知识点。</p>
<p>不知道笔者所谓的三部曲的童鞋们可以看一下这张图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0599d987732d932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<p>前两篇传送门：<br><a href="http://www.jianshu.com/p/9c93c7ab734d" target="_blank" rel="external">《Effective Objective-C 》超级干货三部曲（一）：概念篇</a><br><a href="http://www.jianshu.com/p/0b895e39eca1" target="_blank" rel="external">《Effective Objective-C 》超级干货三部曲（二）：规范篇</a></p>
<a id="more"></a>
<h1 id="第9条-以“类族模式“隐藏实现细节"><a href="#第9条-以“类族模式“隐藏实现细节" class="headerlink" title="第9条 以“类族模式“隐藏实现细节"></a>第9条 以“类族模式“隐藏实现细节</h1><hr>
<p>在iOS开发中，我们也会使用“类族”(class cluster)这一设计模式，通过“抽象基类”来实例化不同的实体子类。</p>
<p>举个🌰 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (<span class="built_in">UIButton</span> *)buttonWithType:(<span class="built_in">UIButtonType</span>)type;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，我们只需要输入不同的按钮类型(UIButtonType)就可以得到不同的UIButton的子类。在OC框架中普遍使用这一设计模式。</p>
</blockquote>
<h4 id="为什么要这么做呢"><a href="#为什么要这么做呢" class="headerlink" title="为什么要这么做呢?"></a>为什么要这么做呢?</h4><p>笔者认为这么做的原因是为了“弱化”子类的具体类型，让开发者无需关心创建出来的子类具体属于哪个类。（这里觉得还有点什么，但是还没有想到，欢迎补充！）</p>
<p>我们可以看一个具体的例子：<br>对于“员工”这个类，可以有各种不同的“子类型”：开发员工，设计员工和财政员工。这些“实体类”可以由“员工”这个抽象基类来获得：</p>
<h4 id="1-抽象基类"><a href="#1-抽象基类" class="headerlink" title="1. 抽象基类"></a>1. 抽象基类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//EOCEmployee.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, EOCEmployeeType) &#123;</div><div class="line">    EOCEmployeeTypeDeveloper,</div><div class="line">    EOCEmployeeTypeDesigner,</div><div class="line">    EOCEmployeeTypeFinance,</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCEmployee</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSUInteger</span> salary;</div><div class="line"><span class="comment">// Helper for creating Employee objects</span></div><div class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type;</div><div class="line"><span class="comment">// Make Employees do their respective day's work</span></div><div class="line">- (<span class="keyword">void</span>)doADaysWork;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//EOCEmployee.m</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCEmployee</span></span></div><div class="line">+ (EOCEmployee*)employeeWithType:(EOCEmployeeType)type &#123;</div><div class="line">     <span class="keyword">switch</span> (type) &#123;</div><div class="line">         <span class="keyword">case</span> EOCEmployeeTypeDeveloper:</div><div class="line">            <span class="keyword">return</span> [EOCEmployeeDeveloper new];</div><div class="line">         <span class="keyword">break</span>; </div><div class="line">        <span class="keyword">case</span> EOCEmployeeTypeDesigner:</div><div class="line">             <span class="keyword">return</span> [EOCEmployeeDesigner new];</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> EOCEmployeeTypeFinance:</div><div class="line">             <span class="keyword">return</span> [EOCEmployeeFinance new];</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)doADaysWork &#123;</div><div class="line"> <span class="comment">// 需要子类来实现</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，将EOCEmployee作为抽象基类，这个抽象基类有一个初始化方法，通过这个方法，我们可以得到多种基于这个抽象基类的实体子类:</p>
</blockquote>
<h4 id="2-实体子类（concrete-subclass）"><a href="#2-实体子类（concrete-subclass）" class="headerlink" title="2. 实体子类（concrete subclass）:"></a>2. 实体子类（concrete subclass）:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCEmployeeDeveloper</span> : <span class="title">EOCEmployee</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCEmployeeDeveloper</span></span></div><div class="line">- (<span class="keyword">void</span>)doADaysWork &#123;</div><div class="line">    [<span class="keyword">self</span> writeCode];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong><br>如果对象所属的类位于某个类族中，那么在查询类型信息时就要小心。因为类族中的实体子类并不与其基类属于同一个类。</p>
</blockquote>
<h1 id="第10条：在既有类中使用关联对象存放自定义数据"><a href="#第10条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第10条：在既有类中使用关联对象存放自定义数据"></a>第10条：在既有类中使用关联对象存放自定义数据</h1><hr>
<p>我们可以通“关联对象”机制来把两个对象连接起来。这样我们就可以从某个对象中获取相应的关联对象的值。</p>
<p>先看一下关联对象的语法：</p>
<h4 id="1-为某个对象设置关联对象的值："><a href="#1-为某个对象设置关联对象的值：" class="headerlink" title="1. 为某个对象设置关联对象的值："></a>1. 为某个对象设置关联对象的值：</h4><p><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code></p>
<blockquote>
<p>这里，第一个参数是主对象，第二个参数是键，第三个参数是关联的对象，第四个参数是存储策略:是枚举，定义了内存管理语义。</p>
</blockquote>
<h4 id="2-根据给定的键从某对象中获取相应的关联对象值："><a href="#2-根据给定的键从某对象中获取相应的关联对象值：" class="headerlink" title="2. 根据给定的键从某对象中获取相应的关联对象值："></a>2. 根据给定的键从某对象中获取相应的关联对象值：</h4><p><code>id objc_getAssociatedObject(id object, void *key)</code></p>
<h4 id="3-移除指定对象的关联对象："><a href="#3-移除指定对象的关联对象：" class="headerlink" title="3. 移除指定对象的关联对象："></a>3. 移除指定对象的关联对象：</h4><p><code>void objc_removeAssociatedObjects(id object)</code></p>
<p>举个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"><span class="keyword">static</span> <span class="keyword">void</span> *EOCMyAlertViewKey = <span class="string">"EOCMyAlertViewKey"</span>;</div><div class="line">- (<span class="keyword">void</span>)askUserAQuestion &#123;</div><div class="line">         <span class="built_in">UIAlertView</span> *alert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Question"</span></div><div class="line">                                                         message:<span class="string">@"What do you want to do?"</span></div><div class="line">                                                        delegate:<span class="keyword">self</span></div><div class="line">                                               cancelButtonTitle:<span class="string">@"Cancel"</span></div><div class="line">                                               otherButtonTitles:<span class="string">@"Continue"</span>, <span class="literal">nil</span>];</div><div class="line">         <span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = ^(<span class="built_in">NSInteger</span> buttonIndex)&#123;</div><div class="line">                     <span class="keyword">if</span> (buttonIndex == <span class="number">0</span>) &#123;</div><div class="line">                            [<span class="keyword">self</span> doCancel];</div><div class="line">                     &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            [<span class="keyword">self</span> doContinue];</div><div class="line">                    &#125;</div><div class="line">         &#125;;</div><div class="line">         <span class="comment">//将alert和block关联在了一起</span></div><div class="line">         objc_setAssociatedObject(alert,EOCMyAlertViewKey,block, OBJC_ASSOCIATION_COPY);</div><div class="line">         [alert show];</div><div class="line">&#125;</div><div class="line"><span class="comment">// UIAlertViewDelegate protocol method</span></div><div class="line">- (<span class="keyword">void</span>)alertView:(<span class="built_in">UIAlertView</span>*)alertView clickedButtonAtIndex:(<span class="built_in">NSInteger</span>)buttonIndex</div><div class="line">&#123;</div><div class="line">     <span class="comment">//alert取出关联的block</span></div><div class="line">      <span class="keyword">void</span> (^block)(<span class="built_in">NSInteger</span>) = objc_getAssociatedObject(alertView, EOCMyAlertViewKey)</div><div class="line">     <span class="comment">//给block传入index值</span></div><div class="line">      block(buttonIndex);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第13条：用“方法调配技术”调试“黑盒方法”"><a href="#第13条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第13条：用“方法调配技术”调试“黑盒方法”"></a>第13条：用“方法调配技术”调试“黑盒方法”</h1><hr>
<p>与选择子名称相对应的方法是可以在运行期被改变的，所以，我们可以不用通过继承类并覆写方法就能改变这个类本身的功能。</p>
<p>那么如何在运行期改变选择子对应的方法呢？<br>答：通过操纵类的方法列表的IMP指针</p>
<p>什么是类方法表？什么是IMP指针呢？</p>
<blockquote>
<p>类的方法列表会把<strong>选择子</strong>的名称映射到相关的方法实现上，使得“动态消息派发系统”能够据此找到应该调用的方法。这些方法均以函数指针的形式来表示，这些指针叫做IMP。例如NSString类的选择子列表：</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c58274453996f2c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类方法表的映射"></p>
<p>有了这张表，OC的运行期系统提供的几个方法就能操纵它。开发者可以向其中增加选择子，也可以改变某选择子对应的方法实现，也可以交换两个选择子所映射到的指针以达到交换方法实现的目的。</p>
<p>举个 ：交换<code>lowercaseString</code>和<code>uppercaseString</code>方法的实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Method originalMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(lowercaseString));</div><div class="line">Method swappedMethod = class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>],<span class="keyword">@selector</span>(uppercaseString));</div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<blockquote>
<p>这样一来，类方法表的映射关系就变成了下图：</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-10ddc4e1634625b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="交换两个方法"></p>
<blockquote>
<p>这时，如果我们调用lowercaseString方法就会实际调用uppercaseString的方法，反之亦然。</p>
</blockquote>
<p><strong>然而！</strong><br>在实际应用中，只交换已经存在的两个方法是没有太大意义的。我们应该利用这个特性来给既有的方法添加新功能（听上去吊吊的）：</p>
<p>它的实现原理是：先通过分类增加一个新方法，然后将这个新方法和要增加功能的旧方法替换（旧方法名 对应新方法的实现），这样一来，如果我们调用了旧方法，就会实现新方法了。</p>
<p>不知道这么说是否抽象。还是举个 ：</p>
<p><strong>需求：</strong>我们要在原有的lowercaseString方法中添加一条输出语句。</p>
<h4 id="步骤一：我们先将新方法写在NSString的分类里："><a href="#步骤一：我们先将新方法写在NSString的分类里：" class="headerlink" title="步骤一：我们先将新方法写在NSString的分类里："></a>步骤一：我们先将新方法写在NSString的分类里：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">EOCMyAdditions</span>)</span></div><div class="line">- (<span class="built_in">NSString</span>*)eoc_myLowercaseString;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSString</span> (<span class="title">EOCMyAdditions</span>)</span></div><div class="line">- (<span class="built_in">NSString</span>*)eoc_myLowercaseString &#123;</div><div class="line">     <span class="built_in">NSString</span> *lowercase = [<span class="keyword">self</span> eoc_myLowercaseString];<span class="comment">//eoc_myLowercaseString方法会在将来方法调换后执行lowercaseString的方法</span></div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"%@ =&gt; %@"</span>, <span class="keyword">self</span>, lowercase);<span class="comment">//输出语句，便于调试</span></div><div class="line">     <span class="keyword">return</span> lowercase;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h4 id="步骤二：交换两个方法的实现（操纵调换IMP指针）"><a href="#步骤二：交换两个方法的实现（操纵调换IMP指针）" class="headerlink" title="步骤二：交换两个方法的实现（操纵调换IMP指针）"></a>步骤二：交换两个方法的实现（操纵调换IMP指针）</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Method originalMethod =</div><div class="line"> class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>],</div><div class="line"> <span class="keyword">@selector</span>(lowercaseString));</div><div class="line">Method swappedMethod =</div><div class="line"> class_getInstanceMethod([<span class="built_in">NSString</span> <span class="keyword">class</span>],</div><div class="line"> <span class="keyword">@selector</span>(eoc_myLowercaseString));</div><div class="line">method_exchangeImplementations(originalMethod, swappedMethod);</div></pre></td></tr></table></figure>
<p>这样一来，我们如果交换了<code>lowercaseString</code>和<code>eoc_myLowercaseString</code>的方法实现，那么在调用原来的<code>lowercaseString</code>方法后就可以输出新增的语句了。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *string = <span class="string">@"ThIs iS tHe StRiNg"</span>;</div><div class="line"><span class="built_in">NSString</span> *lowercaseString = [string lowercaseString];</div><div class="line"><span class="comment">// Output: ThIs iS tHe StRiNg =&gt; this is the string”</span></div></pre></td></tr></table></figure>
<h1 id="第16条：提供”全能初始化方法”"><a href="#第16条：提供”全能初始化方法”" class="headerlink" title="第16条：提供”全能初始化方法”"></a>第16条：提供”全能初始化方法”</h1><hr>
<p>有时，由于要实现各种设计需求，一个类可以有多个创建实例的初始化方法。我们应该<strong>选定其中一个</strong>作为<strong>全能初始化方法</strong>，令其他初始化方法都来调用它。</p>
<blockquote>
<p><strong>注意</strong>：</p>
<ul>
<li>只有在这个全能初始化方法里面才能存储内部数据。这样一来，当底层数据存储机制改变时，只需修改此方法的代码就好，无需改动其他初始化方法。</li>
<li>全能初始化方法是所有初始化方法里参数最多的一个，因为它使用了尽可能多的初始化所需要的参数，以便其他的方法来调用自己。</li>
<li>在我们拥有了一个全能初始化方法后，最好还是要覆写init方法来设置默认值。</li>
</ul>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//全能初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)initWithWidth:(<span class="keyword">float</span>)width andHeight:(<span class="keyword">float</span>)height</div><div class="line">&#123;</div><div class="line">     <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        _width = width;</div><div class="line">        _height = height;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//init方法也调用了全能初始化方法</span></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line">     <span class="keyword">return</span> [<span class="keyword">self</span> initWithWidth:<span class="number">5.0</span>f andHeight:<span class="number">10.0</span>f];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在，我们要创造一个squre类继承这上面这个ractangle类,它有自己的全能初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithDimension: (<span class="keyword">float</span>)dimension&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> initWithWidth:dimension andHeight:dimension];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="这里有问题！"><a href="#这里有问题！" class="headerlink" title="这里有问题！"></a>这里有问题！</h4><p>然而，因为square类是rectangle类的子类，那么它也可以使用<code>initWithWidth: andHeight:</code>方法，更可以使用<code>init</code>方法。那么这两种情况下，显然是无法确保初始化的图形是正方形。</p>
<p>因此，我们需要在这里覆写square的父类rectangle的全能初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithWidth:(<span class="keyword">float</span>)width andHeight:(<span class="keyword">float</span>)height</div><div class="line">&#123;</div><div class="line">    <span class="keyword">float</span> dimension = MAX(width, height);</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithDimension:dimension];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，当square用<code>initWithWidth: andHeight:</code>方法初始化时，就会得到一个正方形。</p>
<p>并且，如果用<code>init</code>方法来初始化square的话，我们也可以得到一个默认的正方形。因为在rectangle类里覆写了init方法，而这个init方法又调用了<code>initWithWidth: andHeight:</code>方法，并且square类又覆写了<code>initWithWidth: andHeight:</code>方法，所以我们仍然可以得到一个正方形。</p>
<p>而且，为了让square的init方法得到一个默认的正方形，我们也可以覆写它自己的初始化方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)init&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithDimension:<span class="number">5.0</span>f];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们做个总结：</p>
<p>因为子类的全能初始化方法（initWithDimension:）和其父类的初始化方法并不同，所以我们需要在子类里覆写<code>initWithWidth: andHeight:</code>方法。</p>
<h4 id="还差一点：initWithCoder-的初始化"><a href="#还差一点：initWithCoder-的初始化" class="headerlink" title="还差一点：initWithCoder:的初始化"></a>还差一点：initWithCoder:的初始化</h4><p>有时，需要定义两种全能初始化方法，因为对象有可能有两种完全不同的创建方式，例如<code>initWithCoder:</code>方法。</p>
<p>我们仍然需要调用超类的初始化方法：</p>
<p>在rectangle类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Initializer from NSCoding</span></div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span>*)decoder &#123;</div><div class="line">     <span class="comment">// Call through to super's designated initializer</span></div><div class="line">         <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">            _width = [decoder decodeFloatForKey:<span class="string">@"width"</span>];</div><div class="line">            _height = [decoder decodeFloatForKey:<span class="string">@"height"</span>];</div><div class="line">        &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在square类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Initializer from NSCoding</span></div><div class="line">- (<span class="keyword">id</span>)initWithCoder:(<span class="built_in">NSCoder</span>*)decoder &#123;</div><div class="line"> <span class="comment">// Call through to super's designated initializer</span></div><div class="line">      <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> initWithCoder:decoder])) &#123;</div><div class="line">     <span class="comment">// EOCSquare's specific initializer</span></div><div class="line">    &#125;</div><div class="line">     <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上。在调用了超类的初始化方法后，再执行与本类相关的方法。</p>
<h1 id="第17条：实现description方法"><a href="#第17条：实现description方法" class="headerlink" title="第17条：实现description方法"></a>第17条：实现description方法</h1><hr>
<p>在打印我们自己定义的类的实例对象时，在控制台输出的结果往往是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">object = &lt;EOCPerson: 0x7fd9a1600600&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里只包含了类名和内存地址，它的信息显然是不具体的,远达不到调试的要求。</p>
</blockquote>
<p><strong>但是！</strong>如果在我们自己定义的类覆写description方法，我们就可以在打印这个类的实例时输出我们想要的信息。</p>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)description &#123;</div><div class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p, %@ %@&gt;"</span>, [<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">self</span>, firstName, lastName];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，显示了内存地址，还有该类的所有属性。</p>
<p>而且，如果我们将这些属性值放在字典里打印，则更具有可读性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)description &#123;</div><div class="line">     <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"&lt;%@: %p, %@&gt;"</span>,[<span class="keyword">self</span> <span class="keyword">class</span>],<span class="keyword">self</span>,</div><div class="line">    @&#123;    <span class="string">@"title"</span>:_title,</div><div class="line">       <span class="string">@"latitude"</span>:@(_latitude),</div><div class="line">      <span class="string">@"longitude"</span>:@(_longitude)&#125;</div><div class="line">    ];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">location = &lt;EOCLocation: 0x7f98f2e01d20, &#123;</div><div class="line">    latitude = &quot;51.506&quot;;</div><div class="line">   longitude = 0;</div><div class="line">       title = London;</div><div class="line">&#125;&gt;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以看到，通过重写<code>description</code>方法可以让我们更加了解对象的情况，便于后期的调试，节省开发时间。</p>
</blockquote>
<h1 id="第28条-通过协议提供匿名对象"><a href="#第28条-通过协议提供匿名对象" class="headerlink" title="第28条:通过协议提供匿名对象"></a>第28条:通过协议提供匿名对象</h1><hr>
<p>匿名对象（Annonymous object），可以理解为“没有名字的对象”。有时我们用协议来提供匿名对象，目的在于说明它仅仅表示“遵从某个协议的对象”，而不是“属于某个类的对象”。</p>
<p>它的表示方法为：<code>id&lt;protocol&gt;</code>。<br>通过协议提供匿名对象的主要使用场景有两个：</p>
<ul>
<li>作为属性</li>
<li>作为方法参数</li>
</ul>
<h4 id="1-匿名对象作为属性"><a href="#1-匿名对象作为属性" class="headerlink" title="1. 匿名对象作为属性"></a>1. 匿名对象作为属性</h4><p>在设定某个类为自己的代理属性时，可以不声明代理的类，而是用id<protocol>，因为<strong>成为</strong>代理的终点并不是<strong>某个类的实例</strong>，而是<strong>遵循了某个协议</strong>。</protocol></p>
<p>举个 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> &lt;EOCDelegate&gt; delegate;</div></pre></td></tr></table></figure>
<p>在这里使用匿名对象的原因有两个：</p>
<ol>
<li>将来可能会有很多不同类的实例对象作为该类的代理。</li>
<li>我们不想指明具体要使用哪个类来作为这个类的代理。</li>
</ol>
<p>也就是说，能作为该类的代理的条件只有一个：它遵从了 <eocdelegate>协议。</eocdelegate></p>
<h4 id="2-匿名对象作为方法参数"><a href="#2-匿名对象作为方法参数" class="headerlink" title="2. 匿名对象作为方法参数"></a>2. 匿名对象作为方法参数</h4><p>有时，我们不会在意方法里某个参数的具体类型，而是遵循了某种协议，这个时候就可以使用匿名对象来作为方法参数。</p>
<p>举个 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)object forKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)key;</div></pre></td></tr></table></figure>
<p>这个方法是NSDictionary的设值方法，它的参数只要遵从了<nscopying>协议，就可以作为参数传进去,作为NSDictionary的键。</nscopying></p>
<h1 id="第32条：编写“异常安全代码”时留意内存管理问题"><a href="#第32条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第32条：编写“异常安全代码”时留意内存管理问题"></a>第32条：编写“异常安全代码”时留意内存管理问题</h1><hr>
<p>在发生异常时的内存管理需要仔细考虑内存管理的问题：</p>
<blockquote>
<p>在try块中，如果先保留了某个对象，然后在释放它之前又抛出了异常，那么除非在catch块中能处理此问题，否则对象所占内存就将泄漏。</p>
</blockquote>
<h4 id="在MRC环境下："><a href="#在MRC环境下：" class="headerlink" title="在MRC环境下："></a>在MRC环境下：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@try</span> &#123;</div><div class="line">     EOCSomeClass *object = [[EOCSomeClass alloc] init];</div><div class="line">      [object doSomethingThatMayThrow];</div><div class="line">      [object release];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@catch</span> (...) &#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"Whoops, there was an error. Oh well..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里，我们用release方法释放了try中的对象，但是这样做仍然有问题：如果在<code>doSomthingThatMayThrow</code>方法中抛出了异常了呢？</p>
<p>这样就无法执行<code>release</code>方法了。</p>
<p>解决办法是使用@finnaly块，无论是否抛出异常，其中的代码都能运行：</p>
<figure class="highlight plain"><figcaption><span>*object;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line">    object = [[EOCSomeClass alloc] init];</div><div class="line">    [object doSomethingThatMayThrow];</div><div class="line">&#125;</div><div class="line">@catch (...) &#123;</div><div class="line">     NSLog(@&quot;Whoops, there was an error. Oh well...&quot;);</div><div class="line">&#125;</div><div class="line">@finally &#123;</div><div class="line">    [object release];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####在ARC环境下呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@try</span> &#123;</div><div class="line">     EOCSomeClass *object = [[EOCSomeClass alloc] init];</div><div class="line">     [object doSomethingThatMayThrow];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@catch</span> (...) &#123;</div><div class="line"> <span class="built_in">NSLog</span>(<span class="string">@"Whoops, there was an error. Oh well..."</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时，我们无法手动使用<code>release</code>方法了，解决办法是使用：-fobjc-arc-exceptions 标志来加入清理代码，不过会导致应用程序变大，而且会降低运行效率。</p>
<h1 id="第33条：以弱引用避免保留环"><a href="#第33条：以弱引用避免保留环" class="headerlink" title="第33条：以弱引用避免保留环"></a>第33条：以弱引用避免保留环</h1><hr>
<p>对象之间都用强指针引用对方的话会造成保留环。</p>
<h4 id="两个对象的保留环："><a href="#两个对象的保留环：" class="headerlink" title="两个对象的保留环："></a>两个对象的保留环：</h4><p>两个对象都有一个对方的实例来作为自己的属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCClassA</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EOCClassB *other;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCClassB</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EOCClassA *other;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-4e1aa0647dee51fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="两个对象的保留环"></p>
<p>两个对象都有指向对方的强指针，这样会导致这两个属性里的对象无法被释放掉。</p>
<h4 id="多个对象的保留环："><a href="#多个对象的保留环：" class="headerlink" title="多个对象的保留环："></a>多个对象的保留环：</h4><p>如果保留环连接了多个对象，而这里其中一个对象被外界引用，那么当这个引用被移除后，整个保留环就泄漏了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d99033df1cf5e1ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多个对象的保留环：孤岛"></p>
<p>解决方案是使用弱引用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//EOCClassB.m</span></div><div class="line"><span class="comment">//第一种弱引用：unsafe_unretained</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>) EOCClassA *other;</div><div class="line"><span class="comment">//第二种弱引用：weak</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) EOCClassA *other;</div></pre></td></tr></table></figure>
<p>这两种弱引用有什么区别呢？</p>
<p>unsafe_unretained:当指向EOCClassA实例的引用移除后，unsafe_unretained属性仍然指向那个已经回收的实例，</p>
<p>而weak指向nil：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-afc3b538527f93da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="unsafe_unretained 和 weak的区别"></p>
<p>显然，用weak字段应该是更安全的，因为不再使用的对象按理说应该设置为nil,而不应该产生依赖。</p>
<h1 id="第34条：以“自动释放池快”降低内存峰值"><a href="#第34条：以“自动释放池快”降低内存峰值" class="headerlink" title="第34条：以“自动释放池快”降低内存峰值"></a>第34条：以“自动释放池快”降低内存峰值</h1><hr>
<p>释放对象的两种方式：</p>
<ul>
<li>调用release:保留计数递减</li>
<li>调用autorelease将其加入自动释放池中。在将来清空自动释放池时，系统会向其中的对象发送release消息。</li>
</ul>
<p>内存峰值（high-memory waterline）是指应用程序在某个限定时段内的最大内存用量（highest memory footprint）。新增的自动释放池块可以减少这个峰值：</p>
<p>不用自动释放池减少峰值：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</div><div class="line">      [<span class="keyword">self</span> doSomethingWithInt:i];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，<code>doSomethingWithInt:</code>方法可能会创建临时对象。随着循环次数的增加，临时对象的数量也会飙升，而只有在整个for循环结束后，这些临时对象才会得意释放。</p>
<p>这种情况是不理想的，尤其在我们无法控制循环长度的情况下，我们会不断占用内存并突然释放掉它们。</p>
<p>因此，我们需要用自动释放池来降低这种突兀的变化：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *databaseRecords = <span class="comment">/* ... */</span>;</div><div class="line"><span class="built_in">NSMutableArray</span> *people = [<span class="built_in">NSMutableArray</span> new];</div><div class="line"><span class="keyword">for</span> (<span class="built_in">NSDictionary</span> *record <span class="keyword">in</span> databaseRecords) &#123;</div><div class="line">     <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">             EOCPerson *person = [[EOCPerson alloc] initWithRecord:record];</div><div class="line">            [people addObject:person];</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这样一来，每次循环结束，我们都会将临时对象放在这个池里面，而不是线程的主池里面。</p>
</blockquote>
<h1 id="第35条：用“僵尸对象”调试内存管理问题"><a href="#第35条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第35条：用“僵尸对象”调试内存管理问题"></a>第35条：用“僵尸对象”调试内存管理问题</h1><hr>
<p>某个对象被回收后，再向它发送消息是不安全的，这并不一定会引起程序崩溃。</p>
<p>如果程序没有崩溃，可能是因为：</p>
<ul>
<li>该内存的部分原数据没有被覆写。</li>
<li>该内存恰好被另一个对象占据，而这个对象可以应答这个方法。</li>
</ul>
<p>如果被回收的对象占用的原内存被新的对象占据，那么收到消息的对象就不会是我们预想的那个对象。在这样的情况下，如果这个对象无法响应那个方法的话，程序依旧会崩溃。</p>
<p>因此，我们希望可以通过一种方法捕捉到<strong>对象被释放后收到消息的情况</strong>。</p>
<p>这种方法就是<strong>利用僵尸对象！</strong></p>
<p>Cocoa提供了“僵尸对象”的功能。如果开启了这个功能，运行期系统会把所有已经回收的实例转化成特殊的“僵尸对象”（通过修改isa指针，令其指向特殊的僵尸类），而不会真正回收它们，而且它们所占据的核心内存将无法被重用，这样也就避免了覆写的情况。</p>
<p>在僵尸对象收到消息后，会抛出异常，它会说明发送过来的消息，也会描述回收之前的那个对象。</p>
<h1 id="第38条：为常用的块类型创建typedef"><a href="#第38条：为常用的块类型创建typedef" class="headerlink" title="第38条：为常用的块类型创建typedef"></a>第38条：为常用的块类型创建typedef</h1><hr>
<p>如果我们需要重复创建某种块（相同参数，返回值）的变量，我们就可以通过typedef来给某一种块定义属于它自己的新类型</p>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> (^variableName)(<span class="built_in">BOOL</span> flag, <span class="keyword">int</span> value) =^(<span class="built_in">BOOL</span> flag, <span class="keyword">int</span> value)&#123;</div><div class="line">     <span class="comment">// Implementation</span></div><div class="line">     <span class="keyword">return</span> someInt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个块有一个bool参数和一个int参数，并返回int类型。我们可以给它定义类型：</p>
<p><code>typedef int(^EOCSomeBlock)(BOOL flag, int value);</code></p>
<p>再次定义的时候，就可以通过简单的赋值来实现：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">EOCSomeBlock block = ^(<span class="built_in">BOOL</span> flag, <span class="keyword">int</span> value)&#123;</div><div class="line">     <span class="comment">// Implementation</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义作为参数的块：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startWithCompletionHandler: (<span class="keyword">void</span>(^)(<span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error))completion;</div></pre></td></tr></table></figure>
<p>这里的块有一个NSData参数，一个NSError参数并没有返回值</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^EOCCompletionHandler)(<span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error);</div><div class="line">- (<span class="keyword">void</span>)startWithCompletionHandler:(EOCCompletionHandler)completion;”</div></pre></td></tr></table></figure>
<p>通过typedef定义块签名的好处是:如果要某种块增加参数，那么只修改定义签名的那行代码即可。</p>
<h1 id="第39条：用handler块降低代码分散程度"><a href="#第39条：用handler块降低代码分散程度" class="headerlink" title="第39条：用handler块降低代码分散程度"></a>第39条：用handler块降低代码分散程度</h1><hr>
<p>下载网络数据时，如果使用代理方法，会使得代码分布不紧凑，而且如果有多个下载任务的话，还要在回调的代理中判断当前请求的类型。但是如果使用block的话，就可以让网络下载的代码和回调处理的代码写在一起，这样就可以同时解决上面的两个问题：</p>
<h4 id="用代理下载："><a href="#用代理下载：" class="headerlink" title="用代理下载："></a>用代理下载：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)fetchFooData &#123;</div><div class="line">     <span class="built_in">NSURL</span> *url = [[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"http://www.example.com/foo.dat"</span>];</div><div class="line">    _fooFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    _fooFetcher.delegate = <span class="keyword">self</span>;</div><div class="line">    [_fooFetcher start];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)fetchBarData &#123;</div><div class="line">     <span class="built_in">NSURL</span> *url = [[<span class="built_in">NSURL</span> alloc] initWithString: <span class="string">@"http://www.example.com/bar.dat"</span>];</div><div class="line">    _barFetcher = [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    _barFetcher.delegate = <span class="keyword">self</span>;</div><div class="line">    [_barFetcher start];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)networkFetcher:(EOCNetworkFetcher*)networkFetcher didFinishWithData:(<span class="built_in">NSData</span>*)data</div><div class="line">&#123;   <span class="comment">//判断下载器类型</span></div><div class="line">     <span class="keyword">if</span> (networkFetcher == _fooFetcher) &#123;</div><div class="line">        _fetchedFooData = data;</div><div class="line">        _fooFetcher = <span class="literal">nil</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (networkFetcher == _barFetcher) &#123;</div><div class="line">        _fetchedBarData = data;</div><div class="line">        _barFetcher = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="用块下载："><a href="#用块下载：" class="headerlink" title="用块下载："></a>用块下载：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)fetchFooData &#123;</div><div class="line">     <span class="built_in">NSURL</span> *url = [[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"http://www.example.com/foo.dat"</span>];</div><div class="line">     EOCNetworkFetcher *fetcher =</div><div class="line">     [[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">     [fetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data)&#123;</div><div class="line">            _fetchedFooData = data;</div><div class="line">   &#125;];</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)fetchBarData &#123;</div><div class="line">     <span class="built_in">NSURL</span> *url = [[<span class="built_in">NSURL</span> alloc] initWithString: <span class="string">@"http://www.example.com/bar.dat"</span>];</div><div class="line">     EOCNetworkFetcher *fetcher =[[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    [fetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data)&#123;</div><div class="line">            _fetchedBarData = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以将处理成功的代码放在一个块里，处理失败的代码放在另一个块中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">“<span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">EOCNetworkFetcher</span>;</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class="built_in">NSData</span> *data);</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^EOCNetworkFetcherErrorHandler)(<span class="built_in">NSError</span> *error);</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span>*)url;</div><div class="line">- (<span class="keyword">void</span>)startWithCompletionHandler: (EOCNetworkFetcherCompletionHandler)completion failureHandler: (EOCNetworkFetcherErrorHandler)failure;</div><div class="line"><span class="keyword">@end</span></div><div class="line">EOCNetworkFetcher *fetcher =[[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">[fetcher startWithCompletionHander:^(<span class="built_in">NSData</span> *data)&#123;</div><div class="line">     <span class="comment">// Handle success</span></div><div class="line">&#125;</div><div class="line"> failureHandler:^(<span class="built_in">NSError</span> *error)&#123;</div><div class="line"> <span class="comment">// Handle failure</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>这样写的好处是，我们可以将处理成功和失败的代码分开来写，看上去更加清晰。</p>
</blockquote>
<p>我们还可以将 成功和失败的代码都放在同一个块里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">“<span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">EOCNetworkFetcher</span>;</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error);</div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span>*)url;</div><div class="line">- (<span class="keyword">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)completion;</div><div class="line"><span class="keyword">@end</span></div><div class="line">EOCNetworkFetcher *fetcher =[[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">[fetcher startWithCompletionHander:</div><div class="line">^(<span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error)&#123;</div><div class="line"><span class="keyword">if</span> (error) &#123;</div><div class="line">     <span class="comment">// Handle failure</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">     <span class="comment">// Handle success</span></div><div class="line">&#125;</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<blockquote>
<p>这样做的好处是，如果及时下载失败或中断了，我们仍然可以取到当前所下载的data。而且，如果在需求上指出：下载成功后得到的数据很少，也视为失败，那么单一块的写法就很适用，因为它可以取得数据后（成功）再判断其是否是下载成功的。</p>
</blockquote>
<h1 id="第40条：用块引用其所属对象时不要出现保留环"><a href="#第40条：用块引用其所属对象时不要出现保留环" class="headerlink" title="第40条：用块引用其所属对象时不要出现保留环"></a>第40条：用块引用其所属对象时不要出现保留环</h1><hr>
<p>如果块捕获的对象直接或间接地保留了块本身，那么就需要小心保留环问题:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCClass</span> </span>&#123;</div><div class="line">     EOCNetworkFetcher *_networkFetcher;</div><div class="line">     <span class="built_in">NSData</span> *_fetchedData;</div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)downloadData &#123;</div><div class="line">     <span class="built_in">NSURL</span> *url = [[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"http://www.example.com/something.dat"</span>];</div><div class="line">    _networkFetcher =[[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    [_networkFetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data)&#123;</div><div class="line">             <span class="built_in">NSLog</span>(<span class="string">@"Request URL %@ finished"</span>, _networkFetcher.url);</div><div class="line">            _fetchedData = data;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里出现了保留环：块要设置_fetchedData变量，就需要捕获self变量。而self（EOCClass实例）通过实例变量保留了获取器_networkFetcher，而_networkFetcher又保留了块。</p>
<p>解决方案是：在块中取得了data后，将_networkFetcher设为nil。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)downloadData &#123;</div><div class="line">     <span class="built_in">NSURL</span> *url = [[<span class="built_in">NSURL</span> alloc] initWithString:<span class="string">@"http://www.example.com/something.dat"</span>];</div><div class="line">    _networkFetcher =[[EOCNetworkFetcher alloc] initWithURL:url];</div><div class="line">    [_networkFetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data)&#123;</div><div class="line">             <span class="built_in">NSLog</span>(<span class="string">@"Request URL %@ finished"</span>, _networkFetcher.url);</div><div class="line">            _fetchedData = data;</div><div class="line">            _networkFetcher = <span class="literal">nil</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第41条：多用派发队列，少用同步锁"><a href="#第41条：多用派发队列，少用同步锁" class="headerlink" title="第41条：多用派发队列，少用同步锁"></a>第41条：多用派发队列，少用同步锁</h1><hr>
<p>多个线程执行同一份代码时，很可能会造成数据不同步。作者建议使用GCD来为代码加锁的方式解决这个问题。</p>
<h4 id="方案一：使用串行同步队列来将读写操作都安排到同一个队列里："><a href="#方案一：使用串行同步队列来将读写操作都安排到同一个队列里：" class="headerlink" title="方案一：使用串行同步队列来将读写操作都安排到同一个队列里："></a>方案一：使用串行同步队列来将读写操作都安排到同一个队列里：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_queue_create(<span class="string">"com.effectiveobjectivec.syncQueue"</span>, <span class="literal">NULL</span>);</div><div class="line"><span class="comment">//读取字符串</span></div><div class="line">- (<span class="built_in">NSString</span>*)someString &#123;</div><div class="line">         __block <span class="built_in">NSString</span> *localSomeString;</div><div class="line">         <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">            localSomeString = _someString;</div><div class="line">        &#125;);</div><div class="line">         <span class="keyword">return</span> localSomeString;</div><div class="line">&#125;</div><div class="line"><span class="comment">//设置字符串</span></div><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span>*)someString &#123;</div><div class="line">     <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一来，读写操作都在串行队列进行，就不容易出错。</p>
<p>但是，还有一种方法可以让性能更高：</p>
<h4 id="方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"><a href="#方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。" class="headerlink" title="方案二：将写操作放入栅栏快中，让他们单独执行；将读取操作并发执行。"></a>方案二：将<strong>写操作</strong>放入栅栏快中，让他们单独执行；将<strong>读取操作</strong>并发执行。</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">_syncQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div><div class="line"><span class="comment">//读取字符串</span></div><div class="line">- (<span class="built_in">NSString</span>*)someString &#123;</div><div class="line">     __block <span class="built_in">NSString</span> *localSomeString;</div><div class="line">     <span class="built_in">dispatch_sync</span>(_syncQueue, ^&#123;</div><div class="line">        localSomeString = _someString;</div><div class="line">    &#125;);</div><div class="line">     <span class="keyword">return</span> localSomeString;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置字符串</span></div><div class="line">- (<span class="keyword">void</span>)setSomeString:(<span class="built_in">NSString</span>*)someString &#123;</div><div class="line">     dispatch_barrier_async(_syncQueue, ^&#123;</div><div class="line">        _someString = someString;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>显然，数据的正确性主要取决于写入操作，那么只要保证写入时，线程是安全的，那么即便读取操作是并发的，也可以保证数据是同步的。</p>
<p>这里的<code>dispatch_barrier_async</code>方法使得操作放在了同步队列里“有序进行”，保证了写入操作的任务是在串行队列里。</p>
</blockquote>
<h1 id="第42条：多用GCD，少用performSelector系列方法"><a href="#第42条：多用GCD，少用performSelector系列方法" class="headerlink" title="第42条：多用GCD，少用performSelector系列方法"></a>第42条：多用GCD，少用performSelector系列方法</h1><hr>
<p>在iOS开发中，有时会使用performSelector来执行某个方法，但是performSelector系列的方法能处理的选择子很局限：</p>
<ul>
<li>它无法处理带有多个参数的选择子。</li>
<li>返回值只能是void或者对象类型。</li>
</ul>
<p>但是如果将方法放在块中，通过GCD来操作就能很好地解决这些问题。尤其是我们如果想要让一个任务在另一个线程上执行，最好应该将任务放到块里，交给GCD来实现，而不是通过performSelector方法。</p>
<p>举几个 来比较这两种方案：</p>
<h4 id="1-延后执行某个任务的方法："><a href="#1-延后执行某个任务的方法：" class="headerlink" title="1. 延后执行某个任务的方法："></a>1. 延后执行某个任务的方法：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 performSelector:withObject:afterDelay:</span></div><div class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span> afterDelay:<span class="number">5.0</span>];</div><div class="line"><span class="comment">// 使用 dispatch_after</span></div><div class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span> * <span class="built_in">NSEC_PER_SEC</span>));</div><div class="line">dispatch_after(time, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123;</div><div class="line">    [<span class="keyword">self</span> doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="2-将任务放在主线程执行："><a href="#2-将任务放在主线程执行：" class="headerlink" title="2. 将任务放在主线程执行："></a>2. 将任务放在主线程执行：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 performSelectorOnMainThread:withObject:waitUntilDone:</span></div><div class="line">[<span class="keyword">self</span> performSelectorOnMainThread:<span class="keyword">@selector</span>(doSomething) withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span>];</div><div class="line"><span class="comment">// 使用 dispatch_async</span></div><div class="line"><span class="comment">// (or if waitUntilDone is YES, then dispatch_sync)</span></div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [<span class="keyword">self</span> doSomething];</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：<br>如果waitUntilDone的参数是Yes，那么就对应GCD的dispatch_sync方法。<br>我们可以看到，使用GCD的方式可以将线程操作代码和方法调用代码写在同一处，一目了然；而且完全不受调用方法的选择子和方法参数个数的限制。</p>
</blockquote>
<h1 id="第43条：掌握GCD及操作队列的使用时机"><a href="#第43条：掌握GCD及操作队列的使用时机" class="headerlink" title="第43条：掌握GCD及操作队列的使用时机"></a>第43条：掌握GCD及操作队列的使用时机</h1><hr>
<p>除了GCD，操作队列（NSOperationQueue）也是解决多线程任务管理问题的一个方案。对于不同的环境，我们要采取不同的策略来解决问题：有时候使用GCD好些，有时则是使用操作队列更加合理。</p>
<p>使用NSOperation和NSOperationQueue的优点：</p>
<ol>
<li>可以取消操作：在运行任务前，可以在NSOperation对象调用cancel方法，标明此任务不需要执行。但是GCD队列是无法取消的，因为它遵循“安排好之后就不管了（fire and forget）”的原则。</li>
<li>可以指定操作间的依赖关系：例如从服务器下载并处理文件的动作可以用操作来表示。而在处理其他文件之前必须先下载“清单文件”。而后续的下载工作，都要依赖于先下载的清单文件这一操作。</li>
<li>监控NSOperation对象的属性：可以通过KVO来监听NSOperation的属性：可以通过isCancelled属性来判断任务是否已取消；通过isFinished属性来判断任务是否已经完成。</li>
<li>可以指定操作的优先级：操作的优先级表示此操作与队列中其他操作之间的优先关系，我们可以指定它。</li>
</ol>
<h1 id="第44条：通过Dispath-Group机制，根据系统资源状况来执行任务"><a href="#第44条：通过Dispath-Group机制，根据系统资源状况来执行任务" class="headerlink" title="第44条：通过Dispath Group机制，根据系统资源状况来执行任务"></a>第44条：通过Dispath Group机制，根据系统资源状况来执行任务</h1><hr>
<p>有时需要<strong>等待</strong>多个并行任务结束的那一刻执行某个任务，这个时候就可以使用dispath group函数来实现这个需求：</p>
<p>通过dispath group函数，可以把并发执行的多个任务合为一组，于是调用者就可以知道这些任务何时才能全部执行完毕。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//一个优先级低的并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> lowPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, <span class="number">0</span>);</div><div class="line"><span class="comment">//一个优先级高的并发队列</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> highPriorityQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>);</div><div class="line"><span class="comment">//创建dispatch_group</span></div><div class="line">dispatch_group_t dispatchGroup = dispatch_group_create();</div><div class="line"><span class="comment">//将优先级低的队列放入dispatch_group</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> lowPriorityObjects) &#123;</div><div class="line"> dispatch_group_async(dispatchGroup,lowPriorityQueue,^&#123; [object performTask]; &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//将优先级高的队列放入dispatch_group</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> highPriorityObjects) &#123;</div><div class="line"> dispatch_group_async(dispatchGroup,highPriorityQueue,^&#123; [object performTask]; &#125;);</div><div class="line">&#125;</div><div class="line"><span class="comment">//dispatch_group里的任务都结束后调用块中的代码</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> notifyQueue = dispatch_get_main_queue();</div><div class="line">dispatch_group_notify(dispatchGroup,notifyQueue,^&#123;</div><div class="line">     <span class="comment">// Continue processing after completing tasks</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h1 id="第45条：使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#第45条：使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="第45条：使用dispatch_once来执行只需运行一次的线程安全代码"></a>第45条：使用dispatch_once来执行只需运行一次的线程安全代码</h1><hr>
<p>有时我们可能只需要将某段代码执行一次，这时可以通过dispatch_once函数来解决。</p>
<p>dispatch_once函数比较重要的使用例子是单例模式：<br>我们在创建单例模式的实例时，可以使用dispatch_once函数来令初始化代码只执行一次，并且内部是线程安全的。</p>
<p>而且，对于执行一次的block来说，每次调用函数时传入的标记都必须完全相同，通常标记变量声明在static或global作用域里。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+ (<span class="keyword">id</span>)sharedInstance &#123;</div><div class="line">     <span class="keyword">static</span> EOCClass *sharedInstance = <span class="literal">nil</span>;</div><div class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">﻿            sharedInstance = [[<span class="keyword">self</span> alloc] init];</div><div class="line">    &#125;);</div><div class="line">     <span class="keyword">return</span> sharedInstance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>我们可以这么理解：在dispatch_once块中的代码在程序启动到终止的过程里，只要运行了一次后，就给自己加上了注释符号，不再存在了。</p>
</blockquote>
<h1 id="第49条：对自定义其内存管理语义的collection使用无缝桥接"><a href="#第49条：对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="第49条：对自定义其内存管理语义的collection使用无缝桥接"></a>第49条：对自定义其内存管理语义的collection使用无缝桥接</h1><hr>
<p>通过无缝桥接技术，可以再Foundation框架中的OC对象和CoreFoundation框架中的C语言数据结构之间来回转换。</p>
<p>创建CoreFoundation中的collection时，可以指定如何处理其中的元素。然后利用无缝桥接技术，可以将其转换为OCcollection。</p>
<p>简单的无缝桥接演示：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *anNSArray = @[@<span class="number">1</span>, @<span class="number">2</span>, @<span class="number">3</span>, @<span class="number">4</span>, @<span class="number">5</span>];</div><div class="line"><span class="built_in">CFArrayRef</span> aCFArray = (__bridge <span class="built_in">CFArrayRef</span>)anNSArray;</div><div class="line"><span class="built_in">NSLog</span>(<span class="string">@"Size of array = %li"</span>, <span class="built_in">CFArrayGetCount</span>(aCFArray));</div></pre></td></tr></table></figure>
<p>这里，<code>__bridge</code>表示ARC仍然具备这个OC对象的所有权。<code>CFArrayGetCount</code>用来获取数组的长高度。</p>
<p>为什么要使用无缝桥接技术呢？因为有些OC对象的特性是其对应的CF数据结构不具备的，反之亦然。因此我们需要通过无缝桥接技术来让这两者进行功能上的“互补”。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>终于总结完了，还是有个别知识点理解得不是很透彻，需要反复阅读和理解消化。希望各位小伙伴多多提出宝贵意见，交流学习~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》&quot;&gt;&lt;/p&gt;
&lt;p&gt;《Effective Objective-C 》超级干货三部曲系列迎来了最后一篇：技巧篇，这一篇总结汇总了这本书中一些用来解决问题的偏向“设计模式”的知识点。&lt;/p&gt;
&lt;p&gt;不知道笔者所谓的三部曲的童鞋们可以看一下这张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-0599d987732d932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;三部曲分布图&quot;&gt;&lt;/p&gt;
&lt;p&gt;前两篇传送门：&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/9c93c7ab734d&quot;&gt;《Effective Objective-C 》超级干货三部曲（一）：概念篇&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://www.jianshu.com/p/0b895e39eca1&quot;&gt;《Effective Objective-C 》超级干货三部曲（二）：规范篇&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C》超级干货三部曲（二）：规范篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E3%80%8AEffective%20Objective-C%E3%80%8B%E8%B6%85%E7%BA%A7%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%A7%84%E8%8C%83%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（二）：规范篇/</id>
    <published>2017-01-13T05:52:04.000Z</published>
    <updated>2017-03-20T07:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>继上一篇<a href="http://www.jianshu.com/p/9c93c7ab734d" target="_blank" rel="external">《Effective Objective-C 》超级干货三部曲（一）：概念篇</a>之后，本篇即是三部曲的第二篇：规范篇。<br>没看过三部曲第一篇的小伙伴可能不知道我在说神马，在这里还是先啰嗦一下三部曲是咋回事：笔者将《Effective Objective-C 》这本书的52个知识点分为三大类进行了归类整理：</p>
<ul>
<li>概念类：讲解了一些概念性知识。</li>
<li>规范类：讲解了一些为了避免一些问题或者为后续开发提供便利所需要遵循的规范性知识。</li>
<li>技巧类：讲解了一些为了解决某些特定问题而需要用到的技巧性知识。</li>
</ul>
<p>然后用思维导图整理了一下：<br><img src="http://upload-images.jianshu.io/upload_images/859001-0599d987732d932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<p>作为三部曲的第二篇，本篇总结抽取了《Effective Objective-C 》这本书中讲解规范性知识的部分：这些知识点都是为了避免在开发过程中出现问题或给开发提供便利的规范性知识点。掌握这些知识有助于形成科学地写OC代码的习惯，使得代码更加容易维护和扩展，学习这类知识是iOS初学者进阶的必经之路。</p>
<p>好吧，不费话了，开始了！</p>
<a id="more"></a>
<h1 id="第2条：-在类的头文件中尽量少引用其他头文件"><a href="#第2条：-在类的头文件中尽量少引用其他头文件" class="headerlink" title="第2条： 在类的头文件中尽量少引用其他头文件"></a>第2条： 在类的头文件中尽量少引用其他头文件</h1><hr>
<p>有时，类A需要将类B的实例变量作为它公共API的属性。这个时候，我们不应该引入类B的头文件，而应该使用向前声明（forward declaring）使用class关键字，并且在A的实现文件引用B的头文件。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// EOCPerson.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">EOCEmployer</span>;</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) EOCEmployer *employer;<span class="comment">//将EOCEmployer作为属性</span></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">// EOCPerson.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"EOCEmployer.h"</span></span></div></pre></td></tr></table></figure>
<p>这样做有什么优点呢：</p>
<blockquote>
<ul>
<li>不在A的头文件中引入B的头文件，就不会一并引入B的全部内容，这样就减少了编译时间。</li>
<li>可以避免循环引用：因为如果两个类在自己的头文件中都引入了对方的头文件，那么就会导致其中一个类无法被正确编译。</li>
</ul>
</blockquote>
<p>但是个别的时候，必须在头文件中引入其他类的头文件:</p>
<blockquote>
<p>主要有两种情况：</p>
<ol>
<li>该类继承于某个类，则应该引入父类的头文件。</li>
<li>该类遵从某个协议，则应该引入该协议的头文件。而且最好将协议单独放在一个头文件中。</li>
</ol>
</blockquote>
<h1 id="第3条：多用字面量语法，少用与之等价的方法"><a href="#第3条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第3条：多用字面量语法，少用与之等价的方法"></a>第3条：多用字面量语法，少用与之等价的方法</h1><hr>
<h2 id="1-声明时的字面量语法："><a href="#1-声明时的字面量语法：" class="headerlink" title="1. 声明时的字面量语法："></a>1. 声明时的字面量语法：</h2><p>在声明NSNumber，NSArray，NSDictionary时，应该尽量使用简洁字面量语法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSNumber</span> *intNumber = @<span class="number">1</span>;</div><div class="line"><span class="built_in">NSNumber</span> *floatNumber = @<span class="number">2.5</span>f;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *animals =[<span class="built_in">NSArray</span> arrayWithObjects:<span class="string">@"cat"</span>, <span class="string">@"dog"</span>,<span class="string">@"mouse"</span>, <span class="string">@"badger"</span>, <span class="literal">nil</span>];</div><div class="line">Dictionary *dict = @&#123;<span class="string">@"animal"</span>:<span class="string">@"tiger"</span>,<span class="string">@"phone"</span>:<span class="string">@"iPhone 6"</span>&#125;;</div></pre></td></tr></table></figure>
<h2 id="2-集合类取下标的字面量语法："><a href="#2-集合类取下标的字面量语法：" class="headerlink" title="2. 集合类取下标的字面量语法："></a>2. 集合类取下标的字面量语法：</h2><p>NSArray，NSDictionary，NSMutableArray，NSMutableDictionary 的取下标操作也应该尽量使用字面量语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *cat = animals[0];</div><div class="line">NSString *iphone = dict[@&quot;phone&quot;];</div></pre></td></tr></table></figure></p>
<blockquote>
<p>使用字面量语法的优点：</p>
<ol>
<li>代码看起来更加简洁。</li>
<li>如果存在nil值，则会立即抛出异常。如果在不用字面量语法定义数组的情况下，如果数组内部存在nil，则系统会将其设为数组最后一个元素并终止。所以当这个nil不是最后一个元素的话，就会出现难以排查的错误。</li>
</ol>
<p><strong>注意</strong>:<br>字面量语法创建出来的字符串，数组，字典对象都是不可变的。</p>
</blockquote>
<h1 id="第4条：多用类型常量，少用-define预处理命令"><a href="#第4条：多用类型常量，少用-define预处理命令" class="headerlink" title="第4条：多用类型常量，少用#define预处理命令"></a>第4条：多用类型常量，少用#define预处理命令</h1><hr>
<p>在OC中，定义常量通常使用预处理命令，但是并不建议使用它，而是使用类型常量的方法。<br>首先比较一下这两种方法的区别：</p>
<ul>
<li>预处理命令：简单的文本替换，不包括类型信息，并且可被任意修改。</li>
<li>类型常量：包括类型信息，并且可以设置其使用范围，而且不可被修改。</li>
</ul>
<p>我们可以看出来，使用预处理虽然能达到替换文本的目的，但是本身还是有局限性的：不具备类型 + 可以被任意修改，总之给人一种不安全的感觉。</p>
<p>知道了它们的长短处，我们再来简单看一下它们的具体使用方法：</p>
<h4 id="预处理命令："><a href="#预处理命令：" class="headerlink" title="预处理命令："></a>预处理命令：</h4><p><code>#define W_LABEL (W_SCREEN - 2*GAP)</code></p>
<blockquote>
<p>这里，(W_SCREEN - 2*GAP)替换了W_LABEL，它不具备W_LABEL的类型信息。而且要注意一下：如果替换式中存在运算符号，以笔者的经验最好用括号括起来，不然容易出现错误（有体会）。</p>
</blockquote>
<h4 id="类型常量："><a href="#类型常量：" class="headerlink" title="类型常量："></a>类型常量：</h4><p><code>static const NSTimeIntervalDuration = 0.3;</code></p>
<blockquote>
<p>这里:<br>const 将其设置为常量，不可更改。<br>static意味着该变量仅仅在定义此变量的编译单元中可见。如果不声明static,编译器会为它创建一个外部符号（external symbol）。我们来看一下对外公开的常量的声明方法：</p>
</blockquote>
<h4 id="对外公开某个常量："><a href="#对外公开某个常量：" class="headerlink" title="对外公开某个常量："></a>对外公开某个常量：</h4><p>如果我们需要发送通知，那么就需要在不同的地方拿到通知的“频道”字符串，那么显然这个字符串是不能被轻易更改，而且可以在不同的地方获取。这个时候就需要定义一个外界可见的字符串常量。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//header file</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> NotificationString;</div><div class="line"><span class="comment">//implementation file</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span>  NotificationString = <span class="string">@"Finish Download"</span>;</div></pre></td></tr></table></figure>
<blockquote>
<p>这里NSString *const NotificationString是指针常量。<br>extern关键字告诉编译器，在全局符号表中将会有一个名叫NotificationString的符号。</p>
</blockquote>
<p>我们通常在头文件声明常量，在其实现文件里定义该常量。由实现文件生成目标文件时，编译器会在“数据段”为字符串分配存储空间。</p>
<p>最后注意一下公开和非公开的常量的命名规范：</p>
<blockquote>
<p>公开的常量：常量的名字最好用与之相关的类名做前缀。<br>非公开的常量：局限于某个编译单元（tanslation unit，实现文件 implementation file）内，在签名加上字母k。</p>
</blockquote>
<h1 id="第5条：用枚举表示状态，选项，状态码"><a href="#第5条：用枚举表示状态，选项，状态码" class="headerlink" title="第5条：用枚举表示状态，选项，状态码"></a>第5条：用枚举表示状态，选项，状态码</h1><hr>
<p>我们经常需要给类定义几个状态，这些状态码可以用枚举来管理。下面是关于网络连接状态的状态码枚举：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, EOCConnectionState) &#123;</div><div class="line">  EOCConnectionStateDisconnected,</div><div class="line">  EOCConnectionStateConnecting,</div><div class="line">  EOCConnectionStateConnected,</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>需要注意的一点是：<br>在枚举类型的switch语句中不要实现default分支。它的好处是，当我们给枚举增加成员时，编译器就会提示开发者：switch语句并未处理所有的枚举。对此，笔者有个教训，又一次在switch语句中将“默认分支”设置为枚举中的第一项，自以为这样写可以让程序更健壮，结果后来导致了严重的崩溃。</p>
<h1 id="第7条：-在对象内部尽量直接访问实例变量"><a href="#第7条：-在对象内部尽量直接访问实例变量" class="headerlink" title="第7条： 在对象内部尽量直接访问实例变量"></a>第7条： 在对象内部尽量直接访问实例变量</h1><hr>
<p>关于实例变量的访问，可以直接访问，也可以通过属性的方式(点语法)来访问。书中作者建议在读取实例变量时采用直接访问的形式，而在设置实例变量的时候通过属性来做。</p>
<h4 id="直接访问属性的特点："><a href="#直接访问属性的特点：" class="headerlink" title="直接访问属性的特点："></a>直接访问属性的特点：</h4><ul>
<li>绕过set，get语义，速度快；</li>
</ul>
<h4 id="通过属性访问属性的特点："><a href="#通过属性访问属性的特点：" class="headerlink" title="通过属性访问属性的特点："></a>通过属性访问属性的特点：</h4><ul>
<li>不会绕过属性定义的内存管理语义</li>
<li>有助于打断点排查错误</li>
<li>可以触发KVO</li>
</ul>
<p>因此，有个关于折中的方案：</p>
<blockquote>
<p>设置属性：通过属性<br>读取属性：直接访问</p>
</blockquote>
<p>不过有两个特例：</p>
<ol>
<li>初始化方法和dealloc方法中，需要直接访问实例变量来进行设置属性操作。因为如果在这里没有绕过set方法，就有可能触发其他不必要的操作。</li>
<li>惰性初始化（lazy initialization）的属性，必须通过属性来读取数据。因为惰性初始化是通过重写get方法来初始化实例变量的，如果不通过属性来读取该实例变量，那么这个实例变量就永远不会被初始化。</li>
</ol>
<h1 id="第15条：用前缀-避免命名空间冲突"><a href="#第15条：用前缀-避免命名空间冲突" class="headerlink" title="第15条：用前缀 避免命名空间冲突"></a>第15条：用前缀 避免命名空间冲突</h1><hr>
<p>Apple宣称其保留使用所有”两字母前缀”的权利，所以我们选用的前缀应该是三个字母的。<br>而且，如果自己开发的程序使用到了第三方库，也应该加上前缀。</p>
<h1 id="第18条：尽量使用不可变对象"><a href="#第18条：尽量使用不可变对象" class="headerlink" title="第18条：尽量使用不可变对象"></a>第18条：尽量使用不可变对象</h1><hr>
<p>书中作者建议尽量把对外公布出来的属性设置为只读，在实现文件内部设为读写。具体做法是：</p>
<p>在头文件中，设置对象属性为<code>readonly</code>，在实现文件中设置为<code>readwrite</code>。这样一来，在外部就只能读取该数据，而不能修改它，使得这个类的实例所持有的数据更加安全。</p>
<p>而且，对于集合类的对象，更应该仔细考虑是否可以将其设为可变的。</p>
<p>如果在公开部分只能设置其为只读属性，那么就在非公开部分存储一个可变型。这样一来，当在外部获取这个属性时，获取的只是内部可变型的一个不可变版本,例如：</p>
<p>在公共API中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSSet</span> *friends <span class="comment">//向外公开的不可变集合</span></div><div class="line">- (<span class="keyword">id</span>)initWithFirstName:(<span class="built_in">NSString</span>*)firstName andLastName:(<span class="built_in">NSString</span>*)lastName;</div><div class="line">- (<span class="keyword">void</span>)addFriend:(EOCPerson*)person;</div><div class="line">- (<span class="keyword">void</span>)removeFriend:(EOCPerson*)person;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，我们将friends属性设置为不可变的set。然后，提供了来增加和删除这个set里的元素的公共接口。</p>
</blockquote>
<p>在实现文件里：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readwrite</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span> </span>&#123;</div><div class="line">     <span class="built_in">NSMutableSet</span> *_internalFriends;  <span class="comment">//实现文件里的可变集合</span></div><div class="line">&#125;</div><div class="line">- (<span class="built_in">NSSet</span>*)friends &#123;</div><div class="line">     <span class="keyword">return</span> [_internalFriends <span class="keyword">copy</span>]; <span class="comment">//get方法返回的永远是可变set的不可变型</span></div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)addFriend:(EOCPerson*)person &#123;</div><div class="line">    [_internalFriends addObject:person]; <span class="comment">//在外部增加集合元素的操作</span></div><div class="line">    <span class="comment">//do something when add element</span></div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)removeFriend:(EOCPerson*)person &#123;</div><div class="line">    [_internalFriends removeObject:person]; <span class="comment">//在外部移除元素的操作</span></div><div class="line">    <span class="comment">//do something when remove element</span></div><div class="line">&#125;</div><div class="line">- (<span class="keyword">id</span>)initWithFirstName:(<span class="built_in">NSString</span>*)firstName andLastName:(<span class="built_in">NSString</span>*)lastName &#123;</div><div class="line">     <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        _firstName = firstName;</div><div class="line">        _lastName = lastName;</div><div class="line">        _internalFriends = [<span class="built_in">NSMutableSet</span> new];</div><div class="line">    &#125;</div><div class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在实现文件里，保存一个可变set来记录外部的增删操作。</p>
<p>这里最重要的代码是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSSet</span>*)friends &#123;</div><div class="line"> <span class="keyword">return</span> [_internalFriends <span class="keyword">copy</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>这个是friends属性的获取方法：它将当前保存的可变set复制了一不可变的set并返回。因此，外部读取到的set都将是不可变的版本。</p>
</blockquote>
<h4 id="等一下，有个疑问：在公共接口设置不可变set-和-将增删的代码放在公共接口中是否矛盾的？"><a href="#等一下，有个疑问：在公共接口设置不可变set-和-将增删的代码放在公共接口中是否矛盾的？" class="headerlink" title="等一下，有个疑问：在公共接口设置不可变set 和 将增删的代码放在公共接口中是否矛盾的？"></a>等一下，有个疑问：在公共接口设置不可变set 和 将增删的代码放在公共接口中是否矛盾的？</h4><h4 id="答案：并不矛盾"><a href="#答案：并不矛盾" class="headerlink" title="答案：并不矛盾!"></a>答案：<strong>并不矛盾!</strong></h4><p>因为如果将friends属性设置为可变的，那么外部就可以随便更改set集合里的数据，这里的更改，仅仅是底层数据的更改，并不伴随其他任何操作。<br>然而有时，我们需要在更改set数据的同时<strong>要执行隐秘在实现文件里的其他工作</strong>，那么如果在外部随意更改这个属性的话，显然是达不到这种需求的。</p>
<p>因此，我们需要提供给外界<strong>我们定制的</strong>增删的方法，并不让外部”自行“增删。</p>
<h1 id="第19条：使用清晰而协调的命名方式"><a href="#第19条：使用清晰而协调的命名方式" class="headerlink" title="第19条：使用清晰而协调的命名方式"></a>第19条：使用清晰而协调的命名方式</h1><hr>
<p>在给OC的方法取名字的时候要充分利用OC方法的命名优势，取一个<strong>语义清晰</strong>的方法名！什么叫语义清晰呢?就是说读起来像是一句话一样。</p>
<p>我们看一个例子：</p>
<p>先看名字取得不好的：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法定义</span></div><div class="line">- (<span class="keyword">id</span>)initWithSize:(<span class="keyword">float</span>)width :(<span class="keyword">float</span>)height;</div><div class="line"><span class="comment">//方法调用</span></div><div class="line">EOCRectangle *aRectangle =[[EOCRectangle alloc] initWithSize:<span class="number">5.0</span>f :<span class="number">10.0</span>f];</div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里定义了Rectangle的初始化方法。虽然直观上可以知道这个方法通过传入的两个参数来组成矩形的size，但是我们并不知道哪个是矩形的宽，哪个是矩形的高。<br>来看一下正确的🌰 ：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//方法定义</span></div><div class="line">- (<span class="keyword">id</span>)initWithWidth:(<span class="keyword">float</span>)width andHeight:(<span class="keyword">float</span>)height;</div><div class="line"><span class="comment">//方法调用</span></div><div class="line">EOCRectangle *aRectangle =[[EOCRectangle alloc] initWithWidth:<span class="number">5.0</span>f andHeight:<span class="number">10.0</span>f];</div></pre></td></tr></table></figure>
<blockquote>
<p>这个方法名就很好的诠释了该方法的意图：这个类的初始化是需要宽度和高度的。而且，哪个参数是高度，哪个参数是宽度，看得人一清二楚。永远要记得：<strong>代码是给人看的</strong>。</p>
</blockquote>
<p>笔者自己总结的方法命名规则：</p>
<blockquote>
<p>每个冒号左边的方法部分最好与右边的参数名一致。</p>
</blockquote>
<p>对于返回值是布尔值的方法，我们也要注意命名的规范：</p>
<ul>
<li>获取”是否“的布尔值，应该增加“is”前缀：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- hasPrefix:</div></pre></td></tr></table></figure>
<p>获取“是否有”的布尔值，应该增加“has”前缀：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- isEqualToString:</div></pre></td></tr></table></figure>
<h1 id="第20条：为私有方法名加前缀"><a href="#第20条：为私有方法名加前缀" class="headerlink" title="第20条：为私有方法名加前缀"></a>第20条：为私有方法名加前缀</h1><hr>
<p>建议在实现文件里将非公开的方法都加上前缀，便于调试，而且这样一来也很容易区分哪些是公共方法，哪些是私有方法。因为往往公共方法是不便于任意修改的。</p>
<p>在这里，作者举了个例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCObject</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="keyword">void</span>)publicMethod;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCObject</span></span></div><div class="line">- (<span class="keyword">void</span>)publicMethod &#123;</div><div class="line"> <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)p_privateMethod &#123;</div><div class="line"> <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：<br>不要用下划线来区分私有方法和公共方法，因为会和苹果公司的API重复。</p>
</blockquote>
<h1 id="第23条：通过委托与数据源协议进行对象间通信"><a href="#第23条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第23条：通过委托与数据源协议进行对象间通信"></a>第23条：通过委托与数据源协议进行对象间通信</h1><hr>
<p>如果给委托对象发送消息，那么必须提前判断该委托对象是否实现了该消息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSData</span> *data = <span class="comment">/* data obtained from network */</span>;</div><div class="line"><span class="keyword">if</span> ([_delegate respondsToSelector: <span class="keyword">@selector</span>(networkFetcher:didReceiveData:)])</div><div class="line">&#123;</div><div class="line">        [_delegate networkFetcher:<span class="keyword">self</span> didReceiveData:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而且，最好再加上一个判断：判断委托对象是否存在<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSData</span> *data = <span class="comment">/* data obtained from network */</span>;</div><div class="line"><span class="keyword">if</span> ( (_delegate) &amp;&amp; ([_delegate respondsToSelector: <span class="keyword">@selector</span>(networkFetcher:didReceiveData:)]))</div><div class="line">&#123;</div><div class="line">        [_delegate networkFetcher:<span class="keyword">self</span> didReceiveData:data];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于代理模式，在iOS中分为两种：</p>
<ul>
<li>普通的委托模式:信息从类流向委托者</li>
<li>信息源模式:信息从数据源流向类</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d9349b44ab6fba52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="普通的委托 | 信息源"></p>
<blockquote>
<p>就好比tableview告诉它的代理（delegate）“我被点击了”；而它的数据源（data Source）告诉它“你有这些数据”。仔细回味一下，这两个信息的传递方向是相反的。</p>
</blockquote>
<h1 id="第24条：将类的实现代码分散到便于管理的数个分类中"><a href="#第24条：将类的实现代码分散到便于管理的数个分类中" class="headerlink" title="第24条：将类的实现代码分散到便于管理的数个分类中"></a>第24条：将类的实现代码分散到便于管理的数个分类中</h1><hr>
<p>通常一个类会有很多方法，而这些方法往往可以用某种特有的逻辑来分组。我们可以利用OC的分类机制，将类的这些方法按一定的逻辑划入几个分区中。</p>
<p>例子：</p>
<p>无分类的类：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *friends;</div><div class="line">- (<span class="keyword">id</span>)initWithFirstName:(<span class="built_in">NSString</span>*)firstName andLastName:(<span class="built_in">NSString</span>*)lastName;</div><div class="line"><span class="comment">/* Friendship methods */</span></div><div class="line">- (<span class="keyword">void</span>)addFriend:(EOCPerson*)person;</div><div class="line">- (<span class="keyword">void</span>)removeFriend:(EOCPerson*)person;</div><div class="line">- (<span class="built_in">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class="line"><span class="comment">/* Work methods */</span></div><div class="line">- (<span class="keyword">void</span>)performDaysWork;</div><div class="line">- (<span class="keyword">void</span>)takeVacationFromWork;</div><div class="line"><span class="comment">/* Play methods */</span></div><div class="line">- (<span class="keyword">void</span>)goToTheCinema;</div><div class="line">- (<span class="keyword">void</span>)goToSportsGame;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>分类之后：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *friends;</div><div class="line">- (<span class="keyword">id</span>)initWithFirstName:(<span class="built_in">NSString</span>*)firstName</div><div class="line">andLastName:(<span class="built_in">NSString</span>*)lastName;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> (<span class="title">Friendship</span>)</span></div><div class="line">- (<span class="keyword">void</span>)addFriend:(EOCPerson*)person;</div><div class="line">- (<span class="keyword">void</span>)removeFriend:(EOCPerson*)person;</div><div class="line">- (<span class="built_in">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> (<span class="title">Work</span>)</span></div><div class="line">- (<span class="keyword">void</span>)performDaysWork;</div><div class="line">- (<span class="keyword">void</span>)takeVacationFromWork;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> (<span class="title">Play</span>)</span></div><div class="line">- (<span class="keyword">void</span>)goToTheCinema;</div><div class="line">- (<span class="keyword">void</span>)goToSportsGame;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>其中，FriendShip分类的实现代码可以这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// EOCPerson+Friendship.h</span></div><div class="line"><span class="meta">#import <span class="meta-string">"EOCPerson.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> (<span class="title">Friendship</span>)</span></div><div class="line">- (<span class="keyword">void</span>)addFriend:(EOCPerson*)person;</div><div class="line">- (<span class="keyword">void</span>)removeFriend:(EOCPerson*)person;</div><div class="line">- (<span class="built_in">BOOL</span>)isFriendsWith:(EOCPerson*)person;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="comment">// EOCPerson+Friendship.m</span></div><div class="line"><span class="meta">#import <span class="meta-string">"EOCPerson+Friendship.h"</span></span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span> (<span class="title">Friendship</span>)</span></div><div class="line">- (<span class="keyword">void</span>)addFriend:(EOCPerson*)person &#123;</div><div class="line"> <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line">- (<span class="keyword">void</span>)removeFriend:(EOCPerson*)person &#123;</div><div class="line"> <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line">- (<span class="built_in">BOOL</span>)isFriendsWith:(EOCPerson*)person &#123;</div><div class="line"> <span class="comment">/* ... */</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<blockquote>
<p>注意：在新建分类文件时，一定要引入被分类的类文件。</p>
</blockquote>
<p>通过分类机制，可以把类代码分成很多个易于管理的功能区，同时也便于调试。因为分类的方法名称会包含分类的名称，可以马上看到该方法属于哪个分类中。</p>
<p>利用这一点，我们可以创建名为Private的分类，将所有私有方法都放在该类里。这样一来，我们就可以根据private一词的出现位置来判断调用的合理性，这也是一种编写“自我描述式代码（self-documenting）”的办法。</p>
<h1 id="第25条：总是为第三方类的分类名称加前缀"><a href="#第25条：总是为第三方类的分类名称加前缀" class="headerlink" title="第25条：总是为第三方类的分类名称加前缀"></a>第25条：总是为第三方类的分类名称加前缀</h1><hr>
<p>分类机制虽然强大，但是如果分类里的方法与原来的方法名称一致，那么分类的方法就会覆盖掉原来的方法，而且总是以最后一次被覆盖为基准。</p>
<p>因此，我们应该以命名空间来区别各个分类的名称与其中定义的方法。在OC里的做法就是给这些方法加上某个共用的前缀。例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSString</span> (<span class="title">ABC_HTTP</span>)</span></div><div class="line"><span class="comment">// Encode a string with URL encoding</span></div><div class="line">- (<span class="built_in">NSString</span>*)abc_urlEncodedString;</div><div class="line"><span class="comment">// Decode a URL encoded string</span></div><div class="line">- (<span class="built_in">NSString</span>*)abc_urlDecodedString;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>因此，如果我们想给第三方库或者iOS框架里的类添加分类时，最好将分类名和方法名加上前缀。</p>
<h1 id="第26条-勿在分类中声明属性"><a href="#第26条-勿在分类中声明属性" class="headerlink" title="第26条:勿在分类中声明属性"></a>第26条:勿在分类中声明属性</h1><hr>
<p>除了实现文件里的class-continuation分类中可以声明属性外，其他分类无法向类中新增实例变量。</p>
<p>因此，类所封装的全部数据都应该定义在主接口中，这里是唯一能够定义实例变量的地方。</p>
<p>关于分类，需要强调一点：</p>
<blockquote>
<p>分类机制，目标在于扩展类的功能，而不是封装数据。</p>
</blockquote>
<h2 id="第27条：使用class-continuation分类-隐藏实现细节"><a href="#第27条：使用class-continuation分类-隐藏实现细节" class="headerlink" title="#第27条：使用class-continuation分类 隐藏实现细节"></a>#第27条：使用class-continuation分类 隐藏实现细节</h2><p>通常，我们需要减少在公共接口中向外暴露的部分(包括属性和方法)，而因此带给我们的局限性可以利用class-continuation分类的特性来补偿：</p>
<ul>
<li>可以在class-continuation分类中增加实例变量。</li>
<li>可以在class-continuation分类中将公共接口的只读属性设置为读写。</li>
<li>可以在class-continuation分类中遵循协议，使其不为人知。</li>
</ul>
<h1 id="第31条：在dealloc方法中只释放引用并解除监听"><a href="#第31条：在dealloc方法中只释放引用并解除监听" class="headerlink" title="第31条：在dealloc方法中只释放引用并解除监听"></a>第31条：在dealloc方法中只释放引用并解除监听</h1><hr>
<p>永远不要自己调用dealloc方法，运行期系统会在适当的时候调用它。根据性能需求我们有时需要在dealloc方法中做一些操作。那么我们可以在dealloc方法里做什么呢？</p>
<ul>
<li>释放对象所拥有的所有引用，不过ARC会自动添加这些释放代码，可以不必操心。</li>
<li>而且对象拥有的其他非OC对象也要释放（CoreFoundation对象就必须手动释放）</li>
<li>释放原来的观测行为：注销通知。如果没有及时注销，就会向其发送通知，使得程序崩溃。</li>
</ul>
<p>举个简单的🌰 ：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line"></div><div class="line">     <span class="built_in">CFRelease</span>(coreFoundationObject);</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>尤其注意</strong>：在dealloc方法中不应该调用其他的方法，因为如果这些方法是异步的，并且回调中还要使用当前对象，那么很有可能当前对象已经被释放了，会导致崩溃。</p>
<p>并且在dealloc方法中也不能调用属性的存取方法，因为很有可能在这些方法里还有其他操作。而且这个属性还有可能处于键值观察状态，该属性的观察者可能会在属性改变时保留或者使用这个即将回收的对象。</p>
</blockquote>
<h1 id="第36条：不要使用retainCount"><a href="#第36条：不要使用retainCount" class="headerlink" title="第36条：不要使用retainCount"></a>第36条：不要使用retainCount</h1><hr>
<p>在非ARC得环境下使用retainCount可以返回当前对象的引用计数，但是在ARC环境下调用会报错，因为该方法已经被废弃了 。</p>
<p>它被废弃的原因是因为它所返回的引用计数只能反映对象某一时刻的引用计数，而无法“预知”对象将来引用计数的变化（比如对象当前处于自动释放池中，那么将来就会自动递减引用计数）。</p>
<h1 id="第46条：不要使用dispatch-get-current-queue"><a href="#第46条：不要使用dispatch-get-current-queue" class="headerlink" title="第46条：不要使用dispatch_get_current_queue"></a>第46条：不要使用dispatch_get_current_queue</h1><hr>
<p>我们无法用某个队列来描述“当前队列”这一属性，因为派发队列是按照层级来组织的。</p>
<p>那么什么是队列的层级呢?</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-e880be58b75c49c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="队列的层及分布"></p>
<p>安排在某条队列中的快，会在其上层队列中执行，而层级地位最高的那个队列总是全局并发队列。</p>
<p>在这里，B，C中的块会在A里执行。但是D中的块，可能与A里的块并行，因为A和D的目标队列是并发队列。</p>
<p>正因为有了这种层级关系，所以检查当前队列是并发的还是非并发的就不会总是很准确。</p>
<h1 id="第48条：多用块枚举，少用for循环"><a href="#第48条：多用块枚举，少用for循环" class="headerlink" title="第48条：多用块枚举，少用for循环"></a>第48条：多用块枚举，少用for循环</h1><hr>
<p>当遍历集合元素时，建议使用块枚举，因为相对于传统的for循环，它更加高效，而且简洁,还能获取到用传统的for循环无法提供的值：</p>
<p>我们首先看一下传统的遍历：</p>
<h4 id="传统的for遍历"><a href="#传统的for遍历" class="headerlink" title="传统的for遍历"></a>传统的for遍历</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *anArray = <span class="comment">/* ... */</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; anArray.count; i++) &#123;</div><div class="line">   <span class="keyword">id</span> object = anArray[i];</div><div class="line">   <span class="comment">// Do something with 'object'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Dictionary</span></div><div class="line"><span class="built_in">NSDictionary</span> *aDictionary = <span class="comment">/* ... */</span>;</div><div class="line"><span class="built_in">NSArray</span> *keys = [aDictionary allKeys];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keys.count; i++) &#123;</div><div class="line">   <span class="keyword">id</span> key = keys[i];</div><div class="line">   <span class="keyword">id</span> value = aDictionary[key];</div><div class="line">   <span class="comment">// Do something with 'key' and 'value'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Set</span></div><div class="line"><span class="built_in">NSSet</span> *aSet = <span class="comment">/* ... */</span>;</div><div class="line"><span class="built_in">NSArray</span> *objects = [aSet allObjects];</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; objects.count; i++) &#123;</div><div class="line">   <span class="keyword">id</span> object = objects[i];</div><div class="line">   <span class="comment">// Do something with 'object'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在遍历NSDictionary,和NSet时，我们又新创建了一个数组。虽然遍历的目的达成了，但是却加大了系统的开销。</p>
<h4 id="利用快速遍历："><a href="#利用快速遍历：" class="headerlink" title="利用快速遍历："></a>利用快速遍历：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *anArray = <span class="comment">/* ... */</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> anArray) &#123;</div><div class="line"> <span class="comment">// Do something with 'object'</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// Dictionary</span></div><div class="line"><span class="built_in">NSDictionary</span> *aDictionary = <span class="comment">/* ... */</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> aDictionary) &#123;</div><div class="line"> <span class="keyword">id</span> value = aDictionary[key];</div><div class="line"> <span class="comment">// Do something with 'key' and 'value'</span></div><div class="line">&#125;</div><div class="line"><span class="built_in">NSSet</span> *aSet = <span class="comment">/* ... */</span>;</div><div class="line"><span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> aSet) &#123;</div><div class="line"> <span class="comment">// Do something with 'object'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种快速遍历的方法要比传统的遍历方法更加简洁易懂，但是缺点是无法方便获取元素的下标。</p>
<h4 id="利用基于块（block）的遍历："><a href="#利用基于块（block）的遍历：" class="headerlink" title="利用基于块（block）的遍历："></a>利用基于块（block）的遍历：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span> *anArray = <span class="comment">/* ... */</span>;</div><div class="line">[anArray enumerateObjectsUsingBlock:^(<span class="keyword">id</span> object, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop)&#123;</div><div class="line">   <span class="comment">// Do something with 'object'</span></div><div class="line">   <span class="keyword">if</span> (shouldStop) &#123;</div><div class="line">      *stop = <span class="literal">YES</span>; <span class="comment">//使迭代停止</span></div><div class="line">  &#125;</div><div class="line">&#125;];</div><div class="line"><span class="comment">// Dictionary</span></div><div class="line"><span class="built_in">NSDictionary</span> *aDictionary = <span class="comment">/* ... */</span>;</div><div class="line">[aDictionary enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> key, <span class="keyword">id</span> object, <span class="built_in">BOOL</span> *stop)&#123;</div><div class="line">     <span class="comment">// Do something with 'key' and 'object'</span></div><div class="line">     <span class="keyword">if</span> (shouldStop) &#123;</div><div class="line">        *stop = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line"><span class="comment">// Set</span></div><div class="line"><span class="built_in">NSSet</span> *aSet = <span class="comment">/* ... */</span>;</div><div class="line">[aSet enumerateObjectsUsingBlock:^(<span class="keyword">id</span> object, <span class="built_in">BOOL</span> *stop)&#123;</div><div class="line">     <span class="comment">// Do something with 'object'</span></div><div class="line">     <span class="keyword">if</span> (shouldStop) &#123;</div><div class="line">        *stop = <span class="literal">YES</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在使用块进行快速枚举的时候，我们可以不创建临时数组。虽然语法上没有快速枚举简洁，但是我们可以获得数组元素对应的序号，字典元素对应的键值，而且，我们还可以随时令遍历终止。</p>
<p>利用快速枚举和块的枚举还有一个优点：能够修改块的方法签名</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> aDictionary) &#123;</div><div class="line">         <span class="built_in">NSString</span> *object = (<span class="built_in">NSString</span>*)aDictionary[key];</div><div class="line">        <span class="comment">// Do something with 'key' and 'object'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSDictionary</span> *aDictionary = <span class="comment">/* ... */</span>;</div><div class="line">    [aDictionary enumerateKeysAndObjectsUsingBlock:^(<span class="built_in">NSString</span> *key, <span class="built_in">NSString</span> *obj, <span class="built_in">BOOL</span> *stop)&#123;</div><div class="line">             <span class="comment">// Do something with 'key' and 'obj'</span></div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p>如果我们可以知道集合里的元素类型，就可以修改签名。这样做的好处是：可以让编译期检查该元素是否可以实现我们想调用的方法，如果不能实现，就做另外的处理。这样一来，程序就能变得更加安全。</p>
<h1 id="第50条：构建缓存时选用NSCache-而非NSDictionary"><a href="#第50条：构建缓存时选用NSCache-而非NSDictionary" class="headerlink" title="第50条：构建缓存时选用NSCache 而非NSDictionary"></a>第50条：构建缓存时选用NSCache 而非NSDictionary</h1><hr>
<p>如果我们缓存使用得当，那么应用程序的响应速度就会提高。只有那种“重新计算起来很费事的数据，才值得放入缓存”，比如那些需要从网络获取或从磁盘读取的数据。</p>
<p>在构建缓存的时候很多人习惯用NSDictionary或者NSMutableDictionary，但是作者建议大家使用NSCache，它作为管理缓存的类，有很多特点要优于字典，因为它本来就是为了管理缓存而设计的。</p>
<h4 id="NSCache优于NSDictionary的几点："><a href="#NSCache优于NSDictionary的几点：" class="headerlink" title="NSCache优于NSDictionary的几点："></a>NSCache优于NSDictionary的几点：</h4><ul>
<li>当系统资源将要耗尽时，NSCache具备自动删减缓冲的功能。并且还会先删减“最久未使用”的对象。</li>
<li>NSCache不拷贝键，而是保留键。因为并不是所有的键都遵从拷贝协议（字典的键是必须要支持拷贝协议的，有局限性）。</li>
<li>NSCache是线程安全的：不编写加锁代码的前提下，多个线程可以同时访问NSCache。</li>
</ul>
<h4 id="关于操控NSCache删减内容的时机"><a href="#关于操控NSCache删减内容的时机" class="headerlink" title="关于操控NSCache删减内容的时机"></a>关于操控NSCache删减内容的时机</h4><p>开发者可以通过两个尺度来调整这个时机：</p>
<ul>
<li>缓存中的对象总数.</li>
<li>将对象加入缓存时，为其指定开销值。</li>
</ul>
<p>对于开销值，只有在能很快计算出开销值的情况下，才应该考虑采用这个尺度，不然反而会加大系统的开销。</p>
<p>下面我们来看一下缓存的用法：缓存网络下载的数据</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Network fetcher class</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>(^EOCNetworkFetcherCompletionHandler)(<span class="built_in">NSData</span> *data);</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCNetworkFetcher</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)initWithURL:(<span class="built_in">NSURL</span>*)url;</div><div class="line">- (<span class="keyword">void</span>)startWithCompletionHandler:(EOCNetworkFetcherCompletionHandler)handler;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// Class that uses the network fetcher and caches results</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCClass</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCClass</span> </span>&#123;</div><div class="line">     <span class="built_in">NSCache</span> *_cache;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line"></div><div class="line">     <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">    _cache = [<span class="built_in">NSCache</span> new];</div><div class="line"></div><div class="line">     <span class="comment">// Cache a maximum of 100 URLs</span></div><div class="line">    _cache.countLimit = <span class="number">100</span>;</div><div class="line"></div><div class="line"></div><div class="line">     <span class="comment">/**</span></div><div class="line">     * The size in bytes of data is used as the cost,</div><div class="line">     * so this sets a cost limit of 5MB.</div><div class="line">     */</div><div class="line">    _cache.totalCostLimit = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</div><div class="line">    &#125;</div><div class="line"> <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)downloadDataForURL:(<span class="built_in">NSURL</span>*)url &#123; </div><div class="line"></div><div class="line">     <span class="built_in">NSData</span> *cachedData = [_cache objectForKey:url];</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (cachedData) &#123;</div><div class="line"></div><div class="line">         <span class="comment">// Cache hit：存在缓存，读取</span></div><div class="line">        [<span class="keyword">self</span> useData:cachedData];</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">         <span class="comment">// Cache miss：没有缓存，下载</span></div><div class="line">         EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];      </div><div class="line"></div><div class="line">        [fetcher startWithCompletionHandler:^(<span class="built_in">NSData</span> *data)&#123;</div><div class="line">         [_cache setObject:data forKey:url cost:data.length];    </div><div class="line">        [<span class="keyword">self</span> useData:data];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>在这里，我们使用URL作为缓存的key，将总对象数目设置为100，将开销值设置为5MB。</p>
<h2 id="NSPurgeableData"><a href="#NSPurgeableData" class="headerlink" title="NSPurgeableData"></a>NSPurgeableData</h2><p>NSPurgeableData是NSMutableData的子类，把它和NSCache配合使用效果很好。</p>
<p>因为当系统资源紧张时，可以把保存NSPurgeableData的那块内存释放掉。</p>
<p>如果需要访问某个NSPurgeableData对象，可以调用<code>beginContentAccess</code>方发，告诉它现在还不应该丢弃自己所占据的内存。</p>
<p>在使用完之后，调用<code>endContentAccess</code>方法，告诉系统在必要时可以丢弃自己所占据的内存。</p>
<blockquote>
<p>上面这两个方法类似于“引用计数”递增递减的操作，也就是说，只有当“引用计数”为0的时候，才可以在将来删去它所占的内存。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">- (void)downloadDataForURL:(NSURL*)url &#123; </div><div class="line"></div><div class="line">      NSPurgeableData *cachedData = [_cache objectForKey:url];</div><div class="line"></div><div class="line">      if (cachedData) &#123;         </div><div class="line"></div><div class="line">            // 如果存在缓存，需要调用beginContentAccess方法</div><div class="line">            [cacheData beginContentAccess];</div><div class="line"></div><div class="line">             // Use the cached data</div><div class="line">            [self useData:cachedData];</div><div class="line"></div><div class="line">             // 使用后，调用endContentAccess</div><div class="line">            [cacheData endContentAccess];</div><div class="line"></div><div class="line"></div><div class="line">        &#125; else &#123;</div><div class="line"></div><div class="line">                 //没有缓存</div><div class="line">                 EOCNetworkFetcher *fetcher = [[EOCNetworkFetcher alloc] initWithURL:url];    </div><div class="line"></div><div class="line">                  [fetcher startWithCompletionHandler:^(NSData *data)&#123;</div><div class="line"></div><div class="line">                         NSPurgeableData *purgeableData = [NSPurgeableData dataWithData:data];</div><div class="line">                         [_cache setObject:purgeableData forKey:url cost:purgeableData.length];</div><div class="line"></div><div class="line">                          // Don&apos;t need to beginContentAccess as it begins            </div><div class="line">                          // with access already marked</div><div class="line">                           // Use the retrieved data</div><div class="line">                            [self useData:data];</div><div class="line"></div><div class="line">                             // Mark that the data may be purged now</div><div class="line">                            [purgeableData endContentAccess];</div><div class="line"></div><div class="line">            &#125;];</div><div class="line">      &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
</blockquote>
<p>在我们可以直接拿到purgeableData的情况下需要执行<code>beginContentAccess</code>方法。然而，在创建purgeableData的情况下，是不需要执行beginContentAccess，因为在创建了purgeableData之后，其引用计数会自动+1；</p>
<h1 id="第51条-精简initialize-与-load的实现代码"><a href="#第51条-精简initialize-与-load的实现代码" class="headerlink" title="第51条: 精简initialize 与 load的实现代码"></a>第51条: 精简initialize 与 load的实现代码</h1><hr>
<h2 id="load方法"><a href="#load方法" class="headerlink" title="load方法"></a>load方法</h2><p><code>+(void)load;</code><br>每个类和分类在加入运行期系统时，都会调用<code>load</code>方法，而且仅仅调用一次，可能有些小伙伴习惯在这里调用一些方法，但是作者建议尽量不要在这个方法里调用其他方法，尤其是使用其他的类。原因是每个类载入程序库的时机是不同的，如果该类调用了还未载入程序库的类，就会很危险。</p>
<h2 id="initialize方法"><a href="#initialize方法" class="headerlink" title="initialize方法"></a>initialize方法</h2><p><code>+(void)initialize;</code></p>
<p>这个方法与<code>load</code>方法类似，区别是这个方法会在程序<strong>首次</strong>调用这个类的时候调用（惰性调用），而且只调用一次（绝对不能主动使用代码调用）。</p>
<p>值得注意的一点是，如果子类没有实现它，它的超类却实现了，那么就会运行超类的代码：这个情况往往很容易让人忽视。</p>
<p>看一下🌰 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCBaseClass : NSObject</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCBaseClass</div><div class="line">+ (void)initialize &#123;</div><div class="line"> NSLog(@&quot;%@ initialize&quot;, self);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@interface EOCSubClass : EOCBaseClass</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation EOCSubClass</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>当使用EOCSubClass类时，控制台会输出两次打印方法：<br><code>EOCBaseClass initialize
EOCSubClass initialize</code></p>
<p>因为子类EOCSubClass并没有覆写<code>initialize</code>方法，那么自然会调用其父类EOCBaseClass的方法。<br>解决方案是通过检测类的类型的方法：</p>
<p>``</p>
<ul>
<li>(void)initialize {<br> if (self == [EOCBaseClass class]) {<pre><code>NSLog(@&quot;%@ initialized&quot;, self);
</code></pre>  }<br>}<br>``</li>
</ul>
<p>这样一来，EOCBaseClass的子类EOCSubClass就无法再调用<code>initialize</code>方法了。<br>我们可以察觉到，如果在这个方法里执行过多的操作的话，会使得程序难以维护，也可能引起其他的bug。因此，在<code>initialize</code>方法里，最好只是设置内部的数据，不要调用其他的方法，因为将来可能会给这些方法添加其它的功能，那么会可能会引起难以排查的bug。</p>
<h1 id="第52条-别忘了NSTimer会保留其目标对象"><a href="#第52条-别忘了NSTimer会保留其目标对象" class="headerlink" title="第52条: 别忘了NSTimer会保留其目标对象"></a>第52条: 别忘了NSTimer会保留其目标对象</h1><hr>
<p>在使用NSTimer的时候，NSTimer会生成指向其使用者的引用，而其使用者如果也引用了NSTimer，那么就会生成保留环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface EOCClass : NSObject</div><div class="line">- (void)startPolling;</div><div class="line">- (void)stopPolling;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line">@implementation EOCClass &#123;</div><div class="line">     NSTimer *_pollTimer;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (id)init &#123;</div><div class="line">     return [super init];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)dealloc &#123;</div><div class="line">    [_pollTimer invalidate];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)stopPolling &#123;</div><div class="line"></div><div class="line">    [_pollTimer invalidate];</div><div class="line">    _pollTimer = nil;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (void)startPolling &#123;</div><div class="line">   _pollTimer = [NSTimer scheduledTimerWithTimeInterval:5.0</div><div class="line">                                                 target:self</div><div class="line">                                               selector:@selector(p_doPoll)</div><div class="line">                                               userInfo:nil</div><div class="line">                                                repeats:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)p_doPoll &#123;</div><div class="line">    // Poll the resource</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，在EOCClass和_pollTimer之间形成了保留环，如果不主动调用<code>stopPolling</code>方法就无法打破这个保留环。像这种通过主动调用方法来打破保留环的设计显然是不好的。</p>
</blockquote>
<p>而且，如果通过回收该类的方法来打破此保留环也是行不通的，因为会将该类和NSTimer孤立出来，形成“孤岛”:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d60b4571e7709e46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="孤立了类和它的NSTimer"></p>
<p>这可能是一个极其危险的情况，因为NSTimer没有消失，它还有可能持续执行一些任务，不断消耗系统资源。而且，如果任务涉及到下载，那么可能会更糟。。</p>
<p>那么如何解决呢？ 通过“块”来解决！</p>
<p>通过给NSTimer增加一个分类就可以解决：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">                                         block:(void(^)())block</div><div class="line">                                         repeats:(BOOL)repeats;</div><div class="line">@end</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@implementation NSTimer (EOCBlocksSupport)</div><div class="line"></div><div class="line">+ (NSTimer*)eoc_scheduledTimerWithTimeInterval:(NSTimeInterval)interval</div><div class="line">                                         block:(void(^)())block</div><div class="line">                                        repeats:(BOOL)repeats</div><div class="line">&#123;</div><div class="line">             return [self scheduledTimerWithTimeInterval:interval</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(eoc_blockInvoke:)</div><div class="line">                                                userInfo:[block copy]</div><div class="line">                                                 repeats:repeats];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">+ (void)eoc_blockInvoke:(NSTimer*)timer &#123;</div><div class="line">     void (^block)() = timer.userInfo;</div><div class="line">         if (block) &#123;</div><div class="line">             block();</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>我们在NSTimer类里添加了方法，我们来看一下如何使用它：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)startPolling &#123;</div><div class="line"></div><div class="line">         __<span class="keyword">weak</span> EOCClass *weakSelf = <span class="keyword">self</span>;    </div><div class="line">         _pollTimer = [<span class="built_in">NSTimer</span> eoc_scheduledTimerWithTimeInterval:<span class="number">5.0</span> block:^&#123;</div><div class="line"></div><div class="line">               EOCClass *strongSelf = weakSelf;</div><div class="line">               [strongSelf p_doPoll];</div><div class="line">          &#125;</div><div class="line"></div><div class="line">                                                          repeats:<span class="literal">YES</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>﻿在这里，创建了一个self的弱引用，然后让块捕获了这个self变量，让其在执行期间存活。</p>
<p>一旦外界指向EOC类的最后一个引用消失，该类就会被释放，被释放的同时，也会向NSTimer发送invalidate消息（因为在该类的dealloc方法中向NSTimer发送了invalidate消息）。</p>
<p>而且，即使在dealloc方法里没有发送invalidate消息，因为块里的weakSelf会变成nil，所以NSTimer同样会失效。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>总的来说这一部分还是比较容易理解的，更多的只是教我们一些编写OC程序的规范，并没有深入讲解技术细节。</p>
<p>而三部曲的最后一篇：技巧篇则着重讲解了一些在编写OC代码的过程中可以使用的一些技巧。广义上来讲，这些技巧也可以被称为“规范”，例如“提供全能初始化方法”这一节，但是这些知识点更像是一些“设计模式”目的更偏向于在于解决一些实际问题，因此将这些知识点归类为“技巧类”。</p>
<p>因为第三篇的内容稍微难一点，所以笔者打算再好好消化几天，将第三篇的初稿再三润饰之后呈献给大家~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》&quot;&gt;&lt;/p&gt;
&lt;p&gt;继上一篇&lt;a href=&quot;http://www.jianshu.com/p/9c93c7ab734d&quot;&gt;《Effective Objective-C 》超级干货三部曲（一）：概念篇&lt;/a&gt;之后，本篇即是三部曲的第二篇：规范篇。&lt;br&gt;没看过三部曲第一篇的小伙伴可能不知道我在说神马，在这里还是先啰嗦一下三部曲是咋回事：笔者将《Effective Objective-C 》这本书的52个知识点分为三大类进行了归类整理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念类：讲解了一些概念性知识。&lt;/li&gt;
&lt;li&gt;规范类：讲解了一些为了避免一些问题或者为后续开发提供便利所需要遵循的规范性知识。&lt;/li&gt;
&lt;li&gt;技巧类：讲解了一些为了解决某些特定问题而需要用到的技巧性知识。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后用思维导图整理了一下：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-0599d987732d932e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;三部曲分布图&quot;&gt;&lt;/p&gt;
&lt;p&gt;作为三部曲的第二篇，本篇总结抽取了《Effective Objective-C 》这本书中讲解规范性知识的部分：这些知识点都是为了避免在开发过程中出现问题或给开发提供便利的规范性知识点。掌握这些知识有助于形成科学地写OC代码的习惯，使得代码更加容易维护和扩展，学习这类知识是iOS初学者进阶的必经之路。&lt;/p&gt;
&lt;p&gt;好吧，不费话了，开始了！&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Objective-C》超级干货三部曲（一）：概念篇</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E3%80%8AEffective%20Objective-C%E3%80%8B%E8%B6%85%E7%BA%A7%E5%B9%B2%E8%B4%A7%E4%B8%89%E9%83%A8%E6%9B%B2%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E6%A6%82%E5%BF%B5%E7%AF%87/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/《Effective Objective-C》超级干货三部曲（一）：概念篇/</id>
    <published>2017-01-13T05:50:51.000Z</published>
    <updated>2017-03-20T07:49:49.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》"></p>
<p>很多文章和大牛都在推荐这本书，说它讲授了很多编写Objective-C语言时所应该遵循的规范。刚好笔者前段时间因为产品刚开发完，有了一点空档期，于是用了3个星期的时间仔细研读和总结了这本书。</p>
<p>在学习过程中也看过很多总结这本书的博客和文章，但是发现多数只是将每节的总结部分抄了过来，讲得并不是很详细，于是笔者就想按照自己的方式对这本书进行总结，并以博客的形式展现出来：既能分享，同时又能对知识进行一下梳理和二次复习。</p>
<p>虽然本书的作者按照知识模块来将这本书分成七个章节，共52节，但是笔者在拜读的过程中发现本书介绍的知识点可以大致分为三类：概念类，规范类，和技巧类。笔者打算按照这三类来对这本书进行总结，形成三部曲：</p>
<ul>
<li>概念类：讲解了一些概念性知识。</li>
<li>规范类：讲解了一些为了避免一些问题或者为后续开发提供便利所需要遵循的规范性知识。</li>
<li>技巧类：讲解了一些为了解决某些特定问题而需要用到的技巧性知识。</li>
</ul>
<p>而且，笔者也按照自己的归类将这本书的结构用思维导图工具画了出来：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-539498fef0819472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="三部曲分布图"></p>
<blockquote>
<p>从图中可以看到，笔者并没有打乱原来作者的标题顺序。本篇总结即是三部曲之一：概念篇，后续会呈上规范篇和技巧篇。<br>备注：本总结所有的代码和图片都来自原书。其中，代码会适当加上笔者的注释，便于各位看官理解。</p>
</blockquote>
<p>好了，不啰嗦了， 开始吧！</p>
<a id="more"></a>
<h1 id="第1条：了解Objective-C的起源"><a href="#第1条：了解Objective-C的起源" class="headerlink" title="第1条：了解Objective-C的起源"></a>第1条：了解Objective-C的起源</h1><hr>
<h2 id="1-运行期组件"><a href="#1-运行期组件" class="headerlink" title="1. 运行期组件"></a>1. 运行期组件</h2><p>对于消息结构的语言，运行时所执行的代码由运行环境来决定；在运行时才回去查找索要执行的方法。其实现原理是由运行期组件完成（runtime component），使用Objective-C的面向对象特性所需的全部数据结构以及函数都在运行期组件里面。</p>
<p>运行期组件本质上是一种与开发者所编写的代码相链接的动态库（dynamic library），其代码能把开发者所编写的所有程序粘合起来，所以只要更新运行期组件，就可以提升应用程序性能。</p>
<p>内存：对象分配到堆空间,指针分配到栈空间。<br>分配在队中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。</p>
<p>不含*的变量，可能会使用栈空间。结构体保存非对象类型。</p>
<h1 id="第6条：理解“属性”这一概念"><a href="#第6条：理解“属性”这一概念" class="headerlink" title="第6条：理解“属性”这一概念"></a>第6条：理解“属性”这一概念</h1><hr>
<blockquote>
<p>属性用于封装对象中的数据。</p>
</blockquote>
<h2 id="1-存取方法"><a href="#1-存取方法" class="headerlink" title="1. 存取方法"></a>1. 存取方法</h2><p>在设置完属性后，编译器会自动写出一套存取方法，用于访问相应名称的变量：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSObject</span></span></div><div class="line">- (<span class="built_in">NSString</span>*)firstName;</div><div class="line">- (<span class="keyword">void</span>)setFirstName:(<span class="built_in">NSString</span>*)firstName;</div><div class="line">- (<span class="built_in">NSString</span>*)lastName;</div><div class="line">- (<span class="keyword">void</span>)setLastName:(<span class="built_in">NSString</span>*)lastName;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<p>访问属性，可以使用点语法。编译器会把点语法转换为对存取方法的调用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">aPerson.firstName = <span class="string">@"Bob"</span>; <span class="comment">// Same as:</span></div><div class="line">[aPerson setFirstName:<span class="string">@"Bob"</span>];</div><div class="line"></div><div class="line"><span class="built_in">NSString</span> *lastName = aPerson.lastName; <span class="comment">// Same as:</span></div><div class="line"><span class="built_in">NSString</span> *lastName = [aPerson lastName];</div></pre></td></tr></table></figure>
<p>如果我们不希望编译器自动生成存取方法的话，需要设置@dynamic 字段：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCPerson</span> : <span class="title">NSManagedObject</span></span></div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *firstName;</div><div class="line"><span class="keyword">@property</span> <span class="built_in">NSString</span> *lastName;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCPerson</span></span></div><div class="line"><span class="keyword">@dynamic</span> firstName, lastName;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
<h2 id="2-属相特质"><a href="#2-属相特质" class="headerlink" title="2. 属相特质"></a>2. 属相特质</h2><blockquote>
<p>定义属性的时候，通常会赋予它一些特性，来满足一些对类保存数据所要遵循的需求。</p>
</blockquote>
<h4 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h4><ul>
<li>nonatomic：不使用同步锁</li>
<li>atomic：加同步锁，确保其原子性</li>
</ul>
<h4 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h4><ul>
<li>readwrite:同时存在存取方法</li>
<li>readonly:只有获取方法</li>
</ul>
<h4 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h4><ul>
<li>assign:纯量类型(scalar type)的简单赋值操作</li>
<li>strong:拥有关系保留新值，释放旧值，再设置新值</li>
<li>weak:非拥有关系(nonowning relationship)，属性所指的对象遭到摧毁时，属性也会清空</li>
<li>unsafe_unretained ：类似assign，适用于对象类型，非拥有关系，属性所指的对象遭到摧毁时，属性不会清空。</li>
<li>copy：不保留新值，而是将其拷贝</li>
</ul>
<h4 id="注意：遵循属性定义"><a href="#注意：遵循属性定义" class="headerlink" title="注意：遵循属性定义"></a>注意：遵循属性定义</h4><p>如果属性定义为copy，那么在非设置方法里设定属性的时候，也要遵循copy的语义</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithFirstName:(<span class="built_in">NSString</span>*)firstName lastName:(<span class="built_in">NSString</span>*)lastName</div><div class="line">&#123;</div><div class="line">         <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">            _firstName = [firstName <span class="keyword">copy</span>];</div><div class="line">            _lastName = [lastName <span class="keyword">copy</span>];</div><div class="line">        &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第8条：理解“对象等同性”这一概念"><a href="#第8条：理解“对象等同性”这一概念" class="headerlink" title="第8条：理解“对象等同性”这一概念"></a>第8条：理解“对象等同性”这一概念</h1><hr>
<h2 id="1-同等性判断"><a href="#1-同等性判断" class="headerlink" title="1. 同等性判断"></a>1. 同等性判断</h2><blockquote>
<p>==操作符比较的是指针值，也就是内存地址。</p>
</blockquote>
<p>然而有的时候我们只是想比较指针所指向的内容，在这个时候，就需要通过<code>isEqual:</code>方法来比较。</p>
<p>而且，如果已知两个对象是字符串，最好通过<code>isEqualToString:</code>方法来比较。<br>对于数组和字典，也有<code>isEqualToArray:</code>方法和<code>isEqualToDictionary:</code>方法。</p>
<p>另外，如果比较的对象类型和当前对象类型相同，就可以采用自己编写的判定方法，否则调用父类的<code>isEqual:</code>方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)isEqualToPerson:(EOCPerson*)otherPerson &#123;</div><div class="line">     <span class="comment">//先比较对象类型，然后比较每个属性</span></div><div class="line">     <span class="keyword">if</span> (<span class="keyword">self</span> == object) <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">     <span class="keyword">if</span> (![_firstName isEqualToString:otherPerson.firstName])</div><div class="line">         <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">     <span class="keyword">if</span> (![_lastName isEqualToString:otherPerson.lastName])</div><div class="line">         <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">     <span class="keyword">if</span> (_age != otherPerson.age)</div><div class="line">         <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">     <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">BOOL</span>)isEqual:(<span class="keyword">id</span>)object &#123;</div><div class="line">    <span class="comment">//如果对象所属类型相同，就调用自己编写的判定方法，如果不同，调用父类的isEqual:方法</span></div><div class="line">     <span class="keyword">if</span> ([<span class="keyword">self</span> <span class="keyword">class</span>] == [object <span class="keyword">class</span>]) &#123;    </div><div class="line">         <span class="keyword">return</span> [<span class="keyword">self</span> isEqualToPerson:(EOCPerson*)object];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;    </div><div class="line">         <span class="keyword">return</span> [<span class="keyword">super</span> isEqual:object];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-深度等同性判定"><a href="#2-深度等同性判定" class="headerlink" title="2. 深度等同性判定"></a>2. 深度等同性判定</h2><p>比较两个数组是否相等的话可以使用深度同等性判断方法：</p>
<blockquote>
<p>1.先比较数组的个数<br>2.再比较两个数组对应位置上的对象均相等。</p>
</blockquote>
<h1 id="第11条：理解objc-msgSend的作用"><a href="#第11条：理解objc-msgSend的作用" class="headerlink" title="第11条：理解objc_msgSend的作用"></a>第11条：理解objc_msgSend的作用</h1><hr>
<p>在OC中，如果向某对象传递信息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数.</p>
<p>然而对象收到 消息后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得OC成为一门真正的动态语言。</p>
<p>在OC中，给对象发送消息的语法是：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = [someObject messageName:parameter];</div></pre></td></tr></table></figure>
<blockquote>
<p>这里，someObject叫做“接收者(receiver)”，messageName:叫做”选择子（selector）”,选择子和参数合起来称为“消息”。编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是消息传递机制中的核心函数叫做objc_msgSend，它的原型如下：</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL cmd, ...)</div></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数代表接收者，第二个参数代表选择子，后续参数就是消息中的那些参数，数量是可变的，所以这个函数就是参数个数可变的函数。</p>
</blockquote>
<p>因此，上述以OC形式展现出来的函数就会转化成如下函数:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> returnValue = objc_msgSend(someObject,<span class="keyword">@selector</span>(messageName:),parameter);</div></pre></td></tr></table></figure>
<blockquote>
<p>这个函数会在接收者所属的类中搜寻其“方法列表”，如果能找到与选择子名称相符的方法，就去实现代码，如果找不到就沿着继承体系继续向上查找。如果找到了就执行，如果最终还是找不到，就执行<strong>消息转发</strong>操作。</p>
<p><strong>注意</strong>：如果匹配成功的话，这种匹配的结果会缓存在“快速映射表”里面。每个类都有这样一块缓存。所以如果将来再次向该类发送形同的消息，执行速度就会更快了。</p>
</blockquote>
<h1 id="第12条：理解消息转发机制"><a href="#第12条：理解消息转发机制" class="headerlink" title="第12条：理解消息转发机制"></a>第12条：理解消息转发机制</h1><hr>
<p>如果对象所属类和其所有的父类都无法解读收到的消息，就会启动消息转发机制（message forwarding）。</p>
<p>尤其我们在编写自己的类时，可在消息转发过程中设置挂钩，用以执行预定的逻辑，而不应该使应用程序崩溃。</p>
<p>消息转发分为两个阶段:</p>
<ol>
<li><p>征询接受者，看它能否动态添加方法，以处理这个未知的选择子，这个过程叫做动态方法解析（dynamic method resolution）。</p>
</li>
<li><p>请接受者看看有没有其他对象能处理这条消息：</p>
<p>  2.1 如果有，则运行期系统会把消息转给那个对象。<br>  2.2 如果没有，则启动完整的消息转发机制（full forwarding mechanism），运行期系统会把与消息有关的全部细节都封装到NSInvocation对象中，再给接受者最后一次机会，令其设法解决当前还未处理的这条消息。</p>
</li>
</ol>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6619cbf33830ce3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Effective Objective-C 》"></p>
<p>类方法<code>+(BOOL)resolveInstanceMethod:(SEL)selector</code>:查看这个类是否能新增一个实例方法用以处理此选择子</p>
<p>实例方法<code>- (id)forwardTargetForSelector:(SEL)selector;</code>:询问是否能找到未知消息的备援接受者，如果能找到备援对象，就将其返回，如果不能，就返回nil。</p>
<p>实例方法<code>- (void)forwardInvocation:(NSInvocation*)invocation</code>:创建NSInvocation对象，将尚未处理的那条消息 有关的全部细节都封于其中，在触发NSInvocation对象时，“消息派发系统（message-dispatch system）”就会将消息派给目标对象。</p>
<p>下面来看一个关于动态方法解析的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCAutoDictionary</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *string;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSNumber</span> *number;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *date;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> opaqueObject;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="meta">#import <span class="meta-string">"EOCAutoDictionary.h"</span></span></div><div class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">EOCAutoDictionary</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *backingStore;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">EOCAutoDictionary</span></span></div><div class="line"><span class="keyword">@dynamic</span> string, number, date, opaqueObject;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)init &#123;</div><div class="line"> <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">    _backingStore = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">&#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector &#123;</div><div class="line"></div><div class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(selector);</div><div class="line">     <span class="keyword">if</span> ([selectorString hasPrefix:<span class="string">@"set"</span>]) &#123;</div><div class="line">         class_addMethod(<span class="keyword">self</span>,selector,(IMP)autoDictionarySetter, <span class="string">"v@:@"</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">         class_addMethod(<span class="keyword">self</span>,selector,(IMP)autoDictionaryGetter, <span class="string">"@@:"</span>);</div><div class="line">    &#125;</div><div class="line">     <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在本例中，EOCAutoDictionary类将属性设置为@dynamic，也就是说编译器无法自动为其属性生成set和get方法，因此我们需要动态给其添加set和get方法。</p>
<p>我们实现了<code>resolveInstanceMethod:</code>方法：首先将选择子转换为String，然后判断字符串是否含有set字段，如果有，则增加处理选择子的set方法；如果没有，则增加处理选择子的get方法。其中<code>class_addMethod</code>可以给类动态添加方法。</p>
</blockquote>
<p>实现增加处理选择子的get方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> autoDictionaryGetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</div><div class="line"></div><div class="line">     <span class="comment">// Get the backing store from the object</span></div><div class="line">     EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)<span class="keyword">self</span>;</div><div class="line">     <span class="built_in">NSMutableDictionary</span> *backingStore = typedSelf.backingStore;</div><div class="line"></div><div class="line">     <span class="comment">// The key is simply the selector name</span></div><div class="line">     <span class="built_in">NSString</span> *key = <span class="built_in">NSStringFromSelector</span>(_cmd);</div><div class="line"></div><div class="line">     <span class="comment">// Return the value</span></div><div class="line">     <span class="keyword">return</span> [backingStore objectForKey:key];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，键的名字就等于方法名，所以在取出键对应的值之前，要将方法名转换为字符串。</p>
</blockquote>
<p>实现增加处理选择子的set方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> autoDictionarySetter(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> value) &#123;</div><div class="line"></div><div class="line">     <span class="comment">// Get the backing store from the object</span></div><div class="line">     EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)<span class="keyword">self</span>;</div><div class="line">     <span class="built_in">NSMutableDictionary</span> *backingStore = typedSelf.backingStore;</div><div class="line"></div><div class="line">     <span class="comment">/** The selector will be for example, "setOpaqueObject:".</span></div><div class="line">     * We need to remove the "set", ":" and lowercase the first</div><div class="line">     * letter of the remainder.</div><div class="line">     */</div><div class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(_cmd);</div><div class="line">     <span class="built_in">NSMutableString</span> *key = [selectorString mutableCopy];</div><div class="line"></div><div class="line">     <span class="comment">// Remove the ':' at the end</span></div><div class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(key.length - <span class="number">1</span>, <span class="number">1</span>)];</div><div class="line"></div><div class="line">     <span class="comment">// Remove the 'set' prefix</span></div><div class="line">    [key deleteCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">3</span>)];</div><div class="line"></div><div class="line">     <span class="comment">// Lowercase the first character</span></div><div class="line">     <span class="built_in">NSString</span> *lowercaseFirstChar = [[key substringToIndex:<span class="number">1</span>] lowercaseString];</div><div class="line">    [key replaceCharactersInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">1</span>) withString:lowercaseFirstChar];</div><div class="line"></div><div class="line">     <span class="keyword">if</span> (value) &#123;</div><div class="line">       [backingStore setObject:value forKey:key];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [backingStore removeObjectForKey:key];        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>因为key的名字对应了属性名，也就是没有set，首字母小写，尾部没有：的字符串。然而，将set方法转换为字符串后，我们需要将set方法的这些“边角”都处理掉。最后得到了“纯净”的键后，再进行字典的赋值操作。</p>
</blockquote>
<h1 id="第14条：理解“类对象”的用意"><a href="#第14条：理解“类对象”的用意" class="headerlink" title="第14条：理解“类对象”的用意"></a>第14条：理解“类对象”的用意</h1><hr>
<p>在运行期程序库的头文件里定义了描述OC对象所用的数据结构：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_class *Class;</div><div class="line">    <span class="keyword">struct</span> objc_class &#123;</div><div class="line">         Class isa;</div><div class="line">         Class super_class;</div><div class="line">         <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">         <span class="keyword">long</span> version;</div><div class="line">         <span class="keyword">long</span> info;</div><div class="line">         <span class="keyword">long</span> instance_size;</div><div class="line">         <span class="keyword">struct</span> objc_ivar_list *ivars;</div><div class="line">         <span class="keyword">struct</span> objc_method_list **methodLists;</div><div class="line">         <span class="keyword">struct</span> objc_cache *cache;</div><div class="line">         <span class="keyword">struct</span> objc_protocol_list *protocols;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，isa指针指向了对象所属的类：元类（metaclass），它是整个结构体的第一个变量。super_class定义了本类的超类。</p>
</blockquote>
<p>我们也可以向对象发送特定的方法来检视类的继承体系：自身属于哪一类；自身继承与哪一类。</p>
<p>我们使用<code>isMemberOfClass:</code>能够判断出对象是否为某个特定类的实例；<br>而<code>isKindOfClass:</code>方法能够判断出对象是否为某类或其派生类的实例。</p>
<p>这两种方法都是利用了isa指针获取对象所属的类，然后通过super_class类在继承体系中查询。在OC语言中，必须使用这种查询类型信息的方法才能完全了解对象的真实类型。因为对象类型无法在编译期决定。</p>
<p>尤其注意在集合类里获取对象时，通常要查询类型信息因为这些对象不是强类型的（strongly typed），将它们从集合类中取出来的类型通常是id，也就是能响应任何消息（编译期）。</p>
<p>所以如果我们对这些对象的类型把握不好，那么就会有可能造成对象无法响应消息的情况。因此，在我们从集合里取出对象后，通常要进行类型判断：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)commaSeparatedStringFromObjects:(<span class="built_in">NSArray</span>*)array &#123;</div><div class="line"></div><div class="line">         <span class="built_in">NSMutableString</span> *string = [<span class="built_in">NSMutableString</span> new];</div><div class="line"></div><div class="line">             <span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> array) &#123;</div><div class="line">                    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSString</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                            [string appendFormat:<span class="string">@"%@,"</span>, object];</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                            [string appendFormat:<span class="string">@"%d,"</span>, [object intValue]];</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSData</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                           <span class="built_in">NSString</span> *base64Encoded = <span class="comment">/* base64 encoded data */</span>;</div><div class="line">                            [string appendFormat:<span class="string">@"%@,"</span>, base64Encoded];</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="comment">// Type not supported</span></div><div class="line">                    &#125;</div><div class="line">              &#125;</div><div class="line">             <span class="keyword">return</span> string;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第21条：理解Objective-C错误类型"><a href="#第21条：理解Objective-C错误类型" class="headerlink" title="第21条：理解Objective-C错误类型"></a>第21条：理解Objective-C错误类型</h1><hr>
<p>在OC中，我们可以用NSError描述错误。<br>使用NSError可以封装三种信息：</p>
<ul>
<li>Error domain:错误范围，类型是字符串</li>
<li>Error code :错误码，类型是整数</li>
<li>User info：用户信息，类型是字典</li>
</ul>
<h2 id="1-NSError的使用"><a href="#1-NSError的使用" class="headerlink" title="1. NSError的使用"></a>1. NSError的使用</h2><p>用法：</p>
<p>1.通过委托协议来传递NSError，告诉代理错误类型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error</div></pre></td></tr></table></figure>
<p>2.作为方法的“输出参数”返回给调用者</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)doSomething:(<span class="built_in">NSError</span>**)error</div></pre></td></tr></table></figure>
<p>使用范例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</div><div class="line"><span class="built_in">BOOL</span> ret = [object doSomething:&amp;error];</div><div class="line"></div><div class="line"><span class="keyword">if</span> (error) &#123;</div><div class="line">    <span class="comment">// There was an error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2-自定义NSError"><a href="#2-自定义NSError" class="headerlink" title="2. 自定义NSError"></a>2. 自定义NSError</h2><p>我们可以设置属于我们自己程序的错误范围和错误码</p>
<ul>
<li>错误范围可以用全局常量字符串来定义。</li>
<li>错误码可以用枚举来定义。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// EOCErrors.h</span></div><div class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> EOCErrorDomain;</div><div class="line"></div><div class="line"><span class="comment">//定义错误码</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, EOCError) &#123;</div><div class="line"></div><div class="line">    EOCErrorUnknown = –<span class="number">1</span>,</div><div class="line">    EOCErrorInternalInconsistency = <span class="number">100</span>,</div><div class="line">    EOCErrorGeneralFault = <span class="number">105</span>,</div><div class="line">    EOCErrorBadInput = <span class="number">500</span>,</div><div class="line">&#125;;</div><div class="line"><span class="comment">// EOCErrors.m</span></div><div class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> EOCErrorDomain = <span class="string">@"EOCErrorDomain"</span>; <span class="comment">//定义错误范围</span></div></pre></td></tr></table></figure>
<h1 id="第22条：理解NSCopying协议"><a href="#第22条：理解NSCopying协议" class="headerlink" title="第22条：理解NSCopying协议"></a>第22条：理解NSCopying协议</h1><hr>
<p>如果我们想令自己的类支持拷贝操作，那就要实现NSCopying协议，该协议只有一个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span>*)zone</div></pre></td></tr></table></figure>
<p>作者举了个：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)copyWithZone:(<span class="built_in">NSZone</span>*)zone &#123;</div><div class="line">     EOCPerson *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] allocWithZone:zone] initWithFirstName:_firstName  andLastName:_lastName];</div><div class="line">    <span class="keyword">copy</span>-&gt;_friends = [_friends mutableCopy];</div><div class="line">     <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>之所以是copy-&gt;_friends，而不是copy.friends是因为friends并不是属性，而是一个内部使用的实例变量。</p>
</blockquote>
<h2 id="1-复制可变的版本："><a href="#1-复制可变的版本：" class="headerlink" title="1. 复制可变的版本："></a>1. 复制可变的版本：</h2><p>遵从<nsmutablecopying>协议</nsmutablecopying></p>
<p>而且要执行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)mutableCopyWithZone:(<span class="built_in">NSZone</span>*)zone；</div></pre></td></tr></table></figure>
<blockquote>
<p>注意：拷贝可变型和不可变型发送的是<code>copy</code>和<code>mutableCopy</code>消息，而我们实现的却是<code>- (id)copyWithZone:(NSZone*)zone</code>和<code>- (id)mutableCopyWithZone:(NSZone*)zone</code> 方法。</p>
<p>而且，如果我们想获得某对象的不可变型，统一调用copy方法；获得某对象的可变型，统一调用mutableCopy方法。</p>
</blockquote>
<p>例如数组的拷贝：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-[<span class="built_in">NSMutableArray</span> <span class="keyword">copy</span>] =&gt; <span class="built_in">NSArray</span></div><div class="line">-[<span class="built_in">NSArray</span> mutableCopy] =&gt; <span class="built_in">NSMutableArray</span></div></pre></td></tr></table></figure>
<h2 id="2-浅拷贝和深拷贝"><a href="#2-浅拷贝和深拷贝" class="headerlink" title="2. 浅拷贝和深拷贝"></a>2. 浅拷贝和深拷贝</h2><p>Foundation框架中的集合类默认都执行浅拷贝：只拷贝容器对象本身，而不复制其中的数据。<br>而深拷贝的意思是连同对象本身和它的底层数据都要拷贝。</p>
<p>作者用一个图很形象地体现了浅拷贝和深拷贝的区别：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0fd10d82cbecd8d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：《Effective Objective-C》"></p>
<blockquote>
<p>浅拷贝后的内容和原始内容指向同一个对象<br>深拷贝后的内容所指的对象是原始内容对应对象的拷贝</p>
</blockquote>
<h2 id="3-如何深拷贝？"><a href="#3-如何深拷贝？" class="headerlink" title="3. 如何深拷贝？"></a>3. 如何深拷贝？</h2><p>我们需要自己编写深拷贝的方法：遍历每个元素并复制，然后将复制后的所有元素重新组成一个新的集合。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)initWithSet:(<span class="built_in">NSArray</span>*)array copyItems:(<span class="built_in">BOOL</span>)copyItems;</div></pre></td></tr></table></figure>
<blockquote>
<p>在这里，我们自己提供了一个深拷贝的方法：该方法需要传入两个参数：需要拷贝的数组和是否拷贝元素（是否深拷贝）</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">id</span>)deepCopy &#123;</div><div class="line">       EOCPerson *<span class="keyword">copy</span> = [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] initWithFirstName:_firstName andLastName:_lastName];</div><div class="line">        <span class="keyword">copy</span>-&gt;_friends = [[<span class="built_in">NSMutableSet</span> alloc] initWithSet:_friends copyItems:<span class="literal">YES</span>];</div><div class="line">        <span class="keyword">return</span> <span class="keyword">copy</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="第29条：理解引用计数"><a href="#第29条：理解引用计数" class="headerlink" title="第29条：理解引用计数"></a>第29条：理解引用计数</h1><hr>
<p>尽管在iOS系统已经支持了自动引用计数，但仍然需要开发者了解其内存管理机制。</p>
<h2 id="1-计数器的操作："><a href="#1-计数器的操作：" class="headerlink" title="1. 计数器的操作："></a>1. 计数器的操作：</h2><ol>
<li>retain：递增保留计数。</li>
<li>release：递减保留计数</li>
<li>autorelease ：待稍后清理“自动释放池时”，再递减保留计数。</li>
</ol>
<blockquote>
<p>注意：在对象初始化后，引用计数不一定是1，还有可能大于1。因为在初始化方法的实现中，或许还有其他的操作使得引用计数+1，例如其他的对象也保留了此对象。</p>
</blockquote>
<p>有时，我们无法确定在某个操作后引用计数的确切值，而只能判断这个操作是递增还是递减了保留计数。</p>
<h2 id="2-自动释放池："><a href="#2-自动释放池：" class="headerlink" title="2. 自动释放池："></a>2. 自动释放池：</h2><p>将对象放入自动释放池之后，不会马上使其引用计数-1，而是在当前线程的下一次事件循环时递减。</p>
<p>使用举例：如果我们想释放当前需要使用的方法返回值是，可以将其暂时放在自动释放池中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSString</span>*)stringValue &#123;</div><div class="line">     <span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"I am this: %@"</span>, <span class="keyword">self</span>];</div><div class="line">     <span class="keyword">return</span> [str autorelease];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-保留环（retain-cycle）"><a href="#3-保留环（retain-cycle）" class="headerlink" title="3. 保留环（retain cycle）"></a>3. 保留环（retain cycle）</h2><p>对象之间相互用强引用指向对方，会使得全部都无法得以释放。解决方案是讲其中一端的引用改为弱引用（weak reference），在引用的同时不递增引用计数。</p>
<h1 id="第30条：以ARC简化引用计数"><a href="#第30条：以ARC简化引用计数" class="headerlink" title="第30条：以ARC简化引用计数"></a>第30条：以ARC简化引用计数</h1><hr>
<p>使用ARC，可以省略对于引用计数的操作，让开发者专注于开发本身：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> shouldLogMessage]) &#123;</div><div class="line">     <span class="built_in">NSString</span> *message = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"I am object, %p"</span>, <span class="keyword">self</span>];</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"message = %@"</span>, message);</div><div class="line">      [message release]; <span class="comment">///&lt; Added by ARC</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>显然这里我们不需要message对象了，那么ARC会自动为我们添加内存管理的语句。</p>
</blockquote>
<p>因此，在ARC环境下调用内存管理语句是非法的：</p>
<ul>
<li>retain</li>
<li>release</li>
<li>autorelease</li>
<li>dealloc</li>
</ul>
<blockquote>
<p>注意：ARC只负责管理OC对象的内存，CoreFoundation对象不归ARC管理</p>
</blockquote>
<h1 id="第37条：理解“块”这一概念"><a href="#第37条：理解“块”这一概念" class="headerlink" title="第37条：理解“块”这一概念"></a>第37条：理解“块”这一概念</h1><hr>
<p>对于“块”的基础知识就不再赘述了，这里强调一下块的种类。</p>
<p>块(Block)分为三类：</p>
<ul>
<li>栈块</li>
<li>堆块</li>
<li>全局块</li>
</ul>
<h2 id="1-栈块"><a href="#1-栈块" class="headerlink" title="1. 栈块"></a>1. 栈块</h2><p>定义块的时候，其所占内存区域是分配在栈中的，而且只在定义它的那个范围内有效：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^block)();</div><div class="line"><span class="keyword">if</span> ( <span class="comment">/* some condition */</span> ) &#123;</div><div class="line">    block = ^&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Block A"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    block = ^&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"Block B"</span>);</div><div class="line">    &#125;;</div><div class="line">&#125;</div><div class="line">block();</div></pre></td></tr></table></figure>
<p>上面定义的两个块只在if else语句范围内有效，一旦离开了最后一个右括号，如果编译器覆写了分配给块的内存，那么就会造成程序崩溃。</p>
<h2 id="2-堆块"><a href="#2-堆块" class="headerlink" title="2. 堆块"></a>2. 堆块</h2><p>为了解决这个问题，我们可以给对象发送copy消息，复制一份到堆里，并自带引用计数：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^block)();</div><div class="line"><span class="keyword">if</span> ( <span class="comment">/* some condition */</span> ) &#123;</div><div class="line">    block = [^&#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"Block A"</span>);</div><div class="line">   &#125; <span class="keyword">copy</span>];</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    block = [^&#123;</div><div class="line">         <span class="built_in">NSLog</span>(<span class="string">@"Block B"</span>);</div><div class="line">    &#125; <span class="keyword">copy</span>];</div><div class="line">&#125;</div><div class="line">block();</div></pre></td></tr></table></figure>
<h2 id="3-全局块"><a href="#3-全局块" class="headerlink" title="3. 全局块"></a>3. 全局块</h2><p>全局块声明在全局内存里，而不需要在每次用到的时候于栈中创建。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> (^block)() = ^&#123;</div><div class="line">     <span class="built_in">NSLog</span>(<span class="string">@"This is a block"</span>);</div><div class="line">﻿&#125;;</div></pre></td></tr></table></figure>
<h1 id="第47条：熟悉系统框架"><a href="#第47条：熟悉系统框架" class="headerlink" title="第47条：熟悉系统框架"></a>第47条：熟悉系统框架</h1><hr>
<p>如果我们使用了系统提供的现成的框架，那么用户在升级系统后，就可以直接享受系统升级所带来的改进。</p>
<p>主要的系统框架：</p>
<ul>
<li>Foundation:NSObject,NSArray,NSDictionary等</li>
<li>CFoundation框架：C语言API，Foundation框架中的许多功能，都可以在这里找到对应的C语言API</li>
<li>CFNetwork框架:C语言API，提供了C语言级别的网络通信能力</li>
<li>CoreAudio:C语言API，操作设备上的音频硬件</li>
<li>AVFoundation框架：提供的OC对象可以回放并录制音频和视频</li>
<li>CoreData框架：OC的API，将对象写入数据库</li>
<li>CoreText框架：C语言API，高效执行文字排版和渲染操作</li>
</ul>
<p>用C语言来实现API的好处：可以绕过OC的运行期系统，从而提升执行速度。</p>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>像本文开头所说，本文是三部曲系列的第一篇：概念篇，笔者主要将本书讲解概念的知识点抽取出来合并而成，内容相对后两篇简单一些。笔者会在一周的时间里陆续推出第2篇（规范篇），第3篇（技巧篇）~<br>望各路大神和在大神路上的伙伴们多多交流。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-4696272b0a4ffe42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;《Effective Objective-C 编写高质量iOS与OS X代码的52个有效方法》&quot;&gt;&lt;/p&gt;
&lt;p&gt;很多文章和大牛都在推荐这本书，说它讲授了很多编写Objective-C语言时所应该遵循的规范。刚好笔者前段时间因为产品刚开发完，有了一点空档期，于是用了3个星期的时间仔细研读和总结了这本书。&lt;/p&gt;
&lt;p&gt;在学习过程中也看过很多总结这本书的博客和文章，但是发现多数只是将每节的总结部分抄了过来，讲得并不是很详细，于是笔者就想按照自己的方式对这本书进行总结，并以博客的形式展现出来：既能分享，同时又能对知识进行一下梳理和二次复习。&lt;/p&gt;
&lt;p&gt;虽然本书的作者按照知识模块来将这本书分成七个章节，共52节，但是笔者在拜读的过程中发现本书介绍的知识点可以大致分为三类：概念类，规范类，和技巧类。笔者打算按照这三类来对这本书进行总结，形成三部曲：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念类：讲解了一些概念性知识。&lt;/li&gt;
&lt;li&gt;规范类：讲解了一些为了避免一些问题或者为后续开发提供便利所需要遵循的规范性知识。&lt;/li&gt;
&lt;li&gt;技巧类：讲解了一些为了解决某些特定问题而需要用到的技巧性知识。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且，笔者也按照自己的归类将这本书的结构用思维导图工具画了出来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-539498fef0819472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;三部曲分布图&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从图中可以看到，笔者并没有打乱原来作者的标题顺序。本篇总结即是三部曲之一：概念篇，后续会呈上规范篇和技巧篇。&lt;br&gt;备注：本总结所有的代码和图片都来自原书。其中，代码会适当加上笔者的注释，便于各位看官理解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，不啰嗦了， 开始吧！&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>详解iOS多图下载的缓存机制</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E8%AF%A6%E8%A7%A3iOS%E5%A4%9A%E5%9B%BE%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/详解iOS多图下载的缓存机制/</id>
    <published>2017-01-13T05:33:55.000Z</published>
    <updated>2017-03-20T07:56:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>做iOS开发也有半年多了，想想自己对一些第三方库还只是停留在简单运用的阶段，感觉心慌慌的。于是决定用一个月的时间深入了解一些好的第三方库。</p>
<p>第一个想到了SDWebImage，这个库很不错，几乎每个iOS项目都会有它的影子，因为它很完美地解决了下载图片并显示的处理逻辑。那么深究它之前，笔者准备先了解一下多图下载的缓存机制，因为它和SDWebImage的方案类似。</p>
<p>有一个多图缓存机制的教程是来自李明杰小码哥的，笔者觉得讲得挺不错的，于是就花了2个小时好好学习了一下。</p>
<a id="more"></a>
<h1 id="1-需求点是什么？"><a href="#1-需求点是什么？" class="headerlink" title="1.需求点是什么？"></a>1.需求点是什么？</h1><hr>
<p>这里所说的<strong>多图下载</strong>，就是要在tableview的每一个cell里显示一张图片,而且这些图片都需要从网上下载。</p>
<h1 id="2-容易遇到的问题"><a href="#2-容易遇到的问题" class="headerlink" title="2.容易遇到的问题"></a>2.容易遇到的问题</h1><hr>
<p>如果不知道或不使用<strong>异步操作</strong>和<strong>缓存机制</strong>，那么写出来的代码很可能会是这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cell.textLabel.text = app.name;</div><div class="line">cell.detailTextLabel.text = app.download;</div><div class="line"><span class="built_in">NSData</span> *imageData = [<span class="built_in">NSData</span> dataWithContentsOfURL:app.url];</div><div class="line">cell.imageView.image = [<span class="built_in">UIImage</span> imageWithData:imageData];</div></pre></td></tr></table></figure>
<p>这样写有什么后果呢？</p>
<h4 id="后果1：不可避免的卡顿（因为没有异步下载操作）"><a href="#后果1：不可避免的卡顿（因为没有异步下载操作）" class="headerlink" title="后果1：不可避免的卡顿（因为没有异步下载操作）"></a>后果1：不可避免的卡顿（因为没有异步下载操作）</h4><blockquote>
<p>dataWithContentsOfURL：是耗时操作，将其放在主线程会造成卡顿。如果图片很多，图片很大，而且网络情况不好的话肯定会卡出翔！</p>
</blockquote>
<h4 id="后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）"><a href="#后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）" class="headerlink" title="后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）"></a>后果2：同一图片重复下载，耗费流量和系统开销（因为没有建立缓存机制）</h4><blockquote>
<p>由于没有缓存机制，即使下载完成并显示了当前cell的图片，但是当该cell再一次需要显示的时候还是会下载它所对应的图片：耗费了下载流量，而且还导致重复操作。</p>
</blockquote>
<p>很显然，要达到Tableview滚动的<strong>如丝滑般的享受</strong>必须二者兼得才可以，具体怎么做呢？</p>
<h1 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3.解决方案"></a>3.解决方案</h1><hr>
<h4 id="1-先看一下解决方案的流程图"><a href="#1-先看一下解决方案的流程图" class="headerlink" title="1.先看一下解决方案的流程图"></a>1.先看一下解决方案的流程图</h4><p>小码哥将他的解决方案在PPT里用流程图画了出来，笔者觉得很不错，但是颜值略低（毕竟人家是一心搞技术，没时间在意这些外在的东西），笔者理了理思路，自己重新画了一张（好看么？）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-addf3137097c3912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多图下载解决方案流程图"></p>
<p>要想快速看懂此图，需要先了解该流程所需的所有数据源：</p>
<p><strong>1. 图片的URL</strong>：因为每张图片对应的URL都是唯一的，所以我们可以通过它来建立<strong>图片缓存</strong>和<strong>下载操作的缓存</strong>的键，以及拼接<strong>沙盒缓存</strong>的路径字符串。<br><strong>2. 图片缓存（字典）</strong>：存放于内存中；键为图片的URL，值为UIImage对象。作用：读取速度快，直接使用UIImage对象。<br><strong>3. 下载操作缓存（字典）</strong>：存放与内存中，键为图片的URL，值为NSBlockOperation对象。作用：用来避免对于同一张图片还要开启多个下载线程。<br><strong>4. 沙盒缓存(文件路径对应NSData)</strong>：存放于磁盘中，位于Cache文件夹内，路径为“Cache/图片URL的最后的部分”，值为NSData对象（将UIImage转化为NSData才能写入磁盘里）。作用：程序断网，再次启动也可以直接在磁盘中拿到图片。</p>
<h4 id="2-再看一下解决方案的代码"><a href="#2-再看一下解决方案的代码" class="headerlink" title="2.再看一下解决方案的代码"></a>2.再看一下解决方案的代码</h4><p><strong>2.1图片缓存，下载操作缓存，沙盒缓存路径</strong><br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  存放所有下载完的图片</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *images;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  存放所有的下载操作（key是url，value是operation对象）</div><div class="line"> */</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *operations;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> *  拼接Cache文件夹的路径与url最后的部分，合并成唯一约定好的缓存路径</div><div class="line"> */</div><div class="line"><span class="meta">#define CachedImageFile(url) [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject] stringByAppendingPathComponent:[url lastPathComponent]]</span></div></pre></td></tr></table></figure></p>
<p><strong>2.2 图片下载之前的查询缓存部分</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 先从images缓存中取出图片url对应的UIImage</span></div><div class="line">    <span class="built_in">UIImage</span> *image = <span class="keyword">self</span>.images[app.icon];</div><div class="line">    <span class="keyword">if</span> (image) &#123; </div><div class="line"></div><div class="line">    <span class="comment">// 存在：说明图片已经下载成功，并缓存成功）</span></div><div class="line">        cell.imageView.image = image;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">else</span> &#123; </div><div class="line"></div><div class="line">     <span class="comment">// 不存在：说明图片并未下载成功过，或者成功下载但是在images里缓存失败，需要在沙盒里寻找对于的图片</span></div><div class="line"></div><div class="line">         <span class="comment">// 获得url对于的沙盒缓存路径</span></div><div class="line">        <span class="built_in">NSString</span> *file = CachedImageFile(app.icon);</div><div class="line">        </div><div class="line">        <span class="comment">// 先从沙盒中取出图片</span></div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfFile:file];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (data) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//data不为空，说明沙盒中存在这个文件</span></div><div class="line">            cell.imageView.image = [<span class="built_in">UIImage</span> imageWithData:data];</div><div class="line"></div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line"></div><div class="line">         <span class="comment">// 反之沙盒中不存在这个文件</span></div><div class="line">             <span class="comment">// 在下载之前显示占位图片</span></div><div class="line">            cell.imageView.image = [<span class="built_in">UIImage</span> imageNamed:<span class="string">@"placeholder"</span>];</div><div class="line">            </div><div class="line">            <span class="comment">// 下载图片</span></div><div class="line">            [<span class="keyword">self</span> download:app.icon indexPath:indexPath];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>2.3 图片的下载部分</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  下载图片</div><div class="line"> *</div><div class="line"> *  @param imageUrl 图片的url</div><div class="line"> */</div><div class="line">- (<span class="keyword">void</span>)download:(<span class="built_in">NSString</span> *)imageUrl indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">&#123;</div><div class="line">    <span class="comment">// 取出当前图片url对应的下载操作（operation对象）</span></div><div class="line">    <span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span>.operations[imageUrl];</div><div class="line">    <span class="keyword">if</span> (operation) <span class="keyword">return</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// 创建操作，下载图片</span></div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) appsVc = <span class="keyword">self</span>;</div><div class="line">    operation = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</div><div class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:imageUrl];</div><div class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url]; <span class="comment">// 下载</span></div><div class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data]; <span class="comment">// NSData -&gt; UIImage</span></div><div class="line">        </div><div class="line">        <span class="comment">// 回到主线程</span></div><div class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue] addOperationWithBlock:^&#123;</div><div class="line">                     </div><div class="line">            <span class="keyword">if</span> (image) &#123;</div><div class="line">                <span class="comment">// 如果存在图片（下载完成），存放图片到图片缓存字典中</span></div><div class="line">                appsVc.images[imageUrl] = image;</div><div class="line">                </div><div class="line">                <span class="comment">//将图片存入沙盒中</span></div><div class="line">                <span class="comment">//1. 先将图片转化为NSData</span></div><div class="line">                <span class="built_in">NSData</span> *data = <span class="built_in">UIImagePNGRepresentation</span>(image);</div><div class="line">                </div><div class="line">                <span class="comment">//2.  再生成缓存路径            </span></div><div class="line">                [data writeToFile:CachedImageFile(imageUrl) atomically:<span class="literal">YES</span>];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="comment">// 从字典中移除下载操作 (保证下载失败后，能重新下载)</span></div><div class="line">            [appsVc.operations removeObjectForKey:imageUrl];</div><div class="line">            </div><div class="line">            <span class="comment">// 刷新当前表格，减少系统开销</span></div><div class="line">            [appsVc.tableView reloadRowsAtIndexPaths:@[indexPath] withRowAnimation:<span class="built_in">UITableViewRowAnimationNone</span>];</div><div class="line">        &#125;];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    <span class="comment">// 添加下载操作到队列中</span></div><div class="line">    [<span class="keyword">self</span>.queue addOperation:operation];</div><div class="line">    </div><div class="line">    <span class="comment">// 将当前下载操作添加到下载操作缓存中 (为了解决重复下载)</span></div><div class="line">    <span class="keyword">self</span>.operations[imageUrl] = operation;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-有哪些点是值得注意的？"><a href="#3-有哪些点是值得注意的？" class="headerlink" title="3. 有哪些点是值得注意的？"></a>3. 有哪些点是值得注意的？</h4><p>要说值得注意的地方，还是离不开对于缓存内容的添加和删除操作。</p>
<p><strong>3.1 关于图片缓存</strong>：<br>很简单，成功下载，拿到了图片，就将图片添加到图片缓存中；下载失败，什么都不做，反正没有图。在这种机制下，就没有删除缓存里某个图片项的情况，因为图片缓存永远不会出现重复添加多个相同图片的情况，缓存中只要有一张对应的图，就直接拿去用了，不会去再下载了。</p>
<p><strong>3.2 关于沙盒缓存</strong>：<br>同样地，对于沙盒缓存也是一个道理：有图就将其转化为NSData，写入磁盘，并对应唯一的路径，没有图就不写。所以即使是要下载相同的图片，因为当前url对应的沙盒路径已经存在文件了，所以直接拿就可以了，不会再下载。</p>
<p>但是！<br>下载操作缓存是不同的！</p>
<p><strong>3.3 关于下载操作缓存</strong><br>我们需要在下载回调完成后，立即将当前的下载操作从下载操作缓存中删去！<br>因为要避免下载失败后，无法再次下载的情况的发生！</p>
<p>为什么呢？<br>注意一下将下载操作加入到下载操作缓存的时机：<br>是在<strong>下载开始的那一刻</strong>而不是<strong>下载成功的那一刻</strong>！</p>
<p>如果在下载开始的那一刻加入到缓存中的话，这个缓存信息就包括两个情况：下载成功和下载失败：</p>
<ul>
<li><p>如果未来下载成功了，那么我们就不会来到判断当前下载操作是否在下载操作缓存这一步，在这之前直接就可以拿图去用了，下载操作是否存在下载操作缓存里并没有什么影响。</p>
</li>
<li><p>但是！如果未来下载失败了，那就肯定不会有对应的图片缓存和沙盒缓存，也就肯定会来到判断当前的下载操作是否在下载操作缓存里这一步。不幸的是，因为没有被删去，它是存在的。存在的话就不做任何其他操作，放任自流，导致曾经下载失败的图片永远不会再次下载。</p>
</li>
</ul>
<p>忘了那段代码了么？回看一下代码（看我多好）：<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSBlockOperation</span> *operation = <span class="keyword">self</span>.operations[imageUrl];</div><div class="line"> <span class="keyword">if</span> (operation) <span class="keyword">return</span>;<span class="comment">//转身就走，毫不留情</span></div></pre></td></tr></table></figure></p>
<p>因此，无论下载成功或是失败，在图片下载的回调里都要将当前的下载操作从下载操作队列中移走：用来保证如果下载失败了，就可以重新开启对应的下载操作进行下载，逻辑上更加严谨。</p>
<h1 id="4-最后的话"><a href="#4-最后的话" class="headerlink" title="4.最后的话"></a>4.最后的话</h1><hr>
<p>异步+缓存这两个机制双剑合璧的话会对程序新能带来很大的改观。这应该app开发进阶的必经之路。</p>
<p>小码哥讲述的这套流程还算比较完整的了，更重要的还是学习其中的思想：</p>
<blockquote>
<ol>
<li><p>将缓存分级：内存缓存，沙盒缓存，下载操作缓存。</p>
</li>
<li><p>而且还要经常使用二分法，将我们的逻辑考虑得滴水不漏。<br>如果我们没有认识到将下载操作添加到下载操作缓存的时机是包含下载成功和下载失败两个情况，那么就不会考虑到即时要将下载操作从下载操作缓存中删去的操作，很容易引起bug。所以在以后的开发中，成功和失败两个情况都要考虑进去，也就是说有if一定要有else！</p>
</li>
</ol>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;做iOS开发也有半年多了，想想自己对一些第三方库还只是停留在简单运用的阶段，感觉心慌慌的。于是决定用一个月的时间深入了解一些好的第三方库。&lt;/p&gt;
&lt;p&gt;第一个想到了SDWebImage，这个库很不错，几乎每个iOS项目都会有它的影子，因为它很完美地解决了下载图片并显示的处理逻辑。那么深究它之前，笔者准备先了解一下多图下载的缓存机制，因为它和SDWebImage的方案类似。&lt;/p&gt;
&lt;p&gt;有一个多图缓存机制的教程是来自李明杰小码哥的，笔者觉得讲得挺不错的，于是就花了2个小时好好学习了一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>浅显易懂讲解iOS多线程技术-GCD</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E6%B5%85%E6%98%BE%E6%98%93%E6%87%82%E8%AE%B2%E8%A7%A3%E7%9A%84iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%8A%80%E6%9C%AF-GCD/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/浅显易懂讲解的iOS多线程技术-GCD/</id>
    <published>2017-01-13T05:26:33.000Z</published>
    <updated>2017-03-20T07:53:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>励志打造一篇浅显易懂地介绍iOS中GCD的文章！<br>笔者见过很多其他讲解GCD的博客，有些写得非常详细非常专业，几乎涵盖了GCD大大小小的全部知识，细致庞杂的内容容易让人摸不清主次，笔者觉得这类文章<strong>并不适合初学者学习</strong>，于是决定写一篇针对一些只是听过，但是对GCD还不了解的童鞋们。</p>
<p>本文排除了一些细枝末节，扰乱人头绪的东西，着重讲解了GCD中重要的知识点，并在最后展示了GCD中<strong>经常使用的函数</strong>并附上结果图和讲解，简单明了。</p>
<a id="more"></a>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><hr>
<p>在了解多线程之前，需要弄清进程和线程的概念和他们之间的区别。</p>
<h3 id="进程："><a href="#进程：" class="headerlink" title="进程："></a>进程：</h3><p>系统中正在运行的一个程序，进程之间是相互独立的，每个进程都有属于自己的内存空间。比如手机中的<strong>微信</strong>应用和<strong>印象笔记</strong>应用，他们都是iOS系统中独立的进程，有着自己的内存空间。</p>
<h3 id="线程："><a href="#线程：" class="headerlink" title="线程："></a>线程：</h3><p>进程内部执行任务所需要的执行路径。进程若想执行任务，则必须得在线程下执行。也就是说进程至少有一个线程才能执行任务。但是，我们使用软件的时候，很少有只让它做一件事的时候：</p>
<p>举个<strong>印象笔记</strong>的🌰 ： 当你正在编辑一则笔记的时候点击了同步按钮，那么编辑任务（线程）和同步任务（线程）一定是不能按照顺序执行的。因为同步任务的完成时间是不可控的，如果在同步的过程中无法进行别的任务（线程）那就太糟糕了！</p>
<p>因此，我们需要让一些任务可以同时进行。既然任务是在线程上执行的，那么多任务的执行就意味着需要多线程的开启和使用。</p>
<p>来一张图直观地展示一下内存，进程和线程的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-a1e6c65eda0d3aaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存，进程和线程"></p>
<h1 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h1><hr>
<p>多线程的实现原理：虽然在同一时刻，CPU只能处理1条线程，但是CPU可以快速地在多条线程之间调度（切换），造成了多线程并发执行的假象。</p>
<h2 id="1-多线程的优点"><a href="#1-多线程的优点" class="headerlink" title="1. 多线程的优点"></a>1. 多线程的优点</h2><ul>
<li>能适当提高程序的执行效率。</li>
<li>能适当提高资源利用率（CPU、内存利用率）。</li>
</ul>
<h2 id="2-多线程的缺点"><a href="#2-多线程的缺点" class="headerlink" title="2. 多线程的缺点"></a>2. 多线程的缺点</h2><ul>
<li>创建线程是需要成本的：iOS下主要成本包括：在栈空间的子线程512KB、主线程1MB，创建线程大约需要90毫秒的创建时间。</li>
<li>线程越多，CPU在调度线程上的开销就越大。</li>
<li>线程越多，程序设计就越复杂：因为要考虑到线程之间的通信，多线程的数据共享。</li>
</ul>
<h1 id="多线程在iOS开发中的应"><a href="#多线程在iOS开发中的应" class="headerlink" title="多线程在iOS开发中的应"></a>多线程在iOS开发中的应</h1><hr>
<h2 id="1-iOS的主线程"><a href="#1-iOS的主线程" class="headerlink" title="1. iOS的主线程"></a>1. iOS的主线程</h2><p>一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”</p>
<h4 id="主线程的作用"><a href="#主线程的作用" class="headerlink" title="主线程的作用:"></a>主线程的作用:</h4><ul>
<li>显示\刷新UI界面</li>
<li>处理UI事件（比如点击事件、滚动事件、拖拽事件等）</li>
</ul>
<blockquote>
<p>主线程的使用<strong>注意事项</strong>:<br>不能把比较耗时的操作放到主线程中，，严重影响UI的流畅度，给用户一种程序“卡顿”的体验。<br>因此，要将耗时的操作放在子线程中异步执行。这样一来，及时开始执行了耗时的操作，也不会影响主线程中UI交互的体验。</p>
</blockquote>
<h2 id="2-iOS的子线程"><a href="#2-iOS的子线程" class="headerlink" title="2. iOS的子线程"></a>2. iOS的子线程</h2><p>子线程是异步执行的，不影响主线程。在iOS开发中，我们需要将耗时的任务（网络请求，复杂的运算）放在子线程进行，不让其影响UI的交互体验。</p>
<h2 id="3-多线程安全"><a href="#3-多线程安全" class="headerlink" title="3. 多线程安全"></a>3. 多线程安全</h2><p>当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。就好比好几个人在同时修改同一个表格，造成数据的错乱。</p>
<h4 id="3-1-资源抢夺的解决方案"><a href="#3-1-资源抢夺的解决方案" class="headerlink" title="3.1 资源抢夺的解决方案"></a>3.1 资源抢夺的解决方案</h4><p>我们需要给数据添加<strong>互斥锁</strong>。也就是说，当某线程访问一个数据之前就要给数据加锁，让其不被其他的线程所修改。就好比一个人修改表格的时候给表格设置了密码，那么其他人就无法访问文件了。当他修改文件之后，再讲密码撤销，第二个人就可以访问该文件了。</p>
<blockquote>
<p><strong>注意</strong>：<br>这里的线程都为子线程，如果给数据加了锁，就等于将这些异步的子线程变成同步的了，这也叫做线程同步技术。</p>
</blockquote>
<h4 id="3-2-互斥锁使用："><a href="#3-2-互斥锁使用：" class="headerlink" title="3.2 互斥锁使用："></a>3.2 互斥锁使用：</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@synchronized</span>(锁对象) &#123; <span class="comment">// 需要锁定的代码  &#125;;</span></div></pre></td></tr></table></figure>
<h4 id="3-3-互斥锁的优缺点"><a href="#3-3-互斥锁的优缺点" class="headerlink" title="3.3 互斥锁的优缺点"></a>3.3 互斥锁的优缺点</h4><p>优点：能有效防止因多线程抢夺资源造成的数据安全问题<br>缺点：需要消耗大量的CPU资源</p>
<p>互斥锁的使用前提：多条线程抢夺同一块资源的时候使用。</p>
<h4 id="3-4互斥锁在iOS开发中的使用"><a href="#3-4互斥锁在iOS开发中的使用" class="headerlink" title="3.4互斥锁在iOS开发中的使用"></a>3.4互斥锁在iOS开发中的使用</h4><p>OC在定义属性时有<code>nonatomic</code>和<code>atomic</code>两种选择</p>
<ul>
<li>atomic：原子属性，为setter方法加锁（默认就是atomic）</li>
<li>nonatomic：非原子属性，不会为setter方法加锁</li>
</ul>
<h4 id="3-5-nonatomic和atomic对比"><a href="#3-5-nonatomic和atomic对比" class="headerlink" title="3.5 nonatomic和atomic对比"></a>3.5 nonatomic和atomic对比</h4><p>atomic：线程安全，需要消耗大量的资源<br>nonatomic：非线程安全，适合内存小的移动设备</p>
<blockquote>
<p><strong>建议：</strong><br>所有属性都声明为nonatomic，尽量避免多线程抢夺同一块资源，将加锁、资源抢夺的业务逻辑交给服务器端处理，减小移动客户端的压力。</p>
</blockquote>
<h1 id="多线程在iOS中的应用：GCD"><a href="#多线程在iOS中的应用：GCD" class="headerlink" title="多线程在iOS中的应用：GCD"></a>多线程在iOS中的应用：GCD</h1><hr>
<p>GCD，全称为 Grand Central Dispatch ，是iOS用来管理线程的技术。 纯C语言，提供了非常多强大的函数。</p>
<h2 id="1-GCD的优势"><a href="#1-GCD的优势" class="headerlink" title="1. GCD的优势"></a>1. GCD的优势</h2><p>GCD会自动利用更多的CPU内核（比如双核、四核）。<br>GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程）。<br>程序员只需要告诉GCD想要执行什么任务，不需要编写任何线程管理代码。</p>
<h2 id="2-为什么要用GCD？"><a href="#2-为什么要用GCD？" class="headerlink" title="2. 为什么要用GCD？"></a>2. 为什么要用GCD？</h2><p>为了要提高软件性能，应该异步执行耗时任务(加载图片)，以防止影响主线程任务的执行(UI相应)。</p>
<blockquote>
<p>举个🌰 ：<br>从网络加载一张图片，如果将此任务放到主线程，那么在下载完成的时间里，软件是无法相应用户的任何操作的。特别地，如果当前是在可以滚动的页面，就会造成无法滚动这种体验非常糟的情况。</p>
</blockquote>
<p>所以：应该将网络加载放在异步执行，执行成功后，再回到主线程显示加载后的图片(详细做法马上就会讲到)。</p>
<h2 id="3-GCD的使用步骤"><a href="#3-GCD的使用步骤" class="headerlink" title="3. GCD的使用步骤"></a>3. GCD的使用步骤</h2><ol>
<li>由开发者定制将要执行的任务。</li>
</ol>
<ul>
<li>将任务添加到队列中，GCD会自动将队列中的任务取出，放到对应的线程中执行。</li>
</ul>
<blockquote>
<p><strong>注意：</strong><br>任务的取出遵循队列的FIFO原则：先进先出，后进后出。</p>
</blockquote>
<h2 id="4-什么是队列？"><a href="#4-什么是队列？" class="headerlink" title="4. 什么是队列？"></a>4. 什么是队列？</h2><p>队列是用来存放任务的，由GCD将这些任务从队列中取出并放到相应的线程中执行。</p>
<h3 id="GCD的队列可以分为2大类型："><a href="#GCD的队列可以分为2大类型：" class="headerlink" title="GCD的队列可以分为2大类型："></a>GCD的队列可以分为2大类型：</h3><h4 id="1-并发队列（Concurrent-Dispatch-Queue）"><a href="#1-并发队列（Concurrent-Dispatch-Queue）" class="headerlink" title="1. 并发队列（Concurrent Dispatch Queue）"></a>1. 并发队列（Concurrent Dispatch Queue）</h4><p>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务），并发功能只有在异步（dispatch_async）函数下才有效</p>
<h4 id="2-串行队列（Serial-Dispatch-Queue）"><a href="#2-串行队列（Serial-Dispatch-Queue）" class="headerlink" title="2. 串行队列（Serial Dispatch Queue）"></a>2. 串行队列（Serial Dispatch Queue）</h4><p>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）。</p>
<p>那么队列和线程又有什么区别？</p>
<p>简单来说，队列就是用来存放任务的“暂存区”，而线程是执行任务的路径，GCD将这些存在于队列的任务取出来放到相应的线程上去执行，而队列的性质决定了在其中的任务在哪种线程上执行。</p>
<p>下面由一张图来直观地展示任务，队列和线程的关系：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6da601dd550b8390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="任务，队列和线程"></p>
<blockquote>
<p>在这里，我们可以看到，放入串行队列的任务会一个一个地执行。而放入并行队列的任务，会在多个线程并发地执行。</p>
</blockquote>
<h2 id="5-队列的创建"><a href="#5-队列的创建" class="headerlink" title="5. 队列的创建"></a>5. 队列的创建</h2><h3 id="5-1-串行队列的创建："><a href="#5-1-串行队列的创建：" class="headerlink" title="5.1 串行队列的创建："></a>5.1 串行队列的创建：</h3><p>GCD中获得串行有2种途径：</p>
<p>1.使用<code>dispatch_queue_create</code>函数创建串行队列</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建串行队列（队列类型传递NULL或者DISPATCH_QUEUE_SERIAL）</span></div><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"serial_queue"</span>, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>2.使用主队列（跟主线程相关联的队列）</p>
<p>主队列是GCD自带的一种特殊的串行队列：放在主队列中的任务，都会放到主线程中执行。<br>可以使用dispatch_get_main_queue()获得系统提供的主队列：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</div></pre></td></tr></table></figure>
<h3 id="5-2-并发队列的创建："><a href="#5-2-并发队列的创建：" class="headerlink" title="5.2 并发队列的创建："></a>5.2 并发队列的创建：</h3><p>1.使用<code>dispatch_queue_create</code>函数创建并发队列。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"concurrent.queue"</span>, DISPATCH_QUEUE_CONCURRENT);</div></pre></td></tr></table></figure>
<p>2.使用<code>dispatch_get_global_queue</code>获得全局并发队列。</p>
<p>GCD默认已经提供了全局的并发队列，供整个应用使用，可以无需手动创建。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<h2 id="6-GCD的几种重要的应用"><a href="#6-GCD的几种重要的应用" class="headerlink" title="6. GCD的几种重要的应用"></a>6. GCD的几种重要的应用</h2><h3 id="6-1-子线程与主线程的通信"><a href="#6-1-子线程与主线程的通信" class="headerlink" title="6.1 子线程与主线程的通信"></a>6.1 子线程与主线程的通信</h3><p>需求点:我们有时需要在子线程处理一个耗时比较长的任务，而且此任务完成后，要在主线程执行另一个任务。<br>例子：从网络加载图片（在子线程），加载完成就更新UIView（在主线程）。</p>
<p>为了实现这个需求，我们需要首先拿到全局并发队列（或自己开启一个子线程）来执行耗时的操作，然后在其完成block中拿到全局串行队列来执行UI刷新的任务。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line"></div><div class="line">            <span class="comment">//加载图片</span></div><div class="line">            <span class="built_in">NSData</span> *dataFromURL = [<span class="built_in">NSData</span> dataWithContentsOfURL:imageURL];</div><div class="line">            <span class="built_in">UIImage</span> *imageFromData = [<span class="built_in">UIImage</span> imageWithData:dataFromURL];</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">            <span class="comment">//加载完成更新view</span></div><div class="line">            <span class="built_in">UIImageView</span> *imageView = [[<span class="built_in">UIImageView</span> alloc] initWithImage:imageFromData];          </div><div class="line">    &#125;);      </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>以笔者的拙见，除了复杂的算法，网络请求以外，大多数<code>dataWithContentsOf。。。</code>函数可能也会比较耗时，所以以后遇到与NSData交互的操作时，尽量将其放在子线程执行。</p>
</blockquote>
<h4 id="6-2-dispatch-once"><a href="#6-2-dispatch-once" class="headerlink" title="6.2 dispatch_once"></a>6.2 dispatch_once</h4><p>需求点：用于在程序启动到终止，只执行一次的代码。此代码被执行后，相当于自身全部被加上了注释，不会再执行了。<br>为了实现这个需求，我们需要使用<code>dispatch_once</code>让代码在运行一次后即刻被“雪藏”。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用dispatch_once函数能保证某段代码在程序运行过程中只被执行1次</span></div><div class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">    <span class="comment">// 只执行1次的代码，这里默认是线程安全的：不会有其他线程可以访问到这里</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="6-3-dispatch-group"><a href="#6-3-dispatch-group" class="headerlink" title="6.3 dispatch_group"></a>6.3 dispatch_group</h4><p>需求点：执行多个耗时的异步任务，但是只能等到这些任务都执行完毕后，才能在主线程执行某个任务。<br>为了实现这个需求，我们需要让将这些异步执行的操作放在<code>dispatch_group_async</code>函数中执行，最后再调用<code>dispatch_group_notify</code>来执行最后执行的任务。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">dispatch_group_t group =  dispatch_group_create();</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">&#125;);</div><div class="line">dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">    <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>让我们看一下示例代码和运行结果：</p>
<p>示例代码：</p>
<p>为了使对比明显，笔者多开了几条线程，这样更容易看清问题。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line">    dispatch_group_t group =  dispatch_group_create();    </div><div class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index ++) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"完成了任务1"</span>);                </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"完成了任务2"</span>);        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">200000</span>; index ++) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"完成了任务3"</span>);</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">400000</span>; index ++) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"完成了任务4"</span>);</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 执行1个耗时的异步操作</span></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index ++) &#123;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"完成了任务5"</span>);</div><div class="line">        </div><div class="line">    &#125;);</div><div class="line">            </div><div class="line">    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;</div><div class="line">        </div><div class="line">        <span class="comment">// 等前面的异步操作都执行完毕后，回到主线程...</span></div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"都完成了"</span>);        </div><div class="line">    &#125;);</div><div class="line">```  </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">运行结果:</div><div class="line"></div><div class="line"></div><div class="line">![  dispatch_group 的使用运行结果](http:<span class="comment">//upload-images.jianshu.io/upload_images/859001-3c8d5886442ce7b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">&gt;从三次运行的结果来看:</div><div class="line"><span class="number">1.</span> 异步执行的任务<span class="number">1</span><span class="number">-5</span>的最终完成时间是与其自身完成任务所需要的时间并无绝对关联。因为任务<span class="number">5</span>是最耗时的，它在第一次运行结果里并不是最后才完成的。任务<span class="number">1</span>是最不耗时的，但是它在第二次运行结果里也不是最先完成的。</div><div class="line"></div><div class="line">&gt;<span class="number">2.</span> 异步执行的任务<span class="number">1</span><span class="number">-5</span>无论完成顺序如何，只有当他们都完成后才会调用主线程的打印“都完成了”。</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#### 6.4 dispatch_barrier</span></div><div class="line"></div><div class="line">需求点：虽然我们有时要执行几个不同的异步任务，但是我们还是要将其分成两组：当第一组异步任务都执行完成后才执行第二组的异步任务。这里的组可以包含一个任务，也可以包含多个任务。</div><div class="line"></div><div class="line">为了实现这个需求，我们需要使用``dispatch_barrier_async(<span class="built_in">dispatch_queue_t</span> queue, dispatch_block_t block);``在两组任务之间形成“栅栏”，使其“下方”的异步任务在其“上方”的异步任务都完成之前是无法执行的。</div><div class="line"></div><div class="line"></div><div class="line">```objc</div><div class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----任务 1-----"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----任务 2-----"</span>);</div><div class="line">    &#125;);    </div><div class="line"></div><div class="line">    dispatch_barrier_async(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----barrier-----"</span>);</div><div class="line">    &#125;);</div><div class="line">   </div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----任务 3-----"</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"----任务 4-----"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure></p>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"12312312"</span>, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">   </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务1"</span>);       </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">20000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务2"</span>);        </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">200000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务3"</span>);        </div><div class="line">&#125;);</div><div class="line">     </div><div class="line"></div><div class="line">dispatch_barrier_async(queue, ^&#123;        </div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"--------我是分割线--------"</span>);        </div><div class="line">&#125;);</div><div class="line"></div><div class="line">    </div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">400000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务4"</span>);       </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务5"</span>);        </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</div><div class="line">    </div><div class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> index = <span class="number">0</span>; index &lt; <span class="number">1000</span>; index ++) &#123;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"完成了任务6"</span>);       </div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-ca923e54d3839b2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_barrier 的使用运行结果"></p>
<blockquote>
<p>从这三次运行结果来看:</p>
<ol>
<li>无论任务1-3内部的执行顺序如何，只有当三者都完成了才会执行任务4-6。</li>
<li>1-3内部的执行顺序和4-6内部的完成顺序都是不可控的，同上一个知识点类似。</li>
</ol>
</blockquote>
<p>本文介绍了需要了解GCD所需的最重要的知识，因为怕打断读者思路，并没有涵盖所有细节。以后有机会会再写一篇深入介绍GCD的文章，查缺补漏。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;励志打造一篇浅显易懂地介绍iOS中GCD的文章！&lt;br&gt;笔者见过很多其他讲解GCD的博客，有些写得非常详细非常专业，几乎涵盖了GCD大大小小的全部知识，细致庞杂的内容容易让人摸不清主次，笔者觉得这类文章&lt;strong&gt;并不适合初学者学习&lt;/strong&gt;，于是决定写一篇针对一些只是听过，但是对GCD还不了解的童鞋们。&lt;/p&gt;
&lt;p&gt;本文排除了一些细枝末节，扰乱人头绪的东西，着重讲解了GCD中重要的知识点，并在最后展示了GCD中&lt;strong&gt;经常使用的函数&lt;/strong&gt;并附上结果图和讲解，简单明了。&lt;/p&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>远程工作才是实现高效工作和幸福生活的有效途径 - 读《重来2》有感</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C%E6%89%8D%E6%98%AF%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C%E5%92%8C%E5%B9%B8%E7%A6%8F%E7%94%9F%E6%B4%BB%E7%9A%84%E6%9C%89%E6%95%88%E9%80%94%E5%BE%84%20-%20%E8%AF%BB%E3%80%8A%E9%87%8D%E6%9D%A52%E3%80%8B%E6%9C%89%E6%84%9F/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/远程工作才是实现高效工作和幸福生活的有效途径 - 读《重来2》有感/</id>
    <published>2017-01-13T05:18:16.000Z</published>
    <updated>2017-03-20T07:56:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>朝九晚五，被禁锢在办公室里的工作模式是工业社会的产物。然而，在互联网崛起的今天，这种固定死板的工作模式反而拖累了我们。办公室早已变成了干扰工厂，把你的时间切成七零八碎的小块儿，工作无法顺利、及时地完成，更会造成心理上的疲惫。</p>
<p>如果您也是一名互联网从业者，特别是程序员，问问周围的人：如果你可以自己选择时间地点来完成工作你会选择哪里？你能在哪一时间段或是哪一地点才能高效地完成工作？我想答案<strong>一定不是下午的办公室</strong>。</p>
<p>笔者自己就是一名程序员，上班的时候被会议和同行的打断弄得苦不堪言，虽然有些沟通确是必要的。不过有一点我很清楚，我经常是在早上上班之前或是晚上睡觉之前才能<strong>完完全全，满意地</strong>完成一个模块的开发。在下午的时候，我就会给自己安排做一些难度不高的任务，这样一来，打断所带来的负面影响会很低。</p>
<p>因此笔者非常期望自己可以远程工作，摆脱这种固话的工作和生活方式，因为它能带来的好处真的是太多太多了！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-92f9e8f6e5690223.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远程工作"></p>
<a id="more"></a>
<h1 id="远程工作好处多："><a href="#远程工作好处多：" class="headerlink" title="远程工作好处多："></a>远程工作好处多：</h1><hr>
<h2 id="再也不用通勤了"><a href="#再也不用通勤了" class="headerlink" title="再也不用通勤了"></a>再也不用通勤了</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-3c7fb69828e09480.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通勤路上"></p>
<p>有的人为了减少通勤时间在自己的公司附近花费了高额租金。。。<br>有的人为了节省开支，住的离公司很远，但却在拥挤的地铁里倍受煎熬。。。<br>有的人虽然有私家车通勤，但是持续性需要支付的燃油费和停车费也是不可避免的。。。</p>
<p>然而，这一切在远程工作的系统里，完全可以避免！</p>
<p>大多数人将人生耗费在通勤路上，导致心情变糟，影响幸福感，更别说浪费的时间了。。<br>节省了两个小时的时间+疲劳，对于工作效率和幸福感的提升是显而易见的。<br>时间节省了，财产变多了，空气更好了(尾气排放)，世界更美好了不是么？^^</p>
<h2 id="员工可以自己规划自己的生活"><a href="#员工可以自己规划自己的生活" class="headerlink" title="员工可以自己规划自己的生活"></a>员工可以自己规划自己的生活</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-5ec1095da5690e2b.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="规划生活"></p>
<p>有的员工是早起族，他们每天早早起来但是到了下午缺疲惫不堪。。。<br>有的员工是夜猫子，他们只有在凌晨2-3点的时候才是高效工作时间，因此早起上班让他们苦不堪言。。。<br>有的员工家里有小孩，顾家的他们无法平衡接送自己小孩和上下班的时间表。。。</p>
<p>如果我们启动了远程工作的模式，我们几乎可以满足每个雇员的需求：早起族，夜猫子，每天接送孩子的员工。他们的生活不再受朝九晚五的固定模式所束缚，可以充分规划自己的人生。只要能出色完成任务，员工如何安排自己的生活又有什么关系呢？</p>
<p>而且让自己的生活更加丰富多彩，更有助于迸射出创意的火花，这是一个良性循环，何乐而不为呢？</p>
<h2 id="衡量员工的标准更加本质化"><a href="#衡量员工的标准更加本质化" class="headerlink" title="衡量员工的标准更加本质化"></a>衡量员工的标准更加本质化</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-54b23bd2350977c2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="只看成果"></p>
<p>有的员工工作不认真，但是运用其圆滑的处事能力和政治素养在公司里平步青云，这种情况并不少见。。。<br>我们更希望那些具有真才实学的人身居高位，为我们指点江山，不过现实总是让人很无奈。</p>
<p>但是！远程工作使得衡量员工的标准更加单一,更加本质化：我们只看<strong>工作成果</strong>，也可以说我们只能看到工作成果。</p>
<p>远程工作模式让我们更加关注员工的工作成果，从中我们可以看到员工的真实水平和成长情况，而不是其他混淆我们视听，登不上台面的东西，一些在将来可能把我们公司送上不归路的东西。</p>
<p>在这里，引用程序员界的一句比较著名的话：</p>
<blockquote>
<p>talk is cheap，show me the code。</p>
</blockquote>
<p>我们也可以说：</p>
<blockquote>
<p>talk is cheap, show me your work!</p>
</blockquote>
<h2 id="将世界各地的人才纳入囊中"><a href="#将世界各地的人才纳入囊中" class="headerlink" title="将世界各地的人才纳入囊中"></a>将世界各地的人才纳入囊中</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-4b84c7490a984b94.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远方的人"></p>
<p>远程工作系统不受地域的限制，可以雇佣分布在各地的最优秀的人才，而且也不会担心员工搬家或者出国居住的情况。<br>人才本来就是不受地域限制的，并不是说顶尖人才就一定在一线城市里，我们要充分利用一切资源找到那些散落在世界各地的人才为我们工作。而且，不论他们居住在哪里，在当地的生活水平如何，我们都要给他们丰厚的薪水和待遇，让他们自己觉得自己即使远在天涯也依然被“组织”重视着。</p>
<h2 id="大家更加珍惜彼此见面的机会"><a href="#大家更加珍惜彼此见面的机会" class="headerlink" title="大家更加珍惜彼此见面的机会"></a>大家更加珍惜彼此见面的机会</h2><p><img src="http://upload-images.jianshu.io/upload_images/859001-c572e4100af965ca.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="愉快聚会"></p>
<p>其实就算是执行远程工作模式，还是要挑出一些时间来让团队的人员彼此见面的，<br>在远程工作系统中，见面的稀缺提升了它的价值：大家不会浪费时间，会更加珍惜面对面交流，培养感情的机会。</p>
<h1 id="一些反对远程工作的声音"><a href="#一些反对远程工作的声音" class="headerlink" title="一些反对远程工作的声音"></a>一些反对远程工作的声音</h1><hr>
<h3 id="“我怎么知道他们在干活？”"><a href="#“我怎么知道他们在干活？”" class="headerlink" title="“我怎么知道他们在干活？”"></a>“我怎么知道他们在干活？”</h3><p>如果我们不知道该不该信任这个员工，就说明当初这个招聘决定是错误的，如果某个成员不能取得好结果，或是没法管理好自己的工作日程和工作量，那我们也没必要继续聘用他。要么学会信任你的下属，要么就换人吧。</p>
<h3 id="“家里的干扰比较多”"><a href="#“家里的干扰比较多”" class="headerlink" title="“家里的干扰比较多”"></a>“家里的干扰比较多”</h3><p>我们可以给自己单独一个工作房间，而且你也可以去附近的咖啡厅。<br>像笔者自己有的时候在周末就比较喜欢去咖啡厅，个人觉得在一些稍微有点吵杂又比较干净高雅的场所反而能更加集中注意力。而且在家里可能会觉得比较舒服，反而会提不起精神来，影响工作效率。</p>
<h1 id="远程工作的具体实践"><a href="#远程工作的具体实践" class="headerlink" title="远程工作的具体实践"></a>远程工作的具体实践</h1><hr>
<ol>
<li>最好还是能规划出重叠时间，可以避免信息延迟，也能让大家产生同在一个团队的感觉。</li>
<li>共享日历，让每个成员的时间表透明化，节省了沟通成本。</li>
<li>共享所有的资料，通过搜索来节省沟通成本。</li>
<li>每周一次的展示会来秀你的工作进展：谈谈自己上周做了什么，这周做了什么，下周打算做什么。</li>
<li>对于目前还没有实践远程工作的公司，可以先找几位信得过的员工，看看结果。</li>
<li>在家工作时，最好可以把工作区和休闲区分开。</li>
<li>避免过度疲劳，可以在工作后切换到平板电脑，把紧绷的思维转换一下。</li>
<li>或许可以用上午做一些避开干扰的事情，然后在下午去公司做那些需要更多协作的工作。</li>
</ol>
<h1 id="远程工具箱"><a href="#远程工具箱" class="headerlink" title="远程工具箱"></a>远程工具箱</h1><hr>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-bd5885fa7b4658ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="远程工具箱"></p>
<ol>
<li>WebEx:共享屏幕，给异地的某人做产品介绍。</li>
<li>Google Hangouts : 视频会议，可以通过电脑上或手机上的摄像头进行视频通话。</li>
<li>Dropbox:公司文档的存放处，支持多平带，只要可以连上网络就能在世界各处访问公司的资料。</li>
<li>Google Docs:实时共享文档。</li>
</ol>
<h1 id="远程工作的副作用"><a href="#远程工作的副作用" class="headerlink" title="远程工作的副作用"></a>远程工作的副作用</h1><hr>
<h2 id="不要过多延长了工作时间"><a href="#不要过多延长了工作时间" class="headerlink" title="不要过多延长了工作时间"></a>不要过多延长了工作时间</h2><p>我们需要担心的是，如果将一个工作狂放在家里工作，可能导致他干的太多了，造成过度疲劳。<br>解决办法：在规定的工作后，问问自己今天有没有好好工作？如果回答是，就可以停止了。如果不是，问自己五个为什么，找出问题的根源。</p>
<h2 id="换个环境"><a href="#换个环境" class="headerlink" title="换个环境"></a>换个环境</h2><p>就算是远程工作，也尽量不要憋在家里，去咖啡厅或者公园也是蛮不错的选择。</p>
<h2 id="注意健康"><a href="#注意健康" class="headerlink" title="注意健康"></a>注意健康</h2><p>有些人如果可以让他持续坐在电脑前就很难让他离开了（包括我），要注意多运动，特别要使用优良的工作设备：例如人体工学椅。</p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><hr>
<p>我们可以看到，远程工作所能带来的好处太多了：节省通勤的时间和金钱，更好规划员工自己的生活，更加正确地衡量员工的能力和工作态度。。而这些优势，能够吸引更多世界各地的人才，让一群优秀的团队成员合作，是取得巅峰绩效的关键。</p>
<p>随着时间的推移，大家彼此越来越熟悉，相处的越来越融洽，自然而然地，工作质量就会变得很高。在人生的幸福来源中，和卓越的人共事，做出卓越的业绩正式其中之一。</p>
<p>要激发出员工的动力，唯一靠得住的办法就是鼓励他们从事自己喜欢的，在乎的事情，而且跟他们喜欢的，在乎的人一起做事，此外没有捷径可走。</p>
<p>你还在等什么？如果你是雇主，何不启动远程工作系统试试看？如果你是雇员，何不向自己的雇主建议一下呢？</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;朝九晚五，被禁锢在办公室里的工作模式是工业社会的产物。然而，在互联网崛起的今天，这种固定死板的工作模式反而拖累了我们。办公室早已变成了干扰工厂，把你的时间切成七零八碎的小块儿，工作无法顺利、及时地完成，更会造成心理上的疲惫。&lt;/p&gt;
&lt;p&gt;如果您也是一名互联网从业者，特别是程序员，问问周围的人：如果你可以自己选择时间地点来完成工作你会选择哪里？你能在哪一时间段或是哪一地点才能高效地完成工作？我想答案&lt;strong&gt;一定不是下午的办公室&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;笔者自己就是一名程序员，上班的时候被会议和同行的打断弄得苦不堪言，虽然有些沟通确是必要的。不过有一点我很清楚，我经常是在早上上班之前或是晚上睡觉之前才能&lt;strong&gt;完完全全，满意地&lt;/strong&gt;完成一个模块的开发。在下午的时候，我就会给自己安排做一些难度不高的任务，这样一来，打断所带来的负面影响会很低。&lt;/p&gt;
&lt;p&gt;因此笔者非常期望自己可以远程工作，摆脱这种固话的工作和生活方式，因为它能带来的好处真的是太多太多了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-92f9e8f6e5690223.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;远程工作&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/categories/BookNote/"/>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="IT" scheme="https://github.com/knightsj/knightsj.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>浅谈互联网商业思维的几个误区 - 读《重来》有感</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/13/%E6%B5%85%E8%B0%88%E4%BA%92%E8%81%94%E7%BD%91%E5%95%86%E4%B8%9A%E6%80%9D%E7%BB%B4%E7%9A%84%E5%87%A0%E4%B8%AA%E8%AF%AF%E5%8C%BA%20-%20%E8%AF%BB%E3%80%8A%E9%87%8D%E6%9D%A5%E3%80%8B%E6%9C%89%E6%84%9F/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/13/浅谈互联网商业思维的几个误区 - 读《重来》有感/</id>
    <published>2017-01-13T05:12:57.000Z</published>
    <updated>2017-03-20T07:53:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近读了一些关于互联网思维和管理的一些书籍，感触颇深，想从团队，产品，公司方向和个人几个方面，结合笔者的个人经历分享一下笔者的思考和感悟。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-063cce725ad58f38.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片来自：www.pexels.com"></p>
<a id="more"></a>
<hr>
<h1 id="关于团队"><a href="#关于团队" class="headerlink" title="关于团队"></a>关于团队</h1><h3 id="“鸡尾酒会”并不是一个好的氛围"><a href="#“鸡尾酒会”并不是一个好的氛围" class="headerlink" title="“鸡尾酒会”并不是一个好的氛围"></a>“鸡尾酒会”并不是一个好的氛围</h3><p>鸡尾酒会就是关系并不熟的人的聚会，人们都把自己与他们拉开一段距离，秉承着“你好我好大家好，井水不犯河水”的原则，互不侵犯，生怕说错话，想赶紧结束走人。</p>
<p>很显然，这种工作氛围是及其危险的，因为没人敢说实话。笔者个人非常不喜欢这种工作氛围。</p>
<p>笔者在韩国留学的时候，研究室里就是这种氛围，韩国人的等级制度很严重：后辈，也就是相对比较晚加入的年轻人是不能对前辈的行为有任何指点，更不用说批评了。笔者对这种畸形的文化已经厌恶至极，因此毅然决然，毕业后回到了祖国发展。</p>
<p>我们应该营造一个敢说任何胡但是还非常有安全感的环境，这样一来，公司的各种问题都会立即被大家知晓，然后找出解决办法，立马执行！</p>
<h3 id="市场营销并不是一个独立的部门"><a href="#市场营销并不是一个独立的部门" class="headerlink" title="市场营销并不是一个独立的部门"></a>市场营销并不是一个独立的部门</h3><p>笔者所在的公司，技术人员和用户几乎是无交流的，但是如果让技术人员亲自去和反馈问题的用户沟通，那么用户应该会满意很多，因为至少他们所得到的服务是相对更专业的。像这种技术人员与用户直接交流的行为就是市场营销。</p>
<p>因此，无论是技术人员也好，产品人员也好，都要积极与用户沟通交流，积极参与各种“类营销”活动，因为我们每个人都可以作为营销的一员，为公司带来好的影响。</p>
<hr>
<h1 id="关于产品"><a href="#关于产品" class="headerlink" title="关于产品"></a>关于产品</h1><h3 id="不应该为了迎合投资人，个别用户来改变产品的核心"><a href="#不应该为了迎合投资人，个别用户来改变产品的核心" class="headerlink" title="不应该为了迎合投资人，个别用户来改变产品的核心"></a>不应该为了迎合投资人，个别用户来改变产品的核心</h3><p>有很多初创公司听从了投资人的要求或者个别用户的抱怨就改变了产品的初衷，做出了一个连自己都不喜欢的产品。后来，那个提出怪异要求的投资人拿着钱走了，那个抱怨的客户不在使用产品了，公司就只剩下一个面目全非毫无个性的产品，这无疑是让人心痛的。</p>
<p>想要创造一个伟大的产品或某项卓越的服务，最简单的办法就是做你自己想用的东西。<br>这个东西有一个核心，它在你的创业等式中是无法被拿掉的。无论投资人，客户，还是个别用户想要撼动他都无济于事，因为这是你自己的产品，你爱你自己的产品，你要去捍卫它，不断地去完善它。这才是事业成功的根本。</p>
<h3 id="不要为了增加功能拖延上线的时间"><a href="#不要为了增加功能拖延上线的时间" class="headerlink" title="不要为了增加功能拖延上线的时间"></a>不要为了增加功能拖延上线的时间</h3><p>有些时候，产品那边一直想要增加需求，甚至是在测试阶段。这是一种非常不明智的做法。</p>
<p>在产品形成初期，产品迭代的节奏和速度是最重要的，与其把某一项功能做的成熟，不如赶紧做好最基本的功能放到市场，这样才有利于把握市场方向，把选择权交给市场而不是在公司里面瞎猜。</p>
<h3 id="不要只关注主打产品，找到副产品给公司带来额外收益"><a href="#不要只关注主打产品，找到副产品给公司带来额外收益" class="headerlink" title="不要只关注主打产品，找到副产品给公司带来额外收益"></a>不要只关注主打产品，找到副产品给公司带来额外收益</h3><p>在不耽误主打产品研发的前提下，可以挖据公司的副产品，虽然收效可能不高，但对于提高公司的影响力和亲和力是由积极影响的。</p>
<p>开个博客，分享有意义的知识；写书，来记录公司的信条；拍个纪录片，来记录公司的成长都是不错的选择。</p>
<hr>
<h1 id="关于方向"><a href="#关于方向" class="headerlink" title="关于方向"></a>关于方向</h1><h3 id="“发展成为大公司”并不一定是一个好的目标"><a href="#“发展成为大公司”并不一定是一个好的目标" class="headerlink" title="“发展成为大公司”并不一定是一个好的目标"></a>“发展成为大公司”并不一定是一个好的目标</h3><p>很多小公司都有想变壮大，而很多大公司却梦想变得更敏捷，更灵活。<br>但是可悲的是，一旦公司做大了，要想再缩小，就在所难免要进行裁员，那么后果就是打击士气，影响工作氛围，这往往是致命的。所以我个人认为，公司不必做得很大，因为这样会导致信息流通效率变低，而团队信息流通效率是团队执行效率的根本。</p>
<p>有一个高效敏捷的小团队胜过低效笨重的大团队，因为它能够对变化迅速做出反应，而且每次的决策都可以迅速下达和执行，这是我们希望看到的。</p>
<h3 id="不应该让对手的方向影响你的方向"><a href="#不应该让对手的方向影响你的方向" class="headerlink" title="不应该让对手的方向影响你的方向"></a>不应该让对手的方向影响你的方向</h3><p>把目光放在自己身上，而不是对手身上。如果你把时间浪费在关注他人身上时，头脑里只会充斥着别人的想法，然后将自己的想法冲淡，更别提自我提高了。</p>
<p>如果你还要制造一个类ipod的产品，注定是失败的。因为游戏规则是他们定下的，而你是无法打败游戏规则制定者的。</p>
<p>走别人走过的路成不了大气候的，不要去挑战规则的制定者，要走出一条自己的路。而不是把别人修好的路在旁边种一排树，这无非是给他人做嫁衣。机智一点，勇敢一点去修一条自己独有的路吧。</p>
<h3 id="不要依赖计划"><a href="#不要依赖计划" class="headerlink" title="不要依赖计划"></a>不要依赖计划</h3><p>最危险的莫过于“不知道自己不知道了”，定制计划时，有很多因素是我们无法预料到的，因为产品投入市场后，有太多的不确定因素，而这些不确定因素恰恰有可能对计划产生不可估量的影响。所以还是加快节奏，尽快把产品投放到市场。</p>
<h3 id="不要自恃清高，应该时刻想着如何盈利"><a href="#不要自恃清高，应该时刻想着如何盈利" class="headerlink" title="不要自恃清高，应该时刻想着如何盈利"></a>不要自恃清高，应该时刻想着如何盈利</h3><p>不要依赖投资人的钱，要从一开始就时时刻刻想着如何给公司带来收益，因为就算你想亏待自己，你也不能亏待你的员工。而且，如果过分依赖别人的钱，那还谈什么坚持走自己的路，开创自己的事业呢？</p>
<hr>
<h1 id="关于个人"><a href="#关于个人" class="headerlink" title="关于个人"></a>关于个人</h1><h3 id="“工作狂”并不是一个好的定位"><a href="#“工作狂”并不是一个好的定位" class="headerlink" title="“工作狂”并不是一个好的定位"></a>“工作狂”并不是一个好的定位</h3><p>我们经常会看到公司中有一些人自诩为“工作狂”，每天加班到很晚，但是工作成果平平，而且精神状态萎靡不振。其实这些人大多是通过增加时间的方式来去完成一些事实上比较次要的任务或者细节，或是不去思考完成任务的正确方法，低效率工作。</p>
<p>其实我们应该明智地去工作，不应靠蛮力来弥补思维上的惰性，应该准确判断任务的主次，想出最高效的方法解决掉它。</p>
<p>前一阵子，笔者独立负责公司的一个项目，压力很大，但是怕刚不上工期，便一味地延长工作时间:加班+回家再搞到1点。虽然产品及时上线，但是回想一下好多工作都返工了，因为当时并没有做好决策，选择最好的解决办法。</p>
<p>不过当我认识到了问题的严重性后，刻意逼迫自己回家只做自己的事情。在工作时，处理每个任务之前仔细推敲逻辑，找出最合理的办法。虽然工作的节奏慢了一点(因为不是一味地蛮干)，但是功能做出来之后bug极少，几乎没有重写或者优化的部分。而且最重要的是，我每天回家都有自己的时间去给自己充电。现在回想一下当时的我还是蛮心疼的，明明可以换一种更加轻松高效方式去生活，何必把自己搞得那么累呢?</p>
<h3 id="单纯地罗列问题并不能解决问题"><a href="#单纯地罗列问题并不能解决问题" class="headerlink" title="单纯地罗列问题并不能解决问题"></a>单纯地罗列问题并不能解决问题</h3><p>很多人在使用任务清单，但是大多数只是把他们列到那里，做完了去打个勾。但是，虽然这可以起到提醒的作用，但还是不够完善，为什么呢？<br>罗列一个to-do清单并不是在部署任务，而更多地像是给大脑一个缓存而已。</p>
<p>任务是要被执行的，而执行就需要执行的时间。因此，给每一条干巴巴的项目条加上优先级并且附上执行时间和期限才是比较现实的做法。千万别列了好长的清单然后勾了几个无足轻重的任务后才发现还有一根硬骨头躺在上面等你解决。</p>
<h3 id="高端设备和工具并不是初学者应该用的"><a href="#高端设备和工具并不是初学者应该用的" class="headerlink" title="高端设备和工具并不是初学者应该用的"></a>高端设备和工具并不是初学者应该用的</h3><p>人们都喜欢高端设备，认为“好的装备”才是取胜的法宝。所以我们会经常会看到一些初学者去使用花哨的插件(为了节省编程时间)，使用一些看似能提高效率的工具。一些初创公司置办豪华的家具，给员工提供非常舒适的办公环境。但是，初学者们应该从零做起，先打好基础，而公司应该关注的是怎样赢得客户，如何盈利。</p>
<p>笔者自己几个月前非常想用机械键盘，因为觉得这是一个程序员应该用的工具。但是后来想想，如果无法准确把正在使用的编程语言的各种语句和字符打出来，而且光标也得多数靠鼠标来移动的话，即使是用机械键盘，效率也不会提高很多。所以笔者决定等自己完全熟练语法以及可以完全脱离鼠标之后再使用机械键盘。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近读了一些关于互联网思维和管理的一些书籍，感触颇深，想从团队，产品，公司方向和个人几个方面，结合笔者的个人经历分享一下笔者的思考和感悟。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/859001-063cce725ad58f38.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;图片来自：www.pexels.com&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/categories/BookNote/"/>
    
    
      <category term="BookNote" scheme="https://github.com/knightsj/knightsj.github.io/tags/BookNote/"/>
    
      <category term="IT" scheme="https://github.com/knightsj/knightsj.github.io/tags/IT/"/>
    
  </entry>
  
  <entry>
    <title>斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI</title>
    <link href="https://github.com/knightsj/knightsj.github.io/2017/01/11/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6iOS%E5%BC%80%E5%8F%91%E5%85%AC%E5%BC%80%E8%AF%BE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8D%81%E5%85%AB%EF%BC%89%EF%BC%9A%E5%9B%BD%E9%99%85%E5%8C%96%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E7%BD%AEUI/"/>
    <id>https://github.com/knightsj/knightsj.github.io/2017/01/11/斯坦福大学iOS开发公开课总结（十八）：国际化，自定义设置UI/</id>
    <published>2017-01-11T07:30:42.000Z</published>
    <updated>2017-03-20T07:55:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇是斯坦福大学iOS7系列课程（CS193P）的最后一节课的总结，终于把18节课的内容都总结完了，而且这个文集也画上了句号，有点不舍的赶脚。。</p>
<p>好了，不煽情了，开始！<br><a id="more"></a></p>
<h1 id="国际化-Internationalization"><a href="#国际化-Internationalization" class="headerlink" title="国际化 Internationalization"></a>国际化 Internationalization</h1><hr>
<p>如果我们想要将app推广到国际市场，那么就免不了将我们的app翻译成其他国家的语言以便于当地人去使用。</p>
<p>而翻译的内容主要集中于“非内容”部分：例如标题类文字，按钮上的文字，提示框的文字等等。</p>
<p>所谓“翻译”app的过程主要分为<strong>国际化</strong>和<strong>本地化</strong>两个步骤：</p>
<ol>
<li>国际化：是让app能够本地化的过程。</li>
<li>本地化：将程序翻译另外一种语言。<ul>
<li>故事版字符串的本地化：改变故事版中出现的字符串。</li>
<li>类文件字符串的本地化：改变文件中出现的字符串，包括字符串面量和非字符串面量。</li>
</ul>
</li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>好的UI设计：给用户呈现出的内容大多数都需要显示的（内容），而不是自己添加的（提示）。这样一来，也会减少我们本地化的工作量。</li>
<li>所有的地方都要设置好自动布局，否则本地化将无从谈起，因为将文字翻译成其他语言后，长度很可能是不一样的。</li>
</ol>
</blockquote>
<p>下面来来具体看一下本地化的方法，分为<strong>故事版中字符串</strong>的本地化和<strong>类文件中字符串</strong>的本地化。</p>
<h2 id="1-故事版中的本地化"><a href="#1-故事版中的本地化" class="headerlink" title="1. 故事版中的本地化"></a>1. 故事版中的本地化</h2><p>在故事版中本地化的过程是：</p>
<ol>
<li>在项目里添加其他语言。</li>
<li>在被添加语言的故事版文件中找到相应的.string文件，加以更改。</li>
</ol>
<p>具体过程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-917657136741d815.gif?imageMogr2/auto-orient/strip" alt="故事版的本地化.gif"></p>
<h2 id="2-类文件中字符串的本地化"><a href="#2-类文件中字符串的本地化" class="headerlink" title="2. 类文件中字符串的本地化"></a>2. 类文件中字符串的本地化</h2><p>除了需要本地化故事版中的字符串，类文件中的字符串也需要本地化，因为故事版并不能显示所有需要翻译的字符串。</p>
<p>而且，类文件中的字符串分为两种形式：</p>
<ol>
<li>字符串面量。</li>
<li>非字符串面量。</li>
</ol>
<p>字符串面量:</p>
<p><code>NSString *myName = @“Jack”;</code></p>
<p>类似这样的字符串是比较好找的，只需要搜索<code>@</code>即可很容易找到。<br>但是，我们仍然会通过该方法搜索到不应该本地化的字符串：<br>也就是不出现在UI中的字符串面量。</p>
<p>例如：</p>
<ul>
<li>文件扩展名</li>
<li>segure的identifier</li>
<li>stiringWithFormat:</li>
</ul>
<h4 id="2-1字符串面量的本地化步骤："><a href="#2-1字符串面量的本地化步骤：" class="headerlink" title="2.1字符串面量的本地化步骤："></a>2.1字符串面量的本地化步骤：</h4><ol>
<li>找到需要本地化的字符串面量。</li>
<li>通过宏，将字符串面量添加到表中。</li>
<li>创建表的.string文件。</li>
<li>本地化.string文件</li>
</ol>
<p>﻿<br>1.找到 <code>@&quot;Sorry, this device cannot add a photo.&quot;</code> 字符串面量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    [super viewDidAppear:animated];</div><div class="line">    if (![[self class] canAddPhoto]) &#123;</div><div class="line">        [self fatalAlert:@&quot;Sorry, this device cannot add a photo.&quot;]; //</div><div class="line">    &#125; else &#123;</div><div class="line">        [self.locationManager startUpdatingLocation];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.通过宏，将字符串面量添加到表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidAppear:(BOOL)animated</div><div class="line">&#123;</div><div class="line">   [super viewDidAppear: animated];</div><div class="line">   </div><div class="line">   if (![[self class] canAddPhoto]) &#123;</div><div class="line">       [self fatalAlert:ALERT_CANT_ADD_PHOTO]; // @&quot;Sorry, this device cannot add a photo.&quot;</div><div class="line">   &#125; else &#123;</div><div class="line">       [self.locationManager startUpdatingLocation];</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define ALERT_CANT_ADD_PHOTO NSLocalizedStringFromTable(@&quot;ALERT_CANT_ADD_PHOTO&quot;, @&quot;AddPhotoViewController&quot;, @&quot;Alert message delivered when there is something that prevents the user from adding a new photo to the database that the user can do nothing about.&quot;)</div></pre></td></tr></table></figure>
<p>3.创建表的.string文件</p>
<p>我们已经在AddPhotoViewController.m文件里将需要本地化的字符串添加到了叫做AddPhotoViewController的表里，下面就需要用命令行工具找到该.m文件：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-a043fa2da855615c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="找到.m文件所在目录"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-b3adf539663b1269.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输入genstrigns ^*m命令"></p>
<p>4.本地化.string文件</p>
<p>在第三步中，我们需要手动创建<code>AddPhotoViewController</code>表的.string文件，然后在文件内部将对应的key进行翻译。因为过程略繁琐，所以以动图的形式呈献给大家：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-100dfbddbe7399bb.gif?imageMogr2/auto-orient/strip" alt="本地化string.gif"></p>
<blockquote>
<p>失误了，右侧的字符串应该是没有“@”的，大家注意。因为到最后才发现的，不好改了 额。。 理解万岁。。</p>
</blockquote>
<h2 id="2-2-非字面量字符串的本地化："><a href="#2-2-非字面量字符串的本地化：" class="headerlink" title="2.2 非字面量字符串的本地化："></a>2.2 非字面量字符串的本地化：</h2><p>在类文件里，有些显示出来的字符串并不都是通过字符串面量赋值的，比如下面这个例子：</p>
<p><code>self.title = newfrc.fetchRequest.entity.name;</code></p>
<p>在这里，title取的是模型里的字段，并没有用字面量语法来表示。<br>对于这种情况，我们需要用NSBundle的<code>localizedStringForKey:value:table:</code>方法来进行本地化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.title = [[NSBundle mainBundle] localizedStringForKey:newfrc.fetchRequest.entity.name</div><div class="line">                         value:newfrc.fetchRequest.entity.name     </div><div class="line">                         table:@&quot;Entities&quot;];</div></pre></td></tr></table></figure>
<p>这样一来，我们就生成了对应名字叫<strong>Entities</strong>的表的映射。但是这张表对应的.string文件还没有生成，需要我们手动去生成，并设置对应的key和value。生成方法如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-965d85e9b008d0c8.gif?imageMogr2/auto-orient/strip" alt="手动生成.string文件"></p>
<h1 id="设置页的UI"><a href="#设置页的UI" class="headerlink" title="设置页的UI"></a>设置页的UI</h1><hr>
<p>在苹果系统的设置里，会有我们装入的app的信息和设置。有时，我们需要将一些设置选项放在这里面供用户使用。</p>
<p>而这里的UI是通过通过Settings bundle来设定的。我们首先要新建一个Settings Bundle:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-d49a21d343306156.gif?imageMogr2/auto-orient/strip" alt="创建Settings Bundle"></p>
<p>创建成功后，分别有一个slider，switch，和textfield来对应设置页里的UI。</p>
<p>在设置页里的样子是这样的：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-6dc1b24f8d070871.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建的Settings Bundle 后的设置页效果"></p>
<p>那么如何使用呢？我们设置一下上一节课的Bouncer Demo的弹性系数：让用户通过调节设置里的slider来调整app里的弹性系数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)resetElasticity</div><div class="line">&#123;</div><div class="line">    //连接代码与Setting Bundle</div><div class="line">    NSNumber *elasticity = [[NSUserDefaults standardUserDefaults] valueForKey:@&quot;Setting_Elasticity&quot;];//连接setting bundle</div><div class="line">    if (elasticity) &#123;</div><div class="line">        //如果有，就取当前设定的</div><div class="line">        self.elastic.elasticity = [elasticity floatValue];</div><div class="line">    &#125; else &#123;</div><div class="line">        //如果没有，就设置为1</div><div class="line">        self.elastic.elasticity = 1.0;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里，通过<code>valueForKey</code>的键值对应了Setting Bundle plist 文件里的<code>identifier</code>，我们将plist文件里的<code>identifier</code>修改成了<code>Setting_Elasticity</code>而且更改了<code>Title</code>，而且将按钮和文本框删除掉，只保留了slider：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-f195429739d8262b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Setting Bundle plist"></p>
<p>所对应的设置页的UI：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-1d15dcab18d5df94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新的设置页UI"></p>
<p>现在我们可以通过identifier连接了代码和plist文件，获取到了键对应的值。</p>
<p>而且，我们还需考虑在程序运行过程中，用户跳转到了设置页面来设置弹性系数的情况。因此，我们需要监听用户是否更改了设置里的选项：</p>
<p>监听用户在设置中的行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserverForName:NSUserDefaultsDidChangeNotification</div><div class="line">                                                  object:nil</div><div class="line">                                                   queue:nil</div><div class="line">                                              usingBlock:^(NSNotification *note) &#123;</div><div class="line">                                                  [self resetElasticity];</div><div class="line">                                              &#125;];</div></pre></td></tr></table></figure>
<h1 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h1><hr>
<p>当~当~当~当~！<br>笔者终于利用了2个月的部分业余时间总结了所有斯坦福iOS7的课程和相关Demo。通过以博客的形式总结，更加加深了对知识的理解和认识，也对基础知识进行了一次查缺补漏，或许也在一定程度上给其他看到这些博客的同仁们一些帮助吧~</p>
<p>最后附上这一系列笔者总结的所有Demo在GitHub上的地址：<a href="https://github.com/Shijie0111/Stanford_iOS_Lecture_DemoBundle">Stanford_iOS_Lecture_DemoBundle</a>。</p>
<p>笔者下一阶段应该是总结下面两本书的内容：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-0eeac0652f909c84.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Effective Objective- C 2.0"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/859001-c1046257878a01d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Swift 基础教程"></p>
<p>这两本书笔者都已经看了3分之一，因为要总结归纳，所以应该进度不是很快，不过还是会坚持写博客的！</p>
<p>加油~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇是斯坦福大学iOS7系列课程（CS193P）的最后一节课的总结，终于把18节课的内容都总结完了，而且这个文集也画上了句号，有点不舍的赶脚。。&lt;/p&gt;
&lt;p&gt;好了，不煽情了，开始！&lt;br&gt;
    
    </summary>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/categories/Objective-C/"/>
    
    
      <category term="iOS" scheme="https://github.com/knightsj/knightsj.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://github.com/knightsj/knightsj.github.io/tags/Objective-C/"/>
    
  </entry>
  
</feed>
